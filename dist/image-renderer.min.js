(function (root) {

	// Store setTimeout reference so promise-polyfill will be unaffected by
	// other code modifying setTimeout (like sinon.useFakeTimers())
	var setTimeoutFunc = setTimeout;

	function noop() { }

	// Polyfill for Function.prototype.bind
	function bind(fn, thisArg) {
		return function () {
			fn.apply(thisArg, arguments);
		};
	}

	function Promise(fn) {
		if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
		if (typeof fn !== 'function') throw new TypeError('not a function');
		this._state = 0;
		this._handled = false;
		this._value = undefined;
		this._deferreds = [];

		doResolve(fn, this);
	}

	function handle(self, deferred) {
		while (self._state === 3) {
			self = self._value;
		}
		if (self._state === 0) {
			self._deferreds.push(deferred);
			return;
		}
		self._handled = true;
		Promise._immediateFn(function () {
			var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
			if (cb === null) {
				(self._state === 1 ? resolve : reject)(deferred.promise, self._value);
				return;
			}
			var ret;
			try {
				ret = cb(self._value);
			} catch (e) {
				reject(deferred.promise, e);
				return;
			}
			resolve(deferred.promise, ret);
		});
	}

	function resolve(self, newValue) {
		try {
			// Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
			if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
			if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
				var then = newValue.then;
				if (newValue instanceof Promise) {
					self._state = 3;
					self._value = newValue;
					finale(self);
					return;
				} else if (typeof then === 'function') {
					doResolve(bind(then, newValue), self);
					return;
				}
			}
			self._state = 1;
			self._value = newValue;
			finale(self);
		} catch (e) {
			reject(self, e);
		}
	}

	function reject(self, newValue) {
		self._state = 2;
		self._value = newValue;
		finale(self);
	}

	function finale(self) {
		if (self._state === 2 && self._deferreds.length === 0) {
			Promise._immediateFn(function () {
				if (!self._handled) {
					Promise._unhandledRejectionFn(self._value);
				}
			});
		}

		for (var i = 0, len = self._deferreds.length; i < len; i++) {
			handle(self, self._deferreds[i]);
		}
		self._deferreds = null;
	}

	function Handler(onFulfilled, onRejected, promise) {
		this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
		this.onRejected = typeof onRejected === 'function' ? onRejected : null;
		this.promise = promise;
	}

	/**
	 * Take a potentially misbehaving resolver function and make sure
	 * onFulfilled and onRejected are only called once.
	 *
	 * Makes no guarantees about asynchrony.
	 */
	function doResolve(fn, self) {
		var done = false;
		try {
			fn(function (value) {
				if (done) return;
				done = true;
				resolve(self, value);
			}, function (reason) {
				if (done) return;
				done = true;
				reject(self, reason);
			});
		} catch (ex) {
			if (done) return;
			done = true;
			reject(self, ex);
		}
	}

	Promise.prototype['catch'] = function (onRejected) {
		return this.then(null, onRejected);
	};

	Promise.prototype.then = function (onFulfilled, onRejected) {
		var prom = new (this.constructor)(noop);

		handle(this, new Handler(onFulfilled, onRejected, prom));
		return prom;
	};

	Promise.all = function (arr) {
		var args = Array.prototype.slice.call(arr);

		return new Promise(function (resolve, reject) {
			if (args.length === 0) return resolve([]);
			var remaining = args.length;

			function res(i, val) {
				try {
					if (val && (typeof val === 'object' || typeof val === 'function')) {
						var then = val.then;
						if (typeof then === 'function') {
							then.call(val, function (val) {
								res(i, val);
							}, reject);
							return;
						}
					}
					args[i] = val;
					if (--remaining === 0) {
						resolve(args);
					}
				} catch (ex) {
					reject(ex);
				}
			}

			for (var i = 0; i < args.length; i++) {
				res(i, args[i]);
			}
		});
	};

	Promise.resolve = function (value) {
		if (value && typeof value === 'object' && value.constructor === Promise) {
			return value;
		}

		return new Promise(function (resolve) {
			resolve(value);
		});
	};

	Promise.reject = function (value) {
		return new Promise(function (resolve, reject) {
			reject(value);
		});
	};

	Promise.race = function (values) {
		return new Promise(function (resolve, reject) {
			for (var i = 0, len = values.length; i < len; i++) {
				values[i].then(resolve, reject);
			}
		});
	};

	// Use polyfill for setImmediate for performance gains
	Promise._immediateFn = (typeof setImmediate === 'function' && function (fn) { setImmediate(fn); }) ||
		function (fn) {
			setTimeoutFunc(fn, 0);
		};

	Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
		if (typeof console !== 'undefined' && console) {
			console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
		}
	};

	/**
	 * Set the immediate function to execute callbacks
	 * @param fn {function} Function to execute
	 * @deprecated
	 */
	Promise._setImmediateFn = function _setImmediateFn(fn) {
		Promise._immediateFn = fn;
	};

	/**
	 * Change the function to execute on unhandled rejection
	 * @param {function} fn Function to execute on unhandled rejection
	 * @deprecated
	 */
	Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
		Promise._unhandledRejectionFn = fn;
	};

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = Promise;
	} else if (!root.Promise) {
		root.Promise = Promise;
	}

})(this);
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.3.2
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

!function(t,a){if("object"==typeof exports&&"object"==typeof module)module.exports=a();else if("function"==typeof define&&define.amd)define([],a);else{var n=a();for(var r in n)("object"==typeof exports?exports:t)[r]=n[r]}}(this,function(){return function(t){function a(r){if(n[r])return n[r].exports;var o=n[r]={exports:{},id:r,loaded:!1};return t[r].call(o.exports,o,o.exports,a),o.loaded=!0,o.exports}var n={};return a.m=t,a.c=n,a.p="",a(0)}([function(t,a,n){a.glMatrix=n(1),a.mat2=n(2),a.mat2d=n(3),a.mat3=n(4),a.mat4=n(5),a.quat=n(6),a.vec2=n(9),a.vec3=n(7),a.vec4=n(8)},function(t,a){var n={};n.EPSILON=1e-6,n.ARRAY_TYPE="undefined"!=typeof Float32Array?Float32Array:Array,n.RANDOM=Math.random,n.ENABLE_SIMD=!1,n.SIMD_AVAILABLE=n.ARRAY_TYPE===Float32Array&&"SIMD"in this,n.USE_SIMD=n.ENABLE_SIMD&&n.SIMD_AVAILABLE,n.setMatrixArrayType=function(t){n.ARRAY_TYPE=t};var r=Math.PI/180;n.toRadian=function(t){return t*r},n.equals=function(t,a){return Math.abs(t-a)<=n.EPSILON*Math.max(1,Math.abs(t),Math.abs(a))},t.exports=n},function(t,a,n){var r=n(1),o={};o.create=function(){var t=new r.ARRAY_TYPE(4);return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t},o.clone=function(t){var a=new r.ARRAY_TYPE(4);return a[0]=t[0],a[1]=t[1],a[2]=t[2],a[3]=t[3],a},o.copy=function(t,a){return t[0]=a[0],t[1]=a[1],t[2]=a[2],t[3]=a[3],t},o.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t},o.fromValues=function(t,a,n,o){var u=new r.ARRAY_TYPE(4);return u[0]=t,u[1]=a,u[2]=n,u[3]=o,u},o.set=function(t,a,n,r,o){return t[0]=a,t[1]=n,t[2]=r,t[3]=o,t},o.transpose=function(t,a){if(t===a){var n=a[1];t[1]=a[2],t[2]=n}else t[0]=a[0],t[1]=a[2],t[2]=a[1],t[3]=a[3];return t},o.invert=function(t,a){var n=a[0],r=a[1],o=a[2],u=a[3],l=n*u-o*r;return l?(l=1/l,t[0]=u*l,t[1]=-r*l,t[2]=-o*l,t[3]=n*l,t):null},o.adjoint=function(t,a){var n=a[0];return t[0]=a[3],t[1]=-a[1],t[2]=-a[2],t[3]=n,t},o.determinant=function(t){return t[0]*t[3]-t[2]*t[1]},o.multiply=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=a[3],e=n[0],M=n[1],s=n[2],i=n[3];return t[0]=r*e+u*M,t[1]=o*e+l*M,t[2]=r*s+u*i,t[3]=o*s+l*i,t},o.mul=o.multiply,o.rotate=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=a[3],e=Math.sin(n),M=Math.cos(n);return t[0]=r*M+u*e,t[1]=o*M+l*e,t[2]=r*-e+u*M,t[3]=o*-e+l*M,t},o.scale=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=a[3],e=n[0],M=n[1];return t[0]=r*e,t[1]=o*e,t[2]=u*M,t[3]=l*M,t},o.fromRotation=function(t,a){var n=Math.sin(a),r=Math.cos(a);return t[0]=r,t[1]=n,t[2]=-n,t[3]=r,t},o.fromScaling=function(t,a){return t[0]=a[0],t[1]=0,t[2]=0,t[3]=a[1],t},o.str=function(t){return"mat2("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"},o.frob=function(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2))},o.LDU=function(t,a,n,r){return t[2]=r[2]/r[0],n[0]=r[0],n[1]=r[1],n[3]=r[3]-t[2]*n[1],[t,a,n]},o.add=function(t,a,n){return t[0]=a[0]+n[0],t[1]=a[1]+n[1],t[2]=a[2]+n[2],t[3]=a[3]+n[3],t},o.subtract=function(t,a,n){return t[0]=a[0]-n[0],t[1]=a[1]-n[1],t[2]=a[2]-n[2],t[3]=a[3]-n[3],t},o.sub=o.subtract,o.exactEquals=function(t,a){return t[0]===a[0]&&t[1]===a[1]&&t[2]===a[2]&&t[3]===a[3]},o.equals=function(t,a){var n=t[0],o=t[1],u=t[2],l=t[3],e=a[0],M=a[1],s=a[2],i=a[3];return Math.abs(n-e)<=r.EPSILON*Math.max(1,Math.abs(n),Math.abs(e))&&Math.abs(o-M)<=r.EPSILON*Math.max(1,Math.abs(o),Math.abs(M))&&Math.abs(u-s)<=r.EPSILON*Math.max(1,Math.abs(u),Math.abs(s))&&Math.abs(l-i)<=r.EPSILON*Math.max(1,Math.abs(l),Math.abs(i))},o.multiplyScalar=function(t,a,n){return t[0]=a[0]*n,t[1]=a[1]*n,t[2]=a[2]*n,t[3]=a[3]*n,t},o.multiplyScalarAndAdd=function(t,a,n,r){return t[0]=a[0]+n[0]*r,t[1]=a[1]+n[1]*r,t[2]=a[2]+n[2]*r,t[3]=a[3]+n[3]*r,t},t.exports=o},function(t,a,n){var r=n(1),o={};o.create=function(){var t=new r.ARRAY_TYPE(6);return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=0,t[5]=0,t},o.clone=function(t){var a=new r.ARRAY_TYPE(6);return a[0]=t[0],a[1]=t[1],a[2]=t[2],a[3]=t[3],a[4]=t[4],a[5]=t[5],a},o.copy=function(t,a){return t[0]=a[0],t[1]=a[1],t[2]=a[2],t[3]=a[3],t[4]=a[4],t[5]=a[5],t},o.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=0,t[5]=0,t},o.fromValues=function(t,a,n,o,u,l){var e=new r.ARRAY_TYPE(6);return e[0]=t,e[1]=a,e[2]=n,e[3]=o,e[4]=u,e[5]=l,e},o.set=function(t,a,n,r,o,u,l){return t[0]=a,t[1]=n,t[2]=r,t[3]=o,t[4]=u,t[5]=l,t},o.invert=function(t,a){var n=a[0],r=a[1],o=a[2],u=a[3],l=a[4],e=a[5],M=n*u-r*o;return M?(M=1/M,t[0]=u*M,t[1]=-r*M,t[2]=-o*M,t[3]=n*M,t[4]=(o*e-u*l)*M,t[5]=(r*l-n*e)*M,t):null},o.determinant=function(t){return t[0]*t[3]-t[1]*t[2]},o.multiply=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=a[3],e=a[4],M=a[5],s=n[0],i=n[1],c=n[2],h=n[3],S=n[4],I=n[5];return t[0]=r*s+u*i,t[1]=o*s+l*i,t[2]=r*c+u*h,t[3]=o*c+l*h,t[4]=r*S+u*I+e,t[5]=o*S+l*I+M,t},o.mul=o.multiply,o.rotate=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=a[3],e=a[4],M=a[5],s=Math.sin(n),i=Math.cos(n);return t[0]=r*i+u*s,t[1]=o*i+l*s,t[2]=r*-s+u*i,t[3]=o*-s+l*i,t[4]=e,t[5]=M,t},o.scale=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=a[3],e=a[4],M=a[5],s=n[0],i=n[1];return t[0]=r*s,t[1]=o*s,t[2]=u*i,t[3]=l*i,t[4]=e,t[5]=M,t},o.translate=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=a[3],e=a[4],M=a[5],s=n[0],i=n[1];return t[0]=r,t[1]=o,t[2]=u,t[3]=l,t[4]=r*s+u*i+e,t[5]=o*s+l*i+M,t},o.fromRotation=function(t,a){var n=Math.sin(a),r=Math.cos(a);return t[0]=r,t[1]=n,t[2]=-n,t[3]=r,t[4]=0,t[5]=0,t},o.fromScaling=function(t,a){return t[0]=a[0],t[1]=0,t[2]=0,t[3]=a[1],t[4]=0,t[5]=0,t},o.fromTranslation=function(t,a){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=a[0],t[5]=a[1],t},o.str=function(t){return"mat2d("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+")"},o.frob=function(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+1)},o.add=function(t,a,n){return t[0]=a[0]+n[0],t[1]=a[1]+n[1],t[2]=a[2]+n[2],t[3]=a[3]+n[3],t[4]=a[4]+n[4],t[5]=a[5]+n[5],t},o.subtract=function(t,a,n){return t[0]=a[0]-n[0],t[1]=a[1]-n[1],t[2]=a[2]-n[2],t[3]=a[3]-n[3],t[4]=a[4]-n[4],t[5]=a[5]-n[5],t},o.sub=o.subtract,o.multiplyScalar=function(t,a,n){return t[0]=a[0]*n,t[1]=a[1]*n,t[2]=a[2]*n,t[3]=a[3]*n,t[4]=a[4]*n,t[5]=a[5]*n,t},o.multiplyScalarAndAdd=function(t,a,n,r){return t[0]=a[0]+n[0]*r,t[1]=a[1]+n[1]*r,t[2]=a[2]+n[2]*r,t[3]=a[3]+n[3]*r,t[4]=a[4]+n[4]*r,t[5]=a[5]+n[5]*r,t},o.exactEquals=function(t,a){return t[0]===a[0]&&t[1]===a[1]&&t[2]===a[2]&&t[3]===a[3]&&t[4]===a[4]&&t[5]===a[5]},o.equals=function(t,a){var n=t[0],o=t[1],u=t[2],l=t[3],e=t[4],M=t[5],s=a[0],i=a[1],c=a[2],h=a[3],S=a[4],I=a[5];return Math.abs(n-s)<=r.EPSILON*Math.max(1,Math.abs(n),Math.abs(s))&&Math.abs(o-i)<=r.EPSILON*Math.max(1,Math.abs(o),Math.abs(i))&&Math.abs(u-c)<=r.EPSILON*Math.max(1,Math.abs(u),Math.abs(c))&&Math.abs(l-h)<=r.EPSILON*Math.max(1,Math.abs(l),Math.abs(h))&&Math.abs(e-S)<=r.EPSILON*Math.max(1,Math.abs(e),Math.abs(S))&&Math.abs(M-I)<=r.EPSILON*Math.max(1,Math.abs(M),Math.abs(I))},t.exports=o},function(t,a,n){var r=n(1),o={};o.create=function(){var t=new r.ARRAY_TYPE(9);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},o.fromMat4=function(t,a){return t[0]=a[0],t[1]=a[1],t[2]=a[2],t[3]=a[4],t[4]=a[5],t[5]=a[6],t[6]=a[8],t[7]=a[9],t[8]=a[10],t},o.clone=function(t){var a=new r.ARRAY_TYPE(9);return a[0]=t[0],a[1]=t[1],a[2]=t[2],a[3]=t[3],a[4]=t[4],a[5]=t[5],a[6]=t[6],a[7]=t[7],a[8]=t[8],a},o.copy=function(t,a){return t[0]=a[0],t[1]=a[1],t[2]=a[2],t[3]=a[3],t[4]=a[4],t[5]=a[5],t[6]=a[6],t[7]=a[7],t[8]=a[8],t},o.fromValues=function(t,a,n,o,u,l,e,M,s){var i=new r.ARRAY_TYPE(9);return i[0]=t,i[1]=a,i[2]=n,i[3]=o,i[4]=u,i[5]=l,i[6]=e,i[7]=M,i[8]=s,i},o.set=function(t,a,n,r,o,u,l,e,M,s){return t[0]=a,t[1]=n,t[2]=r,t[3]=o,t[4]=u,t[5]=l,t[6]=e,t[7]=M,t[8]=s,t},o.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},o.transpose=function(t,a){if(t===a){var n=a[1],r=a[2],o=a[5];t[1]=a[3],t[2]=a[6],t[3]=n,t[5]=a[7],t[6]=r,t[7]=o}else t[0]=a[0],t[1]=a[3],t[2]=a[6],t[3]=a[1],t[4]=a[4],t[5]=a[7],t[6]=a[2],t[7]=a[5],t[8]=a[8];return t},o.invert=function(t,a){var n=a[0],r=a[1],o=a[2],u=a[3],l=a[4],e=a[5],M=a[6],s=a[7],i=a[8],c=i*l-e*s,h=-i*u+e*M,S=s*u-l*M,I=n*c+r*h+o*S;return I?(I=1/I,t[0]=c*I,t[1]=(-i*r+o*s)*I,t[2]=(e*r-o*l)*I,t[3]=h*I,t[4]=(i*n-o*M)*I,t[5]=(-e*n+o*u)*I,t[6]=S*I,t[7]=(-s*n+r*M)*I,t[8]=(l*n-r*u)*I,t):null},o.adjoint=function(t,a){var n=a[0],r=a[1],o=a[2],u=a[3],l=a[4],e=a[5],M=a[6],s=a[7],i=a[8];return t[0]=l*i-e*s,t[1]=o*s-r*i,t[2]=r*e-o*l,t[3]=e*M-u*i,t[4]=n*i-o*M,t[5]=o*u-n*e,t[6]=u*s-l*M,t[7]=r*M-n*s,t[8]=n*l-r*u,t},o.determinant=function(t){var a=t[0],n=t[1],r=t[2],o=t[3],u=t[4],l=t[5],e=t[6],M=t[7],s=t[8];return a*(s*u-l*M)+n*(-s*o+l*e)+r*(M*o-u*e)},o.multiply=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=a[3],e=a[4],M=a[5],s=a[6],i=a[7],c=a[8],h=n[0],S=n[1],I=n[2],f=n[3],x=n[4],D=n[5],F=n[6],m=n[7],d=n[8];return t[0]=h*r+S*l+I*s,t[1]=h*o+S*e+I*i,t[2]=h*u+S*M+I*c,t[3]=f*r+x*l+D*s,t[4]=f*o+x*e+D*i,t[5]=f*u+x*M+D*c,t[6]=F*r+m*l+d*s,t[7]=F*o+m*e+d*i,t[8]=F*u+m*M+d*c,t},o.mul=o.multiply,o.translate=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=a[3],e=a[4],M=a[5],s=a[6],i=a[7],c=a[8],h=n[0],S=n[1];return t[0]=r,t[1]=o,t[2]=u,t[3]=l,t[4]=e,t[5]=M,t[6]=h*r+S*l+s,t[7]=h*o+S*e+i,t[8]=h*u+S*M+c,t},o.rotate=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=a[3],e=a[4],M=a[5],s=a[6],i=a[7],c=a[8],h=Math.sin(n),S=Math.cos(n);return t[0]=S*r+h*l,t[1]=S*o+h*e,t[2]=S*u+h*M,t[3]=S*l-h*r,t[4]=S*e-h*o,t[5]=S*M-h*u,t[6]=s,t[7]=i,t[8]=c,t},o.scale=function(t,a,n){var r=n[0],o=n[1];return t[0]=r*a[0],t[1]=r*a[1],t[2]=r*a[2],t[3]=o*a[3],t[4]=o*a[4],t[5]=o*a[5],t[6]=a[6],t[7]=a[7],t[8]=a[8],t},o.fromTranslation=function(t,a){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=a[0],t[7]=a[1],t[8]=1,t},o.fromRotation=function(t,a){var n=Math.sin(a),r=Math.cos(a);return t[0]=r,t[1]=n,t[2]=0,t[3]=-n,t[4]=r,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},o.fromScaling=function(t,a){return t[0]=a[0],t[1]=0,t[2]=0,t[3]=0,t[4]=a[1],t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},o.fromMat2d=function(t,a){return t[0]=a[0],t[1]=a[1],t[2]=0,t[3]=a[2],t[4]=a[3],t[5]=0,t[6]=a[4],t[7]=a[5],t[8]=1,t},o.fromQuat=function(t,a){var n=a[0],r=a[1],o=a[2],u=a[3],l=n+n,e=r+r,M=o+o,s=n*l,i=r*l,c=r*e,h=o*l,S=o*e,I=o*M,f=u*l,x=u*e,D=u*M;return t[0]=1-c-I,t[3]=i-D,t[6]=h+x,t[1]=i+D,t[4]=1-s-I,t[7]=S-f,t[2]=h-x,t[5]=S+f,t[8]=1-s-c,t},o.normalFromMat4=function(t,a){var n=a[0],r=a[1],o=a[2],u=a[3],l=a[4],e=a[5],M=a[6],s=a[7],i=a[8],c=a[9],h=a[10],S=a[11],I=a[12],f=a[13],x=a[14],D=a[15],F=n*e-r*l,m=n*M-o*l,d=n*s-u*l,b=r*M-o*e,v=r*s-u*e,z=o*s-u*M,p=i*f-c*I,w=i*x-h*I,E=i*D-S*I,A=c*x-h*f,P=c*D-S*f,L=h*D-S*x,q=F*L-m*P+d*A+b*E-v*w+z*p;return q?(q=1/q,t[0]=(e*L-M*P+s*A)*q,t[1]=(M*E-l*L-s*w)*q,t[2]=(l*P-e*E+s*p)*q,t[3]=(o*P-r*L-u*A)*q,t[4]=(n*L-o*E+u*w)*q,t[5]=(r*E-n*P-u*p)*q,t[6]=(f*z-x*v+D*b)*q,t[7]=(x*d-I*z-D*m)*q,t[8]=(I*v-f*d+D*F)*q,t):null},o.str=function(t){return"mat3("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+", "+t[8]+")"},o.frob=function(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+Math.pow(t[6],2)+Math.pow(t[7],2)+Math.pow(t[8],2))},o.add=function(t,a,n){return t[0]=a[0]+n[0],t[1]=a[1]+n[1],t[2]=a[2]+n[2],t[3]=a[3]+n[3],t[4]=a[4]+n[4],t[5]=a[5]+n[5],t[6]=a[6]+n[6],t[7]=a[7]+n[7],t[8]=a[8]+n[8],t},o.subtract=function(t,a,n){return t[0]=a[0]-n[0],t[1]=a[1]-n[1],t[2]=a[2]-n[2],t[3]=a[3]-n[3],t[4]=a[4]-n[4],t[5]=a[5]-n[5],t[6]=a[6]-n[6],t[7]=a[7]-n[7],t[8]=a[8]-n[8],t},o.sub=o.subtract,o.multiplyScalar=function(t,a,n){return t[0]=a[0]*n,t[1]=a[1]*n,t[2]=a[2]*n,t[3]=a[3]*n,t[4]=a[4]*n,t[5]=a[5]*n,t[6]=a[6]*n,t[7]=a[7]*n,t[8]=a[8]*n,t},o.multiplyScalarAndAdd=function(t,a,n,r){return t[0]=a[0]+n[0]*r,t[1]=a[1]+n[1]*r,t[2]=a[2]+n[2]*r,t[3]=a[3]+n[3]*r,t[4]=a[4]+n[4]*r,t[5]=a[5]+n[5]*r,t[6]=a[6]+n[6]*r,t[7]=a[7]+n[7]*r,t[8]=a[8]+n[8]*r,t},o.exactEquals=function(t,a){return t[0]===a[0]&&t[1]===a[1]&&t[2]===a[2]&&t[3]===a[3]&&t[4]===a[4]&&t[5]===a[5]&&t[6]===a[6]&&t[7]===a[7]&&t[8]===a[8]},o.equals=function(t,a){var n=t[0],o=t[1],u=t[2],l=t[3],e=t[4],M=t[5],s=t[6],i=t[7],c=t[8],h=a[0],S=a[1],I=a[2],f=a[3],x=a[4],D=a[5],F=t[6],m=a[7],d=a[8];return Math.abs(n-h)<=r.EPSILON*Math.max(1,Math.abs(n),Math.abs(h))&&Math.abs(o-S)<=r.EPSILON*Math.max(1,Math.abs(o),Math.abs(S))&&Math.abs(u-I)<=r.EPSILON*Math.max(1,Math.abs(u),Math.abs(I))&&Math.abs(l-f)<=r.EPSILON*Math.max(1,Math.abs(l),Math.abs(f))&&Math.abs(e-x)<=r.EPSILON*Math.max(1,Math.abs(e),Math.abs(x))&&Math.abs(M-D)<=r.EPSILON*Math.max(1,Math.abs(M),Math.abs(D))&&Math.abs(s-F)<=r.EPSILON*Math.max(1,Math.abs(s),Math.abs(F))&&Math.abs(i-m)<=r.EPSILON*Math.max(1,Math.abs(i),Math.abs(m))&&Math.abs(c-d)<=r.EPSILON*Math.max(1,Math.abs(c),Math.abs(d))},t.exports=o},function(t,a,n){var r=n(1),o={scalar:{},SIMD:{}};o.create=function(){var t=new r.ARRAY_TYPE(16);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},o.clone=function(t){var a=new r.ARRAY_TYPE(16);return a[0]=t[0],a[1]=t[1],a[2]=t[2],a[3]=t[3],a[4]=t[4],a[5]=t[5],a[6]=t[6],a[7]=t[7],a[8]=t[8],a[9]=t[9],a[10]=t[10],a[11]=t[11],a[12]=t[12],a[13]=t[13],a[14]=t[14],a[15]=t[15],a},o.copy=function(t,a){return t[0]=a[0],t[1]=a[1],t[2]=a[2],t[3]=a[3],t[4]=a[4],t[5]=a[5],t[6]=a[6],t[7]=a[7],t[8]=a[8],t[9]=a[9],t[10]=a[10],t[11]=a[11],t[12]=a[12],t[13]=a[13],t[14]=a[14],t[15]=a[15],t},o.fromValues=function(t,a,n,o,u,l,e,M,s,i,c,h,S,I,f,x){var D=new r.ARRAY_TYPE(16);return D[0]=t,D[1]=a,D[2]=n,D[3]=o,D[4]=u,D[5]=l,D[6]=e,D[7]=M,D[8]=s,D[9]=i,D[10]=c,D[11]=h,D[12]=S,D[13]=I,D[14]=f,D[15]=x,D},o.set=function(t,a,n,r,o,u,l,e,M,s,i,c,h,S,I,f,x){return t[0]=a,t[1]=n,t[2]=r,t[3]=o,t[4]=u,t[5]=l,t[6]=e,t[7]=M,t[8]=s,t[9]=i,t[10]=c,t[11]=h,t[12]=S,t[13]=I,t[14]=f,t[15]=x,t},o.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},o.scalar.transpose=function(t,a){if(t===a){var n=a[1],r=a[2],o=a[3],u=a[6],l=a[7],e=a[11];t[1]=a[4],t[2]=a[8],t[3]=a[12],t[4]=n,t[6]=a[9],t[7]=a[13],t[8]=r,t[9]=u,t[11]=a[14],t[12]=o,t[13]=l,t[14]=e}else t[0]=a[0],t[1]=a[4],t[2]=a[8],t[3]=a[12],t[4]=a[1],t[5]=a[5],t[6]=a[9],t[7]=a[13],t[8]=a[2],t[9]=a[6],t[10]=a[10],t[11]=a[14],t[12]=a[3],t[13]=a[7],t[14]=a[11],t[15]=a[15];return t},o.SIMD.transpose=function(t,a){var n,r,o,u,l,e,M,s,i,c;return n=SIMD.Float32x4.load(a,0),r=SIMD.Float32x4.load(a,4),o=SIMD.Float32x4.load(a,8),u=SIMD.Float32x4.load(a,12),l=SIMD.Float32x4.shuffle(n,r,0,1,4,5),e=SIMD.Float32x4.shuffle(o,u,0,1,4,5),M=SIMD.Float32x4.shuffle(l,e,0,2,4,6),s=SIMD.Float32x4.shuffle(l,e,1,3,5,7),SIMD.Float32x4.store(t,0,M),SIMD.Float32x4.store(t,4,s),l=SIMD.Float32x4.shuffle(n,r,2,3,6,7),e=SIMD.Float32x4.shuffle(o,u,2,3,6,7),i=SIMD.Float32x4.shuffle(l,e,0,2,4,6),c=SIMD.Float32x4.shuffle(l,e,1,3,5,7),SIMD.Float32x4.store(t,8,i),SIMD.Float32x4.store(t,12,c),t},o.transpose=r.USE_SIMD?o.SIMD.transpose:o.scalar.transpose,o.scalar.invert=function(t,a){var n=a[0],r=a[1],o=a[2],u=a[3],l=a[4],e=a[5],M=a[6],s=a[7],i=a[8],c=a[9],h=a[10],S=a[11],I=a[12],f=a[13],x=a[14],D=a[15],F=n*e-r*l,m=n*M-o*l,d=n*s-u*l,b=r*M-o*e,v=r*s-u*e,z=o*s-u*M,p=i*f-c*I,w=i*x-h*I,E=i*D-S*I,A=c*x-h*f,P=c*D-S*f,L=h*D-S*x,q=F*L-m*P+d*A+b*E-v*w+z*p;return q?(q=1/q,t[0]=(e*L-M*P+s*A)*q,t[1]=(o*P-r*L-u*A)*q,t[2]=(f*z-x*v+D*b)*q,t[3]=(h*v-c*z-S*b)*q,t[4]=(M*E-l*L-s*w)*q,t[5]=(n*L-o*E+u*w)*q,t[6]=(x*d-I*z-D*m)*q,t[7]=(i*z-h*d+S*m)*q,t[8]=(l*P-e*E+s*p)*q,t[9]=(r*E-n*P-u*p)*q,t[10]=(I*v-f*d+D*F)*q,t[11]=(c*d-i*v-S*F)*q,t[12]=(e*w-l*A-M*p)*q,t[13]=(n*A-r*w+o*p)*q,t[14]=(f*m-I*b-x*F)*q,t[15]=(i*b-c*m+h*F)*q,t):null},o.SIMD.invert=function(t,a){var n,r,o,u,l,e,M,s,i,c,h=SIMD.Float32x4.load(a,0),S=SIMD.Float32x4.load(a,4),I=SIMD.Float32x4.load(a,8),f=SIMD.Float32x4.load(a,12);return l=SIMD.Float32x4.shuffle(h,S,0,1,4,5),r=SIMD.Float32x4.shuffle(I,f,0,1,4,5),n=SIMD.Float32x4.shuffle(l,r,0,2,4,6),r=SIMD.Float32x4.shuffle(r,l,1,3,5,7),l=SIMD.Float32x4.shuffle(h,S,2,3,6,7),u=SIMD.Float32x4.shuffle(I,f,2,3,6,7),o=SIMD.Float32x4.shuffle(l,u,0,2,4,6),u=SIMD.Float32x4.shuffle(u,l,1,3,5,7),l=SIMD.Float32x4.mul(o,u),l=SIMD.Float32x4.swizzle(l,1,0,3,2),e=SIMD.Float32x4.mul(r,l),M=SIMD.Float32x4.mul(n,l),l=SIMD.Float32x4.swizzle(l,2,3,0,1),e=SIMD.Float32x4.sub(SIMD.Float32x4.mul(r,l),e),M=SIMD.Float32x4.sub(SIMD.Float32x4.mul(n,l),M),M=SIMD.Float32x4.swizzle(M,2,3,0,1),l=SIMD.Float32x4.mul(r,o),l=SIMD.Float32x4.swizzle(l,1,0,3,2),e=SIMD.Float32x4.add(SIMD.Float32x4.mul(u,l),e),i=SIMD.Float32x4.mul(n,l),l=SIMD.Float32x4.swizzle(l,2,3,0,1),e=SIMD.Float32x4.sub(e,SIMD.Float32x4.mul(u,l)),i=SIMD.Float32x4.sub(SIMD.Float32x4.mul(n,l),i),i=SIMD.Float32x4.swizzle(i,2,3,0,1),l=SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(r,2,3,0,1),u),l=SIMD.Float32x4.swizzle(l,1,0,3,2),o=SIMD.Float32x4.swizzle(o,2,3,0,1),e=SIMD.Float32x4.add(SIMD.Float32x4.mul(o,l),e),s=SIMD.Float32x4.mul(n,l),l=SIMD.Float32x4.swizzle(l,2,3,0,1),e=SIMD.Float32x4.sub(e,SIMD.Float32x4.mul(o,l)),s=SIMD.Float32x4.sub(SIMD.Float32x4.mul(n,l),s),s=SIMD.Float32x4.swizzle(s,2,3,0,1),l=SIMD.Float32x4.mul(n,r),l=SIMD.Float32x4.swizzle(l,1,0,3,2),s=SIMD.Float32x4.add(SIMD.Float32x4.mul(u,l),s),i=SIMD.Float32x4.sub(SIMD.Float32x4.mul(o,l),i),l=SIMD.Float32x4.swizzle(l,2,3,0,1),s=SIMD.Float32x4.sub(SIMD.Float32x4.mul(u,l),s),i=SIMD.Float32x4.sub(i,SIMD.Float32x4.mul(o,l)),l=SIMD.Float32x4.mul(n,u),l=SIMD.Float32x4.swizzle(l,1,0,3,2),M=SIMD.Float32x4.sub(M,SIMD.Float32x4.mul(o,l)),s=SIMD.Float32x4.add(SIMD.Float32x4.mul(r,l),s),l=SIMD.Float32x4.swizzle(l,2,3,0,1),M=SIMD.Float32x4.add(SIMD.Float32x4.mul(o,l),M),s=SIMD.Float32x4.sub(s,SIMD.Float32x4.mul(r,l)),l=SIMD.Float32x4.mul(n,o),l=SIMD.Float32x4.swizzle(l,1,0,3,2),M=SIMD.Float32x4.add(SIMD.Float32x4.mul(u,l),M),i=SIMD.Float32x4.sub(i,SIMD.Float32x4.mul(r,l)),l=SIMD.Float32x4.swizzle(l,2,3,0,1),M=SIMD.Float32x4.sub(M,SIMD.Float32x4.mul(u,l)),i=SIMD.Float32x4.add(SIMD.Float32x4.mul(r,l),i),c=SIMD.Float32x4.mul(n,e),c=SIMD.Float32x4.add(SIMD.Float32x4.swizzle(c,2,3,0,1),c),c=SIMD.Float32x4.add(SIMD.Float32x4.swizzle(c,1,0,3,2),c),l=SIMD.Float32x4.reciprocalApproximation(c),c=SIMD.Float32x4.sub(SIMD.Float32x4.add(l,l),SIMD.Float32x4.mul(c,SIMD.Float32x4.mul(l,l))),(c=SIMD.Float32x4.swizzle(c,0,0,0,0))?(SIMD.Float32x4.store(t,0,SIMD.Float32x4.mul(c,e)),SIMD.Float32x4.store(t,4,SIMD.Float32x4.mul(c,M)),SIMD.Float32x4.store(t,8,SIMD.Float32x4.mul(c,s)),SIMD.Float32x4.store(t,12,SIMD.Float32x4.mul(c,i)),t):null},o.invert=r.USE_SIMD?o.SIMD.invert:o.scalar.invert,o.scalar.adjoint=function(t,a){var n=a[0],r=a[1],o=a[2],u=a[3],l=a[4],e=a[5],M=a[6],s=a[7],i=a[8],c=a[9],h=a[10],S=a[11],I=a[12],f=a[13],x=a[14],D=a[15];return t[0]=e*(h*D-S*x)-c*(M*D-s*x)+f*(M*S-s*h),t[1]=-(r*(h*D-S*x)-c*(o*D-u*x)+f*(o*S-u*h)),t[2]=r*(M*D-s*x)-e*(o*D-u*x)+f*(o*s-u*M),t[3]=-(r*(M*S-s*h)-e*(o*S-u*h)+c*(o*s-u*M)),t[4]=-(l*(h*D-S*x)-i*(M*D-s*x)+I*(M*S-s*h)),t[5]=n*(h*D-S*x)-i*(o*D-u*x)+I*(o*S-u*h),t[6]=-(n*(M*D-s*x)-l*(o*D-u*x)+I*(o*s-u*M)),t[7]=n*(M*S-s*h)-l*(o*S-u*h)+i*(o*s-u*M),t[8]=l*(c*D-S*f)-i*(e*D-s*f)+I*(e*S-s*c),t[9]=-(n*(c*D-S*f)-i*(r*D-u*f)+I*(r*S-u*c)),t[10]=n*(e*D-s*f)-l*(r*D-u*f)+I*(r*s-u*e),t[11]=-(n*(e*S-s*c)-l*(r*S-u*c)+i*(r*s-u*e)),t[12]=-(l*(c*x-h*f)-i*(e*x-M*f)+I*(e*h-M*c)),t[13]=n*(c*x-h*f)-i*(r*x-o*f)+I*(r*h-o*c),t[14]=-(n*(e*x-M*f)-l*(r*x-o*f)+I*(r*M-o*e)),t[15]=n*(e*h-M*c)-l*(r*h-o*c)+i*(r*M-o*e),t},o.SIMD.adjoint=function(t,a){var n,r,o,u,l,e,M,s,i,c,h,S,I,n=SIMD.Float32x4.load(a,0),r=SIMD.Float32x4.load(a,4),o=SIMD.Float32x4.load(a,8),u=SIMD.Float32x4.load(a,12);return i=SIMD.Float32x4.shuffle(n,r,0,1,4,5),e=SIMD.Float32x4.shuffle(o,u,0,1,4,5),l=SIMD.Float32x4.shuffle(i,e,0,2,4,6),e=SIMD.Float32x4.shuffle(e,i,1,3,5,7),i=SIMD.Float32x4.shuffle(n,r,2,3,6,7),s=SIMD.Float32x4.shuffle(o,u,2,3,6,7),M=SIMD.Float32x4.shuffle(i,s,0,2,4,6),s=SIMD.Float32x4.shuffle(s,i,1,3,5,7),i=SIMD.Float32x4.mul(M,s),i=SIMD.Float32x4.swizzle(i,1,0,3,2),c=SIMD.Float32x4.mul(e,i),h=SIMD.Float32x4.mul(l,i),i=SIMD.Float32x4.swizzle(i,2,3,0,1),c=SIMD.Float32x4.sub(SIMD.Float32x4.mul(e,i),c),h=SIMD.Float32x4.sub(SIMD.Float32x4.mul(l,i),h),h=SIMD.Float32x4.swizzle(h,2,3,0,1),i=SIMD.Float32x4.mul(e,M),i=SIMD.Float32x4.swizzle(i,1,0,3,2),c=SIMD.Float32x4.add(SIMD.Float32x4.mul(s,i),c),I=SIMD.Float32x4.mul(l,i),i=SIMD.Float32x4.swizzle(i,2,3,0,1),c=SIMD.Float32x4.sub(c,SIMD.Float32x4.mul(s,i)),I=SIMD.Float32x4.sub(SIMD.Float32x4.mul(l,i),I),I=SIMD.Float32x4.swizzle(I,2,3,0,1),i=SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(e,2,3,0,1),s),i=SIMD.Float32x4.swizzle(i,1,0,3,2),M=SIMD.Float32x4.swizzle(M,2,3,0,1),c=SIMD.Float32x4.add(SIMD.Float32x4.mul(M,i),c),S=SIMD.Float32x4.mul(l,i),i=SIMD.Float32x4.swizzle(i,2,3,0,1),c=SIMD.Float32x4.sub(c,SIMD.Float32x4.mul(M,i)),S=SIMD.Float32x4.sub(SIMD.Float32x4.mul(l,i),S),S=SIMD.Float32x4.swizzle(S,2,3,0,1),i=SIMD.Float32x4.mul(l,e),i=SIMD.Float32x4.swizzle(i,1,0,3,2),S=SIMD.Float32x4.add(SIMD.Float32x4.mul(s,i),S),I=SIMD.Float32x4.sub(SIMD.Float32x4.mul(M,i),I),i=SIMD.Float32x4.swizzle(i,2,3,0,1),S=SIMD.Float32x4.sub(SIMD.Float32x4.mul(s,i),S),I=SIMD.Float32x4.sub(I,SIMD.Float32x4.mul(M,i)),i=SIMD.Float32x4.mul(l,s),i=SIMD.Float32x4.swizzle(i,1,0,3,2),h=SIMD.Float32x4.sub(h,SIMD.Float32x4.mul(M,i)),S=SIMD.Float32x4.add(SIMD.Float32x4.mul(e,i),S),i=SIMD.Float32x4.swizzle(i,2,3,0,1),h=SIMD.Float32x4.add(SIMD.Float32x4.mul(M,i),h),S=SIMD.Float32x4.sub(S,SIMD.Float32x4.mul(e,i)),i=SIMD.Float32x4.mul(l,M),i=SIMD.Float32x4.swizzle(i,1,0,3,2),h=SIMD.Float32x4.add(SIMD.Float32x4.mul(s,i),h),I=SIMD.Float32x4.sub(I,SIMD.Float32x4.mul(e,i)),i=SIMD.Float32x4.swizzle(i,2,3,0,1),h=SIMD.Float32x4.sub(h,SIMD.Float32x4.mul(s,i)),I=SIMD.Float32x4.add(SIMD.Float32x4.mul(e,i),I),SIMD.Float32x4.store(t,0,c),SIMD.Float32x4.store(t,4,h),SIMD.Float32x4.store(t,8,S),SIMD.Float32x4.store(t,12,I),t},o.adjoint=r.USE_SIMD?o.SIMD.adjoint:o.scalar.adjoint,o.determinant=function(t){var a=t[0],n=t[1],r=t[2],o=t[3],u=t[4],l=t[5],e=t[6],M=t[7],s=t[8],i=t[9],c=t[10],h=t[11],S=t[12],I=t[13],f=t[14],x=t[15],D=a*l-n*u,F=a*e-r*u,m=a*M-o*u,d=n*e-r*l,b=n*M-o*l,v=r*M-o*e,z=s*I-i*S,p=s*f-c*S,w=s*x-h*S,E=i*f-c*I,A=i*x-h*I,P=c*x-h*f;return D*P-F*A+m*E+d*w-b*p+v*z},o.SIMD.multiply=function(t,a,n){var r=SIMD.Float32x4.load(a,0),o=SIMD.Float32x4.load(a,4),u=SIMD.Float32x4.load(a,8),l=SIMD.Float32x4.load(a,12),e=SIMD.Float32x4.load(n,0),M=SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(e,0,0,0,0),r),SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(e,1,1,1,1),o),SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(e,2,2,2,2),u),SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(e,3,3,3,3),l))));SIMD.Float32x4.store(t,0,M);var s=SIMD.Float32x4.load(n,4),i=SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(s,0,0,0,0),r),SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(s,1,1,1,1),o),SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(s,2,2,2,2),u),SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(s,3,3,3,3),l))));SIMD.Float32x4.store(t,4,i);var c=SIMD.Float32x4.load(n,8),h=SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(c,0,0,0,0),r),SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(c,1,1,1,1),o),SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(c,2,2,2,2),u),SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(c,3,3,3,3),l))));SIMD.Float32x4.store(t,8,h);var S=SIMD.Float32x4.load(n,12),I=SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(S,0,0,0,0),r),SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(S,1,1,1,1),o),SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(S,2,2,2,2),u),SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(S,3,3,3,3),l))));return SIMD.Float32x4.store(t,12,I),t},o.scalar.multiply=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=a[3],e=a[4],M=a[5],s=a[6],i=a[7],c=a[8],h=a[9],S=a[10],I=a[11],f=a[12],x=a[13],D=a[14],F=a[15],m=n[0],d=n[1],b=n[2],v=n[3];return t[0]=m*r+d*e+b*c+v*f,t[1]=m*o+d*M+b*h+v*x,t[2]=m*u+d*s+b*S+v*D,t[3]=m*l+d*i+b*I+v*F,m=n[4],d=n[5],b=n[6],v=n[7],t[4]=m*r+d*e+b*c+v*f,t[5]=m*o+d*M+b*h+v*x,t[6]=m*u+d*s+b*S+v*D,t[7]=m*l+d*i+b*I+v*F,m=n[8],d=n[9],b=n[10],v=n[11],t[8]=m*r+d*e+b*c+v*f,t[9]=m*o+d*M+b*h+v*x,t[10]=m*u+d*s+b*S+v*D,t[11]=m*l+d*i+b*I+v*F,m=n[12],d=n[13],b=n[14],v=n[15],t[12]=m*r+d*e+b*c+v*f,t[13]=m*o+d*M+b*h+v*x,t[14]=m*u+d*s+b*S+v*D,t[15]=m*l+d*i+b*I+v*F,t},o.multiply=r.USE_SIMD?o.SIMD.multiply:o.scalar.multiply,o.mul=o.multiply,o.scalar.translate=function(t,a,n){var r,o,u,l,e,M,s,i,c,h,S,I,f=n[0],x=n[1],D=n[2];return a===t?(t[12]=a[0]*f+a[4]*x+a[8]*D+a[12],t[13]=a[1]*f+a[5]*x+a[9]*D+a[13],t[14]=a[2]*f+a[6]*x+a[10]*D+a[14],t[15]=a[3]*f+a[7]*x+a[11]*D+a[15]):(r=a[0],o=a[1],u=a[2],l=a[3],e=a[4],M=a[5],s=a[6],i=a[7],c=a[8],h=a[9],S=a[10],I=a[11],t[0]=r,t[1]=o,t[2]=u,t[3]=l,t[4]=e,t[5]=M,t[6]=s,t[7]=i,t[8]=c,t[9]=h,t[10]=S,t[11]=I,t[12]=r*f+e*x+c*D+a[12],t[13]=o*f+M*x+h*D+a[13],t[14]=u*f+s*x+S*D+a[14],t[15]=l*f+i*x+I*D+a[15]),t},o.SIMD.translate=function(t,a,n){var r=SIMD.Float32x4.load(a,0),o=SIMD.Float32x4.load(a,4),u=SIMD.Float32x4.load(a,8),l=SIMD.Float32x4.load(a,12),e=SIMD.Float32x4(n[0],n[1],n[2],0);a!==t&&(t[0]=a[0],t[1]=a[1],t[2]=a[2],t[3]=a[3],t[4]=a[4],t[5]=a[5],t[6]=a[6],t[7]=a[7],t[8]=a[8],t[9]=a[9],t[10]=a[10],t[11]=a[11]),r=SIMD.Float32x4.mul(r,SIMD.Float32x4.swizzle(e,0,0,0,0)),o=SIMD.Float32x4.mul(o,SIMD.Float32x4.swizzle(e,1,1,1,1)),u=SIMD.Float32x4.mul(u,SIMD.Float32x4.swizzle(e,2,2,2,2));var M=SIMD.Float32x4.add(r,SIMD.Float32x4.add(o,SIMD.Float32x4.add(u,l)));return SIMD.Float32x4.store(t,12,M),t},o.translate=r.USE_SIMD?o.SIMD.translate:o.scalar.translate,o.scalar.scale=function(t,a,n){var r=n[0],o=n[1],u=n[2];return t[0]=a[0]*r,t[1]=a[1]*r,t[2]=a[2]*r,t[3]=a[3]*r,t[4]=a[4]*o,t[5]=a[5]*o,t[6]=a[6]*o,t[7]=a[7]*o,t[8]=a[8]*u,t[9]=a[9]*u,t[10]=a[10]*u,t[11]=a[11]*u,t[12]=a[12],t[13]=a[13],t[14]=a[14],t[15]=a[15],t},o.SIMD.scale=function(t,a,n){var r,o,u,l=SIMD.Float32x4(n[0],n[1],n[2],0);return r=SIMD.Float32x4.load(a,0),SIMD.Float32x4.store(t,0,SIMD.Float32x4.mul(r,SIMD.Float32x4.swizzle(l,0,0,0,0))),o=SIMD.Float32x4.load(a,4),SIMD.Float32x4.store(t,4,SIMD.Float32x4.mul(o,SIMD.Float32x4.swizzle(l,1,1,1,1))),u=SIMD.Float32x4.load(a,8),SIMD.Float32x4.store(t,8,SIMD.Float32x4.mul(u,SIMD.Float32x4.swizzle(l,2,2,2,2))),t[12]=a[12],t[13]=a[13],t[14]=a[14],t[15]=a[15],t},o.scale=r.USE_SIMD?o.SIMD.scale:o.scalar.scale,o.rotate=function(t,a,n,o){var u,l,e,M,s,i,c,h,S,I,f,x,D,F,m,d,b,v,z,p,w,E,A,P,L=o[0],q=o[1],R=o[2],N=Math.sqrt(L*L+q*q+R*R);return Math.abs(N)<r.EPSILON?null:(N=1/N,L*=N,q*=N,R*=N,u=Math.sin(n),l=Math.cos(n),e=1-l,M=a[0],s=a[1],i=a[2],c=a[3],h=a[4],S=a[5],I=a[6],f=a[7],x=a[8],D=a[9],F=a[10],m=a[11],d=L*L*e+l,b=q*L*e+R*u,v=R*L*e-q*u,z=L*q*e-R*u,p=q*q*e+l,w=R*q*e+L*u,E=L*R*e+q*u,A=q*R*e-L*u,P=R*R*e+l,t[0]=M*d+h*b+x*v,t[1]=s*d+S*b+D*v,t[2]=i*d+I*b+F*v,t[3]=c*d+f*b+m*v,t[4]=M*z+h*p+x*w,t[5]=s*z+S*p+D*w,t[6]=i*z+I*p+F*w,t[7]=c*z+f*p+m*w,t[8]=M*E+h*A+x*P,t[9]=s*E+S*A+D*P,t[10]=i*E+I*A+F*P,t[11]=c*E+f*A+m*P,a!==t&&(t[12]=a[12],t[13]=a[13],t[14]=a[14],t[15]=a[15]),t)},o.scalar.rotateX=function(t,a,n){var r=Math.sin(n),o=Math.cos(n),u=a[4],l=a[5],e=a[6],M=a[7],s=a[8],i=a[9],c=a[10],h=a[11];return a!==t&&(t[0]=a[0],t[1]=a[1],t[2]=a[2],t[3]=a[3],t[12]=a[12],t[13]=a[13],t[14]=a[14],t[15]=a[15]),t[4]=u*o+s*r,t[5]=l*o+i*r,t[6]=e*o+c*r,t[7]=M*o+h*r,t[8]=s*o-u*r,t[9]=i*o-l*r,t[10]=c*o-e*r,t[11]=h*o-M*r,t},o.SIMD.rotateX=function(t,a,n){var r=SIMD.Float32x4.splat(Math.sin(n)),o=SIMD.Float32x4.splat(Math.cos(n));a!==t&&(t[0]=a[0],t[1]=a[1],t[2]=a[2],t[3]=a[3],t[12]=a[12],t[13]=a[13],t[14]=a[14],t[15]=a[15]);var u=SIMD.Float32x4.load(a,4),l=SIMD.Float32x4.load(a,8);return SIMD.Float32x4.store(t,4,SIMD.Float32x4.add(SIMD.Float32x4.mul(u,o),SIMD.Float32x4.mul(l,r))),SIMD.Float32x4.store(t,8,SIMD.Float32x4.sub(SIMD.Float32x4.mul(l,o),SIMD.Float32x4.mul(u,r))),t},o.rotateX=r.USE_SIMD?o.SIMD.rotateX:o.scalar.rotateX,o.scalar.rotateY=function(t,a,n){var r=Math.sin(n),o=Math.cos(n),u=a[0],l=a[1],e=a[2],M=a[3],s=a[8],i=a[9],c=a[10],h=a[11];return a!==t&&(t[4]=a[4],t[5]=a[5],t[6]=a[6],t[7]=a[7],t[12]=a[12],t[13]=a[13],t[14]=a[14],t[15]=a[15]),t[0]=u*o-s*r,t[1]=l*o-i*r,t[2]=e*o-c*r,t[3]=M*o-h*r,t[8]=u*r+s*o,t[9]=l*r+i*o,t[10]=e*r+c*o,t[11]=M*r+h*o,t},o.SIMD.rotateY=function(t,a,n){var r=SIMD.Float32x4.splat(Math.sin(n)),o=SIMD.Float32x4.splat(Math.cos(n));a!==t&&(t[4]=a[4],t[5]=a[5],t[6]=a[6],t[7]=a[7],t[12]=a[12],t[13]=a[13],t[14]=a[14],t[15]=a[15]);var u=SIMD.Float32x4.load(a,0),l=SIMD.Float32x4.load(a,8);return SIMD.Float32x4.store(t,0,SIMD.Float32x4.sub(SIMD.Float32x4.mul(u,o),SIMD.Float32x4.mul(l,r))),SIMD.Float32x4.store(t,8,SIMD.Float32x4.add(SIMD.Float32x4.mul(u,r),SIMD.Float32x4.mul(l,o))),t},o.rotateY=r.USE_SIMD?o.SIMD.rotateY:o.scalar.rotateY,o.scalar.rotateZ=function(t,a,n){var r=Math.sin(n),o=Math.cos(n),u=a[0],l=a[1],e=a[2],M=a[3],s=a[4],i=a[5],c=a[6],h=a[7];return a!==t&&(t[8]=a[8],t[9]=a[9],t[10]=a[10],t[11]=a[11],t[12]=a[12],t[13]=a[13],t[14]=a[14],t[15]=a[15]),t[0]=u*o+s*r,t[1]=l*o+i*r,t[2]=e*o+c*r,t[3]=M*o+h*r,t[4]=s*o-u*r,t[5]=i*o-l*r,t[6]=c*o-e*r,t[7]=h*o-M*r,t},o.SIMD.rotateZ=function(t,a,n){var r=SIMD.Float32x4.splat(Math.sin(n)),o=SIMD.Float32x4.splat(Math.cos(n));a!==t&&(t[8]=a[8],t[9]=a[9],t[10]=a[10],t[11]=a[11],t[12]=a[12],t[13]=a[13],t[14]=a[14],t[15]=a[15]);var u=SIMD.Float32x4.load(a,0),l=SIMD.Float32x4.load(a,4);return SIMD.Float32x4.store(t,0,SIMD.Float32x4.add(SIMD.Float32x4.mul(u,o),SIMD.Float32x4.mul(l,r))),SIMD.Float32x4.store(t,4,SIMD.Float32x4.sub(SIMD.Float32x4.mul(l,o),SIMD.Float32x4.mul(u,r))),t},o.rotateZ=r.USE_SIMD?o.SIMD.rotateZ:o.scalar.rotateZ,o.fromTranslation=function(t,a){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=a[0],t[13]=a[1],t[14]=a[2],t[15]=1,t},o.fromScaling=function(t,a){return t[0]=a[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=a[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=a[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},o.fromRotation=function(t,a,n){var o,u,l,e=n[0],M=n[1],s=n[2],i=Math.sqrt(e*e+M*M+s*s);return Math.abs(i)<r.EPSILON?null:(i=1/i,e*=i,M*=i,s*=i,o=Math.sin(a),u=Math.cos(a),l=1-u,t[0]=e*e*l+u,t[1]=M*e*l+s*o,t[2]=s*e*l-M*o,t[3]=0,t[4]=e*M*l-s*o,t[5]=M*M*l+u,t[6]=s*M*l+e*o,t[7]=0,t[8]=e*s*l+M*o,t[9]=M*s*l-e*o,t[10]=s*s*l+u,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t)},o.fromXRotation=function(t,a){var n=Math.sin(a),r=Math.cos(a);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=r,t[6]=n,t[7]=0,t[8]=0,t[9]=-n,t[10]=r,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},o.fromYRotation=function(t,a){var n=Math.sin(a),r=Math.cos(a);return t[0]=r,t[1]=0,t[2]=-n,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=n,t[9]=0,t[10]=r,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},o.fromZRotation=function(t,a){var n=Math.sin(a),r=Math.cos(a);return t[0]=r,t[1]=n,t[2]=0,t[3]=0,t[4]=-n,t[5]=r,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},o.fromRotationTranslation=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=a[3],e=r+r,M=o+o,s=u+u,i=r*e,c=r*M,h=r*s,S=o*M,I=o*s,f=u*s,x=l*e,D=l*M,F=l*s;return t[0]=1-(S+f),t[1]=c+F,t[2]=h-D,t[3]=0,t[4]=c-F,t[5]=1-(i+f),t[6]=I+x,t[7]=0,t[8]=h+D,t[9]=I-x,t[10]=1-(i+S),t[11]=0,t[12]=n[0],t[13]=n[1],t[14]=n[2],t[15]=1,t},o.getTranslation=function(t,a){return t[0]=a[12],t[1]=a[13],t[2]=a[14],t},o.getRotation=function(t,a){var n=a[0]+a[5]+a[10],r=0;return n>0?(r=2*Math.sqrt(n+1),t[3]=.25*r,t[0]=(a[6]-a[9])/r,t[1]=(a[8]-a[2])/r,t[2]=(a[1]-a[4])/r):a[0]>a[5]&a[0]>a[10]?(r=2*Math.sqrt(1+a[0]-a[5]-a[10]),t[3]=(a[6]-a[9])/r,t[0]=.25*r,t[1]=(a[1]+a[4])/r,t[2]=(a[8]+a[2])/r):a[5]>a[10]?(r=2*Math.sqrt(1+a[5]-a[0]-a[10]),t[3]=(a[8]-a[2])/r,t[0]=(a[1]+a[4])/r,t[1]=.25*r,t[2]=(a[6]+a[9])/r):(r=2*Math.sqrt(1+a[10]-a[0]-a[5]),t[3]=(a[1]-a[4])/r,t[0]=(a[8]+a[2])/r,t[1]=(a[6]+a[9])/r,t[2]=.25*r),t},o.fromRotationTranslationScale=function(t,a,n,r){var o=a[0],u=a[1],l=a[2],e=a[3],M=o+o,s=u+u,i=l+l,c=o*M,h=o*s,S=o*i,I=u*s,f=u*i,x=l*i,D=e*M,F=e*s,m=e*i,d=r[0],b=r[1],v=r[2];return t[0]=(1-(I+x))*d,t[1]=(h+m)*d,t[2]=(S-F)*d,t[3]=0,t[4]=(h-m)*b,t[5]=(1-(c+x))*b,t[6]=(f+D)*b,t[7]=0,t[8]=(S+F)*v,t[9]=(f-D)*v,t[10]=(1-(c+I))*v,t[11]=0,t[12]=n[0],t[13]=n[1],t[14]=n[2],t[15]=1,t},o.fromRotationTranslationScaleOrigin=function(t,a,n,r,o){
var u=a[0],l=a[1],e=a[2],M=a[3],s=u+u,i=l+l,c=e+e,h=u*s,S=u*i,I=u*c,f=l*i,x=l*c,D=e*c,F=M*s,m=M*i,d=M*c,b=r[0],v=r[1],z=r[2],p=o[0],w=o[1],E=o[2];return t[0]=(1-(f+D))*b,t[1]=(S+d)*b,t[2]=(I-m)*b,t[3]=0,t[4]=(S-d)*v,t[5]=(1-(h+D))*v,t[6]=(x+F)*v,t[7]=0,t[8]=(I+m)*z,t[9]=(x-F)*z,t[10]=(1-(h+f))*z,t[11]=0,t[12]=n[0]+p-(t[0]*p+t[4]*w+t[8]*E),t[13]=n[1]+w-(t[1]*p+t[5]*w+t[9]*E),t[14]=n[2]+E-(t[2]*p+t[6]*w+t[10]*E),t[15]=1,t},o.fromQuat=function(t,a){var n=a[0],r=a[1],o=a[2],u=a[3],l=n+n,e=r+r,M=o+o,s=n*l,i=r*l,c=r*e,h=o*l,S=o*e,I=o*M,f=u*l,x=u*e,D=u*M;return t[0]=1-c-I,t[1]=i+D,t[2]=h-x,t[3]=0,t[4]=i-D,t[5]=1-s-I,t[6]=S+f,t[7]=0,t[8]=h+x,t[9]=S-f,t[10]=1-s-c,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},o.frustum=function(t,a,n,r,o,u,l){var e=1/(n-a),M=1/(o-r),s=1/(u-l);return t[0]=2*u*e,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=2*u*M,t[6]=0,t[7]=0,t[8]=(n+a)*e,t[9]=(o+r)*M,t[10]=(l+u)*s,t[11]=-1,t[12]=0,t[13]=0,t[14]=l*u*2*s,t[15]=0,t},o.perspective=function(t,a,n,r,o){var u=1/Math.tan(a/2),l=1/(r-o);return t[0]=u/n,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=u,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=(o+r)*l,t[11]=-1,t[12]=0,t[13]=0,t[14]=2*o*r*l,t[15]=0,t},o.perspectiveFromFieldOfView=function(t,a,n,r){var o=Math.tan(a.upDegrees*Math.PI/180),u=Math.tan(a.downDegrees*Math.PI/180),l=Math.tan(a.leftDegrees*Math.PI/180),e=Math.tan(a.rightDegrees*Math.PI/180),M=2/(l+e),s=2/(o+u);return t[0]=M,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=s,t[6]=0,t[7]=0,t[8]=-((l-e)*M*.5),t[9]=(o-u)*s*.5,t[10]=r/(n-r),t[11]=-1,t[12]=0,t[13]=0,t[14]=r*n/(n-r),t[15]=0,t},o.ortho=function(t,a,n,r,o,u,l){var e=1/(a-n),M=1/(r-o),s=1/(u-l);return t[0]=-2*e,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*M,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*s,t[11]=0,t[12]=(a+n)*e,t[13]=(o+r)*M,t[14]=(l+u)*s,t[15]=1,t},o.lookAt=function(t,a,n,u){var l,e,M,s,i,c,h,S,I,f,x=a[0],D=a[1],F=a[2],m=u[0],d=u[1],b=u[2],v=n[0],z=n[1],p=n[2];return Math.abs(x-v)<r.EPSILON&&Math.abs(D-z)<r.EPSILON&&Math.abs(F-p)<r.EPSILON?o.identity(t):(h=x-v,S=D-z,I=F-p,f=1/Math.sqrt(h*h+S*S+I*I),h*=f,S*=f,I*=f,l=d*I-b*S,e=b*h-m*I,M=m*S-d*h,f=Math.sqrt(l*l+e*e+M*M),f?(f=1/f,l*=f,e*=f,M*=f):(l=0,e=0,M=0),s=S*M-I*e,i=I*l-h*M,c=h*e-S*l,f=Math.sqrt(s*s+i*i+c*c),f?(f=1/f,s*=f,i*=f,c*=f):(s=0,i=0,c=0),t[0]=l,t[1]=s,t[2]=h,t[3]=0,t[4]=e,t[5]=i,t[6]=S,t[7]=0,t[8]=M,t[9]=c,t[10]=I,t[11]=0,t[12]=-(l*x+e*D+M*F),t[13]=-(s*x+i*D+c*F),t[14]=-(h*x+S*D+I*F),t[15]=1,t)},o.str=function(t){return"mat4("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+", "+t[8]+", "+t[9]+", "+t[10]+", "+t[11]+", "+t[12]+", "+t[13]+", "+t[14]+", "+t[15]+")"},o.frob=function(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+Math.pow(t[6],2)+Math.pow(t[7],2)+Math.pow(t[8],2)+Math.pow(t[9],2)+Math.pow(t[10],2)+Math.pow(t[11],2)+Math.pow(t[12],2)+Math.pow(t[13],2)+Math.pow(t[14],2)+Math.pow(t[15],2))},o.add=function(t,a,n){return t[0]=a[0]+n[0],t[1]=a[1]+n[1],t[2]=a[2]+n[2],t[3]=a[3]+n[3],t[4]=a[4]+n[4],t[5]=a[5]+n[5],t[6]=a[6]+n[6],t[7]=a[7]+n[7],t[8]=a[8]+n[8],t[9]=a[9]+n[9],t[10]=a[10]+n[10],t[11]=a[11]+n[11],t[12]=a[12]+n[12],t[13]=a[13]+n[13],t[14]=a[14]+n[14],t[15]=a[15]+n[15],t},o.subtract=function(t,a,n){return t[0]=a[0]-n[0],t[1]=a[1]-n[1],t[2]=a[2]-n[2],t[3]=a[3]-n[3],t[4]=a[4]-n[4],t[5]=a[5]-n[5],t[6]=a[6]-n[6],t[7]=a[7]-n[7],t[8]=a[8]-n[8],t[9]=a[9]-n[9],t[10]=a[10]-n[10],t[11]=a[11]-n[11],t[12]=a[12]-n[12],t[13]=a[13]-n[13],t[14]=a[14]-n[14],t[15]=a[15]-n[15],t},o.sub=o.subtract,o.multiplyScalar=function(t,a,n){return t[0]=a[0]*n,t[1]=a[1]*n,t[2]=a[2]*n,t[3]=a[3]*n,t[4]=a[4]*n,t[5]=a[5]*n,t[6]=a[6]*n,t[7]=a[7]*n,t[8]=a[8]*n,t[9]=a[9]*n,t[10]=a[10]*n,t[11]=a[11]*n,t[12]=a[12]*n,t[13]=a[13]*n,t[14]=a[14]*n,t[15]=a[15]*n,t},o.multiplyScalarAndAdd=function(t,a,n,r){return t[0]=a[0]+n[0]*r,t[1]=a[1]+n[1]*r,t[2]=a[2]+n[2]*r,t[3]=a[3]+n[3]*r,t[4]=a[4]+n[4]*r,t[5]=a[5]+n[5]*r,t[6]=a[6]+n[6]*r,t[7]=a[7]+n[7]*r,t[8]=a[8]+n[8]*r,t[9]=a[9]+n[9]*r,t[10]=a[10]+n[10]*r,t[11]=a[11]+n[11]*r,t[12]=a[12]+n[12]*r,t[13]=a[13]+n[13]*r,t[14]=a[14]+n[14]*r,t[15]=a[15]+n[15]*r,t},o.exactEquals=function(t,a){return t[0]===a[0]&&t[1]===a[1]&&t[2]===a[2]&&t[3]===a[3]&&t[4]===a[4]&&t[5]===a[5]&&t[6]===a[6]&&t[7]===a[7]&&t[8]===a[8]&&t[9]===a[9]&&t[10]===a[10]&&t[11]===a[11]&&t[12]===a[12]&&t[13]===a[13]&&t[14]===a[14]&&t[15]===a[15]},o.equals=function(t,a){var n=t[0],o=t[1],u=t[2],l=t[3],e=t[4],M=t[5],s=t[6],i=t[7],c=t[8],h=t[9],S=t[10],I=t[11],f=t[12],x=t[13],D=t[14],F=t[15],m=a[0],d=a[1],b=a[2],v=a[3],z=a[4],p=a[5],w=a[6],E=a[7],A=a[8],P=a[9],L=a[10],q=a[11],R=a[12],N=a[13],O=a[14],Y=a[15];return Math.abs(n-m)<=r.EPSILON*Math.max(1,Math.abs(n),Math.abs(m))&&Math.abs(o-d)<=r.EPSILON*Math.max(1,Math.abs(o),Math.abs(d))&&Math.abs(u-b)<=r.EPSILON*Math.max(1,Math.abs(u),Math.abs(b))&&Math.abs(l-v)<=r.EPSILON*Math.max(1,Math.abs(l),Math.abs(v))&&Math.abs(e-z)<=r.EPSILON*Math.max(1,Math.abs(e),Math.abs(z))&&Math.abs(M-p)<=r.EPSILON*Math.max(1,Math.abs(M),Math.abs(p))&&Math.abs(s-w)<=r.EPSILON*Math.max(1,Math.abs(s),Math.abs(w))&&Math.abs(i-E)<=r.EPSILON*Math.max(1,Math.abs(i),Math.abs(E))&&Math.abs(c-A)<=r.EPSILON*Math.max(1,Math.abs(c),Math.abs(A))&&Math.abs(h-P)<=r.EPSILON*Math.max(1,Math.abs(h),Math.abs(P))&&Math.abs(S-L)<=r.EPSILON*Math.max(1,Math.abs(S),Math.abs(L))&&Math.abs(I-q)<=r.EPSILON*Math.max(1,Math.abs(I),Math.abs(q))&&Math.abs(f-R)<=r.EPSILON*Math.max(1,Math.abs(f),Math.abs(R))&&Math.abs(x-N)<=r.EPSILON*Math.max(1,Math.abs(x),Math.abs(N))&&Math.abs(D-O)<=r.EPSILON*Math.max(1,Math.abs(D),Math.abs(O))&&Math.abs(F-Y)<=r.EPSILON*Math.max(1,Math.abs(F),Math.abs(Y))},t.exports=o},function(t,a,n){var r=n(1),o=n(4),u=n(7),l=n(8),e={};e.create=function(){var t=new r.ARRAY_TYPE(4);return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t},e.rotationTo=function(){var t=u.create(),a=u.fromValues(1,0,0),n=u.fromValues(0,1,0);return function(r,o,l){var M=u.dot(o,l);return-.999999>M?(u.cross(t,a,o),u.length(t)<1e-6&&u.cross(t,n,o),u.normalize(t,t),e.setAxisAngle(r,t,Math.PI),r):M>.999999?(r[0]=0,r[1]=0,r[2]=0,r[3]=1,r):(u.cross(t,o,l),r[0]=t[0],r[1]=t[1],r[2]=t[2],r[3]=1+M,e.normalize(r,r))}}(),e.setAxes=function(){var t=o.create();return function(a,n,r,o){return t[0]=r[0],t[3]=r[1],t[6]=r[2],t[1]=o[0],t[4]=o[1],t[7]=o[2],t[2]=-n[0],t[5]=-n[1],t[8]=-n[2],e.normalize(a,e.fromMat3(a,t))}}(),e.clone=l.clone,e.fromValues=l.fromValues,e.copy=l.copy,e.set=l.set,e.identity=function(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t},e.setAxisAngle=function(t,a,n){n=.5*n;var r=Math.sin(n);return t[0]=r*a[0],t[1]=r*a[1],t[2]=r*a[2],t[3]=Math.cos(n),t},e.getAxisAngle=function(t,a){var n=2*Math.acos(a[3]),r=Math.sin(n/2);return 0!=r?(t[0]=a[0]/r,t[1]=a[1]/r,t[2]=a[2]/r):(t[0]=1,t[1]=0,t[2]=0),n},e.add=l.add,e.multiply=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=a[3],e=n[0],M=n[1],s=n[2],i=n[3];return t[0]=r*i+l*e+o*s-u*M,t[1]=o*i+l*M+u*e-r*s,t[2]=u*i+l*s+r*M-o*e,t[3]=l*i-r*e-o*M-u*s,t},e.mul=e.multiply,e.scale=l.scale,e.rotateX=function(t,a,n){n*=.5;var r=a[0],o=a[1],u=a[2],l=a[3],e=Math.sin(n),M=Math.cos(n);return t[0]=r*M+l*e,t[1]=o*M+u*e,t[2]=u*M-o*e,t[3]=l*M-r*e,t},e.rotateY=function(t,a,n){n*=.5;var r=a[0],o=a[1],u=a[2],l=a[3],e=Math.sin(n),M=Math.cos(n);return t[0]=r*M-u*e,t[1]=o*M+l*e,t[2]=u*M+r*e,t[3]=l*M-o*e,t},e.rotateZ=function(t,a,n){n*=.5;var r=a[0],o=a[1],u=a[2],l=a[3],e=Math.sin(n),M=Math.cos(n);return t[0]=r*M+o*e,t[1]=o*M-r*e,t[2]=u*M+l*e,t[3]=l*M-u*e,t},e.calculateW=function(t,a){var n=a[0],r=a[1],o=a[2];return t[0]=n,t[1]=r,t[2]=o,t[3]=Math.sqrt(Math.abs(1-n*n-r*r-o*o)),t},e.dot=l.dot,e.lerp=l.lerp,e.slerp=function(t,a,n,r){var o,u,l,e,M,s=a[0],i=a[1],c=a[2],h=a[3],S=n[0],I=n[1],f=n[2],x=n[3];return u=s*S+i*I+c*f+h*x,0>u&&(u=-u,S=-S,I=-I,f=-f,x=-x),1-u>1e-6?(o=Math.acos(u),l=Math.sin(o),e=Math.sin((1-r)*o)/l,M=Math.sin(r*o)/l):(e=1-r,M=r),t[0]=e*s+M*S,t[1]=e*i+M*I,t[2]=e*c+M*f,t[3]=e*h+M*x,t},e.sqlerp=function(){var t=e.create(),a=e.create();return function(n,r,o,u,l,M){return e.slerp(t,r,l,M),e.slerp(a,o,u,M),e.slerp(n,t,a,2*M*(1-M)),n}}(),e.invert=function(t,a){var n=a[0],r=a[1],o=a[2],u=a[3],l=n*n+r*r+o*o+u*u,e=l?1/l:0;return t[0]=-n*e,t[1]=-r*e,t[2]=-o*e,t[3]=u*e,t},e.conjugate=function(t,a){return t[0]=-a[0],t[1]=-a[1],t[2]=-a[2],t[3]=a[3],t},e.length=l.length,e.len=e.length,e.squaredLength=l.squaredLength,e.sqrLen=e.squaredLength,e.normalize=l.normalize,e.fromMat3=function(t,a){var n,r=a[0]+a[4]+a[8];if(r>0)n=Math.sqrt(r+1),t[3]=.5*n,n=.5/n,t[0]=(a[5]-a[7])*n,t[1]=(a[6]-a[2])*n,t[2]=(a[1]-a[3])*n;else{var o=0;a[4]>a[0]&&(o=1),a[8]>a[3*o+o]&&(o=2);var u=(o+1)%3,l=(o+2)%3;n=Math.sqrt(a[3*o+o]-a[3*u+u]-a[3*l+l]+1),t[o]=.5*n,n=.5/n,t[3]=(a[3*u+l]-a[3*l+u])*n,t[u]=(a[3*u+o]+a[3*o+u])*n,t[l]=(a[3*l+o]+a[3*o+l])*n}return t},e.str=function(t){return"quat("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"},e.exactEquals=l.exactEquals,e.equals=l.equals,t.exports=e},function(t,a,n){var r=n(1),o={};o.create=function(){var t=new r.ARRAY_TYPE(3);return t[0]=0,t[1]=0,t[2]=0,t},o.clone=function(t){var a=new r.ARRAY_TYPE(3);return a[0]=t[0],a[1]=t[1],a[2]=t[2],a},o.fromValues=function(t,a,n){var o=new r.ARRAY_TYPE(3);return o[0]=t,o[1]=a,o[2]=n,o},o.copy=function(t,a){return t[0]=a[0],t[1]=a[1],t[2]=a[2],t},o.set=function(t,a,n,r){return t[0]=a,t[1]=n,t[2]=r,t},o.add=function(t,a,n){return t[0]=a[0]+n[0],t[1]=a[1]+n[1],t[2]=a[2]+n[2],t},o.subtract=function(t,a,n){return t[0]=a[0]-n[0],t[1]=a[1]-n[1],t[2]=a[2]-n[2],t},o.sub=o.subtract,o.multiply=function(t,a,n){return t[0]=a[0]*n[0],t[1]=a[1]*n[1],t[2]=a[2]*n[2],t},o.mul=o.multiply,o.divide=function(t,a,n){return t[0]=a[0]/n[0],t[1]=a[1]/n[1],t[2]=a[2]/n[2],t},o.div=o.divide,o.ceil=function(t,a){return t[0]=Math.ceil(a[0]),t[1]=Math.ceil(a[1]),t[2]=Math.ceil(a[2]),t},o.floor=function(t,a){return t[0]=Math.floor(a[0]),t[1]=Math.floor(a[1]),t[2]=Math.floor(a[2]),t},o.min=function(t,a,n){return t[0]=Math.min(a[0],n[0]),t[1]=Math.min(a[1],n[1]),t[2]=Math.min(a[2],n[2]),t},o.max=function(t,a,n){return t[0]=Math.max(a[0],n[0]),t[1]=Math.max(a[1],n[1]),t[2]=Math.max(a[2],n[2]),t},o.round=function(t,a){return t[0]=Math.round(a[0]),t[1]=Math.round(a[1]),t[2]=Math.round(a[2]),t},o.scale=function(t,a,n){return t[0]=a[0]*n,t[1]=a[1]*n,t[2]=a[2]*n,t},o.scaleAndAdd=function(t,a,n,r){return t[0]=a[0]+n[0]*r,t[1]=a[1]+n[1]*r,t[2]=a[2]+n[2]*r,t},o.distance=function(t,a){var n=a[0]-t[0],r=a[1]-t[1],o=a[2]-t[2];return Math.sqrt(n*n+r*r+o*o)},o.dist=o.distance,o.squaredDistance=function(t,a){var n=a[0]-t[0],r=a[1]-t[1],o=a[2]-t[2];return n*n+r*r+o*o},o.sqrDist=o.squaredDistance,o.length=function(t){var a=t[0],n=t[1],r=t[2];return Math.sqrt(a*a+n*n+r*r)},o.len=o.length,o.squaredLength=function(t){var a=t[0],n=t[1],r=t[2];return a*a+n*n+r*r},o.sqrLen=o.squaredLength,o.negate=function(t,a){return t[0]=-a[0],t[1]=-a[1],t[2]=-a[2],t},o.inverse=function(t,a){return t[0]=1/a[0],t[1]=1/a[1],t[2]=1/a[2],t},o.normalize=function(t,a){var n=a[0],r=a[1],o=a[2],u=n*n+r*r+o*o;return u>0&&(u=1/Math.sqrt(u),t[0]=a[0]*u,t[1]=a[1]*u,t[2]=a[2]*u),t},o.dot=function(t,a){return t[0]*a[0]+t[1]*a[1]+t[2]*a[2]},o.cross=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=n[0],e=n[1],M=n[2];return t[0]=o*M-u*e,t[1]=u*l-r*M,t[2]=r*e-o*l,t},o.lerp=function(t,a,n,r){var o=a[0],u=a[1],l=a[2];return t[0]=o+r*(n[0]-o),t[1]=u+r*(n[1]-u),t[2]=l+r*(n[2]-l),t},o.hermite=function(t,a,n,r,o,u){var l=u*u,e=l*(2*u-3)+1,M=l*(u-2)+u,s=l*(u-1),i=l*(3-2*u);return t[0]=a[0]*e+n[0]*M+r[0]*s+o[0]*i,t[1]=a[1]*e+n[1]*M+r[1]*s+o[1]*i,t[2]=a[2]*e+n[2]*M+r[2]*s+o[2]*i,t},o.bezier=function(t,a,n,r,o,u){var l=1-u,e=l*l,M=u*u,s=e*l,i=3*u*e,c=3*M*l,h=M*u;return t[0]=a[0]*s+n[0]*i+r[0]*c+o[0]*h,t[1]=a[1]*s+n[1]*i+r[1]*c+o[1]*h,t[2]=a[2]*s+n[2]*i+r[2]*c+o[2]*h,t},o.random=function(t,a){a=a||1;var n=2*r.RANDOM()*Math.PI,o=2*r.RANDOM()-1,u=Math.sqrt(1-o*o)*a;return t[0]=Math.cos(n)*u,t[1]=Math.sin(n)*u,t[2]=o*a,t},o.transformMat4=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=n[3]*r+n[7]*o+n[11]*u+n[15];return l=l||1,t[0]=(n[0]*r+n[4]*o+n[8]*u+n[12])/l,t[1]=(n[1]*r+n[5]*o+n[9]*u+n[13])/l,t[2]=(n[2]*r+n[6]*o+n[10]*u+n[14])/l,t},o.transformMat3=function(t,a,n){var r=a[0],o=a[1],u=a[2];return t[0]=r*n[0]+o*n[3]+u*n[6],t[1]=r*n[1]+o*n[4]+u*n[7],t[2]=r*n[2]+o*n[5]+u*n[8],t},o.transformQuat=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=n[0],e=n[1],M=n[2],s=n[3],i=s*r+e*u-M*o,c=s*o+M*r-l*u,h=s*u+l*o-e*r,S=-l*r-e*o-M*u;return t[0]=i*s+S*-l+c*-M-h*-e,t[1]=c*s+S*-e+h*-l-i*-M,t[2]=h*s+S*-M+i*-e-c*-l,t},o.rotateX=function(t,a,n,r){var o=[],u=[];return o[0]=a[0]-n[0],o[1]=a[1]-n[1],o[2]=a[2]-n[2],u[0]=o[0],u[1]=o[1]*Math.cos(r)-o[2]*Math.sin(r),u[2]=o[1]*Math.sin(r)+o[2]*Math.cos(r),t[0]=u[0]+n[0],t[1]=u[1]+n[1],t[2]=u[2]+n[2],t},o.rotateY=function(t,a,n,r){var o=[],u=[];return o[0]=a[0]-n[0],o[1]=a[1]-n[1],o[2]=a[2]-n[2],u[0]=o[2]*Math.sin(r)+o[0]*Math.cos(r),u[1]=o[1],u[2]=o[2]*Math.cos(r)-o[0]*Math.sin(r),t[0]=u[0]+n[0],t[1]=u[1]+n[1],t[2]=u[2]+n[2],t},o.rotateZ=function(t,a,n,r){var o=[],u=[];return o[0]=a[0]-n[0],o[1]=a[1]-n[1],o[2]=a[2]-n[2],u[0]=o[0]*Math.cos(r)-o[1]*Math.sin(r),u[1]=o[0]*Math.sin(r)+o[1]*Math.cos(r),u[2]=o[2],t[0]=u[0]+n[0],t[1]=u[1]+n[1],t[2]=u[2]+n[2],t},o.forEach=function(){var t=o.create();return function(a,n,r,o,u,l){var e,M;for(n||(n=3),r||(r=0),M=o?Math.min(o*n+r,a.length):a.length,e=r;M>e;e+=n)t[0]=a[e],t[1]=a[e+1],t[2]=a[e+2],u(t,t,l),a[e]=t[0],a[e+1]=t[1],a[e+2]=t[2];return a}}(),o.angle=function(t,a){var n=o.fromValues(t[0],t[1],t[2]),r=o.fromValues(a[0],a[1],a[2]);o.normalize(n,n),o.normalize(r,r);var u=o.dot(n,r);return u>1?0:Math.acos(u)},o.str=function(t){return"vec3("+t[0]+", "+t[1]+", "+t[2]+")"},o.exactEquals=function(t,a){return t[0]===a[0]&&t[1]===a[1]&&t[2]===a[2]},o.equals=function(t,a){var n=t[0],o=t[1],u=t[2],l=a[0],e=a[1],M=a[2];return Math.abs(n-l)<=r.EPSILON*Math.max(1,Math.abs(n),Math.abs(l))&&Math.abs(o-e)<=r.EPSILON*Math.max(1,Math.abs(o),Math.abs(e))&&Math.abs(u-M)<=r.EPSILON*Math.max(1,Math.abs(u),Math.abs(M))},t.exports=o},function(t,a,n){var r=n(1),o={};o.create=function(){var t=new r.ARRAY_TYPE(4);return t[0]=0,t[1]=0,t[2]=0,t[3]=0,t},o.clone=function(t){var a=new r.ARRAY_TYPE(4);return a[0]=t[0],a[1]=t[1],a[2]=t[2],a[3]=t[3],a},o.fromValues=function(t,a,n,o){var u=new r.ARRAY_TYPE(4);return u[0]=t,u[1]=a,u[2]=n,u[3]=o,u},o.copy=function(t,a){return t[0]=a[0],t[1]=a[1],t[2]=a[2],t[3]=a[3],t},o.set=function(t,a,n,r,o){return t[0]=a,t[1]=n,t[2]=r,t[3]=o,t},o.add=function(t,a,n){return t[0]=a[0]+n[0],t[1]=a[1]+n[1],t[2]=a[2]+n[2],t[3]=a[3]+n[3],t},o.subtract=function(t,a,n){return t[0]=a[0]-n[0],t[1]=a[1]-n[1],t[2]=a[2]-n[2],t[3]=a[3]-n[3],t},o.sub=o.subtract,o.multiply=function(t,a,n){return t[0]=a[0]*n[0],t[1]=a[1]*n[1],t[2]=a[2]*n[2],t[3]=a[3]*n[3],t},o.mul=o.multiply,o.divide=function(t,a,n){return t[0]=a[0]/n[0],t[1]=a[1]/n[1],t[2]=a[2]/n[2],t[3]=a[3]/n[3],t},o.div=o.divide,o.ceil=function(t,a){return t[0]=Math.ceil(a[0]),t[1]=Math.ceil(a[1]),t[2]=Math.ceil(a[2]),t[3]=Math.ceil(a[3]),t},o.floor=function(t,a){return t[0]=Math.floor(a[0]),t[1]=Math.floor(a[1]),t[2]=Math.floor(a[2]),t[3]=Math.floor(a[3]),t},o.min=function(t,a,n){return t[0]=Math.min(a[0],n[0]),t[1]=Math.min(a[1],n[1]),t[2]=Math.min(a[2],n[2]),t[3]=Math.min(a[3],n[3]),t},o.max=function(t,a,n){return t[0]=Math.max(a[0],n[0]),t[1]=Math.max(a[1],n[1]),t[2]=Math.max(a[2],n[2]),t[3]=Math.max(a[3],n[3]),t},o.round=function(t,a){return t[0]=Math.round(a[0]),t[1]=Math.round(a[1]),t[2]=Math.round(a[2]),t[3]=Math.round(a[3]),t},o.scale=function(t,a,n){return t[0]=a[0]*n,t[1]=a[1]*n,t[2]=a[2]*n,t[3]=a[3]*n,t},o.scaleAndAdd=function(t,a,n,r){return t[0]=a[0]+n[0]*r,t[1]=a[1]+n[1]*r,t[2]=a[2]+n[2]*r,t[3]=a[3]+n[3]*r,t},o.distance=function(t,a){var n=a[0]-t[0],r=a[1]-t[1],o=a[2]-t[2],u=a[3]-t[3];return Math.sqrt(n*n+r*r+o*o+u*u)},o.dist=o.distance,o.squaredDistance=function(t,a){var n=a[0]-t[0],r=a[1]-t[1],o=a[2]-t[2],u=a[3]-t[3];return n*n+r*r+o*o+u*u},o.sqrDist=o.squaredDistance,o.length=function(t){var a=t[0],n=t[1],r=t[2],o=t[3];return Math.sqrt(a*a+n*n+r*r+o*o)},o.len=o.length,o.squaredLength=function(t){var a=t[0],n=t[1],r=t[2],o=t[3];return a*a+n*n+r*r+o*o},o.sqrLen=o.squaredLength,o.negate=function(t,a){return t[0]=-a[0],t[1]=-a[1],t[2]=-a[2],t[3]=-a[3],t},o.inverse=function(t,a){return t[0]=1/a[0],t[1]=1/a[1],t[2]=1/a[2],t[3]=1/a[3],t},o.normalize=function(t,a){var n=a[0],r=a[1],o=a[2],u=a[3],l=n*n+r*r+o*o+u*u;return l>0&&(l=1/Math.sqrt(l),t[0]=n*l,t[1]=r*l,t[2]=o*l,t[3]=u*l),t},o.dot=function(t,a){return t[0]*a[0]+t[1]*a[1]+t[2]*a[2]+t[3]*a[3]},o.lerp=function(t,a,n,r){var o=a[0],u=a[1],l=a[2],e=a[3];return t[0]=o+r*(n[0]-o),t[1]=u+r*(n[1]-u),t[2]=l+r*(n[2]-l),t[3]=e+r*(n[3]-e),t},o.random=function(t,a){return a=a||1,t[0]=r.RANDOM(),t[1]=r.RANDOM(),t[2]=r.RANDOM(),t[3]=r.RANDOM(),o.normalize(t,t),o.scale(t,t,a),t},o.transformMat4=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=a[3];return t[0]=n[0]*r+n[4]*o+n[8]*u+n[12]*l,t[1]=n[1]*r+n[5]*o+n[9]*u+n[13]*l,t[2]=n[2]*r+n[6]*o+n[10]*u+n[14]*l,t[3]=n[3]*r+n[7]*o+n[11]*u+n[15]*l,t},o.transformQuat=function(t,a,n){var r=a[0],o=a[1],u=a[2],l=n[0],e=n[1],M=n[2],s=n[3],i=s*r+e*u-M*o,c=s*o+M*r-l*u,h=s*u+l*o-e*r,S=-l*r-e*o-M*u;return t[0]=i*s+S*-l+c*-M-h*-e,t[1]=c*s+S*-e+h*-l-i*-M,t[2]=h*s+S*-M+i*-e-c*-l,t[3]=a[3],t},o.forEach=function(){var t=o.create();return function(a,n,r,o,u,l){var e,M;for(n||(n=4),r||(r=0),M=o?Math.min(o*n+r,a.length):a.length,e=r;M>e;e+=n)t[0]=a[e],t[1]=a[e+1],t[2]=a[e+2],t[3]=a[e+3],u(t,t,l),a[e]=t[0],a[e+1]=t[1],a[e+2]=t[2],a[e+3]=t[3];return a}}(),o.str=function(t){return"vec4("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"},o.exactEquals=function(t,a){return t[0]===a[0]&&t[1]===a[1]&&t[2]===a[2]&&t[3]===a[3]},o.equals=function(t,a){var n=t[0],o=t[1],u=t[2],l=t[3],e=a[0],M=a[1],s=a[2],i=a[3];return Math.abs(n-e)<=r.EPSILON*Math.max(1,Math.abs(n),Math.abs(e))&&Math.abs(o-M)<=r.EPSILON*Math.max(1,Math.abs(o),Math.abs(M))&&Math.abs(u-s)<=r.EPSILON*Math.max(1,Math.abs(u),Math.abs(s))&&Math.abs(l-i)<=r.EPSILON*Math.max(1,Math.abs(l),Math.abs(i))},t.exports=o},function(t,a,n){var r=n(1),o={};o.create=function(){var t=new r.ARRAY_TYPE(2);return t[0]=0,t[1]=0,t},o.clone=function(t){var a=new r.ARRAY_TYPE(2);return a[0]=t[0],a[1]=t[1],a},o.fromValues=function(t,a){var n=new r.ARRAY_TYPE(2);return n[0]=t,n[1]=a,n},o.copy=function(t,a){return t[0]=a[0],t[1]=a[1],t},o.set=function(t,a,n){return t[0]=a,t[1]=n,t},o.add=function(t,a,n){return t[0]=a[0]+n[0],t[1]=a[1]+n[1],t},o.subtract=function(t,a,n){return t[0]=a[0]-n[0],t[1]=a[1]-n[1],t},o.sub=o.subtract,o.multiply=function(t,a,n){return t[0]=a[0]*n[0],t[1]=a[1]*n[1],t},o.mul=o.multiply,o.divide=function(t,a,n){return t[0]=a[0]/n[0],t[1]=a[1]/n[1],t},o.div=o.divide,o.ceil=function(t,a){return t[0]=Math.ceil(a[0]),t[1]=Math.ceil(a[1]),t},o.floor=function(t,a){return t[0]=Math.floor(a[0]),t[1]=Math.floor(a[1]),t},o.min=function(t,a,n){return t[0]=Math.min(a[0],n[0]),t[1]=Math.min(a[1],n[1]),t},o.max=function(t,a,n){return t[0]=Math.max(a[0],n[0]),t[1]=Math.max(a[1],n[1]),t},o.round=function(t,a){return t[0]=Math.round(a[0]),t[1]=Math.round(a[1]),t},o.scale=function(t,a,n){return t[0]=a[0]*n,t[1]=a[1]*n,t},o.scaleAndAdd=function(t,a,n,r){return t[0]=a[0]+n[0]*r,t[1]=a[1]+n[1]*r,t},o.distance=function(t,a){var n=a[0]-t[0],r=a[1]-t[1];return Math.sqrt(n*n+r*r)},o.dist=o.distance,o.squaredDistance=function(t,a){var n=a[0]-t[0],r=a[1]-t[1];return n*n+r*r},o.sqrDist=o.squaredDistance,o.length=function(t){var a=t[0],n=t[1];return Math.sqrt(a*a+n*n)},o.len=o.length,o.squaredLength=function(t){var a=t[0],n=t[1];return a*a+n*n},o.sqrLen=o.squaredLength,o.negate=function(t,a){return t[0]=-a[0],t[1]=-a[1],t},o.inverse=function(t,a){return t[0]=1/a[0],t[1]=1/a[1],t},o.normalize=function(t,a){var n=a[0],r=a[1],o=n*n+r*r;return o>0&&(o=1/Math.sqrt(o),t[0]=a[0]*o,t[1]=a[1]*o),t},o.dot=function(t,a){return t[0]*a[0]+t[1]*a[1]},o.cross=function(t,a,n){var r=a[0]*n[1]-a[1]*n[0];return t[0]=t[1]=0,t[2]=r,t},o.lerp=function(t,a,n,r){var o=a[0],u=a[1];return t[0]=o+r*(n[0]-o),t[1]=u+r*(n[1]-u),t},o.random=function(t,a){a=a||1;var n=2*r.RANDOM()*Math.PI;return t[0]=Math.cos(n)*a,t[1]=Math.sin(n)*a,t},o.transformMat2=function(t,a,n){var r=a[0],o=a[1];return t[0]=n[0]*r+n[2]*o,t[1]=n[1]*r+n[3]*o,t},o.transformMat2d=function(t,a,n){var r=a[0],o=a[1];return t[0]=n[0]*r+n[2]*o+n[4],t[1]=n[1]*r+n[3]*o+n[5],t},o.transformMat3=function(t,a,n){var r=a[0],o=a[1];return t[0]=n[0]*r+n[3]*o+n[6],t[1]=n[1]*r+n[4]*o+n[7],t},o.transformMat4=function(t,a,n){var r=a[0],o=a[1];return t[0]=n[0]*r+n[4]*o+n[12],t[1]=n[1]*r+n[5]*o+n[13],t},o.forEach=function(){var t=o.create();return function(a,n,r,o,u,l){var e,M;for(n||(n=2),r||(r=0),M=o?Math.min(o*n+r,a.length):a.length,e=r;M>e;e+=n)t[0]=a[e],t[1]=a[e+1],u(t,t,l),a[e]=t[0],a[e+1]=t[1];return a}}(),o.str=function(t){return"vec2("+t[0]+", "+t[1]+")"},o.exactEquals=function(t,a){return t[0]===a[0]&&t[1]===a[1]},o.equals=function(t,a){var n=t[0],o=t[1],u=a[0],l=a[1];return Math.abs(n-u)<=r.EPSILON*Math.max(1,Math.abs(n),Math.abs(u))&&Math.abs(o-l)<=r.EPSILON*Math.max(1,Math.abs(o),Math.abs(l))},t.exports=o}])});
/*
Copyright (c) 2015, Brandon Jones.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

/*
Utility class to make loading shader programs easier. Does all the error
checking you typically want, automatically queries uniform and attribute
locations, and attempts to take advantage of some browser's ability to link
asynchronously by not querying any information from the program until it's
first use.
*/
var WGLUProgram = (function() {

  "use strict";

  // Attempts to allow the browser to asynchronously compile and link
  var Program = function(gl) {
    this.gl = gl;
    this.program = gl.createProgram();
    this.attrib = null;
    this.uniform = null;

    this._firstUse = true;
    this._vertexShader = null;
    this._fragmentShader = null;
  }

  Program.prototype.attachShaderSource = function(source, type) {
    var gl = this.gl;
    var shader;

    switch (type) {
      case gl.VERTEX_SHADER:
        this._vertexShader = gl.createShader(type);
        shader = this._vertexShader;
        break;
      case gl.FRAGMENT_SHADER:
        this._fragmentShader = gl.createShader(type);
        shader = this._fragmentShader;
        break;
      default:
        console.Error("Invalid Shader Type:", type);
        return;
    }

    gl.attachShader(this.program, shader);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
  }

  Program.prototype.attachShaderSourceFromXHR = function(url, type) {
    var self = this;
    return new Promise(function(resolve, reject) {
      var xhr = new XMLHttpRequest();
      xhr.addEventListener("load", function (ev) {
        if (xhr.status == 200) {
          self.attachShaderSource(xhr.response, type);
          resolve();
        } else {
          reject(xhr.statusText);
        }
      }, false);
      xhr.open("GET", url, true);
      xhr.send(null);
    });
  }

  Program.prototype.attachShaderSourceFromTag = function(tagId, type) {
    var shaderTag = document.getElementById(tagId);
    if (!shaderTag) {
      console.error("Shader source tag not found:", tagId);
      return;
    }

    if (!type) {
      if (shaderTag.type == "x-shader/x-vertex") {
        type = this.gl.VERTEX_SHADER;
      } else if (shaderTag.type == "x-shader/x-fragment") {
        type = this.gl.FRAGMENT_SHADER;
      } else {
        console.error("Invalid Shader Type:", shaderTag.type);
        return;
      }
    }

    var src = "";
    var k = shaderTag.firstChild;
    while (k) {
      if (k.nodeType == 3) {
        src += k.textContent;
      }
      k = k.nextSibling;
    }
    this.attachShaderSource(src, type);
  }

  Program.prototype.bindAttribLocation = function(attribLocationMap) {
    var gl = this.gl;

    if (attribLocationMap) {
      this.attrib = {};
      for (var attribName in attribLocationMap) {
        gl.bindAttribLocation(this.program, attribLocationMap[attribName], attribName);
        this.attrib[attribName] = attribLocationMap[attribName];
      }
    }
  }

  Program.prototype.transformFeedbackVaryings = function(varyings, type) {
    gl.transformFeedbackVaryings(this.program, varyings, type);
  }

  Program.prototype.link = function() {
    this.gl.linkProgram(this.program);
  }

  Program.prototype.use = function() {
    var gl = this.gl;

    // If this is the first time the program has been used do all the error checking and
    // attrib/uniform querying needed.
    if (this._firstUse) {
      if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
        if (this._vertexShader && !gl.getShaderParameter(this._vertexShader, gl.COMPILE_STATUS)) {
          console.error("Vertex shader compile error:", gl.getShaderInfoLog(this._vertexShader));
        } else if (this._fragmentShader && !gl.getShaderParameter(this._fragmentShader, gl.COMPILE_STATUS)) {
          console.error("Fragment shader compile error:", gl.getShaderInfoLog(this._fragmentShader));
        } else {
          console.error("Program link error:", gl.getProgramInfoLog(this.program));
        }
        gl.deleteProgram(this.program);
        this.program = null;
      } else {
        if (!this.attrib) {
          this.attrib = {};
          var attribCount = gl.getProgramParameter(this.program, gl.ACTIVE_ATTRIBUTES);
          for (var i = 0; i < attribCount; i++) {
            var attribInfo = gl.getActiveAttrib(this.program, i);
            this.attrib[attribInfo.name] = gl.getAttribLocation(this.program, attribInfo.name);
          }
        }

        this.uniform = {};
        var uniformCount = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);
        var uniformName = "";
        for (var i = 0; i < uniformCount; i++) {
          var uniformInfo = gl.getActiveUniform(this.program, i);
          uniformName = uniformInfo.name.replace("[0]", "");
          this.uniform[uniformName] = gl.getUniformLocation(this.program, uniformName);
        }
      }
      gl.deleteShader(this._vertexShader);
      gl.deleteShader(this._fragmentShader);
      this._firstUse = false;
    }

    gl.useProgram(this.program);
  }

  return Program;
})();

/**
 * @license
 * webvr-polyfill
 * Copyright (c) 2015-2017 Google
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * wglu-preserve-state.js
 * Copyright (c) 2016, Brandon Jones.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/******/ (function (modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if (installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
			/******/
}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
			/******/
};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
		/******/
}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function (exports, name, getter) {
/******/ 		if (!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
				/******/
});
			/******/
}
		/******/
};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function (module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
		/******/
};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 7);
	/******/
})
/************************************************************************/
/******/([
/* 0 */
/***/ (function (module, exports) {

			/*
			 * Copyright 2015 Google Inc. All Rights Reserved.
			 * Licensed under the Apache License, Version 2.0 (the "License");
			 * you may not use this file except in compliance with the License.
			 * You may obtain a copy of the License at
			 *
			 *     http://www.apache.org/licenses/LICENSE-2.0
			 *
			 * Unless required by applicable law or agreed to in writing, software
			 * distributed under the License is distributed on an "AS IS" BASIS,
			 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
			 * See the License for the specific language governing permissions and
			 * limitations under the License.
			 */

			var Util = window.Util || {};

			Util.MIN_TIMESTEP = 0.001;
			Util.MAX_TIMESTEP = 1;

			Util.base64 = function (mimeType, base64) {
				return 'data:' + mimeType + ';base64,' + base64;
			};

			Util.clamp = function (value, min, max) {
				return Math.min(Math.max(min, value), max);
			};

			Util.lerp = function (a, b, t) {
				return a + ((b - a) * t);
			};

			/**
			 * Light polyfill for `Promise.race`. Returns
			 * a promise that resolves when the first promise
			 * provided resolves.
			 *
			 * @param {Array<Promise>} promises
			 */
			Util.race = function (promises) {
				if (Promise.race) {
					return Promise.race(promises);
				}

				return new Promise(function (resolve, reject) {
					for (var i = 0; i < promises.length; i++) {
						promises[i].then(resolve, reject);
					}
				});
			};

			Util.isIOS = (function () {
				var isIOS = /iPad|iPhone|iPod/.test(navigator.platform);
				return function () {
					return isIOS;
				};
			})();

			Util.isWebViewAndroid = (function () {
				var isWebViewAndroid = navigator.userAgent.indexOf('Version') !== -1 &&
					navigator.userAgent.indexOf('Android') !== -1 &&
					navigator.userAgent.indexOf('Chrome') !== -1;
				return function () {
					return isWebViewAndroid;
				};
			})();

			Util.isSafari = (function () {
				var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
				return function () {
					return isSafari;
				};
			})();

			Util.isFirefoxAndroid = (function () {
				var isFirefoxAndroid = navigator.userAgent.indexOf('Firefox') !== -1 &&
					navigator.userAgent.indexOf('Android') !== -1;
				return function () {
					return isFirefoxAndroid;
				};
			})();

			Util.isR7 = (function () {
				var isR7 = navigator.userAgent.indexOf('R7 Build') !== -1;
				return function () {
					return isR7;
				};
			})();

			Util.isLandscapeMode = function () {
				var rtn = (window.orientation == 90 || window.orientation == -90);
				return Util.isR7() ? !rtn : rtn;
			};

			// Helper method to validate the time steps of sensor timestamps.
			Util.isTimestampDeltaValid = function (timestampDeltaS) {
				if (isNaN(timestampDeltaS)) {
					return false;
				}
				if (timestampDeltaS <= Util.MIN_TIMESTEP) {
					return false;
				}
				if (timestampDeltaS > Util.MAX_TIMESTEP) {
					return false;
				}
				return true;
			};

			Util.getScreenWidth = function () {
				return Math.max(window.screen.width, window.screen.height) *
					window.devicePixelRatio;
			};

			Util.getScreenHeight = function () {
				return Math.min(window.screen.width, window.screen.height) *
					window.devicePixelRatio;
			};

			Util.requestFullscreen = function (element) {
				if (Util.isWebViewAndroid()) {
					return false;
				}
				if (element.requestFullscreen) {
					element.requestFullscreen();
				} else if (element.webkitRequestFullscreen) {
					element.webkitRequestFullscreen();
				} else if (element.mozRequestFullScreen) {
					element.mozRequestFullScreen();
				} else if (element.msRequestFullscreen) {
					element.msRequestFullscreen();
				} else {
					return false;
				}

				return true;
			};

			Util.exitFullscreen = function () {
				if (document.exitFullscreen) {
					document.exitFullscreen();
				} else if (document.webkitExitFullscreen) {
					document.webkitExitFullscreen();
				} else if (document.mozCancelFullScreen) {
					document.mozCancelFullScreen();
				} else if (document.msExitFullscreen) {
					document.msExitFullscreen();
				} else {
					return false;
				}

				return true;
			};

			Util.getFullscreenElement = function () {
				return document.fullscreenElement ||
					document.webkitFullscreenElement ||
					document.mozFullScreenElement ||
					document.msFullscreenElement;
			};

			Util.linkProgram = function (gl, vertexSource, fragmentSource, attribLocationMap) {
				// No error checking for brevity.
				var vertexShader = gl.createShader(gl.VERTEX_SHADER);
				gl.shaderSource(vertexShader, vertexSource);
				gl.compileShader(vertexShader);

				var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
				gl.shaderSource(fragmentShader, fragmentSource);
				gl.compileShader(fragmentShader);

				var program = gl.createProgram();
				gl.attachShader(program, vertexShader);
				gl.attachShader(program, fragmentShader);

				for (var attribName in attribLocationMap)
					gl.bindAttribLocation(program, attribLocationMap[attribName], attribName);

				gl.linkProgram(program);

				gl.deleteShader(vertexShader);
				gl.deleteShader(fragmentShader);

				return program;
			};

			Util.getProgramUniforms = function (gl, program) {
				var uniforms = {};
				var uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
				var uniformName = '';
				for (var i = 0; i < uniformCount; i++) {
					var uniformInfo = gl.getActiveUniform(program, i);
					uniformName = uniformInfo.name.replace('[0]', '');
					uniforms[uniformName] = gl.getUniformLocation(program, uniformName);
				}
				return uniforms;
			};

			Util.orthoMatrix = function (out, left, right, bottom, top, near, far) {
				var lr = 1 / (left - right),
					bt = 1 / (bottom - top),
					nf = 1 / (near - far);
				out[0] = -2 * lr;
				out[1] = 0;
				out[2] = 0;
				out[3] = 0;
				out[4] = 0;
				out[5] = -2 * bt;
				out[6] = 0;
				out[7] = 0;
				out[8] = 0;
				out[9] = 0;
				out[10] = 2 * nf;
				out[11] = 0;
				out[12] = (left + right) * lr;
				out[13] = (top + bottom) * bt;
				out[14] = (far + near) * nf;
				out[15] = 1;
				return out;
			};

			Util.copyArray = function (source, dest) {
				for (var i = 0, n = source.length; i < n; i++) {
					dest[i] = source[i];
				}
			};

			Util.isMobile = function () {
				var check = false;
				(function (a) { if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) check = true })(navigator.userAgent || navigator.vendor || window.opera);
				return check;
			};

			Util.extend = function (dest, src) {
				for (var key in src) {
					if (src.hasOwnProperty(key)) {
						dest[key] = src[key];
					}
				}

				return dest;
			}

			Util.safariCssSizeWorkaround = function (canvas) {
				// TODO(smus): Remove this workaround when Safari for iOS is fixed.
				// iOS only workaround (for https://bugs.webkit.org/show_bug.cgi?id=152556).
				//
				// "To the last I grapple with thee;
				//  from hell's heart I stab at thee;
				//  for hate's sake I spit my last breath at thee."
				// -- Moby Dick, by Herman Melville
				if (Util.isIOS()) {
					var width = canvas.style.width;
					var height = canvas.style.height;
					canvas.style.width = (parseInt(width) + 1) + 'px';
					canvas.style.height = (parseInt(height)) + 'px';
					setTimeout(function () {
						canvas.style.width = width;
						canvas.style.height = height;
					}, 100);
				}

				// Debug only.
				window.Util = Util;
				window.canvas = canvas;
			};

			Util.isDebug = function () {
				return Util.getQueryParameter('debug');
			};

			Util.getQueryParameter = function (name) {
				var name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
				var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
					results = regex.exec(location.search);
				return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
			};

			Util.frameDataFromPose = (function () {
				var piOver180 = Math.PI / 180.0;
				var rad45 = Math.PI * 0.25;

				// Borrowed from glMatrix.
				function mat4_perspectiveFromFieldOfView(out, fov, near, far) {
					var upTan = Math.tan(fov ? (fov.upDegrees * piOver180) : rad45),
						downTan = Math.tan(fov ? (fov.downDegrees * piOver180) : rad45),
						leftTan = Math.tan(fov ? (fov.leftDegrees * piOver180) : rad45),
						rightTan = Math.tan(fov ? (fov.rightDegrees * piOver180) : rad45),
						xScale = 2.0 / (leftTan + rightTan),
						yScale = 2.0 / (upTan + downTan);

					out[0] = xScale;
					out[1] = 0.0;
					out[2] = 0.0;
					out[3] = 0.0;
					out[4] = 0.0;
					out[5] = yScale;
					out[6] = 0.0;
					out[7] = 0.0;
					out[8] = -((leftTan - rightTan) * xScale * 0.5);
					out[9] = ((upTan - downTan) * yScale * 0.5);
					out[10] = far / (near - far);
					out[11] = -1.0;
					out[12] = 0.0;
					out[13] = 0.0;
					out[14] = (far * near) / (near - far);
					out[15] = 0.0;
					return out;
				}

				function mat4_fromRotationTranslation(out, q, v) {
					// Quaternion math
					var x = q[0], y = q[1], z = q[2], w = q[3],
						x2 = x + x,
						y2 = y + y,
						z2 = z + z,

						xx = x * x2,
						xy = x * y2,
						xz = x * z2,
						yy = y * y2,
						yz = y * z2,
						zz = z * z2,
						wx = w * x2,
						wy = w * y2,
						wz = w * z2;

					out[0] = 1 - (yy + zz);
					out[1] = xy + wz;
					out[2] = xz - wy;
					out[3] = 0;
					out[4] = xy - wz;
					out[5] = 1 - (xx + zz);
					out[6] = yz + wx;
					out[7] = 0;
					out[8] = xz + wy;
					out[9] = yz - wx;
					out[10] = 1 - (xx + yy);
					out[11] = 0;
					out[12] = v[0];
					out[13] = v[1];
					out[14] = v[2];
					out[15] = 1;

					return out;
				};

				function mat4_translate(out, a, v) {
					var x = v[0], y = v[1], z = v[2],
						a00, a01, a02, a03,
						a10, a11, a12, a13,
						a20, a21, a22, a23;

					if (a === out) {
						out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
						out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
						out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
						out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
					} else {
						a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
						a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
						a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

						out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
						out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
						out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

						out[12] = a00 * x + a10 * y + a20 * z + a[12];
						out[13] = a01 * x + a11 * y + a21 * z + a[13];
						out[14] = a02 * x + a12 * y + a22 * z + a[14];
						out[15] = a03 * x + a13 * y + a23 * z + a[15];
					}

					return out;
				};

				function mat4_invert(out, a) {
					var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
						a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
						a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
						a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

						b00 = a00 * a11 - a01 * a10,
						b01 = a00 * a12 - a02 * a10,
						b02 = a00 * a13 - a03 * a10,
						b03 = a01 * a12 - a02 * a11,
						b04 = a01 * a13 - a03 * a11,
						b05 = a02 * a13 - a03 * a12,
						b06 = a20 * a31 - a21 * a30,
						b07 = a20 * a32 - a22 * a30,
						b08 = a20 * a33 - a23 * a30,
						b09 = a21 * a32 - a22 * a31,
						b10 = a21 * a33 - a23 * a31,
						b11 = a22 * a33 - a23 * a32,

						// Calculate the determinant
						det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

					if (!det) {
						return null;
					}
					det = 1.0 / det;

					out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
					out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
					out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
					out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
					out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
					out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
					out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
					out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
					out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
					out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
					out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
					out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
					out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
					out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
					out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
					out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

					return out;
				};

				var defaultOrientation = new Float32Array([0, 0, 0, 1]);
				var defaultPosition = new Float32Array([0, 0, 0]);

				function updateEyeMatrices(projection, view, pose, parameters, vrDisplay) {
					mat4_perspectiveFromFieldOfView(projection, parameters ? parameters.fieldOfView : null, vrDisplay.depthNear, vrDisplay.depthFar);

					var orientation = pose.orientation || defaultOrientation;
					var position = pose.position || defaultPosition;

					mat4_fromRotationTranslation(view, orientation, position);
					if (parameters)
						mat4_translate(view, view, parameters.offset);
					mat4_invert(view, view);
				}

				return function (frameData, pose, vrDisplay) {
					if (!frameData || !pose)
						return false;

					frameData.pose = pose;
					frameData.timestamp = pose.timestamp;

					updateEyeMatrices(
						frameData.leftProjectionMatrix, frameData.leftViewMatrix,
						pose, vrDisplay.getEyeParameters("left"), vrDisplay);
					updateEyeMatrices(
						frameData.rightProjectionMatrix, frameData.rightViewMatrix,
						pose, vrDisplay.getEyeParameters("right"), vrDisplay);

					return true;
				};
			})();

			Util.isInsideCrossDomainIFrame = function () {
				var isFramed = (window.self !== window.top);
				var refDomain = Util.getDomainFromUrl(document.referrer);
				var thisDomain = Util.getDomainFromUrl(window.location.href);

				return isFramed && (refDomain !== thisDomain);
			};

			// From http://stackoverflow.com/a/23945027.
			Util.getDomainFromUrl = function (url) {
				var domain;
				// Find & remove protocol (http, ftp, etc.) and get domain.
				if (url.indexOf("://") > -1) {
					domain = url.split('/')[2];
				}
				else {
					domain = url.split('/')[0];
				}

				//find & remove port number
				domain = domain.split(':')[0];

				return domain;
			}

			module.exports = Util;


			/***/
}),
/* 1 */
/***/ (function (module, exports, __webpack_require__) {

			/*
			 * Copyright 2015 Google Inc. All Rights Reserved.
			 * Licensed under the Apache License, Version 2.0 (the "License");
			 * you may not use this file except in compliance with the License.
			 * You may obtain a copy of the License at
			 *
			 *     http://www.apache.org/licenses/LICENSE-2.0
			 *
			 * Unless required by applicable law or agreed to in writing, software
			 * distributed under the License is distributed on an "AS IS" BASIS,
			 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
			 * See the License for the specific language governing permissions and
			 * limitations under the License.
			 */

			var Util = __webpack_require__(0);
			var WakeLock = __webpack_require__(21);

			// Start at a higher number to reduce chance of conflict.
			var nextDisplayId = 1000;
			var hasShowDeprecationWarning = false;

			var defaultLeftBounds = [0, 0, 0.5, 1];
			var defaultRightBounds = [0.5, 0, 0.5, 1];

			/**
			 * The base class for all VR frame data.
			 */

			function VRFrameData() {
				this.leftProjectionMatrix = new Float32Array(16);
				this.leftViewMatrix = new Float32Array(16);
				this.rightProjectionMatrix = new Float32Array(16);
				this.rightViewMatrix = new Float32Array(16);
				this.pose = null;
			};

			/**
			 * The base class for all VR displays.
			 */
			function VRDisplay() {
				this.isPolyfilled = true;
				this.displayId = nextDisplayId++;
				this.displayName = 'webvr-polyfill displayName';

				this.depthNear = 0.01;
				this.depthFar = 10000.0;

				this.isConnected = true;
				this.isPresenting = false;
				this.capabilities = {
					hasPosition: false,
					hasOrientation: false,
					hasExternalDisplay: false,
					canPresent: false,
					maxLayers: 1
				};
				this.stageParameters = null;

				// "Private" members.
				this.waitingForPresent_ = false;
				this.layer_ = null;

				this.fullscreenElement_ = null;
				this.fullscreenWrapper_ = null;
				this.fullscreenElementCachedStyle_ = null;

				this.fullscreenEventTarget_ = null;
				this.fullscreenChangeHandler_ = null;
				this.fullscreenErrorHandler_ = null;

				this.wakelock_ = new WakeLock();
			}

			VRDisplay.prototype.getFrameData = function (frameData) {
				// TODO: Technically this should retain it's value for the duration of a frame
				// but I doubt that's practical to do in javascript.
				return Util.frameDataFromPose(frameData, this.getPose(), this);
			};

			VRDisplay.prototype.getPose = function () {
				// TODO: Technically this should retain it's value for the duration of a frame
				// but I doubt that's practical to do in javascript.
				return this.getImmediatePose();
			};

			VRDisplay.prototype.requestAnimationFrame = function (callback) {
				return window.requestAnimationFrame(callback);
			};

			VRDisplay.prototype.cancelAnimationFrame = function (id) {
				return window.cancelAnimationFrame(id);
			};

			VRDisplay.prototype.wrapForFullscreen = function (element) {
				// Don't wrap in iOS.
				if (Util.isIOS()) {
					return element;
				}
				if (!this.fullscreenWrapper_) {
					this.fullscreenWrapper_ = document.createElement('div');
					var cssProperties = [
						'height: ' + Math.min(screen.height, screen.width) + 'px !important',
						'top: 0 !important',
						'left: 0 !important',
						'right: 0 !important',
						'border: 0',
						'margin: 0',
						'padding: 0',
						'z-index: 999999 !important',
						'position: fixed',
					];
					this.fullscreenWrapper_.setAttribute('style', cssProperties.join('; ') + ';');
					this.fullscreenWrapper_.classList.add('webvr-polyfill-fullscreen-wrapper');
				}

				if (this.fullscreenElement_ == element) {
					return this.fullscreenWrapper_;
				}

				// Remove any previously applied wrappers
				this.removeFullscreenWrapper();

				this.fullscreenElement_ = element;
				var parent = this.fullscreenElement_.parentElement;
				parent.insertBefore(this.fullscreenWrapper_, this.fullscreenElement_);
				parent.removeChild(this.fullscreenElement_);
				this.fullscreenWrapper_.insertBefore(this.fullscreenElement_, this.fullscreenWrapper_.firstChild);
				this.fullscreenElementCachedStyle_ = this.fullscreenElement_.getAttribute('style');

				var self = this;
				function applyFullscreenElementStyle() {
					if (!self.fullscreenElement_) {
						return;
					}

					var cssProperties = [
						'position: absolute',
						'top: 0',
						'left: 0',
						'width: ' + Math.max(screen.width, screen.height) + 'px',
						'height: ' + Math.min(screen.height, screen.width) + 'px',
						'border: 0',
						'margin: 0',
						'padding: 0',
					];
					self.fullscreenElement_.setAttribute('style', cssProperties.join('; ') + ';');
				}

				applyFullscreenElementStyle();

				return this.fullscreenWrapper_;
			};

			VRDisplay.prototype.removeFullscreenWrapper = function () {
				if (!this.fullscreenElement_) {
					return;
				}

				var element = this.fullscreenElement_;
				if (this.fullscreenElementCachedStyle_) {
					element.setAttribute('style', this.fullscreenElementCachedStyle_);
				} else {
					element.removeAttribute('style');
				}
				this.fullscreenElement_ = null;
				this.fullscreenElementCachedStyle_ = null;

				var parent = this.fullscreenWrapper_.parentElement;
				this.fullscreenWrapper_.removeChild(element);
				parent.insertBefore(element, this.fullscreenWrapper_);
				parent.removeChild(this.fullscreenWrapper_);

				return element;
			};

			VRDisplay.prototype.requestPresent = function (layers) {
				var wasPresenting = this.isPresenting;
				var self = this;

				if (!(layers instanceof Array)) {
					if (!hasShowDeprecationWarning) {
						console.warn("Using a deprecated form of requestPresent. Should pass in an array of VRLayers.");
						hasShowDeprecationWarning = true;
					}
					layers = [layers];
				}

				return new Promise(function (resolve, reject) {
					if (!self.capabilities.canPresent) {
						reject(new Error('VRDisplay is not capable of presenting.'));
						return;
					}

					if (layers.length == 0 || layers.length > self.capabilities.maxLayers) {
						reject(new Error('Invalid number of layers.'));
						return;
					}

					var incomingLayer = layers[0];
					if (!incomingLayer.source) {
						/*
						todo: figure out the correct behavior if the source is not provided.
						see https://github.com/w3c/webvr/issues/58
						*/
						resolve();
						return;
					}

					var leftBounds = incomingLayer.leftBounds || defaultLeftBounds;
					var rightBounds = incomingLayer.rightBounds || defaultRightBounds;
					if (wasPresenting) {
						// Already presenting, just changing configuration
						var layer = self.layer_;
						if (layer.source !== incomingLayer.source) {
							layer.source = incomingLayer.source;
						}

						for (var i = 0; i < 4; i++) {
							layer.leftBounds[i] = leftBounds[i];
							layer.rightBounds[i] = rightBounds[i];
						}

						resolve();
						return;
					}

					// Was not already presenting.
					self.layer_ = {
						predistorted: incomingLayer.predistorted,
						source: incomingLayer.source,
						leftBounds: leftBounds.slice(0),
						rightBounds: rightBounds.slice(0)
					};

					self.waitingForPresent_ = false;
					if (self.layer_ && self.layer_.source) {
						var fullscreenElement = self.wrapForFullscreen(self.layer_.source);

						var onFullscreenChange = function () {
							var actualFullscreenElement = Util.getFullscreenElement();

							self.isPresenting = (fullscreenElement === actualFullscreenElement);
							if (self.isPresenting) {
								if (screen.orientation && screen.orientation.lock) {
									screen.orientation.lock('landscape-primary').catch(function (error) {
										console.error('screen.orientation.lock() failed due to', error.message)
									});
								}
								self.waitingForPresent_ = false;
								self.beginPresent_();
								resolve();
							} else {
								if (screen.orientation && screen.orientation.unlock) {
									screen.orientation.unlock();
								}
								self.removeFullscreenWrapper();
								self.wakelock_.release();
								self.endPresent_();
								self.removeFullscreenListeners_();
							}
							self.fireVRDisplayPresentChange_();
						}
						var onFullscreenError = function () {
							if (!self.waitingForPresent_) {
								return;
							}

							self.removeFullscreenWrapper();
							self.removeFullscreenListeners_();

							self.wakelock_.release();
							self.waitingForPresent_ = false;
							self.isPresenting = false;

							reject(new Error('Unable to present.'));
						}

						self.addFullscreenListeners_(fullscreenElement,
							onFullscreenChange, onFullscreenError);

						if (Util.requestFullscreen(fullscreenElement)) {
							self.wakelock_.request();
							self.waitingForPresent_ = true;
						} else if (Util.isIOS() || Util.isWebViewAndroid()) {
							// *sigh* Just fake it.
							self.wakelock_.request();
							self.isPresenting = true;
							self.beginPresent_();
							self.fireVRDisplayPresentChange_();
							resolve();
						}
					}

					if (!self.waitingForPresent_ && !Util.isIOS()) {
						Util.exitFullscreen();
						reject(new Error('Unable to present.'));
					}
				});
			};

			VRDisplay.prototype.exitPresent = function () {
				var wasPresenting = this.isPresenting;
				var self = this;
				this.isPresenting = false;
				this.layer_ = null;
				this.wakelock_.release();

				return new Promise(function (resolve, reject) {
					if (wasPresenting) {
						if (!Util.exitFullscreen() && Util.isIOS()) {
							self.endPresent_();
							self.fireVRDisplayPresentChange_();
						}

						if (Util.isWebViewAndroid()) {
							self.removeFullscreenWrapper();
							self.removeFullscreenListeners_();
							self.endPresent_();
							self.fireVRDisplayPresentChange_();
						}

						resolve();
					} else {
						reject(new Error('Was not presenting to VRDisplay.'));
					}
				});
			};

			VRDisplay.prototype.getLayers = function () {
				if (this.layer_) {
					return [this.layer_];
				}
				return [];
			};

			VRDisplay.prototype.fireVRDisplayPresentChange_ = function () {
				// Important: unfortunately we cannot have full spec compliance here.
				// CustomEvent custom fields all go under e.detail (so the VRDisplay ends up
				// being e.detail.display, instead of e.display as per WebVR spec).
				var event = new CustomEvent('vrdisplaypresentchange', { detail: { display: this } });
				window.dispatchEvent(event);
			};

			VRDisplay.prototype.fireVRDisplayConnect_ = function () {
				// Important: unfortunately we cannot have full spec compliance here.
				// CustomEvent custom fields all go under e.detail (so the VRDisplay ends up
				// being e.detail.display, instead of e.display as per WebVR spec).
				var event = new CustomEvent('vrdisplayconnect', { detail: { display: this } });
				window.dispatchEvent(event);
			};

			VRDisplay.prototype.addFullscreenListeners_ = function (element, changeHandler, errorHandler) {
				this.removeFullscreenListeners_();

				this.fullscreenEventTarget_ = element;
				this.fullscreenChangeHandler_ = changeHandler;
				this.fullscreenErrorHandler_ = errorHandler;

				if (changeHandler) {
					if (document.fullscreenEnabled) {
						element.addEventListener('fullscreenchange', changeHandler, false);
					} else if (document.webkitFullscreenEnabled) {
						element.addEventListener('webkitfullscreenchange', changeHandler, false);
					} else if (document.mozFullScreenEnabled) {
						document.addEventListener('mozfullscreenchange', changeHandler, false);
					} else if (document.msFullscreenEnabled) {
						element.addEventListener('msfullscreenchange', changeHandler, false);
					}
				}

				if (errorHandler) {
					if (document.fullscreenEnabled) {
						element.addEventListener('fullscreenerror', errorHandler, false);
					} else if (document.webkitFullscreenEnabled) {
						element.addEventListener('webkitfullscreenerror', errorHandler, false);
					} else if (document.mozFullScreenEnabled) {
						document.addEventListener('mozfullscreenerror', errorHandler, false);
					} else if (document.msFullscreenEnabled) {
						element.addEventListener('msfullscreenerror', errorHandler, false);
					}
				}
			};

			VRDisplay.prototype.removeFullscreenListeners_ = function () {
				if (!this.fullscreenEventTarget_)
					return;

				var element = this.fullscreenEventTarget_;

				if (this.fullscreenChangeHandler_) {
					var changeHandler = this.fullscreenChangeHandler_;
					element.removeEventListener('fullscreenchange', changeHandler, false);
					element.removeEventListener('webkitfullscreenchange', changeHandler, false);
					document.removeEventListener('mozfullscreenchange', changeHandler, false);
					element.removeEventListener('msfullscreenchange', changeHandler, false);
				}

				if (this.fullscreenErrorHandler_) {
					var errorHandler = this.fullscreenErrorHandler_;
					element.removeEventListener('fullscreenerror', errorHandler, false);
					element.removeEventListener('webkitfullscreenerror', errorHandler, false);
					document.removeEventListener('mozfullscreenerror', errorHandler, false);
					element.removeEventListener('msfullscreenerror', errorHandler, false);
				}

				this.fullscreenEventTarget_ = null;
				this.fullscreenChangeHandler_ = null;
				this.fullscreenErrorHandler_ = null;
			};

			VRDisplay.prototype.beginPresent_ = function () {
				// Override to add custom behavior when presentation begins.
			};

			VRDisplay.prototype.endPresent_ = function () {
				// Override to add custom behavior when presentation ends.
			};

			VRDisplay.prototype.submitFrame = function (pose) {
				// Override to add custom behavior for frame submission.
			};

			VRDisplay.prototype.getEyeParameters = function (whichEye) {
				// Override to return accurate eye parameters if canPresent is true.
				return null;
			};

			/*
			 * Deprecated classes
			 */

			/**
			 * The base class for all VR devices. (Deprecated)
			 */
			function VRDevice() {
				this.isPolyfilled = true;
				this.hardwareUnitId = 'webvr-polyfill hardwareUnitId';
				this.deviceId = 'webvr-polyfill deviceId';
				this.deviceName = 'webvr-polyfill deviceName';
			}

			/**
			 * The base class for all VR HMD devices. (Deprecated)
			 */
			function HMDVRDevice() {
			}
			HMDVRDevice.prototype = new VRDevice();

			/**
			 * The base class for all VR position sensor devices. (Deprecated)
			 */
			function PositionSensorVRDevice() {
			}
			PositionSensorVRDevice.prototype = new VRDevice();

			module.exports.VRFrameData = VRFrameData;
			module.exports.VRDisplay = VRDisplay;
			module.exports.VRDevice = VRDevice;
			module.exports.HMDVRDevice = HMDVRDevice;
			module.exports.PositionSensorVRDevice = PositionSensorVRDevice;


			/***/
}),
/* 2 */
/***/ (function (module, exports) {

			/*
			 * Copyright 2016 Google Inc. All Rights Reserved.
			 * Licensed under the Apache License, Version 2.0 (the "License");
			 * you may not use this file except in compliance with the License.
			 * You may obtain a copy of the License at
			 *
			 *     http://www.apache.org/licenses/LICENSE-2.0
			 *
			 * Unless required by applicable law or agreed to in writing, software
			 * distributed under the License is distributed on an "AS IS" BASIS,
			 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
			 * See the License for the specific language governing permissions and
			 * limitations under the License.
			 */

			var MathUtil = window.MathUtil || {};

			MathUtil.degToRad = Math.PI / 180;
			MathUtil.radToDeg = 180 / Math.PI;

			// Some minimal math functionality borrowed from THREE.Math and stripped down
			// for the purposes of this library.


			MathUtil.Vector2 = function (x, y) {
				this.x = x || 0;
				this.y = y || 0;
			};

			MathUtil.Vector2.prototype = {
				constructor: MathUtil.Vector2,

				set: function (x, y) {
					this.x = x;
					this.y = y;

					return this;
				},

				copy: function (v) {
					this.x = v.x;
					this.y = v.y;

					return this;
				},

				subVectors: function (a, b) {
					this.x = a.x - b.x;
					this.y = a.y - b.y;

					return this;
				},
			};

			MathUtil.Vector3 = function (x, y, z) {
				this.x = x || 0;
				this.y = y || 0;
				this.z = z || 0;
			};

			MathUtil.Vector3.prototype = {
				constructor: MathUtil.Vector3,

				set: function (x, y, z) {
					this.x = x;
					this.y = y;
					this.z = z;

					return this;
				},

				copy: function (v) {
					this.x = v.x;
					this.y = v.y;
					this.z = v.z;

					return this;
				},

				length: function () {
					return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
				},

				normalize: function () {
					var scalar = this.length();

					if (scalar !== 0) {
						var invScalar = 1 / scalar;

						this.multiplyScalar(invScalar);
					} else {
						this.x = 0;
						this.y = 0;
						this.z = 0;
					}

					return this;
				},

				multiplyScalar: function (scalar) {
					this.x *= scalar;
					this.y *= scalar;
					this.z *= scalar;
				},

				applyQuaternion: function (q) {
					var x = this.x;
					var y = this.y;
					var z = this.z;

					var qx = q.x;
					var qy = q.y;
					var qz = q.z;
					var qw = q.w;

					// calculate quat * vector
					var ix = qw * x + qy * z - qz * y;
					var iy = qw * y + qz * x - qx * z;
					var iz = qw * z + qx * y - qy * x;
					var iw = - qx * x - qy * y - qz * z;

					// calculate result * inverse quat
					this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
					this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
					this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

					return this;
				},

				dot: function (v) {
					return this.x * v.x + this.y * v.y + this.z * v.z;
				},

				crossVectors: function (a, b) {
					var ax = a.x, ay = a.y, az = a.z;
					var bx = b.x, by = b.y, bz = b.z;

					this.x = ay * bz - az * by;
					this.y = az * bx - ax * bz;
					this.z = ax * by - ay * bx;

					return this;
				},
			};

			MathUtil.Quaternion = function (x, y, z, w) {
				this.x = x || 0;
				this.y = y || 0;
				this.z = z || 0;
				this.w = (w !== undefined) ? w : 1;
			};

			MathUtil.Quaternion.prototype = {
				constructor: MathUtil.Quaternion,

				set: function (x, y, z, w) {
					this.x = x;
					this.y = y;
					this.z = z;
					this.w = w;

					return this;
				},

				copy: function (quaternion) {
					this.x = quaternion.x;
					this.y = quaternion.y;
					this.z = quaternion.z;
					this.w = quaternion.w;

					return this;
				},

				setFromEulerXYZ: function (x, y, z) {
					var c1 = Math.cos(x / 2);
					var c2 = Math.cos(y / 2);
					var c3 = Math.cos(z / 2);
					var s1 = Math.sin(x / 2);
					var s2 = Math.sin(y / 2);
					var s3 = Math.sin(z / 2);

					this.x = s1 * c2 * c3 + c1 * s2 * s3;
					this.y = c1 * s2 * c3 - s1 * c2 * s3;
					this.z = c1 * c2 * s3 + s1 * s2 * c3;
					this.w = c1 * c2 * c3 - s1 * s2 * s3;

					return this;
				},

				setFromEulerYXZ: function (x, y, z) {
					var c1 = Math.cos(x / 2);
					var c2 = Math.cos(y / 2);
					var c3 = Math.cos(z / 2);
					var s1 = Math.sin(x / 2);
					var s2 = Math.sin(y / 2);
					var s3 = Math.sin(z / 2);

					this.x = s1 * c2 * c3 + c1 * s2 * s3;
					this.y = c1 * s2 * c3 - s1 * c2 * s3;
					this.z = c1 * c2 * s3 - s1 * s2 * c3;
					this.w = c1 * c2 * c3 + s1 * s2 * s3;

					return this;
				},

				setFromAxisAngle: function (axis, angle) {
					// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
					// assumes axis is normalized

					var halfAngle = angle / 2, s = Math.sin(halfAngle);

					this.x = axis.x * s;
					this.y = axis.y * s;
					this.z = axis.z * s;
					this.w = Math.cos(halfAngle);

					return this;
				},

				multiply: function (q) {
					return this.multiplyQuaternions(this, q);
				},

				multiplyQuaternions: function (a, b) {
					// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

					var qax = a.x, qay = a.y, qaz = a.z, qaw = a.w;
					var qbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;

					this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
					this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
					this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
					this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

					return this;
				},

				inverse: function () {
					this.x *= -1;
					this.y *= -1;
					this.z *= -1;

					this.normalize();

					return this;
				},

				normalize: function () {
					var l = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);

					if (l === 0) {
						this.x = 0;
						this.y = 0;
						this.z = 0;
						this.w = 1;
					} else {
						l = 1 / l;

						this.x = this.x * l;
						this.y = this.y * l;
						this.z = this.z * l;
						this.w = this.w * l;
					}

					return this;
				},

				slerp: function (qb, t) {
					if (t === 0) return this;
					if (t === 1) return this.copy(qb);

					var x = this.x, y = this.y, z = this.z, w = this.w;

					// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

					var cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;

					if (cosHalfTheta < 0) {
						this.w = - qb.w;
						this.x = - qb.x;
						this.y = - qb.y;
						this.z = - qb.z;

						cosHalfTheta = - cosHalfTheta;
					} else {
						this.copy(qb);
					}

					if (cosHalfTheta >= 1.0) {
						this.w = w;
						this.x = x;
						this.y = y;
						this.z = z;

						return this;
					}

					var halfTheta = Math.acos(cosHalfTheta);
					var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);

					if (Math.abs(sinHalfTheta) < 0.001) {
						this.w = 0.5 * (w + this.w);
						this.x = 0.5 * (x + this.x);
						this.y = 0.5 * (y + this.y);
						this.z = 0.5 * (z + this.z);

						return this;
					}

					var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
						ratioB = Math.sin(t * halfTheta) / sinHalfTheta;

					this.w = (w * ratioA + this.w * ratioB);
					this.x = (x * ratioA + this.x * ratioB);
					this.y = (y * ratioA + this.y * ratioB);
					this.z = (z * ratioA + this.z * ratioB);

					return this;
				},

				setFromUnitVectors: function () {
					// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final
					// assumes direction vectors vFrom and vTo are normalized

					var v1, r;
					var EPS = 0.000001;

					return function (vFrom, vTo) {
						if (v1 === undefined) v1 = new MathUtil.Vector3();

						r = vFrom.dot(vTo) + 1;

						if (r < EPS) {
							r = 0;

							if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
								v1.set(- vFrom.y, vFrom.x, 0);
							} else {
								v1.set(0, - vFrom.z, vFrom.y);
							}
						} else {
							v1.crossVectors(vFrom, vTo);
						}

						this.x = v1.x;
						this.y = v1.y;
						this.z = v1.z;
						this.w = r;

						this.normalize();

						return this;
					}
				}(),
			};

			module.exports = MathUtil;


			/***/
}),
/* 3 */
/***/ (function (module, exports, __webpack_require__) {

			/*
			 * Copyright 2016 Google Inc. All Rights Reserved.
			 * Licensed under the Apache License, Version 2.0 (the "License");
			 * you may not use this file except in compliance with the License.
			 * You may obtain a copy of the License at
			 *
			 *     http://www.apache.org/licenses/LICENSE-2.0
			 *
			 * Unless required by applicable law or agreed to in writing, software
			 * distributed under the License is distributed on an "AS IS" BASIS,
			 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
			 * See the License for the specific language governing permissions and
			 * limitations under the License.
			 */

			var Util = __webpack_require__(0);
			var WGLUPreserveGLState = __webpack_require__(4);

			var uiVS = [
				'attribute vec2 position;',

				'uniform mat4 projectionMat;',

				'void main() {',
				'  gl_Position = projectionMat * vec4( position, -1.0, 1.0 );',
				'}',
			].join('\n');

			var uiFS = [
				'precision mediump float;',

				'uniform vec4 color;',

				'void main() {',
				'  gl_FragColor = color;',
				'}',
			].join('\n');

			var DEG2RAD = Math.PI / 180.0;

			// The gear has 6 identical sections, each spanning 60 degrees.
			var kAnglePerGearSection = 60;

			// Half-angle of the span of the outer rim.
			var kOuterRimEndAngle = 12;

			// Angle between the middle of the outer rim and the start of the inner rim.
			var kInnerRimBeginAngle = 20;

			// Distance from center to outer rim, normalized so that the entire model
			// fits in a [-1, 1] x [-1, 1] square.
			var kOuterRadius = 1;

			// Distance from center to depressed rim, in model units.
			var kMiddleRadius = 0.75;

			// Radius of the inner hollow circle, in model units.
			var kInnerRadius = 0.3125;

			// Center line thickness in DP.
			var kCenterLineThicknessDp = 4;

			// Button width in DP.
			var kButtonWidthDp = 28;

			// Factor to scale the touch area that responds to the touch.
			var kTouchSlopFactor = 1.5;

			var Angles = [
				0, kOuterRimEndAngle, kInnerRimBeginAngle,
				kAnglePerGearSection - kInnerRimBeginAngle,
				kAnglePerGearSection - kOuterRimEndAngle
			];

			/**
			 * Renders the alignment line and "options" gear. It is assumed that the canvas
			 * this is rendered into covers the entire screen (or close to it.)
			 */
			function CardboardUI(gl) {
				this.gl = gl;

				this.attribs = {
					position: 0
				};
				this.program = Util.linkProgram(gl, uiVS, uiFS, this.attribs);
				this.uniforms = Util.getProgramUniforms(gl, this.program);

				this.vertexBuffer = gl.createBuffer();
				this.gearOffset = 0;
				this.gearVertexCount = 0;
				this.arrowOffset = 0;
				this.arrowVertexCount = 0;

				this.projMat = new Float32Array(16);

				this.listener = null;

				this.onResize();
			};

			/**
			 * Tears down all the resources created by the UI renderer.
			 */
			CardboardUI.prototype.destroy = function () {
				var gl = this.gl;

				if (this.listener) {
					gl.canvas.removeEventListener('click', this.listener, false);
				}

				gl.deleteProgram(this.program);
				gl.deleteBuffer(this.vertexBuffer);
			};

			/**
			 * Adds a listener to clicks on the gear and back icons
			 */
			CardboardUI.prototype.listen = function (optionsCallback, backCallback) {
				var canvas = this.gl.canvas;
				this.listener = function (event) {
					var midline = canvas.clientWidth / 2;
					var buttonSize = kButtonWidthDp * kTouchSlopFactor;
					// Check to see if the user clicked on (or around) the gear icon
					if (event.clientX > midline - buttonSize &&
						event.clientX < midline + buttonSize &&
						event.clientY > canvas.clientHeight - buttonSize) {
						optionsCallback(event);
					}
					// Check to see if the user clicked on (or around) the back icon
					else if (event.clientX < buttonSize && event.clientY < buttonSize) {
						backCallback(event);
					}
				};
				canvas.addEventListener('click', this.listener, false);
			};

			/**
			 * Builds the UI mesh.
			 */
			CardboardUI.prototype.onResize = function () {
				var gl = this.gl;
				var self = this;

				var glState = [
					gl.ARRAY_BUFFER_BINDING
				];

				WGLUPreserveGLState(gl, glState, function (gl) {
					var vertices = [];

					var midline = gl.drawingBufferWidth / 2;

					// The gl buffer size will likely be smaller than the physical pixel count.
					// So we need to scale the dps down based on the actual buffer size vs physical pixel count.
					// This will properly size the ui elements no matter what the gl buffer resolution is
					var physicalPixels = Math.max(screen.width, screen.height) * window.devicePixelRatio;
					var scalingRatio = gl.drawingBufferWidth / physicalPixels;
					var dps = scalingRatio * window.devicePixelRatio;

					var lineWidth = kCenterLineThicknessDp * dps / 2;
					var buttonSize = kButtonWidthDp * kTouchSlopFactor * dps;
					var buttonScale = kButtonWidthDp * dps / 2;
					var buttonBorder = ((kButtonWidthDp * kTouchSlopFactor) - kButtonWidthDp) * dps;

					// Build centerline
					vertices.push(midline - lineWidth, buttonSize);
					vertices.push(midline - lineWidth, gl.drawingBufferHeight);
					vertices.push(midline + lineWidth, buttonSize);
					vertices.push(midline + lineWidth, gl.drawingBufferHeight);

					// Build gear
					self.gearOffset = (vertices.length / 2);

					function addGearSegment(theta, r) {
						var angle = (90 - theta) * DEG2RAD;
						var x = Math.cos(angle);
						var y = Math.sin(angle);
						vertices.push(kInnerRadius * x * buttonScale + midline, kInnerRadius * y * buttonScale + buttonScale);
						vertices.push(r * x * buttonScale + midline, r * y * buttonScale + buttonScale);
					}

					for (var i = 0; i <= 6; i++) {
						var segmentTheta = i * kAnglePerGearSection;

						addGearSegment(segmentTheta, kOuterRadius);
						addGearSegment(segmentTheta + kOuterRimEndAngle, kOuterRadius);
						addGearSegment(segmentTheta + kInnerRimBeginAngle, kMiddleRadius);
						addGearSegment(segmentTheta + (kAnglePerGearSection - kInnerRimBeginAngle), kMiddleRadius);
						addGearSegment(segmentTheta + (kAnglePerGearSection - kOuterRimEndAngle), kOuterRadius);
					}

					self.gearVertexCount = (vertices.length / 2) - self.gearOffset;

					// Build back arrow
					self.arrowOffset = (vertices.length / 2);

					function addArrowVertex(x, y) {
						vertices.push(buttonBorder + x, gl.drawingBufferHeight - buttonBorder - y);
					}

					var angledLineWidth = lineWidth / Math.sin(45 * DEG2RAD);

					addArrowVertex(0, buttonScale);
					addArrowVertex(buttonScale, 0);
					addArrowVertex(buttonScale + angledLineWidth, angledLineWidth);
					addArrowVertex(angledLineWidth, buttonScale + angledLineWidth);

					addArrowVertex(angledLineWidth, buttonScale - angledLineWidth);
					addArrowVertex(0, buttonScale);
					addArrowVertex(buttonScale, buttonScale * 2);
					addArrowVertex(buttonScale + angledLineWidth, (buttonScale * 2) - angledLineWidth);

					addArrowVertex(angledLineWidth, buttonScale - angledLineWidth);
					addArrowVertex(0, buttonScale);

					addArrowVertex(angledLineWidth, buttonScale - lineWidth);
					addArrowVertex(kButtonWidthDp * dps, buttonScale - lineWidth);
					addArrowVertex(angledLineWidth, buttonScale + lineWidth);
					addArrowVertex(kButtonWidthDp * dps, buttonScale + lineWidth);

					self.arrowVertexCount = (vertices.length / 2) - self.arrowOffset;

					// Buffer data
					gl.bindBuffer(gl.ARRAY_BUFFER, self.vertexBuffer);
					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
				});
			};

			/**
			 * Performs distortion pass on the injected backbuffer, rendering it to the real
			 * backbuffer.
			 */
			CardboardUI.prototype.render = function () {
				var gl = this.gl;
				var self = this;

				var glState = [
					gl.CULL_FACE,
					gl.DEPTH_TEST,
					gl.BLEND,
					gl.SCISSOR_TEST,
					gl.STENCIL_TEST,
					gl.COLOR_WRITEMASK,
					gl.VIEWPORT,

					gl.CURRENT_PROGRAM,
					gl.ARRAY_BUFFER_BINDING
				];

				WGLUPreserveGLState(gl, glState, function (gl) {
					// Make sure the GL state is in a good place
					gl.disable(gl.CULL_FACE);
					gl.disable(gl.DEPTH_TEST);
					gl.disable(gl.BLEND);
					gl.disable(gl.SCISSOR_TEST);
					gl.disable(gl.STENCIL_TEST);
					gl.colorMask(true, true, true, true);
					gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

					self.renderNoState();
				});
			};

			CardboardUI.prototype.renderNoState = function () {
				var gl = this.gl;

				// Bind distortion program and mesh
				gl.useProgram(this.program);

				gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
				gl.enableVertexAttribArray(this.attribs.position);
				gl.vertexAttribPointer(this.attribs.position, 2, gl.FLOAT, false, 8, 0);

				gl.uniform4f(this.uniforms.color, 1.0, 1.0, 1.0, 1.0);

				Util.orthoMatrix(this.projMat, 0, gl.drawingBufferWidth, 0, gl.drawingBufferHeight, 0.1, 1024.0);
				gl.uniformMatrix4fv(this.uniforms.projectionMat, false, this.projMat);

				// Draws UI element
				gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
				gl.drawArrays(gl.TRIANGLE_STRIP, this.gearOffset, this.gearVertexCount);
				gl.drawArrays(gl.TRIANGLE_STRIP, this.arrowOffset, this.arrowVertexCount);
			};

			module.exports = CardboardUI;


			/***/
}),
/* 4 */
/***/ (function (module, exports) {

			/**
			 * Copyright (c) 2016, Brandon Jones.
			 * https://github.com/toji/webgl-utils/blob/master/src/wglu-preserve-state.js
			 * LICENSE: https://github.com/toji/webgl-utils/blob/master/LICENSE.md
			 */

			function WGLUPreserveGLState(gl, bindings, callback) {
				if (!bindings) {
					callback(gl);
					return;
				}

				var boundValues = [];

				var activeTexture = null;
				for (var i = 0; i < bindings.length; ++i) {
					var binding = bindings[i];
					switch (binding) {
						case gl.TEXTURE_BINDING_2D:
						case gl.TEXTURE_BINDING_CUBE_MAP:
							var textureUnit = bindings[++i];
							if (textureUnit < gl.TEXTURE0 || textureUnit > gl.TEXTURE31) {
								console.error("TEXTURE_BINDING_2D or TEXTURE_BINDING_CUBE_MAP must be followed by a valid texture unit");
								boundValues.push(null, null);
								break;
							}
							if (!activeTexture) {
								activeTexture = gl.getParameter(gl.ACTIVE_TEXTURE);
							}
							gl.activeTexture(textureUnit);
							boundValues.push(gl.getParameter(binding), null);
							break;
						case gl.ACTIVE_TEXTURE:
							activeTexture = gl.getParameter(gl.ACTIVE_TEXTURE);
							boundValues.push(null);
							break;
						default:
							boundValues.push(gl.getParameter(binding));
							break;
					}
				}

				callback(gl);

				for (var i = 0; i < bindings.length; ++i) {
					var binding = bindings[i];
					var boundValue = boundValues[i];
					switch (binding) {
						case gl.ACTIVE_TEXTURE:
							break; // Ignore this binding, since we special-case it to happen last.
						case gl.ARRAY_BUFFER_BINDING:
							gl.bindBuffer(gl.ARRAY_BUFFER, boundValue);
							break;
						case gl.COLOR_CLEAR_VALUE:
							gl.clearColor(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
							break;
						case gl.COLOR_WRITEMASK:
							gl.colorMask(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
							break;
						case gl.CURRENT_PROGRAM:
							gl.useProgram(boundValue);
							break;
						case gl.ELEMENT_ARRAY_BUFFER_BINDING:
							gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, boundValue);
							break;
						case gl.FRAMEBUFFER_BINDING:
							gl.bindFramebuffer(gl.FRAMEBUFFER, boundValue);
							break;
						case gl.RENDERBUFFER_BINDING:
							gl.bindRenderbuffer(gl.RENDERBUFFER, boundValue);
							break;
						case gl.TEXTURE_BINDING_2D:
							var textureUnit = bindings[++i];
							if (textureUnit < gl.TEXTURE0 || textureUnit > gl.TEXTURE31)
								break;
							gl.activeTexture(textureUnit);
							gl.bindTexture(gl.TEXTURE_2D, boundValue);
							break;
						case gl.TEXTURE_BINDING_CUBE_MAP:
							var textureUnit = bindings[++i];
							if (textureUnit < gl.TEXTURE0 || textureUnit > gl.TEXTURE31)
								break;
							gl.activeTexture(textureUnit);
							gl.bindTexture(gl.TEXTURE_CUBE_MAP, boundValue);
							break;
						case gl.VIEWPORT:
							gl.viewport(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
							break;
						case gl.BLEND:
						case gl.CULL_FACE:
						case gl.DEPTH_TEST:
						case gl.SCISSOR_TEST:
						case gl.STENCIL_TEST:
							if (boundValue) {
								gl.enable(binding);
							} else {
								gl.disable(binding);
							}
							break;
						default:
							console.log("No GL restore behavior for 0x" + binding.toString(16));
							break;
					}

					if (activeTexture) {
						gl.activeTexture(activeTexture);
					}
				}
			}

			module.exports = WGLUPreserveGLState;


			/***/
}),
/* 5 */
/***/ (function (module, exports, __webpack_require__) {

			/*
			 * Copyright 2015 Google Inc. All Rights Reserved.
			 * Licensed under the Apache License, Version 2.0 (the "License");
			 * you may not use this file except in compliance with the License.
			 * You may obtain a copy of the License at
			 *
			 *     http://www.apache.org/licenses/LICENSE-2.0
			 *
			 * Unless required by applicable law or agreed to in writing, software
			 * distributed under the License is distributed on an "AS IS" BASIS,
			 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
			 * See the License for the specific language governing permissions and
			 * limitations under the License.
			 */

			var Distortion = __webpack_require__(11);
			var MathUtil = __webpack_require__(2);
			var Util = __webpack_require__(0);

			function Device(params) {
				this.width = params.width || Util.getScreenWidth();
				this.height = params.height || Util.getScreenHeight();
				this.widthMeters = params.widthMeters;
				this.heightMeters = params.heightMeters;
				this.bevelMeters = params.bevelMeters;
			}


			// Fallback Android device (based on Nexus 5 measurements) for use when
			// we can't recognize an Android device.
			var DEFAULT_ANDROID = new Device({
				widthMeters: 0.110,
				heightMeters: 0.062,
				bevelMeters: 0.004
			});

			// Fallback iOS device (based on iPhone6) for use when
			// we can't recognize an Android device.
			var DEFAULT_IOS = new Device({
				widthMeters: 0.1038,
				heightMeters: 0.0584,
				bevelMeters: 0.004
			});


			var Viewers = {
				CardboardV1: new CardboardViewer({
					id: 'CardboardV1',
					label: 'Cardboard I/O 2014',
					fov: 40,
					interLensDistance: 0.060,
					baselineLensDistance: 0.035,
					screenLensDistance: 0.042,
					distortionCoefficients: [0.441, 0.156],
					inverseCoefficients: [-0.4410035, 0.42756155, -0.4804439, 0.5460139,
					-0.58821183, 0.5733938, -0.48303202, 0.33299083, -0.17573841,
						0.0651772, -0.01488963, 0.001559834]
				}),
				CardboardV2: new CardboardViewer({
					id: 'CardboardV2',
					label: 'Cardboard I/O 2015',
					fov: 60,
					interLensDistance: 0.064,
					baselineLensDistance: 0.035,
					screenLensDistance: 0.039,
					distortionCoefficients: [0.34, 0.55],
					inverseCoefficients: [-0.33836704, -0.18162185, 0.862655, -1.2462051,
						1.0560602, -0.58208317, 0.21609078, -0.05444823, 0.009177956,
					-9.904169E-4, 6.183535E-5, -1.6981803E-6]
				})
			};


			var DEFAULT_LEFT_CENTER = { x: 0.5, y: 0.5 };
			var DEFAULT_RIGHT_CENTER = { x: 0.5, y: 0.5 };

			/**
			 * Manages information about the device and the viewer.
			 *
			 * deviceParams indicates the parameters of the device to use (generally
			 * obtained from dpdb.getDeviceParams()). Can be null to mean no device
			 * params were found.
			 */
			function DeviceInfo(deviceParams) {
				this.viewer = Viewers.CardboardV2;
				this.updateDeviceParams(deviceParams);
				this.distortion = new Distortion(this.viewer.distortionCoefficients);
			}

			DeviceInfo.prototype.updateDeviceParams = function (deviceParams) {
				this.device = this.determineDevice_(deviceParams) || this.device;
			};

			DeviceInfo.prototype.getDevice = function () {
				return this.device;
			};

			DeviceInfo.prototype.setViewer = function (viewer) {
				this.viewer = viewer;
				this.distortion = new Distortion(this.viewer.distortionCoefficients);
			};

			DeviceInfo.prototype.determineDevice_ = function (deviceParams) {
				if (!deviceParams) {
					// No parameters, so use a default.
					if (Util.isIOS()) {
						console.warn('Using fallback iOS device measurements.');
						return DEFAULT_IOS;
					} else {
						console.warn('Using fallback Android device measurements.');
						return DEFAULT_ANDROID;
					}
				}

				// Compute device screen dimensions based on deviceParams.
				var METERS_PER_INCH = 0.0254;
				var metersPerPixelX = METERS_PER_INCH / deviceParams.xdpi;
				var metersPerPixelY = METERS_PER_INCH / deviceParams.ydpi;
				var width = Util.getScreenWidth();
				var height = Util.getScreenHeight();
				return new Device({
					widthMeters: metersPerPixelX * width,
					heightMeters: metersPerPixelY * height,
					bevelMeters: deviceParams.bevelMm * 0.001,
				});
			};

			/**
			 * Calculates field of view for the left eye.
			 */
			DeviceInfo.prototype.getDistortedFieldOfViewLeftEye = function () {
				var viewer = this.viewer;
				var device = this.device;
				var distortion = this.distortion;

				// Device.height and device.width for device in portrait mode, so transpose.
				var eyeToScreenDistance = viewer.screenLensDistance;

				var outerDist = (device.widthMeters - viewer.interLensDistance) / 2;
				var innerDist = viewer.interLensDistance / 2;
				var bottomDist = viewer.baselineLensDistance - device.bevelMeters;
				var topDist = device.heightMeters - bottomDist;

				var outerAngle = MathUtil.radToDeg * Math.atan(
					distortion.distort(outerDist / eyeToScreenDistance));
				var innerAngle = MathUtil.radToDeg * Math.atan(
					distortion.distort(innerDist / eyeToScreenDistance));
				var bottomAngle = MathUtil.radToDeg * Math.atan(
					distortion.distort(bottomDist / eyeToScreenDistance));
				var topAngle = MathUtil.radToDeg * Math.atan(
					distortion.distort(topDist / eyeToScreenDistance));

				return {
					leftDegrees: Math.min(outerAngle, viewer.fov),
					rightDegrees: Math.min(innerAngle, viewer.fov),
					downDegrees: Math.min(bottomAngle, viewer.fov),
					upDegrees: Math.min(topAngle, viewer.fov)
				};
			};

			/**
			 * Calculates the tan-angles from the maximum FOV for the left eye for the
			 * current device and screen parameters.
			 */
			DeviceInfo.prototype.getLeftEyeVisibleTanAngles = function () {
				var viewer = this.viewer;
				var device = this.device;
				var distortion = this.distortion;

				// Tan-angles from the max FOV.
				var fovLeft = Math.tan(-MathUtil.degToRad * viewer.fov);
				var fovTop = Math.tan(MathUtil.degToRad * viewer.fov);
				var fovRight = Math.tan(MathUtil.degToRad * viewer.fov);
				var fovBottom = Math.tan(-MathUtil.degToRad * viewer.fov);
				// Viewport size.
				var halfWidth = device.widthMeters / 4;
				var halfHeight = device.heightMeters / 2;
				// Viewport center, measured from left lens position.
				var verticalLensOffset = (viewer.baselineLensDistance - device.bevelMeters - halfHeight);
				var centerX = viewer.interLensDistance / 2 - halfWidth;
				var centerY = -verticalLensOffset;
				var centerZ = viewer.screenLensDistance;
				// Tan-angles of the viewport edges, as seen through the lens.
				var screenLeft = distortion.distort((centerX - halfWidth) / centerZ);
				var screenTop = distortion.distort((centerY + halfHeight) / centerZ);
				var screenRight = distortion.distort((centerX + halfWidth) / centerZ);
				var screenBottom = distortion.distort((centerY - halfHeight) / centerZ);
				// Compare the two sets of tan-angles and take the value closer to zero on each side.
				var result = new Float32Array(4);
				result[0] = Math.max(fovLeft, screenLeft);
				result[1] = Math.min(fovTop, screenTop);
				result[2] = Math.min(fovRight, screenRight);
				result[3] = Math.max(fovBottom, screenBottom);
				return result;
			};

			/**
			 * Calculates the tan-angles from the maximum FOV for the left eye for the
			 * current device and screen parameters, assuming no lenses.
			 */
			DeviceInfo.prototype.getLeftEyeNoLensTanAngles = function () {
				var viewer = this.viewer;
				var device = this.device;
				var distortion = this.distortion;

				var result = new Float32Array(4);
				// Tan-angles from the max FOV.
				var fovLeft = distortion.distortInverse(Math.tan(-MathUtil.degToRad * viewer.fov));
				var fovTop = distortion.distortInverse(Math.tan(MathUtil.degToRad * viewer.fov));
				var fovRight = distortion.distortInverse(Math.tan(MathUtil.degToRad * viewer.fov));
				var fovBottom = distortion.distortInverse(Math.tan(-MathUtil.degToRad * viewer.fov));
				// Viewport size.
				var halfWidth = device.widthMeters / 4;
				var halfHeight = device.heightMeters / 2;
				// Viewport center, measured from left lens position.
				var verticalLensOffset = (viewer.baselineLensDistance - device.bevelMeters - halfHeight);
				var centerX = viewer.interLensDistance / 2 - halfWidth;
				var centerY = -verticalLensOffset;
				var centerZ = viewer.screenLensDistance;
				// Tan-angles of the viewport edges, as seen through the lens.
				var screenLeft = (centerX - halfWidth) / centerZ;
				var screenTop = (centerY + halfHeight) / centerZ;
				var screenRight = (centerX + halfWidth) / centerZ;
				var screenBottom = (centerY - halfHeight) / centerZ;
				// Compare the two sets of tan-angles and take the value closer to zero on each side.
				result[0] = Math.max(fovLeft, screenLeft);
				result[1] = Math.min(fovTop, screenTop);
				result[2] = Math.min(fovRight, screenRight);
				result[3] = Math.max(fovBottom, screenBottom);
				return result;
			};

			/**
			 * Calculates the screen rectangle visible from the left eye for the
			 * current device and screen parameters.
			 */
			DeviceInfo.prototype.getLeftEyeVisibleScreenRect = function (undistortedFrustum) {
				var viewer = this.viewer;
				var device = this.device;

				var dist = viewer.screenLensDistance;
				var eyeX = (device.widthMeters - viewer.interLensDistance) / 2;
				var eyeY = viewer.baselineLensDistance - device.bevelMeters;
				var left = (undistortedFrustum[0] * dist + eyeX) / device.widthMeters;
				var top = (undistortedFrustum[1] * dist + eyeY) / device.heightMeters;
				var right = (undistortedFrustum[2] * dist + eyeX) / device.widthMeters;
				var bottom = (undistortedFrustum[3] * dist + eyeY) / device.heightMeters;
				return {
					x: left,
					y: bottom,
					width: right - left,
					height: top - bottom
				};
			};

			DeviceInfo.prototype.getFieldOfViewLeftEye = function (opt_isUndistorted) {
				return opt_isUndistorted ? this.getUndistortedFieldOfViewLeftEye() :
					this.getDistortedFieldOfViewLeftEye();
			};

			DeviceInfo.prototype.getFieldOfViewRightEye = function (opt_isUndistorted) {
				var fov = this.getFieldOfViewLeftEye(opt_isUndistorted);
				return {
					leftDegrees: fov.rightDegrees,
					rightDegrees: fov.leftDegrees,
					upDegrees: fov.upDegrees,
					downDegrees: fov.downDegrees
				};
			};

			/**
			 * Calculates undistorted field of view for the left eye.
			 */
			DeviceInfo.prototype.getUndistortedFieldOfViewLeftEye = function () {
				var p = this.getUndistortedParams_();

				return {
					leftDegrees: MathUtil.radToDeg * Math.atan(p.outerDist),
					rightDegrees: MathUtil.radToDeg * Math.atan(p.innerDist),
					downDegrees: MathUtil.radToDeg * Math.atan(p.bottomDist),
					upDegrees: MathUtil.radToDeg * Math.atan(p.topDist)
				};
			};

			DeviceInfo.prototype.getUndistortedViewportLeftEye = function () {
				var p = this.getUndistortedParams_();
				var viewer = this.viewer;
				var device = this.device;

				// Distances stored in local variables are in tan-angle units unless otherwise
				// noted.
				var eyeToScreenDistance = viewer.screenLensDistance;
				var screenWidth = device.widthMeters / eyeToScreenDistance;
				var screenHeight = device.heightMeters / eyeToScreenDistance;
				var xPxPerTanAngle = device.width / screenWidth;
				var yPxPerTanAngle = device.height / screenHeight;

				var x = Math.round((p.eyePosX - p.outerDist) * xPxPerTanAngle);
				var y = Math.round((p.eyePosY - p.bottomDist) * yPxPerTanAngle);
				return {
					x: x,
					y: y,
					width: Math.round((p.eyePosX + p.innerDist) * xPxPerTanAngle) - x,
					height: Math.round((p.eyePosY + p.topDist) * yPxPerTanAngle) - y
				};
			};

			DeviceInfo.prototype.getUndistortedParams_ = function () {
				var viewer = this.viewer;
				var device = this.device;
				var distortion = this.distortion;

				// Most of these variables in tan-angle units.
				var eyeToScreenDistance = viewer.screenLensDistance;
				var halfLensDistance = viewer.interLensDistance / 2 / eyeToScreenDistance;
				var screenWidth = device.widthMeters / eyeToScreenDistance;
				var screenHeight = device.heightMeters / eyeToScreenDistance;

				var eyePosX = screenWidth / 2 - halfLensDistance;
				var eyePosY = (viewer.baselineLensDistance - device.bevelMeters) / eyeToScreenDistance;

				var maxFov = viewer.fov;
				var viewerMax = distortion.distortInverse(Math.tan(MathUtil.degToRad * maxFov));
				var outerDist = Math.min(eyePosX, viewerMax);
				var innerDist = Math.min(halfLensDistance, viewerMax);
				var bottomDist = Math.min(eyePosY, viewerMax);
				var topDist = Math.min(screenHeight - eyePosY, viewerMax);

				return {
					outerDist: outerDist,
					innerDist: innerDist,
					topDist: topDist,
					bottomDist: bottomDist,
					eyePosX: eyePosX,
					eyePosY: eyePosY
				};
			};


			function CardboardViewer(params) {
				// A machine readable ID.
				this.id = params.id;
				// A human readable label.
				this.label = params.label;

				// Field of view in degrees (per side).
				this.fov = params.fov;

				// Distance between lens centers in meters.
				this.interLensDistance = params.interLensDistance;
				// Distance between viewer baseline and lens center in meters.
				this.baselineLensDistance = params.baselineLensDistance;
				// Screen-to-lens distance in meters.
				this.screenLensDistance = params.screenLensDistance;

				// Distortion coefficients.
				this.distortionCoefficients = params.distortionCoefficients;
				// Inverse distortion coefficients.
				// TODO: Calculate these from distortionCoefficients in the future.
				this.inverseCoefficients = params.inverseCoefficients;
			}

			// Export viewer information.
			DeviceInfo.Viewers = Viewers;
			module.exports = DeviceInfo;


			/***/
}),
/* 6 */
/***/ (function (module, exports, __webpack_require__) {

			/*
			 * Copyright 2016 Google Inc. All Rights Reserved.
			 * Licensed under the Apache License, Version 2.0 (the "License");
			 * you may not use this file except in compliance with the License.
			 * You may obtain a copy of the License at
			 *
			 *     http://www.apache.org/licenses/LICENSE-2.0
			 *
			 * Unless required by applicable law or agreed to in writing, software
			 * distributed under the License is distributed on an "AS IS" BASIS,
			 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
			 * See the License for the specific language governing permissions and
			 * limitations under the License.
			 */
			var VRDisplay = __webpack_require__(1).VRDisplay;
			var HMDVRDevice = __webpack_require__(1).HMDVRDevice;
			var PositionSensorVRDevice = __webpack_require__(1).PositionSensorVRDevice;

			/**
			 * Wraps a VRDisplay and exposes it as a HMDVRDevice
			 */
			function VRDisplayHMDDevice(display) {
				this.display = display;

				this.hardwareUnitId = display.displayId;
				this.deviceId = 'webvr-polyfill:HMD:' + display.displayId;
				this.deviceName = display.displayName + ' (HMD)';
			}
			VRDisplayHMDDevice.prototype = new HMDVRDevice();

			VRDisplayHMDDevice.prototype.getEyeParameters = function (whichEye) {
				var eyeParameters = this.display.getEyeParameters(whichEye);

				return {
					currentFieldOfView: eyeParameters.fieldOfView,
					maximumFieldOfView: eyeParameters.fieldOfView,
					minimumFieldOfView: eyeParameters.fieldOfView,
					recommendedFieldOfView: eyeParameters.fieldOfView,
					eyeTranslation: { x: eyeParameters.offset[0], y: eyeParameters.offset[1], z: eyeParameters.offset[2] },
					renderRect: {
						x: (whichEye == 'right') ? eyeParameters.renderWidth : 0,
						y: 0,
						width: eyeParameters.renderWidth,
						height: eyeParameters.renderHeight
					}
				};
			};

			VRDisplayHMDDevice.prototype.setFieldOfView =
				function (opt_fovLeft, opt_fovRight, opt_zNear, opt_zFar) {
					// Not supported. getEyeParameters reports that the min, max, and recommended
					// FoV is all the same, so no adjustment can be made.
				};

			// TODO: Need to hook requestFullscreen to see if a wrapped VRDisplay was passed
			// in as an option. If so we should prevent the default fullscreen behavior and
			// call VRDisplay.requestPresent instead.

			/**
			 * Wraps a VRDisplay and exposes it as a PositionSensorVRDevice
			 */
			function VRDisplayPositionSensorDevice(display) {
				this.display = display;

				this.hardwareUnitId = display.displayId;
				this.deviceId = 'webvr-polyfill:PositionSensor: ' + display.displayId;
				this.deviceName = display.displayName + ' (PositionSensor)';
			}
			VRDisplayPositionSensorDevice.prototype = new PositionSensorVRDevice();

			VRDisplayPositionSensorDevice.prototype.getState = function () {
				var pose = this.display.getPose();
				return {
					position: pose.position ? { x: pose.position[0], y: pose.position[1], z: pose.position[2] } : null,
					orientation: pose.orientation ? { x: pose.orientation[0], y: pose.orientation[1], z: pose.orientation[2], w: pose.orientation[3] } : null,
					linearVelocity: null,
					linearAcceleration: null,
					angularVelocity: null,
					angularAcceleration: null
				};
			};

			VRDisplayPositionSensorDevice.prototype.resetState = function () {
				return this.positionDevice.resetPose();
			};


			module.exports.VRDisplayHMDDevice = VRDisplayHMDDevice;
			module.exports.VRDisplayPositionSensorDevice = VRDisplayPositionSensorDevice;



			/***/
}),
/* 7 */
/***/ (function (module, exports, __webpack_require__) {

			/*
			 * Copyright 2015 Google Inc. All Rights Reserved.
			 * Licensed under the Apache License, Version 2.0 (the "License");
			 * you may not use this file except in compliance with the License.
			 * You may obtain a copy of the License at
			 *
			 *     http://www.apache.org/licenses/LICENSE-2.0
			 *
			 * Unless required by applicable law or agreed to in writing, software
			 * distributed under the License is distributed on an "AS IS" BASIS,
			 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
			 * See the License for the specific language governing permissions and
			 * limitations under the License.
			 */
			var Util = __webpack_require__(0);
			var WebVRPolyfill = __webpack_require__(8).WebVRPolyfill;

			// Initialize a WebVRConfig just in case.
			window.WebVRConfig = Util.extend({
				// Forces availability of VR mode, even for non-mobile devices.
				FORCE_ENABLE_VR: false,

				// Complementary filter coefficient. 0 for accelerometer, 1 for gyro.
				K_FILTER: 0.98,

				// How far into the future to predict during fast motion (in seconds).
				PREDICTION_TIME_S: 0.040,

				// Flag to enable touch panner. In case you have your own touch controls.
				TOUCH_PANNER_DISABLED: true,

				// Flag to disabled the UI in VR Mode.
				CARDBOARD_UI_DISABLED: false, // Default: false

				// Flag to disable the instructions to rotate your device.
				ROTATE_INSTRUCTIONS_DISABLED: false, // Default: false.

				// Enable yaw panning only, disabling roll and pitch. This can be useful
				// for panoramas with nothing interesting above or below.
				YAW_ONLY: false,

				// To disable keyboard and mouse controls, if you want to use your own
				// implementation.
				MOUSE_KEYBOARD_CONTROLS_DISABLED: false,

				// Prevent the polyfill from initializing immediately. Requires the app
				// to call InitializeWebVRPolyfill() before it can be used.
				DEFER_INITIALIZATION: false,

				// Enable the deprecated version of the API (navigator.getVRDevices).
				ENABLE_DEPRECATED_API: false,

				// Scales the recommended buffer size reported by WebVR, which can improve
				// performance.
				// UPDATE(2016-05-03): Setting this to 0.5 by default since 1.0 does not
				// perform well on many mobile devices.
				BUFFER_SCALE: 0.5,

				// Allow VRDisplay.submitFrame to change gl bindings, which is more
				// efficient if the application code will re-bind its resources on the
				// next frame anyway. This has been seen to cause rendering glitches with
				// THREE.js.
				// Dirty bindings include: gl.FRAMEBUFFER_BINDING, gl.CURRENT_PROGRAM,
				// gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING,
				// and gl.TEXTURE_BINDING_2D for texture unit 0.
				DIRTY_SUBMIT_FRAME_BINDINGS: false,

				// When set to true, this will cause a polyfilled VRDisplay to always be
				// appended to the list returned by navigator.getVRDisplays(), even if that
				// list includes a native VRDisplay.
				ALWAYS_APPEND_POLYFILL_DISPLAY: false,

				// There are versions of Chrome (M58-M60?) where the native WebVR API exists,
				// and instead of returning 0 VR displays when none are detected,
				// `navigator.getVRDisplays()`'s promise never resolves. This results
				// in the polyfill hanging and not being able to provide fallback
				// displays, so set a timeout in milliseconds to stop waiting for a response
				// and just use polyfilled displays.
				// https://bugs.chromium.org/p/chromium/issues/detail?id=727969
				GET_VR_DISPLAYS_TIMEOUT: 1000,
			}, window.WebVRConfig);

			if (!window.WebVRConfig.DEFER_INITIALIZATION) {
				new WebVRPolyfill();
			} else {
				window.InitializeWebVRPolyfill = function () {
					new WebVRPolyfill();
				}
			}

			window.WebVRPolyfill = WebVRPolyfill;


			/***/
}),
/* 8 */
/***/ (function (module, exports, __webpack_require__) {

			/*
			 * Copyright 2015 Google Inc. All Rights Reserved.
			 * Licensed under the Apache License, Version 2.0 (the "License");
			 * you may not use this file except in compliance with the License.
			 * You may obtain a copy of the License at
			 *
			 *     http://www.apache.org/licenses/LICENSE-2.0
			 *
			 * Unless required by applicable law or agreed to in writing, software
			 * distributed under the License is distributed on an "AS IS" BASIS,
			 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
			 * See the License for the specific language governing permissions and
			 * limitations under the License.
			 */

			var Util = __webpack_require__(0);
			var CardboardVRDisplay = __webpack_require__(9);
			var MouseKeyboardVRDisplay = __webpack_require__(22);
			// Uncomment to add positional tracking via webcam.
			//var WebcamPositionSensorVRDevice = require('./webcam-position-sensor-vr-device.js');
			var VRDisplay = __webpack_require__(1).VRDisplay;
			var VRFrameData = __webpack_require__(1).VRFrameData;
			var HMDVRDevice = __webpack_require__(1).HMDVRDevice;
			var PositionSensorVRDevice = __webpack_require__(1).PositionSensorVRDevice;
			var VRDisplayHMDDevice = __webpack_require__(6).VRDisplayHMDDevice;
			var VRDisplayPositionSensorDevice = __webpack_require__(6).VRDisplayPositionSensorDevice;
			var version = __webpack_require__(23).version;

			function WebVRPolyfill() {
				this.displays = [];
				this.devices = []; // For deprecated objects
				this.devicesPopulated = false;
				this.nativeWebVRAvailable = this.isWebVRAvailable();
				this.nativeLegacyWebVRAvailable = this.isDeprecatedWebVRAvailable();
				this.nativeGetVRDisplaysFunc = this.nativeWebVRAvailable ?
					navigator.getVRDisplays :
					null;

				if (!this.nativeLegacyWebVRAvailable && !this.nativeWebVRAvailable) {
					this.enablePolyfill();
					if (window.WebVRConfig.ENABLE_DEPRECATED_API) {
						this.enableDeprecatedPolyfill();
					}
				}

				// Put a shim in place to update the API to 1.1 if needed.
				InstallWebVRSpecShim();
			}

			WebVRPolyfill.prototype.isWebVRAvailable = function () {
				return ('getVRDisplays' in navigator);
			};

			WebVRPolyfill.prototype.isDeprecatedWebVRAvailable = function () {
				return ('getVRDevices' in navigator) || ('mozGetVRDevices' in navigator);
			};

			WebVRPolyfill.prototype.connectDisplay = function (vrDisplay) {
				vrDisplay.fireVRDisplayConnect_();
				this.displays.push(vrDisplay);
			};

			WebVRPolyfill.prototype.populateDevices = function () {
				if (this.devicesPopulated) {
					return;
				}

				// Initialize our virtual VR devices.
				var vrDisplay = null;

				// Add a Cardboard VRDisplay on compatible mobile devices
				if (this.isCardboardCompatible()) {
					vrDisplay = new CardboardVRDisplay();

					this.connectDisplay(vrDisplay);

					// For backwards compatibility
					if (window.WebVRConfig.ENABLE_DEPRECATED_API) {
						this.devices.push(new VRDisplayHMDDevice(vrDisplay));
						this.devices.push(new VRDisplayPositionSensorDevice(vrDisplay));
					}
				}

				// Add a Mouse and Keyboard driven VRDisplay for desktops/laptops
				if (!this.isMobile() && !window.WebVRConfig.MOUSE_KEYBOARD_CONTROLS_DISABLED) {
					vrDisplay = new MouseKeyboardVRDisplay();
					this.connectDisplay(vrDisplay);

					// For backwards compatibility
					if (window.WebVRConfig.ENABLE_DEPRECATED_API) {
						this.devices.push(new VRDisplayHMDDevice(vrDisplay));
						this.devices.push(new VRDisplayPositionSensorDevice(vrDisplay));
					}
				}

				// Uncomment to add positional tracking via webcam.
				//if (!this.isMobile() && window.WebVRConfig.ENABLE_DEPRECATED_API) {
				//  positionDevice = new WebcamPositionSensorVRDevice();
				//  this.devices.push(positionDevice);
				//}

				this.devicesPopulated = true;
			};

			WebVRPolyfill.prototype.enablePolyfill = function () {
				// Provide navigator.getVRDisplays.
				navigator.getVRDisplays = this.getVRDisplays.bind(this);

				// Polyfill native VRDisplay.getFrameData
				if (this.nativeWebVRAvailable && window.VRFrameData) {
					var NativeVRFrameData = window.VRFrameData;
					var nativeFrameData = new window.VRFrameData();
					var nativeGetFrameData = window.VRDisplay.prototype.getFrameData;
					window.VRFrameData = VRFrameData;

					window.VRDisplay.prototype.getFrameData = function (frameData) {
						if (frameData instanceof NativeVRFrameData) {
							nativeGetFrameData.call(this, frameData);
							return;
						}

						/*
						Copy frame data from the native object into the polyfilled object.
						*/

						nativeGetFrameData.call(this, nativeFrameData);
						frameData.pose = nativeFrameData.pose;
						Util.copyArray(nativeFrameData.leftProjectionMatrix, frameData.leftProjectionMatrix);
						Util.copyArray(nativeFrameData.rightProjectionMatrix, frameData.rightProjectionMatrix);
						Util.copyArray(nativeFrameData.leftViewMatrix, frameData.leftViewMatrix);
						Util.copyArray(nativeFrameData.rightViewMatrix, frameData.rightViewMatrix);
						//todo: copy
					};
				}

				// Provide the `VRDisplay` object.
				window.VRDisplay = VRDisplay;

				// Provide the `navigator.vrEnabled` property.
				if (navigator && typeof navigator.vrEnabled === 'undefined') {
					var self = this;
					Object.defineProperty(navigator, 'vrEnabled', {
						get: function () {
							return self.isCardboardCompatible() &&
								(self.isFullScreenAvailable() || Util.isIOS());
						}
					});
				}

				if (!('VRFrameData' in window)) {
					// Provide the VRFrameData object.
					window.VRFrameData = VRFrameData;
				}
			};

			WebVRPolyfill.prototype.enableDeprecatedPolyfill = function () {
				// Provide navigator.getVRDevices.
				navigator.getVRDevices = this.getVRDevices.bind(this);

				// Provide the CardboardHMDVRDevice and PositionSensorVRDevice objects.
				window.HMDVRDevice = HMDVRDevice;
				window.PositionSensorVRDevice = PositionSensorVRDevice;
			};

			WebVRPolyfill.prototype.getVRDisplays = function () {
				this.populateDevices();
				var polyfillDisplays = this.displays;

				if (!this.nativeWebVRAvailable) {
					return Promise.resolve(polyfillDisplays);
				}

				// Set up a race condition if this browser has a bug where
				// `navigator.getVRDisplays()` never resolves.
				var timeoutId;
				var vrDisplaysNative = this.nativeGetVRDisplaysFunc.call(navigator);
				var timeoutPromise = new Promise(function (resolve) {
					timeoutId = setTimeout(function () {
						console.warn('Native WebVR implementation detected, but `getVRDisplays()` failed to resolve. Falling back to polyfill.');
						resolve([]);
					}, window.WebVRConfig.GET_VR_DISPLAYS_TIMEOUT);
				});

				return Util.race([
					vrDisplaysNative,
					timeoutPromise
				]).then(function (nativeDisplays) {
					clearTimeout(timeoutId);
					if (window.WebVRConfig.ALWAYS_APPEND_POLYFILL_DISPLAY) {
						return nativeDisplays.concat(polyfillDisplays);
					} else {
						return nativeDisplays.length > 0 ? nativeDisplays : polyfillDisplays;
					}
				});
			};

			WebVRPolyfill.prototype.getVRDevices = function () {
				console.warn('getVRDevices is deprecated. Please update your code to use getVRDisplays instead.');
				var self = this;
				return new Promise(function (resolve, reject) {
					try {
						if (!self.devicesPopulated) {
							if (self.nativeWebVRAvailable) {
								return navigator.getVRDisplays(function (displays) {
									for (var i = 0; i < displays.length; ++i) {
										self.devices.push(new VRDisplayHMDDevice(displays[i]));
										self.devices.push(new VRDisplayPositionSensorDevice(displays[i]));
									}
									self.devicesPopulated = true;
									resolve(self.devices);
								}, reject);
							}

							if (self.nativeLegacyWebVRAvailable) {
								return (navigator.getVRDDevices || navigator.mozGetVRDevices)(function (devices) {
									for (var i = 0; i < devices.length; ++i) {
										if (devices[i] instanceof HMDVRDevice) {
											self.devices.push(devices[i]);
										}
										if (devices[i] instanceof PositionSensorVRDevice) {
											self.devices.push(devices[i]);
										}
									}
									self.devicesPopulated = true;
									resolve(self.devices);
								}, reject);
							}
						}

						self.populateDevices();
						resolve(self.devices);
					} catch (e) {
						reject(e);
					}
				});
			};

			WebVRPolyfill.prototype.NativeVRFrameData = window.VRFrameData;

			/**
			 * Determine if a device is mobile.
			 */
			WebVRPolyfill.prototype.isMobile = function () {
				return /Android/i.test(navigator.userAgent) ||
					/iPhone|iPad|iPod/i.test(navigator.userAgent);
			};

			WebVRPolyfill.prototype.isCardboardCompatible = function () {
				// For now, support all iOS and Android devices.
				// Also enable the WebVRConfig.FORCE_VR flag for debugging.
				return this.isMobile() || window.WebVRConfig.FORCE_ENABLE_VR;
			};

			WebVRPolyfill.prototype.isFullScreenAvailable = function () {
				return (document.fullscreenEnabled ||
					document.mozFullScreenEnabled ||
					document.webkitFullscreenEnabled ||
					false);
			};

			// Installs a shim that updates a WebVR 1.0 spec implementation to WebVR 1.1
			function InstallWebVRSpecShim() {
				if ('VRDisplay' in window && !('VRFrameData' in window)) {
					// Provide the VRFrameData object.
					window.VRFrameData = VRFrameData;

					// A lot of Chrome builds don't have depthNear and depthFar, even
					// though they're in the WebVR 1.0 spec. Patch them in if they're not present.
					if (!('depthNear' in window.VRDisplay.prototype)) {
						window.VRDisplay.prototype.depthNear = 0.01;
					}

					if (!('depthFar' in window.VRDisplay.prototype)) {
						window.VRDisplay.prototype.depthFar = 10000.0;
					}

					window.VRDisplay.prototype.getFrameData = function (frameData) {
						return Util.frameDataFromPose(frameData, this.getPose(), this);
					}
				}
			};

			WebVRPolyfill.InstallWebVRSpecShim = InstallWebVRSpecShim;
			WebVRPolyfill.version = version;

			module.exports.WebVRPolyfill = WebVRPolyfill;


			/***/
}),
/* 9 */
/***/ (function (module, exports, __webpack_require__) {

			/*
			 * Copyright 2016 Google Inc. All Rights Reserved.
			 * Licensed under the Apache License, Version 2.0 (the "License");
			 * you may not use this file except in compliance with the License.
			 * You may obtain a copy of the License at
			 *
			 *     http://www.apache.org/licenses/LICENSE-2.0
			 *
			 * Unless required by applicable law or agreed to in writing, software
			 * distributed under the License is distributed on an "AS IS" BASIS,
			 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
			 * See the License for the specific language governing permissions and
			 * limitations under the License.
			 */

			var CardboardDistorter = __webpack_require__(10);
			var CardboardUI = __webpack_require__(3);
			var DeviceInfo = __webpack_require__(5);
			var Dpdb = __webpack_require__(12);
			var FusionPoseSensor = __webpack_require__(14);
			var RotateInstructions = __webpack_require__(19);
			var ViewerSelector = __webpack_require__(20);
			var VRDisplay = __webpack_require__(1).VRDisplay;
			var Util = __webpack_require__(0);

			var Eye = {
				LEFT: 'left',
				RIGHT: 'right'
			};

			/**
			 * VRDisplay based on mobile device parameters and DeviceMotion APIs.
			 */
			function CardboardVRDisplay() {
				this.displayName = 'Cardboard VRDisplay (webvr-polyfill)';

				this.capabilities.hasOrientation = true;
				this.capabilities.canPresent = true;

				// "Private" members.
				this.bufferScale_ = window.WebVRConfig.BUFFER_SCALE;
				this.poseSensor_ = new FusionPoseSensor();
				this.distorter_ = null;
				this.cardboardUI_ = null;

				this.dpdb_ = new Dpdb(true, this.onDeviceParamsUpdated_.bind(this));
				this.deviceInfo_ = new DeviceInfo(this.dpdb_.getDeviceParams());

				this.viewerSelector_ = new ViewerSelector();
				this.viewerSelector_.onChange(this.onViewerChanged_.bind(this));

				// Set the correct initial viewer.
				this.deviceInfo_.setViewer(this.viewerSelector_.getCurrentViewer());

				if (!window.WebVRConfig.ROTATE_INSTRUCTIONS_DISABLED) {
					this.rotateInstructions_ = new RotateInstructions();
				}

				if (Util.isIOS()) {
					// Listen for resize events to workaround this awful Safari bug.
					window.addEventListener('resize', this.onResize_.bind(this));
				}
			}
			CardboardVRDisplay.prototype = new VRDisplay();

			CardboardVRDisplay.prototype.getImmediatePose = function () {
				return {
					position: this.poseSensor_.getPosition(),
					orientation: this.poseSensor_.getOrientation(),
					linearVelocity: null,
					linearAcceleration: null,
					angularVelocity: null,
					angularAcceleration: null
				};
			};

			CardboardVRDisplay.prototype.resetPose = function () {
				this.poseSensor_.resetPose();
			};

			CardboardVRDisplay.prototype.getEyeParameters = function (whichEye) {
				var offset = [this.deviceInfo_.viewer.interLensDistance * 0.5, 0.0, 0.0];
				var fieldOfView;

				// TODO: FoV can be a little expensive to compute. Cache when device params change.
				if (whichEye == Eye.LEFT) {
					offset[0] *= -1.0;
					fieldOfView = this.deviceInfo_.getFieldOfViewLeftEye();
				} else if (whichEye == Eye.RIGHT) {
					fieldOfView = this.deviceInfo_.getFieldOfViewRightEye();
				} else {
					console.error('Invalid eye provided: %s', whichEye);
					return null;
				}

				return {
					fieldOfView: fieldOfView,
					offset: offset,
					// TODO: Should be able to provide better values than these.
					renderWidth: this.deviceInfo_.device.width * 0.5 * this.bufferScale_,
					renderHeight: this.deviceInfo_.device.height * this.bufferScale_,
				};
			};

			CardboardVRDisplay.prototype.onDeviceParamsUpdated_ = function (newParams) {
				if (Util.isDebug()) {
					console.log('DPDB reported that device params were updated.');
				}
				this.deviceInfo_.updateDeviceParams(newParams);

				if (this.distorter_) {
					this.distorter_.updateDeviceInfo(this.deviceInfo_);
				}
			};

			CardboardVRDisplay.prototype.updateBounds_ = function () {
				if (this.layer_ && this.distorter_ && (this.layer_.leftBounds || this.layer_.rightBounds)) {
					this.distorter_.setTextureBounds(this.layer_.leftBounds, this.layer_.rightBounds);
				}
			};

			CardboardVRDisplay.prototype.beginPresent_ = function () {
				var gl = this.layer_.source.getContext('webgl');
				if (!gl)
					gl = this.layer_.source.getContext('experimental-webgl');
				if (!gl)
					gl = this.layer_.source.getContext('webgl2');

				if (!gl)
					return; // Can't do distortion without a WebGL context.

				// Provides a way to opt out of distortion
				if (this.layer_.predistorted) {
					if (!window.WebVRConfig.CARDBOARD_UI_DISABLED) {
						gl.canvas.width = Util.getScreenWidth() * this.bufferScale_;
						gl.canvas.height = Util.getScreenHeight() * this.bufferScale_;
						this.cardboardUI_ = new CardboardUI(gl);
					}
				} else {
					// Create a new distorter for the target context
					this.distorter_ = new CardboardDistorter(gl);
					this.distorter_.updateDeviceInfo(this.deviceInfo_);
					this.cardboardUI_ = this.distorter_.cardboardUI;
				}

				if (this.cardboardUI_) {
					this.cardboardUI_.listen(function (e) {
						// Options clicked.
						this.viewerSelector_.show(this.layer_.source.parentElement);
						e.stopPropagation();
						e.preventDefault();
					}.bind(this), function (e) {
						// Back clicked.
						this.exitPresent();
						e.stopPropagation();
						e.preventDefault();
					}.bind(this));
				}

				if (this.rotateInstructions_) {
					if (Util.isLandscapeMode() && Util.isMobile()) {
						// In landscape mode, temporarily show the "put into Cardboard"
						// interstitial. Otherwise, do the default thing.
						this.rotateInstructions_.showTemporarily(3000, this.layer_.source.parentElement);
					} else {
						this.rotateInstructions_.update();
					}
				}

				// Listen for orientation change events in order to show interstitial.
				this.orientationHandler = this.onOrientationChange_.bind(this);
				window.addEventListener('orientationchange', this.orientationHandler);

				// Listen for present display change events in order to update distorter dimensions
				this.vrdisplaypresentchangeHandler = this.updateBounds_.bind(this);
				window.addEventListener('vrdisplaypresentchange', this.vrdisplaypresentchangeHandler);

				// Fire this event initially, to give geometry-distortion clients the chance
				// to do something custom.
				this.fireVRDisplayDeviceParamsChange_();
			};

			CardboardVRDisplay.prototype.endPresent_ = function () {
				if (this.distorter_) {
					this.distorter_.destroy();
					this.distorter_ = null;
				}
				if (this.cardboardUI_) {
					this.cardboardUI_.destroy();
					this.cardboardUI_ = null;
				}

				if (this.rotateInstructions_) {
					this.rotateInstructions_.hide();
				}
				this.viewerSelector_.hide();

				window.removeEventListener('orientationchange', this.orientationHandler);
				window.removeEventListener('vrdisplaypresentchange', this.vrdisplaypresentchangeHandler);
			};

			CardboardVRDisplay.prototype.submitFrame = function (pose) {
				if (this.distorter_) {
					this.updateBounds_();
					this.distorter_.submitFrame();
				} else if (this.cardboardUI_ && this.layer_) {
					// Hack for predistorted: true.
					var canvas = this.layer_.source.getContext('webgl').canvas;
					if (canvas.width != this.lastWidth || canvas.height != this.lastHeight) {
						this.cardboardUI_.onResize();
					}
					this.lastWidth = canvas.width;
					this.lastHeight = canvas.height;

					// Render the Cardboard UI.
					this.cardboardUI_.render();
				}
			};

			CardboardVRDisplay.prototype.onOrientationChange_ = function (e) {
				// Hide the viewer selector.
				this.viewerSelector_.hide();

				// Update the rotate instructions.
				if (this.rotateInstructions_) {
					this.rotateInstructions_.update();
				}

				this.onResize_();
			};

			CardboardVRDisplay.prototype.onResize_ = function (e) {
				if (this.layer_) {
					var gl = this.layer_.source.getContext('webgl');
					// Size the CSS canvas.
					// Added padding on right and bottom because iPhone 5 will not
					// hide the URL bar unless content is bigger than the screen.
					// This will not be visible as long as the container element (e.g. body)
					// is set to 'overflow: hidden'.
					// Additionally, 'box-sizing: content-box' ensures renderWidth = width + padding.
					// This is required when 'box-sizing: border-box' is used elsewhere in the page.
					var cssProperties = [
						'position: absolute',
						'top: 0',
						'left: 0',
						// Use vw/vh to handle implicitly devicePixelRatio; issue #282
						'width: 100vw',
						'height: 100vh',
						'border: 0',
						'margin: 0',
						// Set no padding in the case where you don't have control over
						// the content injection, like in Unity WebGL; issue #282
						'padding: 0px',
						'box-sizing: content-box',
					];
					gl.canvas.setAttribute('style', cssProperties.join('; ') + ';');

					Util.safariCssSizeWorkaround(gl.canvas);
				}
			};

			CardboardVRDisplay.prototype.onViewerChanged_ = function (viewer) {
				this.deviceInfo_.setViewer(viewer);

				if (this.distorter_) {
					// Update the distortion appropriately.
					this.distorter_.updateDeviceInfo(this.deviceInfo_);
				}

				// Fire a new event containing viewer and device parameters for clients that
				// want to implement their own geometry-based distortion.
				this.fireVRDisplayDeviceParamsChange_();
			};

			CardboardVRDisplay.prototype.fireVRDisplayDeviceParamsChange_ = function () {
				var event = new CustomEvent('vrdisplaydeviceparamschange', {
					detail: {
						vrdisplay: this,
						deviceInfo: this.deviceInfo_,
					}
				});
				window.dispatchEvent(event);
			};

			module.exports = CardboardVRDisplay;


			/***/
}),
/* 10 */
/***/ (function (module, exports, __webpack_require__) {

			/*
			 * Copyright 2016 Google Inc. All Rights Reserved.
			 * Licensed under the Apache License, Version 2.0 (the "License");
			 * you may not use this file except in compliance with the License.
			 * You may obtain a copy of the License at
			 *
			 *     http://www.apache.org/licenses/LICENSE-2.0
			 *
			 * Unless required by applicable law or agreed to in writing, software
			 * distributed under the License is distributed on an "AS IS" BASIS,
			 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
			 * See the License for the specific language governing permissions and
			 * limitations under the License.
			 */

			var CardboardUI = __webpack_require__(3);
			var Util = __webpack_require__(0);
			var WGLUPreserveGLState = __webpack_require__(4);

			var distortionVS = [
				'attribute vec2 position;',
				'attribute vec3 texCoord;',

				'varying vec2 vTexCoord;',

				'uniform vec4 viewportOffsetScale[2];',

				'void main() {',
				'  vec4 viewport = viewportOffsetScale[int(texCoord.z)];',
				'  vTexCoord = (texCoord.xy * viewport.zw) + viewport.xy;',
				'  gl_Position = vec4( position, 1.0, 1.0 );',
				'}',
			].join('\n');

			var distortionFS = [
				'precision mediump float;',
				'uniform sampler2D diffuse;',

				'varying vec2 vTexCoord;',

				'void main() {',
				'  gl_FragColor = texture2D(diffuse, vTexCoord);',
				'}',
			].join('\n');

			/**
			 * A mesh-based distorter.
			 */
			function CardboardDistorter(gl) {
				this.gl = gl;
				this.ctxAttribs = gl.getContextAttributes();

				this.meshWidth = 20;
				this.meshHeight = 20;

				this.bufferScale = window.WebVRConfig.BUFFER_SCALE;

				this.bufferWidth = gl.drawingBufferWidth;
				this.bufferHeight = gl.drawingBufferHeight;

				// Patching support
				this.realBindFramebuffer = gl.bindFramebuffer;
				this.realEnable = gl.enable;
				this.realDisable = gl.disable;
				this.realColorMask = gl.colorMask;
				this.realClearColor = gl.clearColor;
				this.realViewport = gl.viewport;

				if (!Util.isIOS()) {
					this.realCanvasWidth = Object.getOwnPropertyDescriptor(gl.canvas.__proto__, 'width');
					this.realCanvasHeight = Object.getOwnPropertyDescriptor(gl.canvas.__proto__, 'height');
				}

				this.isPatched = false;

				// State tracking
				this.lastBoundFramebuffer = null;
				this.cullFace = false;
				this.depthTest = false;
				this.blend = false;
				this.scissorTest = false;
				this.stencilTest = false;
				this.viewport = [0, 0, 0, 0];
				this.colorMask = [true, true, true, true];
				this.clearColor = [0, 0, 0, 0];

				this.attribs = {
					position: 0,
					texCoord: 1
				};
				this.program = Util.linkProgram(gl, distortionVS, distortionFS, this.attribs);
				this.uniforms = Util.getProgramUniforms(gl, this.program);

				this.viewportOffsetScale = new Float32Array(8);
				this.setTextureBounds();

				this.vertexBuffer = gl.createBuffer();
				this.indexBuffer = gl.createBuffer();
				this.indexCount = 0;

				this.renderTarget = gl.createTexture();
				this.framebuffer = gl.createFramebuffer();

				this.depthStencilBuffer = null;
				this.depthBuffer = null;
				this.stencilBuffer = null;

				if (this.ctxAttribs.depth && this.ctxAttribs.stencil) {
					this.depthStencilBuffer = gl.createRenderbuffer();
				} else if (this.ctxAttribs.depth) {
					this.depthBuffer = gl.createRenderbuffer();
				} else if (this.ctxAttribs.stencil) {
					this.stencilBuffer = gl.createRenderbuffer();
				}

				this.patch();

				this.onResize();

				if (!window.WebVRConfig.CARDBOARD_UI_DISABLED) {
					this.cardboardUI = new CardboardUI(gl);
				}
			};

			/**
			 * Tears down all the resources created by the distorter and removes any
			 * patches.
			 */
			CardboardDistorter.prototype.destroy = function () {
				var gl = this.gl;

				this.unpatch();

				gl.deleteProgram(this.program);
				gl.deleteBuffer(this.vertexBuffer);
				gl.deleteBuffer(this.indexBuffer);
				gl.deleteTexture(this.renderTarget);
				gl.deleteFramebuffer(this.framebuffer);
				if (this.depthStencilBuffer) {
					gl.deleteRenderbuffer(this.depthStencilBuffer);
				}
				if (this.depthBuffer) {
					gl.deleteRenderbuffer(this.depthBuffer);
				}
				if (this.stencilBuffer) {
					gl.deleteRenderbuffer(this.stencilBuffer);
				}

				if (this.cardboardUI) {
					this.cardboardUI.destroy();
				}
			};


			/**
			 * Resizes the backbuffer to match the canvas width and height.
			 */
			CardboardDistorter.prototype.onResize = function () {
				var gl = this.gl;
				var self = this;

				var glState = [
					gl.RENDERBUFFER_BINDING,
					gl.TEXTURE_BINDING_2D, gl.TEXTURE0
				];

				WGLUPreserveGLState(gl, glState, function (gl) {
					// Bind real backbuffer and clear it once. We don't need to clear it again
					// after that because we're overwriting the same area every frame.
					self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, null);

					// Put things in a good state
					if (self.scissorTest) { self.realDisable.call(gl, gl.SCISSOR_TEST); }
					self.realColorMask.call(gl, true, true, true, true);
					self.realViewport.call(gl, 0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
					self.realClearColor.call(gl, 0, 0, 0, 1);

					gl.clear(gl.COLOR_BUFFER_BIT);

					// Now bind and resize the fake backbuffer
					self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, self.framebuffer);

					gl.bindTexture(gl.TEXTURE_2D, self.renderTarget);
					gl.texImage2D(gl.TEXTURE_2D, 0, self.ctxAttribs.alpha ? gl.RGBA : gl.RGB,
						self.bufferWidth, self.bufferHeight, 0,
						self.ctxAttribs.alpha ? gl.RGBA : gl.RGB, gl.UNSIGNED_BYTE, null);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
					gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, self.renderTarget, 0);

					if (self.ctxAttribs.depth && self.ctxAttribs.stencil) {
						gl.bindRenderbuffer(gl.RENDERBUFFER, self.depthStencilBuffer);
						gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL,
							self.bufferWidth, self.bufferHeight);
						gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT,
							gl.RENDERBUFFER, self.depthStencilBuffer);
					} else if (self.ctxAttribs.depth) {
						gl.bindRenderbuffer(gl.RENDERBUFFER, self.depthBuffer);
						gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16,
							self.bufferWidth, self.bufferHeight);
						gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT,
							gl.RENDERBUFFER, self.depthBuffer);
					} else if (self.ctxAttribs.stencil) {
						gl.bindRenderbuffer(gl.RENDERBUFFER, self.stencilBuffer);
						gl.renderbufferStorage(gl.RENDERBUFFER, gl.STENCIL_INDEX8,
							self.bufferWidth, self.bufferHeight);
						gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT,
							gl.RENDERBUFFER, self.stencilBuffer);
					}

					if (!gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE) {
						console.error('Framebuffer incomplete!');
					}

					self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, self.lastBoundFramebuffer);

					if (self.scissorTest) { self.realEnable.call(gl, gl.SCISSOR_TEST); }

					self.realColorMask.apply(gl, self.colorMask);
					self.realViewport.apply(gl, self.viewport);
					self.realClearColor.apply(gl, self.clearColor);
				});

				if (this.cardboardUI) {
					this.cardboardUI.onResize();
				}
			};

			CardboardDistorter.prototype.patch = function () {
				if (this.isPatched) {
					return;
				}

				var self = this;
				var canvas = this.gl.canvas;
				var gl = this.gl;

				if (!Util.isIOS()) {
					canvas.width = Util.getScreenWidth() * this.bufferScale;
					canvas.height = Util.getScreenHeight() * this.bufferScale;

					Object.defineProperty(canvas, 'width', {
						configurable: true,
						enumerable: true,
						get: function () {
							return self.bufferWidth;
						},
						set: function (value) {
							self.bufferWidth = value;
							self.realCanvasWidth.set.call(canvas, value);
							self.onResize();
						}
					});

					Object.defineProperty(canvas, 'height', {
						configurable: true,
						enumerable: true,
						get: function () {
							return self.bufferHeight;
						},
						set: function (value) {
							self.bufferHeight = value;
							self.realCanvasHeight.set.call(canvas, value);
							self.onResize();
						}
					});
				}

				this.lastBoundFramebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);

				if (this.lastBoundFramebuffer == null) {
					this.lastBoundFramebuffer = this.framebuffer;
					this.gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
				}

				this.gl.bindFramebuffer = function (target, framebuffer) {
					self.lastBoundFramebuffer = framebuffer ? framebuffer : self.framebuffer;
					// Silently make calls to bind the default framebuffer bind ours instead.
					self.realBindFramebuffer.call(gl, target, self.lastBoundFramebuffer);
				};

				this.cullFace = gl.getParameter(gl.CULL_FACE);
				this.depthTest = gl.getParameter(gl.DEPTH_TEST);
				this.blend = gl.getParameter(gl.BLEND);
				this.scissorTest = gl.getParameter(gl.SCISSOR_TEST);
				this.stencilTest = gl.getParameter(gl.STENCIL_TEST);

				gl.enable = function (pname) {
					switch (pname) {
						case gl.CULL_FACE: self.cullFace = true; break;
						case gl.DEPTH_TEST: self.depthTest = true; break;
						case gl.BLEND: self.blend = true; break;
						case gl.SCISSOR_TEST: self.scissorTest = true; break;
						case gl.STENCIL_TEST: self.stencilTest = true; break;
					}
					self.realEnable.call(gl, pname);
				};

				gl.disable = function (pname) {
					switch (pname) {
						case gl.CULL_FACE: self.cullFace = false; break;
						case gl.DEPTH_TEST: self.depthTest = false; break;
						case gl.BLEND: self.blend = false; break;
						case gl.SCISSOR_TEST: self.scissorTest = false; break;
						case gl.STENCIL_TEST: self.stencilTest = false; break;
					}
					self.realDisable.call(gl, pname);
				};

				this.colorMask = gl.getParameter(gl.COLOR_WRITEMASK);
				gl.colorMask = function (r, g, b, a) {
					self.colorMask[0] = r;
					self.colorMask[1] = g;
					self.colorMask[2] = b;
					self.colorMask[3] = a;
					self.realColorMask.call(gl, r, g, b, a);
				};

				this.clearColor = gl.getParameter(gl.COLOR_CLEAR_VALUE);
				gl.clearColor = function (r, g, b, a) {
					self.clearColor[0] = r;
					self.clearColor[1] = g;
					self.clearColor[2] = b;
					self.clearColor[3] = a;
					self.realClearColor.call(gl, r, g, b, a);
				};

				this.viewport = gl.getParameter(gl.VIEWPORT);
				gl.viewport = function (x, y, w, h) {
					self.viewport[0] = x;
					self.viewport[1] = y;
					self.viewport[2] = w;
					self.viewport[3] = h;
					self.realViewport.call(gl, x, y, w, h);
				};

				this.isPatched = true;
				Util.safariCssSizeWorkaround(canvas);
			};

			CardboardDistorter.prototype.unpatch = function () {
				if (!this.isPatched) {
					return;
				}

				var gl = this.gl;
				var canvas = this.gl.canvas;

				if (!Util.isIOS()) {
					Object.defineProperty(canvas, 'width', this.realCanvasWidth);
					Object.defineProperty(canvas, 'height', this.realCanvasHeight);
				}
				canvas.width = this.bufferWidth;
				canvas.height = this.bufferHeight;

				gl.bindFramebuffer = this.realBindFramebuffer;
				gl.enable = this.realEnable;
				gl.disable = this.realDisable;
				gl.colorMask = this.realColorMask;
				gl.clearColor = this.realClearColor;
				gl.viewport = this.realViewport;

				// Check to see if our fake backbuffer is bound and bind the real backbuffer
				// if that's the case.
				if (this.lastBoundFramebuffer == this.framebuffer) {
					gl.bindFramebuffer(gl.FRAMEBUFFER, null);
				}

				this.isPatched = false;

				setTimeout(function () {
					Util.safariCssSizeWorkaround(canvas);
				}, 1);
			};

			CardboardDistorter.prototype.setTextureBounds = function (leftBounds, rightBounds) {
				if (!leftBounds) {
					leftBounds = [0, 0, 0.5, 1];
				}

				if (!rightBounds) {
					rightBounds = [0.5, 0, 0.5, 1];
				}

				// Left eye
				this.viewportOffsetScale[0] = leftBounds[0]; // X
				this.viewportOffsetScale[1] = leftBounds[1]; // Y
				this.viewportOffsetScale[2] = leftBounds[2]; // Width
				this.viewportOffsetScale[3] = leftBounds[3]; // Height

				// Right eye
				this.viewportOffsetScale[4] = rightBounds[0]; // X
				this.viewportOffsetScale[5] = rightBounds[1]; // Y
				this.viewportOffsetScale[6] = rightBounds[2]; // Width
				this.viewportOffsetScale[7] = rightBounds[3]; // Height
			};

			/**
			 * Performs distortion pass on the injected backbuffer, rendering it to the real
			 * backbuffer.
			 */
			CardboardDistorter.prototype.submitFrame = function () {
				var gl = this.gl;
				var self = this;

				var glState = [];

				if (!window.WebVRConfig.DIRTY_SUBMIT_FRAME_BINDINGS) {
					glState.push(
						gl.CURRENT_PROGRAM,
						gl.ARRAY_BUFFER_BINDING,
						gl.ELEMENT_ARRAY_BUFFER_BINDING,
						gl.TEXTURE_BINDING_2D, gl.TEXTURE0
					);
				}

				WGLUPreserveGLState(gl, glState, function (gl) {
					// Bind the real default framebuffer
					self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, null);

					// Make sure the GL state is in a good place
					if (self.cullFace) { self.realDisable.call(gl, gl.CULL_FACE); }
					if (self.depthTest) { self.realDisable.call(gl, gl.DEPTH_TEST); }
					if (self.blend) { self.realDisable.call(gl, gl.BLEND); }
					if (self.scissorTest) { self.realDisable.call(gl, gl.SCISSOR_TEST); }
					if (self.stencilTest) { self.realDisable.call(gl, gl.STENCIL_TEST); }
					self.realColorMask.call(gl, true, true, true, true);
					self.realViewport.call(gl, 0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

					// If the backbuffer has an alpha channel clear every frame so the page
					// doesn't show through.
					if (self.ctxAttribs.alpha || Util.isIOS()) {
						self.realClearColor.call(gl, 0, 0, 0, 1);
						gl.clear(gl.COLOR_BUFFER_BIT);
					}

					// Bind distortion program and mesh
					gl.useProgram(self.program);

					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, self.indexBuffer);

					gl.bindBuffer(gl.ARRAY_BUFFER, self.vertexBuffer);
					gl.enableVertexAttribArray(self.attribs.position);
					gl.enableVertexAttribArray(self.attribs.texCoord);
					gl.vertexAttribPointer(self.attribs.position, 2, gl.FLOAT, false, 20, 0);
					gl.vertexAttribPointer(self.attribs.texCoord, 3, gl.FLOAT, false, 20, 8);

					gl.activeTexture(gl.TEXTURE0);
					gl.uniform1i(self.uniforms.diffuse, 0);
					gl.bindTexture(gl.TEXTURE_2D, self.renderTarget);

					gl.uniform4fv(self.uniforms.viewportOffsetScale, self.viewportOffsetScale);

					// Draws both eyes
					gl.drawElements(gl.TRIANGLES, self.indexCount, gl.UNSIGNED_SHORT, 0);

					if (self.cardboardUI) {
						self.cardboardUI.renderNoState();
					}

					// Bind the fake default framebuffer again
					self.realBindFramebuffer.call(self.gl, gl.FRAMEBUFFER, self.framebuffer);

					// If preserveDrawingBuffer == false clear the framebuffer
					if (!self.ctxAttribs.preserveDrawingBuffer) {
						self.realClearColor.call(gl, 0, 0, 0, 0);
						gl.clear(gl.COLOR_BUFFER_BIT);
					}

					if (!window.WebVRConfig.DIRTY_SUBMIT_FRAME_BINDINGS) {
						self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, self.lastBoundFramebuffer);
					}

					// Restore state
					if (self.cullFace) { self.realEnable.call(gl, gl.CULL_FACE); }
					if (self.depthTest) { self.realEnable.call(gl, gl.DEPTH_TEST); }
					if (self.blend) { self.realEnable.call(gl, gl.BLEND); }
					if (self.scissorTest) { self.realEnable.call(gl, gl.SCISSOR_TEST); }
					if (self.stencilTest) { self.realEnable.call(gl, gl.STENCIL_TEST); }

					self.realColorMask.apply(gl, self.colorMask);
					self.realViewport.apply(gl, self.viewport);
					if (self.ctxAttribs.alpha || !self.ctxAttribs.preserveDrawingBuffer) {
						self.realClearColor.apply(gl, self.clearColor);
					}
				});

				// Workaround for the fact that Safari doesn't allow us to patch the canvas
				// width and height correctly. After each submit frame check to see what the
				// real backbuffer size has been set to and resize the fake backbuffer size
				// to match.
				if (Util.isIOS()) {
					var canvas = gl.canvas;
					if (canvas.width != self.bufferWidth || canvas.height != self.bufferHeight) {
						self.bufferWidth = canvas.width;
						self.bufferHeight = canvas.height;
						self.onResize();
					}
				}
			};

			/**
			 * Call when the deviceInfo has changed. At this point we need
			 * to re-calculate the distortion mesh.
			 */
			CardboardDistorter.prototype.updateDeviceInfo = function (deviceInfo) {
				var gl = this.gl;
				var self = this;

				var glState = [gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING];
				WGLUPreserveGLState(gl, glState, function (gl) {
					var vertices = self.computeMeshVertices_(self.meshWidth, self.meshHeight, deviceInfo);
					gl.bindBuffer(gl.ARRAY_BUFFER, self.vertexBuffer);
					gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

					// Indices don't change based on device parameters, so only compute once.
					if (!self.indexCount) {
						var indices = self.computeMeshIndices_(self.meshWidth, self.meshHeight);
						gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, self.indexBuffer);
						gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
						self.indexCount = indices.length;
					}
				});
			};

			/**
			 * Build the distortion mesh vertices.
			 * Based on code from the Unity cardboard plugin.
			 */
			CardboardDistorter.prototype.computeMeshVertices_ = function (width, height, deviceInfo) {
				var vertices = new Float32Array(2 * width * height * 5);

				var lensFrustum = deviceInfo.getLeftEyeVisibleTanAngles();
				var noLensFrustum = deviceInfo.getLeftEyeNoLensTanAngles();
				var viewport = deviceInfo.getLeftEyeVisibleScreenRect(noLensFrustum);
				var vidx = 0;
				var iidx = 0;
				for (var e = 0; e < 2; e++) {
					for (var j = 0; j < height; j++) {
						for (var i = 0; i < width; i++ , vidx++) {
							var u = i / (width - 1);
							var v = j / (height - 1);

							// Grid points regularly spaced in StreoScreen, and barrel distorted in
							// the mesh.
							var s = u;
							var t = v;
							var x = Util.lerp(lensFrustum[0], lensFrustum[2], u);
							var y = Util.lerp(lensFrustum[3], lensFrustum[1], v);
							var d = Math.sqrt(x * x + y * y);
							var r = deviceInfo.distortion.distortInverse(d);
							var p = x * r / d;
							var q = y * r / d;
							u = (p - noLensFrustum[0]) / (noLensFrustum[2] - noLensFrustum[0]);
							v = (q - noLensFrustum[3]) / (noLensFrustum[1] - noLensFrustum[3]);

							// Convert u,v to mesh screen coordinates.
							var aspect = deviceInfo.device.widthMeters / deviceInfo.device.heightMeters;

							// FIXME: The original Unity plugin multiplied U by the aspect ratio
							// and didn't multiply either value by 2, but that seems to get it
							// really close to correct looking for me. I hate this kind of "Don't
							// know why it works" code though, and wold love a more logical
							// explanation of what needs to happen here.
							u = (viewport.x + u * viewport.width - 0.5) * 2.0; //* aspect;
							v = (viewport.y + v * viewport.height - 0.5) * 2.0;

							vertices[(vidx * 5) + 0] = u; // position.x
							vertices[(vidx * 5) + 1] = v; // position.y
							vertices[(vidx * 5) + 2] = s; // texCoord.x
							vertices[(vidx * 5) + 3] = t; // texCoord.y
							vertices[(vidx * 5) + 4] = e; // texCoord.z (viewport index)
						}
					}
					var w = lensFrustum[2] - lensFrustum[0];
					lensFrustum[0] = -(w + lensFrustum[0]);
					lensFrustum[2] = w - lensFrustum[2];
					w = noLensFrustum[2] - noLensFrustum[0];
					noLensFrustum[0] = -(w + noLensFrustum[0]);
					noLensFrustum[2] = w - noLensFrustum[2];
					viewport.x = 1 - (viewport.x + viewport.width);
				}
				return vertices;
			}

			/**
			 * Build the distortion mesh indices.
			 * Based on code from the Unity cardboard plugin.
			 */
			CardboardDistorter.prototype.computeMeshIndices_ = function (width, height) {
				var indices = new Uint16Array(2 * (width - 1) * (height - 1) * 6);
				var halfwidth = width / 2;
				var halfheight = height / 2;
				var vidx = 0;
				var iidx = 0;
				for (var e = 0; e < 2; e++) {
					for (var j = 0; j < height; j++) {
						for (var i = 0; i < width; i++ , vidx++) {
							if (i == 0 || j == 0)
								continue;
							// Build a quad.  Lower right and upper left quadrants have quads with
							// the triangle diagonal flipped to get the vignette to interpolate
							// correctly.
							if ((i <= halfwidth) == (j <= halfheight)) {
								// Quad diagonal lower left to upper right.
								indices[iidx++] = vidx;
								indices[iidx++] = vidx - width - 1;
								indices[iidx++] = vidx - width;
								indices[iidx++] = vidx - width - 1;
								indices[iidx++] = vidx;
								indices[iidx++] = vidx - 1;
							} else {
								// Quad diagonal upper left to lower right.
								indices[iidx++] = vidx - 1;
								indices[iidx++] = vidx - width;
								indices[iidx++] = vidx;
								indices[iidx++] = vidx - width;
								indices[iidx++] = vidx - 1;
								indices[iidx++] = vidx - width - 1;
							}
						}
					}
				}
				return indices;
			};

			CardboardDistorter.prototype.getOwnPropertyDescriptor_ = function (proto, attrName) {
				var descriptor = Object.getOwnPropertyDescriptor(proto, attrName);
				// In some cases (ahem... Safari), the descriptor returns undefined get and
				// set fields. In this case, we need to create a synthetic property
				// descriptor. This works around some of the issues in
				// https://github.com/borismus/webvr-polyfill/issues/46
				if (descriptor.get === undefined || descriptor.set === undefined) {
					descriptor.configurable = true;
					descriptor.enumerable = true;
					descriptor.get = function () {
						return this.getAttribute(attrName);
					};
					descriptor.set = function (val) {
						this.setAttribute(attrName, val);
					};
				}
				return descriptor;
			};

			module.exports = CardboardDistorter;


			/***/
}),
/* 11 */
/***/ (function (module, exports) {

			/**
			 * TODO(smus): Implement coefficient inversion.
			 */
			function Distortion(coefficients) {
				this.coefficients = coefficients;
			}

			/**
			 * Calculates the inverse distortion for a radius.
			 * </p><p>
			 * Allows to compute the original undistorted radius from a distorted one.
			 * See also getApproximateInverseDistortion() for a faster but potentially
			 * less accurate method.
			 *
			 * @param {Number} radius Distorted radius from the lens center in tan-angle units.
			 * @return {Number} The undistorted radius in tan-angle units.
			 */
			Distortion.prototype.distortInverse = function (radius) {
				// Secant method.
				var r0 = 0;
				var r1 = 1;
				var dr0 = radius - this.distort(r0);
				while (Math.abs(r1 - r0) > 0.0001 /** 0.1mm */) {
					var dr1 = radius - this.distort(r1);
					var r2 = r1 - dr1 * ((r1 - r0) / (dr1 - dr0));
					r0 = r1;
					r1 = r2;
					dr0 = dr1;
				}
				return r1;
			};

			/**
			 * Distorts a radius by its distortion factor from the center of the lenses.
			 *
			 * @param {Number} radius Radius from the lens center in tan-angle units.
			 * @return {Number} The distorted radius in tan-angle units.
			 */
			Distortion.prototype.distort = function (radius) {
				var r2 = radius * radius;
				var ret = 0;
				for (var i = 0; i < this.coefficients.length; i++) {
					ret = r2 * (ret + this.coefficients[i]);
				}
				return (ret + 1) * radius;
			};

			module.exports = Distortion;


			/***/
}),
/* 12 */
/***/ (function (module, exports, __webpack_require__) {

			/*
			 * Copyright 2015 Google Inc. All Rights Reserved.
			 * Licensed under the Apache License, Version 2.0 (the "License");
			 * you may not use this file except in compliance with the License.
			 * You may obtain a copy of the License at
			 *
			 *     http://www.apache.org/licenses/LICENSE-2.0
			 *
			 * Unless required by applicable law or agreed to in writing, software
			 * distributed under the License is distributed on an "AS IS" BASIS,
			 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
			 * See the License for the specific language governing permissions and
			 * limitations under the License.
			 */

			// Offline cache of the DPDB, to be used until we load the online one (and
			// as a fallback in case we can't load the online one).
			var DPDB_CACHE = __webpack_require__(13);
			var Util = __webpack_require__(0);

			// Online DPDB URL.
			var ONLINE_DPDB_URL =
				'https://dpdb.webvr.rocks/dpdb.json';

			/**
			 * Calculates device parameters based on the DPDB (Device Parameter Database).
			 * Initially, uses the cached DPDB values.
			 *
			 * If fetchOnline == true, then this object tries to fetch the online version
			 * of the DPDB and updates the device info if a better match is found.
			 * Calls the onDeviceParamsUpdated callback when there is an update to the
			 * device information.
			 */
			function Dpdb(fetchOnline, onDeviceParamsUpdated) {
				// Start with the offline DPDB cache while we are loading the real one.
				this.dpdb = DPDB_CACHE;

				// Calculate device params based on the offline version of the DPDB.
				this.recalculateDeviceParams_();

				// XHR to fetch online DPDB file, if requested.
				if (fetchOnline) {
					// Set the callback.
					this.onDeviceParamsUpdated = onDeviceParamsUpdated;

					var xhr = new XMLHttpRequest();
					var obj = this;
					xhr.open('GET', ONLINE_DPDB_URL, true);
					xhr.addEventListener('load', function () {
						obj.loading = false;
						if (xhr.status >= 200 && xhr.status <= 299) {
							// Success.
							obj.dpdb = JSON.parse(xhr.response);
							obj.recalculateDeviceParams_();
						} else {
							// Error loading the DPDB.
							console.error('Error loading online DPDB!');
						}
					});
					xhr.send();
				}
			}

			// Returns the current device parameters.
			Dpdb.prototype.getDeviceParams = function () {
				return this.deviceParams;
			};

			// Recalculates this device's parameters based on the DPDB.
			Dpdb.prototype.recalculateDeviceParams_ = function () {
				var newDeviceParams = this.calcDeviceParams_();
				if (newDeviceParams) {
					this.deviceParams = newDeviceParams;
					// Invoke callback, if it is set.
					if (this.onDeviceParamsUpdated) {
						this.onDeviceParamsUpdated(this.deviceParams);
					}
				} else {
					console.error('Failed to recalculate device parameters.');
				}
			};

			// Returns a DeviceParams object that represents the best guess as to this
			// device's parameters. Can return null if the device does not match any
			// known devices.
			Dpdb.prototype.calcDeviceParams_ = function () {
				var db = this.dpdb; // shorthand
				if (!db) {
					console.error('DPDB not available.');
					return null;
				}
				if (db.format != 1) {
					console.error('DPDB has unexpected format version.');
					return null;
				}
				if (!db.devices || !db.devices.length) {
					console.error('DPDB does not have a devices section.');
					return null;
				}

				// Get the actual user agent and screen dimensions in pixels.
				var userAgent = navigator.userAgent || navigator.vendor || window.opera;
				var width = Util.getScreenWidth();
				var height = Util.getScreenHeight();

				if (!db.devices) {
					console.error('DPDB has no devices section.');
					return null;
				}

				for (var i = 0; i < db.devices.length; i++) {
					var device = db.devices[i];
					if (!device.rules) {
						console.warn('Device[' + i + '] has no rules section.');
						continue;
					}

					if (device.type != 'ios' && device.type != 'android') {
						console.warn('Device[' + i + '] has invalid type.');
						continue;
					}

					// See if this device is of the appropriate type.
					if (Util.isIOS() != (device.type == 'ios')) continue;

					// See if this device matches any of the rules:
					var matched = false;
					for (var j = 0; j < device.rules.length; j++) {
						var rule = device.rules[j];
						if (this.matchRule_(rule, userAgent, width, height)) {
							matched = true;
							break;
						}
					}
					if (!matched) continue;

					// device.dpi might be an array of [ xdpi, ydpi] or just a scalar.
					var xdpi = device.dpi[0] || device.dpi;
					var ydpi = device.dpi[1] || device.dpi;

					return new DeviceParams({ xdpi: xdpi, ydpi: ydpi, bevelMm: device.bw });
				}

				console.warn('No DPDB device match.');
				return null;
			};

			Dpdb.prototype.matchRule_ = function (rule, ua, screenWidth, screenHeight) {
				// We can only match 'ua' and 'res' rules, not other types like 'mdmh'
				// (which are meant for native platforms).
				if (!rule.ua && !rule.res) return false;

				// If our user agent string doesn't contain the indicated user agent string,
				// the match fails.
				if (rule.ua && ua.indexOf(rule.ua) < 0) return false;

				// If the rule specifies screen dimensions that don't correspond to ours,
				// the match fails.
				if (rule.res) {
					if (!rule.res[0] || !rule.res[1]) return false;
					var resX = rule.res[0];
					var resY = rule.res[1];
					// Compare min and max so as to make the order not matter, i.e., it should
					// be true that 640x480 == 480x640.
					if (Math.min(screenWidth, screenHeight) != Math.min(resX, resY) ||
						(Math.max(screenWidth, screenHeight) != Math.max(resX, resY))) {
						return false;
					}
				}

				return true;
			}

			function DeviceParams(params) {
				this.xdpi = params.xdpi;
				this.ydpi = params.ydpi;
				this.bevelMm = params.bevelMm;
			}

			module.exports = Dpdb;


			/***/
}),
/* 13 */
/***/ (function (module, exports) {

			module.exports = { "format": 1, "last_updated": "2017-08-27T14:39:31Z", "devices": [{ "type": "android", "rules": [{ "mdmh": "asus/*/Nexus 7/*" }, { "ua": "Nexus 7" }], "dpi": [320.8, 323], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "asus/*/ASUS_Z00AD/*" }, { "ua": "ASUS_Z00AD" }], "dpi": [403, 404.6], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "Google/*/Pixel XL/*" }, { "ua": "Pixel XL" }], "dpi": [537.9, 533], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "Google/*/Pixel/*" }, { "ua": "Pixel" }], "dpi": [432.6, 436.7], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "HTC/*/HTC6435LVW/*" }, { "ua": "HTC6435LVW" }], "dpi": [449.7, 443.3], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "HTC/*/HTC One XL/*" }, { "ua": "HTC One XL" }], "dpi": [315.3, 314.6], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "htc/*/Nexus 9/*" }, { "ua": "Nexus 9" }], "dpi": 289, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "HTC/*/HTC One M9/*" }, { "ua": "HTC One M9" }], "dpi": [442.5, 443.3], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "HTC/*/HTC One_M8/*" }, { "ua": "HTC One_M8" }], "dpi": [449.7, 447.4], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "HTC/*/HTC One/*" }, { "ua": "HTC One" }], "dpi": 472.8, "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "Huawei/*/Nexus 6P/*" }, { "ua": "Nexus 6P" }], "dpi": [515.1, 518], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "LENOVO/*/Lenovo PB2-690Y/*" }, { "ua": "Lenovo PB2-690Y" }], "dpi": [457.2, 454.713], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/Nexus 5X/*" }, { "ua": "Nexus 5X" }], "dpi": [422, 419.9], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/LGMS345/*" }, { "ua": "LGMS345" }], "dpi": [221.7, 219.1], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/LG-D800/*" }, { "ua": "LG-D800" }], "dpi": [422, 424.1], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/LG-D850/*" }, { "ua": "LG-D850" }], "dpi": [537.9, 541.9], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/VS985 4G/*" }, { "ua": "VS985 4G" }], "dpi": [537.9, 535.6], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/Nexus 5/*" }, { "ua": "Nexus 5 B" }], "dpi": [442.4, 444.8], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/Nexus 4/*" }, { "ua": "Nexus 4" }], "dpi": [319.8, 318.4], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/LG-P769/*" }, { "ua": "LG-P769" }], "dpi": [240.6, 247.5], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/LGMS323/*" }, { "ua": "LGMS323" }], "dpi": [206.6, 204.6], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/LGLS996/*" }, { "ua": "LGLS996" }], "dpi": [403.4, 401.5], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "Micromax/*/4560MMX/*" }, { "ua": "4560MMX" }], "dpi": [240, 219.4], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "Micromax/*/A250/*" }, { "ua": "Micromax A250" }], "dpi": [480, 446.4], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "Micromax/*/Micromax AQ4501/*" }, { "ua": "Micromax AQ4501" }], "dpi": 240, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/DROID RAZR/*" }, { "ua": "DROID RAZR" }], "dpi": [368.1, 256.7], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT830C/*" }, { "ua": "XT830C" }], "dpi": [254, 255.9], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1021/*" }, { "ua": "XT1021" }], "dpi": [254, 256.7], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1023/*" }, { "ua": "XT1023" }], "dpi": [254, 256.7], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1028/*" }, { "ua": "XT1028" }], "dpi": [326.6, 327.6], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1034/*" }, { "ua": "XT1034" }], "dpi": [326.6, 328.4], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1053/*" }, { "ua": "XT1053" }], "dpi": [315.3, 316.1], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1562/*" }, { "ua": "XT1562" }], "dpi": [403.4, 402.7], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/Nexus 6/*" }, { "ua": "Nexus 6 B" }], "dpi": [494.3, 489.7], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1063/*" }, { "ua": "XT1063" }], "dpi": [295, 296.6], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1064/*" }, { "ua": "XT1064" }], "dpi": [295, 295.6], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1092/*" }, { "ua": "XT1092" }], "dpi": [422, 424.1], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1095/*" }, { "ua": "XT1095" }], "dpi": [422, 423.4], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/G4/*" }, { "ua": "Moto G (4)" }], "dpi": 401, "bw": 4, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/A0001/*" }, { "ua": "A0001" }], "dpi": [403.4, 401], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONE E1005/*" }, { "ua": "ONE E1005" }], "dpi": [442.4, 441.4], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONE A2005/*" }, { "ua": "ONE A2005" }], "dpi": [391.9, 405.4], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "OPPO/*/X909/*" }, { "ua": "X909" }], "dpi": [442.4, 444.1], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/GT-I9082/*" }, { "ua": "GT-I9082" }], "dpi": [184.7, 185.4], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G360P/*" }, { "ua": "SM-G360P" }], "dpi": [196.7, 205.4], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/Nexus S/*" }, { "ua": "Nexus S" }], "dpi": [234.5, 229.8], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/GT-I9300/*" }, { "ua": "GT-I9300" }], "dpi": [304.8, 303.9], "bw": 5, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-T230NU/*" }, { "ua": "SM-T230NU" }], "dpi": 216, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SGH-T399/*" }, { "ua": "SGH-T399" }], "dpi": [217.7, 231.4], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SGH-M919/*" }, { "ua": "SGH-M919" }], "dpi": [440.8, 437.7], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-N9005/*" }, { "ua": "SM-N9005" }], "dpi": [386.4, 387], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SAMSUNG-SM-N900A/*" }, { "ua": "SAMSUNG-SM-N900A" }], "dpi": [386.4, 387.7], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/GT-I9500/*" }, { "ua": "GT-I9500" }], "dpi": [442.5, 443.3], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/GT-I9505/*" }, { "ua": "GT-I9505" }], "dpi": 439.4, "bw": 4, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G900F/*" }, { "ua": "SM-G900F" }], "dpi": [415.6, 431.6], "bw": 5, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G900M/*" }, { "ua": "SM-G900M" }], "dpi": [415.6, 431.6], "bw": 5, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G800F/*" }, { "ua": "SM-G800F" }], "dpi": 326.8, "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G906S/*" }, { "ua": "SM-G906S" }], "dpi": [562.7, 572.4], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/GT-I9300/*" }, { "ua": "GT-I9300" }], "dpi": [306.7, 304.8], "bw": 5, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-T535/*" }, { "ua": "SM-T535" }], "dpi": [142.6, 136.4], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-N920C/*" }, { "ua": "SM-N920C" }], "dpi": [515.1, 518.4], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-N920W8/*" }, { "ua": "SM-N920W8" }], "dpi": [515.1, 518.4], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/GT-I9300I/*" }, { "ua": "GT-I9300I" }], "dpi": [304.8, 305.8], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/GT-I9195/*" }, { "ua": "GT-I9195" }], "dpi": [249.4, 256.7], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SPH-L520/*" }, { "ua": "SPH-L520" }], "dpi": [249.4, 255.9], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SAMSUNG-SGH-I717/*" }, { "ua": "SAMSUNG-SGH-I717" }], "dpi": 285.8, "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SPH-D710/*" }, { "ua": "SPH-D710" }], "dpi": [217.7, 204.2], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/GT-N7100/*" }, { "ua": "GT-N7100" }], "dpi": 265.1, "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SCH-I605/*" }, { "ua": "SCH-I605" }], "dpi": 265.1, "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/Galaxy Nexus/*" }, { "ua": "Galaxy Nexus" }], "dpi": [315.3, 314.2], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-N910H/*" }, { "ua": "SM-N910H" }], "dpi": [515.1, 518], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-N910C/*" }, { "ua": "SM-N910C" }], "dpi": [515.2, 520.2], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G130M/*" }, { "ua": "SM-G130M" }], "dpi": [165.9, 164.8], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G928I/*" }, { "ua": "SM-G928I" }], "dpi": [515.1, 518.4], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G920F/*" }, { "ua": "SM-G920F" }], "dpi": 580.6, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G920P/*" }, { "ua": "SM-G920P" }], "dpi": [522.5, 577], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G925F/*" }, { "ua": "SM-G925F" }], "dpi": 580.6, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G925V/*" }, { "ua": "SM-G925V" }], "dpi": [522.5, 576.6], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G930F/*" }, { "ua": "SM-G930F" }], "dpi": 576.6, "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G935F/*" }, { "ua": "SM-G935F" }], "dpi": 533, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G950F/*" }, { "ua": "SM-G950F" }], "dpi": [562.707, 565.293], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G955U/*" }, { "ua": "SM-G955U" }], "dpi": [522.514, 525.762], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "Sony/*/C6903/*" }, { "ua": "C6903" }], "dpi": [442.5, 443.3], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "Sony/*/D6653/*" }, { "ua": "D6653" }], "dpi": [428.6, 427.6], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "Sony/*/E6653/*" }, { "ua": "E6653" }], "dpi": [428.6, 425.7], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "Sony/*/E6853/*" }, { "ua": "E6853" }], "dpi": [403.4, 401.9], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "Sony/*/SGP321/*" }, { "ua": "SGP321" }], "dpi": [224.7, 224.1], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "TCT/*/ALCATEL ONE TOUCH Fierce/*" }, { "ua": "ALCATEL ONE TOUCH Fierce" }], "dpi": [240, 247.5], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "THL/*/thl 5000/*" }, { "ua": "thl 5000" }], "dpi": [480, 443.3], "bw": 3, "ac": 1000 }, { "type": "android", "rules": [{ "mdmh": "ZTE/*/ZTE Blade L2/*" }, { "ua": "ZTE Blade L2" }], "dpi": 240, "bw": 3, "ac": 500 }, { "type": "ios", "rules": [{ "res": [640, 960] }], "dpi": [325.1, 328.4], "bw": 4, "ac": 1000 }, { "type": "ios", "rules": [{ "res": [640, 1136] }], "dpi": [317.1, 320.2], "bw": 3, "ac": 1000 }, { "type": "ios", "rules": [{ "res": [750, 1334] }], "dpi": 326.4, "bw": 4, "ac": 1000 }, { "type": "ios", "rules": [{ "res": [1242, 2208] }], "dpi": [453.6, 458.4], "bw": 4, "ac": 1000 }, { "type": "ios", "rules": [{ "res": [1125, 2001] }], "dpi": [410.9, 415.4], "bw": 4, "ac": 1000 }] }

			/***/
}),
/* 14 */
/***/ (function (module, exports, __webpack_require__) {

			/*
			 * Copyright 2015 Google Inc. All Rights Reserved.
			 * Licensed under the Apache License, Version 2.0 (the "License");
			 * you may not use this file except in compliance with the License.
			 * You may obtain a copy of the License at
			 *
			 *     http://www.apache.org/licenses/LICENSE-2.0
			 *
			 * Unless required by applicable law or agreed to in writing, software
			 * distributed under the License is distributed on an "AS IS" BASIS,
			 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
			 * See the License for the specific language governing permissions and
			 * limitations under the License.
			 */
			var ComplementaryFilter = __webpack_require__(15);
			var PosePredictor = __webpack_require__(17);
			var TouchPanner = __webpack_require__(18);
			var MathUtil = __webpack_require__(2);
			var Util = __webpack_require__(0);

			/**
			 * The pose sensor, implemented using DeviceMotion APIs.
			 */
			function FusionPoseSensor() {
				this.deviceId = 'webvr-polyfill:fused';
				this.deviceName = 'VR Position Device (webvr-polyfill:fused)';

				this.accelerometer = new MathUtil.Vector3();
				this.gyroscope = new MathUtil.Vector3();

				this.start();

				this.filter = new ComplementaryFilter(window.WebVRConfig.K_FILTER);
				this.posePredictor = new PosePredictor(window.WebVRConfig.PREDICTION_TIME_S);
				this.touchPanner = new TouchPanner();

				this.filterToWorldQ = new MathUtil.Quaternion();

				// Set the filter to world transform, depending on OS.
				if (Util.isIOS()) {
					this.filterToWorldQ.setFromAxisAngle(new MathUtil.Vector3(1, 0, 0), Math.PI / 2);
				} else {
					this.filterToWorldQ.setFromAxisAngle(new MathUtil.Vector3(1, 0, 0), -Math.PI / 2);
				}

				this.inverseWorldToScreenQ = new MathUtil.Quaternion();
				this.worldToScreenQ = new MathUtil.Quaternion();
				this.originalPoseAdjustQ = new MathUtil.Quaternion();
				this.originalPoseAdjustQ.setFromAxisAngle(new MathUtil.Vector3(0, 0, 1),
					-window.orientation * Math.PI / 180);

				this.setScreenTransform_();
				// Adjust this filter for being in landscape mode.
				if (Util.isLandscapeMode()) {
					this.filterToWorldQ.multiply(this.inverseWorldToScreenQ);
				}

				// Keep track of a reset transform for resetSensor.
				this.resetQ = new MathUtil.Quaternion();

				this.isFirefoxAndroid = Util.isFirefoxAndroid();
				this.isIOS = Util.isIOS();

				this.orientationOut_ = new Float32Array(4);
			}

			FusionPoseSensor.prototype.getPosition = function () {
				// This PoseSensor doesn't support position
				return null;
			};

			FusionPoseSensor.prototype.getOrientation = function () {
				// Convert from filter space to the the same system used by the
				// deviceorientation event.
				var orientation = this.filter.getOrientation();

				// Predict orientation.
				this.predictedQ = this.posePredictor.getPrediction(orientation, this.gyroscope, this.previousTimestampS);

				// Convert to THREE coordinate system: -Z forward, Y up, X right.
				var out = new MathUtil.Quaternion();
				out.copy(this.filterToWorldQ);
				out.multiply(this.resetQ);
				if (!window.WebVRConfig.TOUCH_PANNER_DISABLED) {
					out.multiply(this.touchPanner.getOrientation());
				}
				out.multiply(this.predictedQ);
				out.multiply(this.worldToScreenQ);

				// Handle the yaw-only case.
				if (window.WebVRConfig.YAW_ONLY) {
					// Make a quaternion that only turns around the Y-axis.
					out.x = 0;
					out.z = 0;
					out.normalize();
				}

				this.orientationOut_[0] = out.x;
				this.orientationOut_[1] = out.y;
				this.orientationOut_[2] = out.z;
				this.orientationOut_[3] = out.w;
				return this.orientationOut_;
			};

			FusionPoseSensor.prototype.resetPose = function () {
				// Reduce to inverted yaw-only.
				this.resetQ.copy(this.filter.getOrientation());
				this.resetQ.x = 0;
				this.resetQ.y = 0;
				this.resetQ.z *= -1;
				this.resetQ.normalize();

				// Take into account extra transformations in landscape mode.
				if (Util.isLandscapeMode()) {
					this.resetQ.multiply(this.inverseWorldToScreenQ);
				}

				// Take into account original pose.
				this.resetQ.multiply(this.originalPoseAdjustQ);

				if (!window.WebVRConfig.TOUCH_PANNER_DISABLED) {
					this.touchPanner.resetSensor();
				}
			};

			FusionPoseSensor.prototype.onDeviceMotion_ = function (deviceMotion) {
				this.updateDeviceMotion_(deviceMotion);
			};

			FusionPoseSensor.prototype.updateDeviceMotion_ = function (deviceMotion) {
				var accGravity = deviceMotion.accelerationIncludingGravity;
				var rotRate = deviceMotion.rotationRate;
				var timestampS = deviceMotion.timeStamp / 1000;

				var deltaS = timestampS - this.previousTimestampS;
				if (deltaS <= Util.MIN_TIMESTEP || deltaS > Util.MAX_TIMESTEP) {
					console.warn('Invalid timestamps detected. Time step between successive ' +
						'gyroscope sensor samples is very small or not monotonic');
					this.previousTimestampS = timestampS;
					return;
				}

				this.accelerometer.set(-accGravity.x, -accGravity.y, -accGravity.z);
				if (Util.isR7()) {
					this.gyroscope.set(-rotRate.beta, rotRate.alpha, rotRate.gamma);
				} else {
					this.gyroscope.set(rotRate.alpha, rotRate.beta, rotRate.gamma);
				}

				// With iOS and Firefox Android, rotationRate is reported in degrees,
				// so we first convert to radians.
				if (this.isIOS || this.isFirefoxAndroid) {
					this.gyroscope.multiplyScalar(Math.PI / 180);
				}

				this.filter.addAccelMeasurement(this.accelerometer, timestampS);
				this.filter.addGyroMeasurement(this.gyroscope, timestampS);

				this.previousTimestampS = timestampS;
			};

			FusionPoseSensor.prototype.onOrientationChange_ = function (screenOrientation) {
				this.setScreenTransform_();
			};

			/**
			 * This is only needed if we are in an cross origin iframe on iOS to work around
			 * this issue: https://bugs.webkit.org/show_bug.cgi?id=152299.
			 */
			FusionPoseSensor.prototype.onMessage_ = function (event) {
				var message = event.data;

				// If there's no message type, ignore it.
				if (!message || !message.type) {
					return;
				}

				// Ignore all messages that aren't devicemotion.
				var type = message.type.toLowerCase();
				if (type !== 'devicemotion') {
					return;
				}

				// Update device motion.
				this.updateDeviceMotion_(message.deviceMotionEvent);
			};

			FusionPoseSensor.prototype.setScreenTransform_ = function () {
				this.worldToScreenQ.set(0, 0, 0, 1);
				switch (window.orientation) {
					case 0:
						break;
					case 90:
						this.worldToScreenQ.setFromAxisAngle(new MathUtil.Vector3(0, 0, 1), -Math.PI / 2);
						break;
					case -90:
						this.worldToScreenQ.setFromAxisAngle(new MathUtil.Vector3(0, 0, 1), Math.PI / 2);
						break;
					case 180:
						// TODO.
						break;
				}
				this.inverseWorldToScreenQ.copy(this.worldToScreenQ);
				this.inverseWorldToScreenQ.inverse();
			};

			FusionPoseSensor.prototype.start = function () {
				this.onDeviceMotionCallback_ = this.onDeviceMotion_.bind(this);
				this.onOrientationChangeCallback_ = this.onOrientationChange_.bind(this);
				this.onMessageCallback_ = this.onMessage_.bind(this);

				// Only listen for postMessages if we're in an iOS and embedded inside a cross
				// domain IFrame. In this case, the polyfill can still work if the containing
				// page sends synthetic devicemotion events. For an example of this, see
				// iframe-message-sender.js in VR View: https://goo.gl/XDtvFZ
				if (Util.isIOS() && Util.isInsideCrossDomainIFrame()) {
					window.addEventListener('message', this.onMessageCallback_);
				}
				window.addEventListener('orientationchange', this.onOrientationChangeCallback_);
				window.addEventListener('devicemotion', this.onDeviceMotionCallback_);
			};

			FusionPoseSensor.prototype.stop = function () {
				window.removeEventListener('devicemotion', this.onDeviceMotionCallback_);
				window.removeEventListener('orientationchange', this.onOrientationChangeCallback_);
				window.removeEventListener('message', this.onMessageCallback_);
			};

			module.exports = FusionPoseSensor;


			/***/
}),
/* 15 */
/***/ (function (module, exports, __webpack_require__) {

			/*
			 * Copyright 2015 Google Inc. All Rights Reserved.
			 * Licensed under the Apache License, Version 2.0 (the "License");
			 * you may not use this file except in compliance with the License.
			 * You may obtain a copy of the License at
			 *
			 *     http://www.apache.org/licenses/LICENSE-2.0
			 *
			 * Unless required by applicable law or agreed to in writing, software
			 * distributed under the License is distributed on an "AS IS" BASIS,
			 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
			 * See the License for the specific language governing permissions and
			 * limitations under the License.
			 */

			var SensorSample = __webpack_require__(16);
			var MathUtil = __webpack_require__(2);
			var Util = __webpack_require__(0);

			/**
			 * An implementation of a simple complementary filter, which fuses gyroscope and
			 * accelerometer data from the 'devicemotion' event.
			 *
			 * Accelerometer data is very noisy, but stable over the long term.
			 * Gyroscope data is smooth, but tends to drift over the long term.
			 *
			 * This fusion is relatively simple:
			 * 1. Get orientation estimates from accelerometer by applying a low-pass filter
			 *    on that data.
			 * 2. Get orientation estimates from gyroscope by integrating over time.
			 * 3. Combine the two estimates, weighing (1) in the long term, but (2) for the
			 *    short term.
			 */
			function ComplementaryFilter(kFilter) {
				this.kFilter = kFilter;

				// Raw sensor measurements.
				this.currentAccelMeasurement = new SensorSample();
				this.currentGyroMeasurement = new SensorSample();
				this.previousGyroMeasurement = new SensorSample();

				// Set default look direction to be in the correct direction.
				if (Util.isIOS()) {
					this.filterQ = new MathUtil.Quaternion(-1, 0, 0, 1);
				} else {
					this.filterQ = new MathUtil.Quaternion(1, 0, 0, 1);
				}
				this.previousFilterQ = new MathUtil.Quaternion();
				this.previousFilterQ.copy(this.filterQ);

				// Orientation based on the accelerometer.
				this.accelQ = new MathUtil.Quaternion();
				// Whether or not the orientation has been initialized.
				this.isOrientationInitialized = false;
				// Running estimate of gravity based on the current orientation.
				this.estimatedGravity = new MathUtil.Vector3();
				// Measured gravity based on accelerometer.
				this.measuredGravity = new MathUtil.Vector3();

				// Debug only quaternion of gyro-based orientation.
				this.gyroIntegralQ = new MathUtil.Quaternion();
			}

			ComplementaryFilter.prototype.addAccelMeasurement = function (vector, timestampS) {
				this.currentAccelMeasurement.set(vector, timestampS);
			};

			ComplementaryFilter.prototype.addGyroMeasurement = function (vector, timestampS) {
				this.currentGyroMeasurement.set(vector, timestampS);

				var deltaT = timestampS - this.previousGyroMeasurement.timestampS;
				if (Util.isTimestampDeltaValid(deltaT)) {
					this.run_();
				}

				this.previousGyroMeasurement.copy(this.currentGyroMeasurement);
			};

			ComplementaryFilter.prototype.run_ = function () {

				if (!this.isOrientationInitialized) {
					this.accelQ = this.accelToQuaternion_(this.currentAccelMeasurement.sample);
					this.previousFilterQ.copy(this.accelQ);
					this.isOrientationInitialized = true;
					return;
				}

				var deltaT = this.currentGyroMeasurement.timestampS -
					this.previousGyroMeasurement.timestampS;

				// Convert gyro rotation vector to a quaternion delta.
				var gyroDeltaQ = this.gyroToQuaternionDelta_(this.currentGyroMeasurement.sample, deltaT);
				this.gyroIntegralQ.multiply(gyroDeltaQ);

				// filter_1 = K * (filter_0 + gyro * dT) + (1 - K) * accel.
				this.filterQ.copy(this.previousFilterQ);
				this.filterQ.multiply(gyroDeltaQ);

				// Calculate the delta between the current estimated gravity and the real
				// gravity vector from accelerometer.
				var invFilterQ = new MathUtil.Quaternion();
				invFilterQ.copy(this.filterQ);
				invFilterQ.inverse();

				this.estimatedGravity.set(0, 0, -1);
				this.estimatedGravity.applyQuaternion(invFilterQ);
				this.estimatedGravity.normalize();

				this.measuredGravity.copy(this.currentAccelMeasurement.sample);
				this.measuredGravity.normalize();

				// Compare estimated gravity with measured gravity, get the delta quaternion
				// between the two.
				var deltaQ = new MathUtil.Quaternion();
				deltaQ.setFromUnitVectors(this.estimatedGravity, this.measuredGravity);
				deltaQ.inverse();

				if (Util.isDebug()) {
					console.log('Delta: %d deg, G_est: (%s, %s, %s), G_meas: (%s, %s, %s)',
						MathUtil.radToDeg * Util.getQuaternionAngle(deltaQ),
						(this.estimatedGravity.x).toFixed(1),
						(this.estimatedGravity.y).toFixed(1),
						(this.estimatedGravity.z).toFixed(1),
						(this.measuredGravity.x).toFixed(1),
						(this.measuredGravity.y).toFixed(1),
						(this.measuredGravity.z).toFixed(1));
				}

				// Calculate the SLERP target: current orientation plus the measured-estimated
				// quaternion delta.
				var targetQ = new MathUtil.Quaternion();
				targetQ.copy(this.filterQ);
				targetQ.multiply(deltaQ);

				// SLERP factor: 0 is pure gyro, 1 is pure accel.
				this.filterQ.slerp(targetQ, 1 - this.kFilter);

				this.previousFilterQ.copy(this.filterQ);
			};

			ComplementaryFilter.prototype.getOrientation = function () {
				return this.filterQ;
			};

			ComplementaryFilter.prototype.accelToQuaternion_ = function (accel) {
				var normAccel = new MathUtil.Vector3();
				normAccel.copy(accel);
				normAccel.normalize();
				var quat = new MathUtil.Quaternion();
				quat.setFromUnitVectors(new MathUtil.Vector3(0, 0, -1), normAccel);
				quat.inverse();
				return quat;
			};

			ComplementaryFilter.prototype.gyroToQuaternionDelta_ = function (gyro, dt) {
				// Extract axis and angle from the gyroscope data.
				var quat = new MathUtil.Quaternion();
				var axis = new MathUtil.Vector3();
				axis.copy(gyro);
				axis.normalize();
				quat.setFromAxisAngle(axis, gyro.length() * dt);
				return quat;
			};


			module.exports = ComplementaryFilter;


			/***/
}),
/* 16 */
/***/ (function (module, exports) {

			function SensorSample(sample, timestampS) {
				this.set(sample, timestampS);
			};

			SensorSample.prototype.set = function (sample, timestampS) {
				this.sample = sample;
				this.timestampS = timestampS;
			};

			SensorSample.prototype.copy = function (sensorSample) {
				this.set(sensorSample.sample, sensorSample.timestampS);
			};

			module.exports = SensorSample;


			/***/
}),
/* 17 */
/***/ (function (module, exports, __webpack_require__) {

			/*
			 * Copyright 2015 Google Inc. All Rights Reserved.
			 * Licensed under the Apache License, Version 2.0 (the "License");
			 * you may not use this file except in compliance with the License.
			 * You may obtain a copy of the License at
			 *
			 *     http://www.apache.org/licenses/LICENSE-2.0
			 *
			 * Unless required by applicable law or agreed to in writing, software
			 * distributed under the License is distributed on an "AS IS" BASIS,
			 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
			 * See the License for the specific language governing permissions and
			 * limitations under the License.
			 */
			var MathUtil = __webpack_require__(2);
			var Util = __webpack_require__(0);

			/**
			 * Given an orientation and the gyroscope data, predicts the future orientation
			 * of the head. This makes rendering appear faster.
			 *
			 * Also see: http://msl.cs.uiuc.edu/~lavalle/papers/LavYerKatAnt14.pdf
			 *
			 * @param {Number} predictionTimeS time from head movement to the appearance of
			 * the corresponding image.
			 */
			function PosePredictor(predictionTimeS) {
				this.predictionTimeS = predictionTimeS;

				// The quaternion corresponding to the previous state.
				this.previousQ = new MathUtil.Quaternion();
				// Previous time a prediction occurred.
				this.previousTimestampS = null;

				// The delta quaternion that adjusts the current pose.
				this.deltaQ = new MathUtil.Quaternion();
				// The output quaternion.
				this.outQ = new MathUtil.Quaternion();
			}

			PosePredictor.prototype.getPrediction = function (currentQ, gyro, timestampS) {
				if (!this.previousTimestampS) {
					this.previousQ.copy(currentQ);
					this.previousTimestampS = timestampS;
					return currentQ;
				}

				// Calculate axis and angle based on gyroscope rotation rate data.
				var axis = new MathUtil.Vector3();
				axis.copy(gyro);
				axis.normalize();

				var angularSpeed = gyro.length();

				// If we're rotating slowly, don't do prediction.
				if (angularSpeed < MathUtil.degToRad * 20) {
					if (Util.isDebug()) {
						console.log('Moving slowly, at %s deg/s: no prediction',
							(MathUtil.radToDeg * angularSpeed).toFixed(1));
					}
					this.outQ.copy(currentQ);
					this.previousQ.copy(currentQ);
					return this.outQ;
				}

				// Get the predicted angle based on the time delta and latency.
				var deltaT = timestampS - this.previousTimestampS;
				var predictAngle = angularSpeed * this.predictionTimeS;

				this.deltaQ.setFromAxisAngle(axis, predictAngle);
				this.outQ.copy(this.previousQ);
				this.outQ.multiply(this.deltaQ);

				this.previousQ.copy(currentQ);
				this.previousTimestampS = timestampS;

				return this.outQ;
			};


			module.exports = PosePredictor;


			/***/
}),
/* 18 */
/***/ (function (module, exports, __webpack_require__) {

			/*
			 * Copyright 2015 Google Inc. All Rights Reserved.
			 * Licensed under the Apache License, Version 2.0 (the "License");
			 * you may not use this file except in compliance with the License.
			 * You may obtain a copy of the License at
			 *
			 *     http://www.apache.org/licenses/LICENSE-2.0
			 *
			 * Unless required by applicable law or agreed to in writing, software
			 * distributed under the License is distributed on an "AS IS" BASIS,
			 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
			 * See the License for the specific language governing permissions and
			 * limitations under the License.
			 */
			var MathUtil = __webpack_require__(2);
			var Util = __webpack_require__(0);

			var ROTATE_SPEED = 0.5;
			/**
			 * Provides a quaternion responsible for pre-panning the scene before further
			 * transformations due to device sensors.
			 */
			function TouchPanner() {
				window.addEventListener('touchstart', this.onTouchStart_.bind(this));
				window.addEventListener('touchmove', this.onTouchMove_.bind(this));
				window.addEventListener('touchend', this.onTouchEnd_.bind(this));

				this.isTouching = false;
				this.rotateStart = new MathUtil.Vector2();
				this.rotateEnd = new MathUtil.Vector2();
				this.rotateDelta = new MathUtil.Vector2();

				this.theta = 0;
				this.orientation = new MathUtil.Quaternion();
			}

			TouchPanner.prototype.getOrientation = function () {
				this.orientation.setFromEulerXYZ(0, 0, this.theta);
				return this.orientation;
			};

			TouchPanner.prototype.resetSensor = function () {
				this.theta = 0;
			};

			TouchPanner.prototype.onTouchStart_ = function (e) {
				// Only respond if there is exactly one touch.
				// Note that the Daydream controller passes in a `touchstart` event with
				// no `touches` property, so we must check for that case too.
				if (!e.touches || e.touches.length != 1) {
					return;
				}
				this.rotateStart.set(e.touches[0].pageX, e.touches[0].pageY);
				this.isTouching = true;
			};

			TouchPanner.prototype.onTouchMove_ = function (e) {
				if (!this.isTouching) {
					return;
				}
				this.rotateEnd.set(e.touches[0].pageX, e.touches[0].pageY);
				this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart);
				this.rotateStart.copy(this.rotateEnd);

				// On iOS, direction is inverted.
				if (Util.isIOS()) {
					this.rotateDelta.x *= -1;
				}

				var element = document.body;
				this.theta += 2 * Math.PI * this.rotateDelta.x / element.clientWidth * ROTATE_SPEED;
			};

			TouchPanner.prototype.onTouchEnd_ = function (e) {
				this.isTouching = false;
			};

			module.exports = TouchPanner;


			/***/
}),
/* 19 */
/***/ (function (module, exports, __webpack_require__) {

			/*
			 * Copyright 2015 Google Inc. All Rights Reserved.
			 * Licensed under the Apache License, Version 2.0 (the "License");
			 * you may not use this file except in compliance with the License.
			 * You may obtain a copy of the License at
			 *
			 *     http://www.apache.org/licenses/LICENSE-2.0
			 *
			 * Unless required by applicable law or agreed to in writing, software
			 * distributed under the License is distributed on an "AS IS" BASIS,
			 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
			 * See the License for the specific language governing permissions and
			 * limitations under the License.
			 */

			var Util = __webpack_require__(0);

			function RotateInstructions() {
				this.loadIcon_();

				var overlay = document.createElement('div');
				var s = overlay.style;
				s.position = 'fixed';
				s.top = 0;
				s.right = 0;
				s.bottom = 0;
				s.left = 0;
				s.backgroundColor = 'gray';
				s.fontFamily = 'sans-serif';
				// Force this to be above the fullscreen canvas, which is at zIndex: 999999.
				s.zIndex = 1000000;

				var img = document.createElement('img');
				img.src = this.icon;
				var s = img.style;
				s.marginLeft = '25%';
				s.marginTop = '25%';
				s.width = '50%';
				overlay.appendChild(img);

				var text = document.createElement('div');
				var s = text.style;
				s.textAlign = 'center';
				s.fontSize = '16px';
				s.lineHeight = '24px';
				s.margin = '24px 25%';
				s.width = '50%';
				text.innerHTML = 'Place your phone into your Cardboard viewer.';
				overlay.appendChild(text);

				var snackbar = document.createElement('div');
				var s = snackbar.style;
				s.backgroundColor = '#CFD8DC';
				s.position = 'fixed';
				s.bottom = 0;
				s.width = '100%';
				s.height = '48px';
				s.padding = '14px 24px';
				s.boxSizing = 'border-box';
				s.color = '#656A6B';
				overlay.appendChild(snackbar);

				var snackbarText = document.createElement('div');
				snackbarText.style.float = 'left';
				snackbarText.innerHTML = 'No Cardboard viewer?';

				var snackbarButton = document.createElement('a');
				snackbarButton.href = 'https://www.google.com/get/cardboard/get-cardboard/';
				snackbarButton.innerHTML = 'get one';
				snackbarButton.target = '_blank';
				var s = snackbarButton.style;
				s.float = 'right';
				s.fontWeight = 600;
				s.textTransform = 'uppercase';
				s.borderLeft = '1px solid gray';
				s.paddingLeft = '24px';
				s.textDecoration = 'none';
				s.color = '#656A6B';

				snackbar.appendChild(snackbarText);
				snackbar.appendChild(snackbarButton);

				this.overlay = overlay;
				this.text = text;

				this.hide();
			}

			RotateInstructions.prototype.show = function (parent) {
				if (!parent && !this.overlay.parentElement) {
					document.body.appendChild(this.overlay);
				} else if (parent) {
					if (this.overlay.parentElement && this.overlay.parentElement != parent)
						this.overlay.parentElement.removeChild(this.overlay);

					parent.appendChild(this.overlay);
				}

				this.overlay.style.display = 'block';

				var img = this.overlay.querySelector('img');
				var s = img.style;

				if (Util.isLandscapeMode()) {
					s.width = '20%';
					s.marginLeft = '40%';
					s.marginTop = '3%';
				} else {
					s.width = '50%';
					s.marginLeft = '25%';
					s.marginTop = '25%';
				}
			};

			RotateInstructions.prototype.hide = function () {
				this.overlay.style.display = 'none';
			};

			RotateInstructions.prototype.showTemporarily = function (ms, parent) {
				this.show(parent);
				this.timer = setTimeout(this.hide.bind(this), ms);
			};

			RotateInstructions.prototype.disableShowTemporarily = function () {
				clearTimeout(this.timer);
			};

			RotateInstructions.prototype.update = function () {
				this.disableShowTemporarily();
				// In portrait VR mode, tell the user to rotate to landscape. Otherwise, hide
				// the instructions.
				if (!Util.isLandscapeMode() && Util.isMobile()) {
					this.show();
				} else {
					this.hide();
				}
			};

			RotateInstructions.prototype.loadIcon_ = function () {
				// Encoded asset_src/rotate-instructions.svg
				this.icon = Util.base64('image/svg+xml', 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE5OHB4IiBoZWlnaHQ9IjI0MHB4IiB2aWV3Qm94PSIwIDAgMTk4IDI0MCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4bWxuczpza2V0Y2g9Imh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaC9ucyI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDMuMy4zICgxMjA4MSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+dHJhbnNpdGlvbjwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPjwvZGVmcz4KICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHNrZXRjaDp0eXBlPSJNU1BhZ2UiPgogICAgICAgIDxnIGlkPSJ0cmFuc2l0aW9uIiBza2V0Y2g6dHlwZT0iTVNBcnRib2FyZEdyb3VwIj4KICAgICAgICAgICAgPGcgaWQ9IkltcG9ydGVkLUxheWVycy1Db3B5LTQtKy1JbXBvcnRlZC1MYXllcnMtQ29weS0rLUltcG9ydGVkLUxheWVycy1Db3B5LTItQ29weSIgc2tldGNoOnR5cGU9Ik1TTGF5ZXJHcm91cCI+CiAgICAgICAgICAgICAgICA8ZyBpZD0iSW1wb3J0ZWQtTGF5ZXJzLUNvcHktNCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsIDEwNy4wMDAwMDApIiBza2V0Y2g6dHlwZT0iTVNTaGFwZUdyb3VwIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTQ5LjYyNSwyLjUyNyBDMTQ5LjYyNSwyLjUyNyAxNTUuODA1LDYuMDk2IDE1Ni4zNjIsNi40MTggTDE1Ni4zNjIsNy4zMDQgQzE1Ni4zNjIsNy40ODEgMTU2LjM3NSw3LjY2NCAxNTYuNCw3Ljg1MyBDMTU2LjQxLDcuOTM0IDE1Ni40Miw4LjAxNSAxNTYuNDI3LDguMDk1IEMxNTYuNTY3LDkuNTEgMTU3LjQwMSwxMS4wOTMgMTU4LjUzMiwxMi4wOTQgTDE2NC4yNTIsMTcuMTU2IEwxNjQuMzMzLDE3LjA2NiBDMTY0LjMzMywxNy4wNjYgMTY4LjcxNSwxNC41MzYgMTY5LjU2OCwxNC4wNDIgQzE3MS4wMjUsMTQuODgzIDE5NS41MzgsMjkuMDM1IDE5NS41MzgsMjkuMDM1IEwxOTUuNTM4LDgzLjAzNiBDMTk1LjUzOCw4My44MDcgMTk1LjE1Miw4NC4yNTMgMTk0LjU5LDg0LjI1MyBDMTk0LjM1Nyw4NC4yNTMgMTk0LjA5NSw4NC4xNzcgMTkzLjgxOCw4NC4wMTcgTDE2OS44NTEsNzAuMTc5IEwxNjkuODM3LDcwLjIwMyBMMTQyLjUxNSw4NS45NzggTDE0MS42NjUsODQuNjU1IEMxMzYuOTM0LDgzLjEyNiAxMzEuOTE3LDgxLjkxNSAxMjYuNzE0LDgxLjA0NSBDMTI2LjcwOSw4MS4wNiAxMjYuNzA3LDgxLjA2OSAxMjYuNzA3LDgxLjA2OSBMMTIxLjY0LDk4LjAzIEwxMTMuNzQ5LDEwMi41ODYgTDExMy43MTIsMTAyLjUyMyBMMTEzLjcxMiwxMzAuMTEzIEMxMTMuNzEyLDEzMC44ODUgMTEzLjMyNiwxMzEuMzMgMTEyLjc2NCwxMzEuMzMgQzExMi41MzIsMTMxLjMzIDExMi4yNjksMTMxLjI1NCAxMTEuOTkyLDEzMS4wOTQgTDY5LjUxOSwxMDYuNTcyIEM2OC41NjksMTA2LjAyMyA2Ny43OTksMTA0LjY5NSA2Ny43OTksMTAzLjYwNSBMNjcuNzk5LDEwMi41NyBMNjcuNzc4LDEwMi42MTcgQzY3LjI3LDEwMi4zOTMgNjYuNjQ4LDEwMi4yNDkgNjUuOTYyLDEwMi4yMTggQzY1Ljg3NSwxMDIuMjE0IDY1Ljc4OCwxMDIuMjEyIDY1LjcwMSwxMDIuMjEyIEM2NS42MDYsMTAyLjIxMiA2NS41MTEsMTAyLjIxNSA2NS40MTYsMTAyLjIxOSBDNjUuMTk1LDEwMi4yMjkgNjQuOTc0LDEwMi4yMzUgNjQuNzU0LDEwMi4yMzUgQzY0LjMzMSwxMDIuMjM1IDYzLjkxMSwxMDIuMjE2IDYzLjQ5OCwxMDIuMTc4IEM2MS44NDMsMTAyLjAyNSA2MC4yOTgsMTAxLjU3OCA1OS4wOTQsMTAwLjg4MiBMMTIuNTE4LDczLjk5MiBMMTIuNTIzLDc0LjAwNCBMMi4yNDUsNTUuMjU0IEMxLjI0NCw1My40MjcgMi4wMDQsNTEuMDM4IDMuOTQzLDQ5LjkxOCBMNTkuOTU0LDE3LjU3MyBDNjAuNjI2LDE3LjE4NSA2MS4zNSwxNy4wMDEgNjIuMDUzLDE3LjAwMSBDNjMuMzc5LDE3LjAwMSA2NC42MjUsMTcuNjYgNjUuMjgsMTguODU0IEw2NS4yODUsMTguODUxIEw2NS41MTIsMTkuMjY0IEw2NS41MDYsMTkuMjY4IEM2NS45MDksMjAuMDAzIDY2LjQwNSwyMC42OCA2Ni45ODMsMjEuMjg2IEw2Ny4yNiwyMS41NTYgQzY5LjE3NCwyMy40MDYgNzEuNzI4LDI0LjM1NyA3NC4zNzMsMjQuMzU3IEM3Ni4zMjIsMjQuMzU3IDc4LjMyMSwyMy44NCA4MC4xNDgsMjIuNzg1IEM4MC4xNjEsMjIuNzg1IDg3LjQ2NywxOC41NjYgODcuNDY3LDE4LjU2NiBDODguMTM5LDE4LjE3OCA4OC44NjMsMTcuOTk0IDg5LjU2NiwxNy45OTQgQzkwLjg5MiwxNy45OTQgOTIuMTM4LDE4LjY1MiA5Mi43OTIsMTkuODQ3IEw5Ni4wNDIsMjUuNzc1IEw5Ni4wNjQsMjUuNzU3IEwxMDIuODQ5LDI5LjY3NCBMMTAyLjc0NCwyOS40OTIgTDE0OS42MjUsMi41MjcgTTE0OS42MjUsMC44OTIgQzE0OS4zNDMsMC44OTIgMTQ5LjA2MiwwLjk2NSAxNDguODEsMS4xMSBMMTAyLjY0MSwyNy42NjYgTDk3LjIzMSwyNC41NDIgTDk0LjIyNiwxOS4wNjEgQzkzLjMxMywxNy4zOTQgOTEuNTI3LDE2LjM1OSA4OS41NjYsMTYuMzU4IEM4OC41NTUsMTYuMzU4IDg3LjU0NiwxNi42MzIgODYuNjQ5LDE3LjE1IEM4My44NzgsMTguNzUgNzkuNjg3LDIxLjE2OSA3OS4zNzQsMjEuMzQ1IEM3OS4zNTksMjEuMzUzIDc5LjM0NSwyMS4zNjEgNzkuMzMsMjEuMzY5IEM3Ny43OTgsMjIuMjU0IDc2LjA4NCwyMi43MjIgNzQuMzczLDIyLjcyMiBDNzIuMDgxLDIyLjcyMiA2OS45NTksMjEuODkgNjguMzk3LDIwLjM4IEw2OC4xNDUsMjAuMTM1IEM2Ny43MDYsMTkuNjcyIDY3LjMyMywxOS4xNTYgNjcuMDA2LDE4LjYwMSBDNjYuOTg4LDE4LjU1OSA2Ni45NjgsMTguNTE5IDY2Ljk0NiwxOC40NzkgTDY2LjcxOSwxOC4wNjUgQzY2LjY5LDE4LjAxMiA2Ni42NTgsMTcuOTYgNjYuNjI0LDE3LjkxMSBDNjUuNjg2LDE2LjMzNyA2My45NTEsMTUuMzY2IDYyLjA1MywxNS4zNjYgQzYxLjA0MiwxNS4zNjYgNjAuMDMzLDE1LjY0IDU5LjEzNiwxNi4xNTggTDMuMTI1LDQ4LjUwMiBDMC40MjYsNTAuMDYxIC0wLjYxMyw1My40NDIgMC44MTEsNTYuMDQgTDExLjA4OSw3NC43OSBDMTEuMjY2LDc1LjExMyAxMS41MzcsNzUuMzUzIDExLjg1LDc1LjQ5NCBMNTguMjc2LDEwMi4yOTggQzU5LjY3OSwxMDMuMTA4IDYxLjQzMywxMDMuNjMgNjMuMzQ4LDEwMy44MDYgQzYzLjgxMiwxMDMuODQ4IDY0LjI4NSwxMDMuODcgNjQuNzU0LDEwMy44NyBDNjUsMTAzLjg3IDY1LjI0OSwxMDMuODY0IDY1LjQ5NCwxMDMuODUyIEM2NS41NjMsMTAzLjg0OSA2NS42MzIsMTAzLjg0NyA2NS43MDEsMTAzLjg0NyBDNjUuNzY0LDEwMy44NDcgNjUuODI4LDEwMy44NDkgNjUuODksMTAzLjg1MiBDNjUuOTg2LDEwMy44NTYgNjYuMDgsMTAzLjg2MyA2Ni4xNzMsMTAzLjg3NCBDNjYuMjgyLDEwNS40NjcgNjcuMzMyLDEwNy4xOTcgNjguNzAyLDEwNy45ODggTDExMS4xNzQsMTMyLjUxIEMxMTEuNjk4LDEzMi44MTIgMTEyLjIzMiwxMzIuOTY1IDExMi43NjQsMTMyLjk2NSBDMTE0LjI2MSwxMzIuOTY1IDExNS4zNDcsMTMxLjc2NSAxMTUuMzQ3LDEzMC4xMTMgTDExNS4zNDcsMTAzLjU1MSBMMTIyLjQ1OCw5OS40NDYgQzEyMi44MTksOTkuMjM3IDEyMy4wODcsOTguODk4IDEyMy4yMDcsOTguNDk4IEwxMjcuODY1LDgyLjkwNSBDMTMyLjI3OSw4My43MDIgMTM2LjU1Nyw4NC43NTMgMTQwLjYwNyw4Ni4wMzMgTDE0MS4xNCw4Ni44NjIgQzE0MS40NTEsODcuMzQ2IDE0MS45NzcsODcuNjEzIDE0Mi41MTYsODcuNjEzIEMxNDIuNzk0LDg3LjYxMyAxNDMuMDc2LDg3LjU0MiAxNDMuMzMzLDg3LjM5MyBMMTY5Ljg2NSw3Mi4wNzYgTDE5Myw4NS40MzMgQzE5My41MjMsODUuNzM1IDE5NC4wNTgsODUuODg4IDE5NC41OSw4NS44ODggQzE5Ni4wODcsODUuODg4IDE5Ny4xNzMsODQuNjg5IDE5Ny4xNzMsODMuMDM2IEwxOTcuMTczLDI5LjAzNSBDMTk3LjE3MywyOC40NTEgMTk2Ljg2MSwyNy45MTEgMTk2LjM1NSwyNy42MTkgQzE5Ni4zNTUsMjcuNjE5IDE3MS44NDMsMTMuNDY3IDE3MC4zODUsMTIuNjI2IEMxNzAuMTMyLDEyLjQ4IDE2OS44NSwxMi40MDcgMTY5LjU2OCwxMi40MDcgQzE2OS4yODUsMTIuNDA3IDE2OS4wMDIsMTIuNDgxIDE2OC43NDksMTIuNjI3IEMxNjguMTQzLDEyLjk3OCAxNjUuNzU2LDE0LjM1NyAxNjQuNDI0LDE1LjEyNSBMMTU5LjYxNSwxMC44NyBDMTU4Ljc5NiwxMC4xNDUgMTU4LjE1NCw4LjkzNyAxNTguMDU0LDcuOTM0IEMxNTguMDQ1LDcuODM3IDE1OC4wMzQsNy43MzkgMTU4LjAyMSw3LjY0IEMxNTguMDA1LDcuNTIzIDE1Ny45OTgsNy40MSAxNTcuOTk4LDcuMzA0IEwxNTcuOTk4LDYuNDE4IEMxNTcuOTk4LDUuODM0IDE1Ny42ODYsNS4yOTUgMTU3LjE4MSw1LjAwMiBDMTU2LjYyNCw0LjY4IDE1MC40NDIsMS4xMTEgMTUwLjQ0MiwxLjExMSBDMTUwLjE4OSwwLjk2NSAxNDkuOTA3LDAuODkyIDE0OS42MjUsMC44OTIiIGlkPSJGaWxsLTEiIGZpbGw9IiM0NTVBNjQiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNOTYuMDI3LDI1LjYzNiBMMTQyLjYwMyw1Mi41MjcgQzE0My44MDcsNTMuMjIyIDE0NC41ODIsNTQuMTE0IDE0NC44NDUsNTUuMDY4IEwxNDQuODM1LDU1LjA3NSBMNjMuNDYxLDEwMi4wNTcgTDYzLjQ2LDEwMi4wNTcgQzYxLjgwNiwxMDEuOTA1IDYwLjI2MSwxMDEuNDU3IDU5LjA1NywxMDAuNzYyIEwxMi40ODEsNzMuODcxIEw5Ni4wMjcsMjUuNjM2IiBpZD0iRmlsbC0yIiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTYzLjQ2MSwxMDIuMTc0IEM2My40NTMsMTAyLjE3NCA2My40NDYsMTAyLjE3NCA2My40MzksMTAyLjE3MiBDNjEuNzQ2LDEwMi4wMTYgNjAuMjExLDEwMS41NjMgNTguOTk4LDEwMC44NjMgTDEyLjQyMiw3My45NzMgQzEyLjM4Niw3My45NTIgMTIuMzY0LDczLjkxNCAxMi4zNjQsNzMuODcxIEMxMi4zNjQsNzMuODMgMTIuMzg2LDczLjc5MSAxMi40MjIsNzMuNzcgTDk1Ljk2OCwyNS41MzUgQzk2LjAwNCwyNS41MTQgOTYuMDQ5LDI1LjUxNCA5Ni4wODUsMjUuNTM1IEwxNDIuNjYxLDUyLjQyNiBDMTQzLjg4OCw1My4xMzQgMTQ0LjY4Miw1NC4wMzggMTQ0Ljk1Nyw1NS4wMzcgQzE0NC45Nyw1NS4wODMgMTQ0Ljk1Myw1NS4xMzMgMTQ0LjkxNSw1NS4xNjEgQzE0NC45MTEsNTUuMTY1IDE0NC44OTgsNTUuMTc0IDE0NC44OTQsNTUuMTc3IEw2My41MTksMTAyLjE1OCBDNjMuNTAxLDEwMi4xNjkgNjMuNDgxLDEwMi4xNzQgNjMuNDYxLDEwMi4xNzQgTDYzLjQ2MSwxMDIuMTc0IFogTTEyLjcxNCw3My44NzEgTDU5LjExNSwxMDAuNjYxIEM2MC4yOTMsMTAxLjM0MSA2MS43ODYsMTAxLjc4MiA2My40MzUsMTAxLjkzNyBMMTQ0LjcwNyw1NS4wMTUgQzE0NC40MjgsNTQuMTA4IDE0My42ODIsNTMuMjg1IDE0Mi41NDQsNTIuNjI4IEw5Ni4wMjcsMjUuNzcxIEwxMi43MTQsNzMuODcxIEwxMi43MTQsNzMuODcxIFoiIGlkPSJGaWxsLTMiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTQ4LjMyNyw1OC40NzEgQzE0OC4xNDUsNTguNDggMTQ3Ljk2Miw1OC40OCAxNDcuNzgxLDU4LjQ3MiBDMTQ1Ljg4Nyw1OC4zODkgMTQ0LjQ3OSw1Ny40MzQgMTQ0LjYzNiw1Ni4zNCBDMTQ0LjY4OSw1NS45NjcgMTQ0LjY2NCw1NS41OTcgMTQ0LjU2NCw1NS4yMzUgTDYzLjQ2MSwxMDIuMDU3IEM2NC4wODksMTAyLjExNSA2NC43MzMsMTAyLjEzIDY1LjM3OSwxMDIuMDk5IEM2NS41NjEsMTAyLjA5IDY1Ljc0MywxMDIuMDkgNjUuOTI1LDEwMi4wOTggQzY3LjgxOSwxMDIuMTgxIDY5LjIyNywxMDMuMTM2IDY5LjA3LDEwNC4yMyBMMTQ4LjMyNyw1OC40NzEiIGlkPSJGaWxsLTQiIGZpbGw9IiNGRkZGRkYiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNjkuMDcsMTA0LjM0NyBDNjkuMDQ4LDEwNC4zNDcgNjkuMDI1LDEwNC4zNCA2OS4wMDUsMTA0LjMyNyBDNjguOTY4LDEwNC4zMDEgNjguOTQ4LDEwNC4yNTcgNjguOTU1LDEwNC4yMTMgQzY5LDEwMy44OTYgNjguODk4LDEwMy41NzYgNjguNjU4LDEwMy4yODggQzY4LjE1MywxMDIuNjc4IDY3LjEwMywxMDIuMjY2IDY1LjkyLDEwMi4yMTQgQzY1Ljc0MiwxMDIuMjA2IDY1LjU2MywxMDIuMjA3IDY1LjM4NSwxMDIuMjE1IEM2NC43NDIsMTAyLjI0NiA2NC4wODcsMTAyLjIzMiA2My40NSwxMDIuMTc0IEM2My4zOTksMTAyLjE2OSA2My4zNTgsMTAyLjEzMiA2My4zNDcsMTAyLjA4MiBDNjMuMzM2LDEwMi4wMzMgNjMuMzU4LDEwMS45ODEgNjMuNDAyLDEwMS45NTYgTDE0NC41MDYsNTUuMTM0IEMxNDQuNTM3LDU1LjExNiAxNDQuNTc1LDU1LjExMyAxNDQuNjA5LDU1LjEyNyBDMTQ0LjY0Miw1NS4xNDEgMTQ0LjY2OCw1NS4xNyAxNDQuNjc3LDU1LjIwNCBDMTQ0Ljc4MSw1NS41ODUgMTQ0LjgwNiw1NS45NzIgMTQ0Ljc1MSw1Ni4zNTcgQzE0NC43MDYsNTYuNjczIDE0NC44MDgsNTYuOTk0IDE0NS4wNDcsNTcuMjgyIEMxNDUuNTUzLDU3Ljg5MiAxNDYuNjAyLDU4LjMwMyAxNDcuNzg2LDU4LjM1NSBDMTQ3Ljk2NCw1OC4zNjMgMTQ4LjE0Myw1OC4zNjMgMTQ4LjMyMSw1OC4zNTQgQzE0OC4zNzcsNTguMzUyIDE0OC40MjQsNTguMzg3IDE0OC40MzksNTguNDM4IEMxNDguNDU0LDU4LjQ5IDE0OC40MzIsNTguNTQ1IDE0OC4zODUsNTguNTcyIEw2OS4xMjksMTA0LjMzMSBDNjkuMTExLDEwNC4zNDIgNjkuMDksMTA0LjM0NyA2OS4wNywxMDQuMzQ3IEw2OS4wNywxMDQuMzQ3IFogTTY1LjY2NSwxMDEuOTc1IEM2NS43NTQsMTAxLjk3NSA2NS44NDIsMTAxLjk3NyA2NS45MywxMDEuOTgxIEM2Ny4xOTYsMTAyLjAzNyA2OC4yODMsMTAyLjQ2OSA2OC44MzgsMTAzLjEzOSBDNjkuMDY1LDEwMy40MTMgNjkuMTg4LDEwMy43MTQgNjkuMTk4LDEwNC4wMjEgTDE0Ny44ODMsNTguNTkyIEMxNDcuODQ3LDU4LjU5MiAxNDcuODExLDU4LjU5MSAxNDcuNzc2LDU4LjU4OSBDMTQ2LjUwOSw1OC41MzMgMTQ1LjQyMiw1OC4xIDE0NC44NjcsNTcuNDMxIEMxNDQuNTg1LDU3LjA5MSAxNDQuNDY1LDU2LjcwNyAxNDQuNTIsNTYuMzI0IEMxNDQuNTYzLDU2LjAyMSAxNDQuNTUyLDU1LjcxNiAxNDQuNDg4LDU1LjQxNCBMNjMuODQ2LDEwMS45NyBDNjQuMzUzLDEwMi4wMDIgNjQuODY3LDEwMi4wMDYgNjUuMzc0LDEwMS45ODIgQzY1LjQ3MSwxMDEuOTc3IDY1LjU2OCwxMDEuOTc1IDY1LjY2NSwxMDEuOTc1IEw2NS42NjUsMTAxLjk3NSBaIiBpZD0iRmlsbC01IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTIuMjA4LDU1LjEzNCBDMS4yMDcsNTMuMzA3IDEuOTY3LDUwLjkxNyAzLjkwNiw0OS43OTcgTDU5LjkxNywxNy40NTMgQzYxLjg1NiwxNi4zMzMgNjQuMjQxLDE2LjkwNyA2NS4yNDMsMTguNzM0IEw2NS40NzUsMTkuMTQ0IEM2NS44NzIsMTkuODgyIDY2LjM2OCwyMC41NiA2Ni45NDUsMjEuMTY1IEw2Ny4yMjMsMjEuNDM1IEM3MC41NDgsMjQuNjQ5IDc1LjgwNiwyNS4xNTEgODAuMTExLDIyLjY2NSBMODcuNDMsMTguNDQ1IEM4OS4zNywxNy4zMjYgOTEuNzU0LDE3Ljg5OSA5Mi43NTUsMTkuNzI3IEw5Ni4wMDUsMjUuNjU1IEwxMi40ODYsNzMuODg0IEwyLjIwOCw1NS4xMzQgWiIgaWQ9IkZpbGwtNiIgZmlsbD0iI0ZBRkFGQSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMi40ODYsNzQuMDAxIEMxMi40NzYsNzQuMDAxIDEyLjQ2NSw3My45OTkgMTIuNDU1LDczLjk5NiBDMTIuNDI0LDczLjk4OCAxMi4zOTksNzMuOTY3IDEyLjM4NCw3My45NCBMMi4xMDYsNTUuMTkgQzEuMDc1LDUzLjMxIDEuODU3LDUwLjg0NSAzLjg0OCw0OS42OTYgTDU5Ljg1OCwxNy4zNTIgQzYwLjUyNSwxNi45NjcgNjEuMjcxLDE2Ljc2NCA2Mi4wMTYsMTYuNzY0IEM2My40MzEsMTYuNzY0IDY0LjY2NiwxNy40NjYgNjUuMzI3LDE4LjY0NiBDNjUuMzM3LDE4LjY1NCA2NS4zNDUsMTguNjYzIDY1LjM1MSwxOC42NzQgTDY1LjU3OCwxOS4wODggQzY1LjU4NCwxOS4xIDY1LjU4OSwxOS4xMTIgNjUuNTkxLDE5LjEyNiBDNjUuOTg1LDE5LjgzOCA2Ni40NjksMjAuNDk3IDY3LjAzLDIxLjA4NSBMNjcuMzA1LDIxLjM1MSBDNjkuMTUxLDIzLjEzNyA3MS42NDksMjQuMTIgNzQuMzM2LDI0LjEyIEM3Ni4zMTMsMjQuMTIgNzguMjksMjMuNTgyIDgwLjA1MywyMi41NjMgQzgwLjA2NCwyMi41NTcgODAuMDc2LDIyLjU1MyA4MC4wODgsMjIuNTUgTDg3LjM3MiwxOC4zNDQgQzg4LjAzOCwxNy45NTkgODguNzg0LDE3Ljc1NiA4OS41MjksMTcuNzU2IEM5MC45NTYsMTcuNzU2IDkyLjIwMSwxOC40NzIgOTIuODU4LDE5LjY3IEw5Ni4xMDcsMjUuNTk5IEM5Ni4xMzgsMjUuNjU0IDk2LjExOCwyNS43MjQgOTYuMDYzLDI1Ljc1NiBMMTIuNTQ1LDczLjk4NSBDMTIuNTI2LDczLjk5NiAxMi41MDYsNzQuMDAxIDEyLjQ4Niw3NC4wMDEgTDEyLjQ4Niw3NC4wMDEgWiBNNjIuMDE2LDE2Ljk5NyBDNjEuMzEyLDE2Ljk5NyA2MC42MDYsMTcuMTkgNTkuOTc1LDE3LjU1NCBMMy45NjUsNDkuODk5IEMyLjA4Myw1MC45ODUgMS4zNDEsNTMuMzA4IDIuMzEsNTUuMDc4IEwxMi41MzEsNzMuNzIzIEw5NS44NDgsMjUuNjExIEw5Mi42NTMsMTkuNzgyIEM5Mi4wMzgsMTguNjYgOTAuODcsMTcuOTkgODkuNTI5LDE3Ljk5IEM4OC44MjUsMTcuOTkgODguMTE5LDE4LjE4MiA4Ny40ODksMTguNTQ3IEw4MC4xNzIsMjIuNzcyIEM4MC4xNjEsMjIuNzc4IDgwLjE0OSwyMi43ODIgODAuMTM3LDIyLjc4NSBDNzguMzQ2LDIzLjgxMSA3Ni4zNDEsMjQuMzU0IDc0LjMzNiwyNC4zNTQgQzcxLjU4OCwyNC4zNTQgNjkuMDMzLDIzLjM0NyA2Ny4xNDIsMjEuNTE5IEw2Ni44NjQsMjEuMjQ5IEM2Ni4yNzcsMjAuNjM0IDY1Ljc3NCwxOS45NDcgNjUuMzY3LDE5LjIwMyBDNjUuMzYsMTkuMTkyIDY1LjM1NiwxOS4xNzkgNjUuMzU0LDE5LjE2NiBMNjUuMTYzLDE4LjgxOSBDNjUuMTU0LDE4LjgxMSA2NS4xNDYsMTguODAxIDY1LjE0LDE4Ljc5IEM2NC41MjUsMTcuNjY3IDYzLjM1NywxNi45OTcgNjIuMDE2LDE2Ljk5NyBMNjIuMDE2LDE2Ljk5NyBaIiBpZD0iRmlsbC03IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTQyLjQzNCw0OC44MDggTDQyLjQzNCw0OC44MDggQzM5LjkyNCw0OC44MDcgMzcuNzM3LDQ3LjU1IDM2LjU4Miw0NS40NDMgQzM0Ljc3MSw0Mi4xMzkgMzYuMTQ0LDM3LjgwOSAzOS42NDEsMzUuNzg5IEw1MS45MzIsMjguNjkxIEM1My4xMDMsMjguMDE1IDU0LjQxMywyNy42NTggNTUuNzIxLDI3LjY1OCBDNTguMjMxLDI3LjY1OCA2MC40MTgsMjguOTE2IDYxLjU3MywzMS4wMjMgQzYzLjM4NCwzNC4zMjcgNjIuMDEyLDM4LjY1NyA1OC41MTQsNDAuNjc3IEw0Ni4yMjMsNDcuNzc1IEM0NS4wNTMsNDguNDUgNDMuNzQyLDQ4LjgwOCA0Mi40MzQsNDguODA4IEw0Mi40MzQsNDguODA4IFogTTU1LjcyMSwyOC4xMjUgQzU0LjQ5NSwyOC4xMjUgNTMuMjY1LDI4LjQ2MSA1Mi4xNjYsMjkuMDk2IEwzOS44NzUsMzYuMTk0IEMzNi41OTYsMzguMDg3IDM1LjMwMiw0Mi4xMzYgMzYuOTkyLDQ1LjIxOCBDMzguMDYzLDQ3LjE3MyA0MC4wOTgsNDguMzQgNDIuNDM0LDQ4LjM0IEM0My42NjEsNDguMzQgNDQuODksNDguMDA1IDQ1Ljk5LDQ3LjM3IEw1OC4yODEsNDAuMjcyIEM2MS41NiwzOC4zNzkgNjIuODUzLDM0LjMzIDYxLjE2NCwzMS4yNDggQzYwLjA5MiwyOS4yOTMgNTguMDU4LDI4LjEyNSA1NS43MjEsMjguMTI1IEw1NS43MjEsMjguMTI1IFoiIGlkPSJGaWxsLTgiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTQ5LjU4OCwyLjQwNyBDMTQ5LjU4OCwyLjQwNyAxNTUuNzY4LDUuOTc1IDE1Ni4zMjUsNi4yOTcgTDE1Ni4zMjUsNy4xODQgQzE1Ni4zMjUsNy4zNiAxNTYuMzM4LDcuNTQ0IDE1Ni4zNjIsNy43MzMgQzE1Ni4zNzMsNy44MTQgMTU2LjM4Miw3Ljg5NCAxNTYuMzksNy45NzUgQzE1Ni41Myw5LjM5IDE1Ny4zNjMsMTAuOTczIDE1OC40OTUsMTEuOTc0IEwxNjUuODkxLDE4LjUxOSBDMTY2LjA2OCwxOC42NzUgMTY2LjI0OSwxOC44MTQgMTY2LjQzMiwxOC45MzQgQzE2OC4wMTEsMTkuOTc0IDE2OS4zODIsMTkuNCAxNjkuNDk0LDE3LjY1MiBDMTY5LjU0MywxNi44NjggMTY5LjU1MSwxNi4wNTcgMTY5LjUxNywxNS4yMjMgTDE2OS41MTQsMTUuMDYzIEwxNjkuNTE0LDEzLjkxMiBDMTcwLjc4LDE0LjY0MiAxOTUuNTAxLDI4LjkxNSAxOTUuNTAxLDI4LjkxNSBMMTk1LjUwMSw4Mi45MTUgQzE5NS41MDEsODQuMDA1IDE5NC43MzEsODQuNDQ1IDE5My43ODEsODMuODk3IEwxNTEuMzA4LDU5LjM3NCBDMTUwLjM1OCw1OC44MjYgMTQ5LjU4OCw1Ny40OTcgMTQ5LjU4OCw1Ni40MDggTDE0OS41ODgsMjIuMzc1IiBpZD0iRmlsbC05IiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE5NC41NTMsODQuMjUgQzE5NC4yOTYsODQuMjUgMTk0LjAxMyw4NC4xNjUgMTkzLjcyMiw4My45OTcgTDE1MS4yNSw1OS40NzYgQzE1MC4yNjksNTguOTA5IDE0OS40NzEsNTcuNTMzIDE0OS40NzEsNTYuNDA4IEwxNDkuNDcxLDIyLjM3NSBMMTQ5LjcwNSwyMi4zNzUgTDE0OS43MDUsNTYuNDA4IEMxNDkuNzA1LDU3LjQ1OSAxNTAuNDUsNTguNzQ0IDE1MS4zNjYsNTkuMjc0IEwxOTMuODM5LDgzLjc5NSBDMTk0LjI2Myw4NC4wNCAxOTQuNjU1LDg0LjA4MyAxOTQuOTQyLDgzLjkxNyBDMTk1LjIyNyw4My43NTMgMTk1LjM4NCw4My4zOTcgMTk1LjM4NCw4Mi45MTUgTDE5NS4zODQsMjguOTgyIEMxOTQuMTAyLDI4LjI0MiAxNzIuMTA0LDE1LjU0MiAxNjkuNjMxLDE0LjExNCBMMTY5LjYzNCwxNS4yMiBDMTY5LjY2OCwxNi4wNTIgMTY5LjY2LDE2Ljg3NCAxNjkuNjEsMTcuNjU5IEMxNjkuNTU2LDE4LjUwMyAxNjkuMjE0LDE5LjEyMyAxNjguNjQ3LDE5LjQwNSBDMTY4LjAyOCwxOS43MTQgMTY3LjE5NywxOS41NzggMTY2LjM2NywxOS4wMzIgQzE2Ni4xODEsMTguOTA5IDE2NS45OTUsMTguNzY2IDE2NS44MTQsMTguNjA2IEwxNTguNDE3LDEyLjA2MiBDMTU3LjI1OSwxMS4wMzYgMTU2LjQxOCw5LjQzNyAxNTYuMjc0LDcuOTg2IEMxNTYuMjY2LDcuOTA3IDE1Ni4yNTcsNy44MjcgMTU2LjI0Nyw3Ljc0OCBDMTU2LjIyMSw3LjU1NSAxNTYuMjA5LDcuMzY1IDE1Ni4yMDksNy4xODQgTDE1Ni4yMDksNi4zNjQgQzE1NS4zNzUsNS44ODMgMTQ5LjUyOSwyLjUwOCAxNDkuNTI5LDIuNTA4IEwxNDkuNjQ2LDIuMzA2IEMxNDkuNjQ2LDIuMzA2IDE1NS44MjcsNS44NzQgMTU2LjM4NCw2LjE5NiBMMTU2LjQ0Miw2LjIzIEwxNTYuNDQyLDcuMTg0IEMxNTYuNDQyLDcuMzU1IDE1Ni40NTQsNy41MzUgMTU2LjQ3OCw3LjcxNyBDMTU2LjQ4OSw3LjggMTU2LjQ5OSw3Ljg4MiAxNTYuNTA3LDcuOTYzIEMxNTYuNjQ1LDkuMzU4IDE1Ny40NTUsMTAuODk4IDE1OC41NzIsMTEuODg2IEwxNjUuOTY5LDE4LjQzMSBDMTY2LjE0MiwxOC41ODQgMTY2LjMxOSwxOC43MiAxNjYuNDk2LDE4LjgzNyBDMTY3LjI1NCwxOS4zMzYgMTY4LDE5LjQ2NyAxNjguNTQzLDE5LjE5NiBDMTY5LjAzMywxOC45NTMgMTY5LjMyOSwxOC40MDEgMTY5LjM3NywxNy42NDUgQzE2OS40MjcsMTYuODY3IDE2OS40MzQsMTYuMDU0IDE2OS40MDEsMTUuMjI4IEwxNjkuMzk3LDE1LjA2NSBMMTY5LjM5NywxMy43MSBMMTY5LjU3MiwxMy44MSBDMTcwLjgzOSwxNC41NDEgMTk1LjU1OSwyOC44MTQgMTk1LjU1OSwyOC44MTQgTDE5NS42MTgsMjguODQ3IEwxOTUuNjE4LDgyLjkxNSBDMTk1LjYxOCw4My40ODQgMTk1LjQyLDgzLjkxMSAxOTUuMDU5LDg0LjExOSBDMTk0LjkwOCw4NC4yMDYgMTk0LjczNyw4NC4yNSAxOTQuNTUzLDg0LjI1IiBpZD0iRmlsbC0xMCIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNDUuNjg1LDU2LjE2MSBMMTY5LjgsNzAuMDgzIEwxNDMuODIyLDg1LjA4MSBMMTQyLjM2LDg0Ljc3NCBDMTM1LjgyNiw4Mi42MDQgMTI4LjczMiw4MS4wNDYgMTIxLjM0MSw4MC4xNTggQzExNi45NzYsNzkuNjM0IDExMi42NzgsODEuMjU0IDExMS43NDMsODMuNzc4IEMxMTEuNTA2LDg0LjQxNCAxMTEuNTAzLDg1LjA3MSAxMTEuNzMyLDg1LjcwNiBDMTEzLjI3LDg5Ljk3MyAxMTUuOTY4LDk0LjA2OSAxMTkuNzI3LDk3Ljg0MSBMMTIwLjI1OSw5OC42ODYgQzEyMC4yNiw5OC42ODUgOTQuMjgyLDExMy42ODMgOTQuMjgyLDExMy42ODMgTDcwLjE2Nyw5OS43NjEgTDE0NS42ODUsNTYuMTYxIiBpZD0iRmlsbC0xMSIgZmlsbD0iI0ZGRkZGRiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik05NC4yODIsMTEzLjgxOCBMOTQuMjIzLDExMy43ODUgTDY5LjkzMyw5OS43NjEgTDcwLjEwOCw5OS42NiBMMTQ1LjY4NSw1Ni4wMjYgTDE0NS43NDMsNTYuMDU5IEwxNzAuMDMzLDcwLjA4MyBMMTQzLjg0Miw4NS4yMDUgTDE0My43OTcsODUuMTk1IEMxNDMuNzcyLDg1LjE5IDE0Mi4zMzYsODQuODg4IDE0Mi4zMzYsODQuODg4IEMxMzUuNzg3LDgyLjcxNCAxMjguNzIzLDgxLjE2MyAxMjEuMzI3LDgwLjI3NCBDMTIwLjc4OCw4MC4yMDkgMTIwLjIzNiw4MC4xNzcgMTE5LjY4OSw4MC4xNzcgQzExNS45MzEsODAuMTc3IDExMi42MzUsODEuNzA4IDExMS44NTIsODMuODE5IEMxMTEuNjI0LDg0LjQzMiAxMTEuNjIxLDg1LjA1MyAxMTEuODQyLDg1LjY2NyBDMTEzLjM3Nyw4OS45MjUgMTE2LjA1OCw5My45OTMgMTE5LjgxLDk3Ljc1OCBMMTE5LjgyNiw5Ny43NzkgTDEyMC4zNTIsOTguNjE0IEMxMjAuMzU0LDk4LjYxNyAxMjAuMzU2LDk4LjYyIDEyMC4zNTgsOTguNjI0IEwxMjAuNDIyLDk4LjcyNiBMMTIwLjMxNyw5OC43ODcgQzEyMC4yNjQsOTguODE4IDk0LjU5OSwxMTMuNjM1IDk0LjM0LDExMy43ODUgTDk0LjI4MiwxMTMuODE4IEw5NC4yODIsMTEzLjgxOCBaIE03MC40MDEsOTkuNzYxIEw5NC4yODIsMTEzLjU0OSBMMTE5LjA4NCw5OS4yMjkgQzExOS42Myw5OC45MTQgMTE5LjkzLDk4Ljc0IDEyMC4xMDEsOTguNjU0IEwxMTkuNjM1LDk3LjkxNCBDMTE1Ljg2NCw5NC4xMjcgMTEzLjE2OCw5MC4wMzMgMTExLjYyMiw4NS43NDYgQzExMS4zODIsODUuMDc5IDExMS4zODYsODQuNDA0IDExMS42MzMsODMuNzM4IEMxMTIuNDQ4LDgxLjUzOSAxMTUuODM2LDc5Ljk0MyAxMTkuNjg5LDc5Ljk0MyBDMTIwLjI0Niw3OS45NDMgMTIwLjgwNiw3OS45NzYgMTIxLjM1NSw4MC4wNDIgQzEyOC43NjcsODAuOTMzIDEzNS44NDYsODIuNDg3IDE0Mi4zOTYsODQuNjYzIEMxNDMuMjMyLDg0LjgzOCAxNDMuNjExLDg0LjkxNyAxNDMuNzg2LDg0Ljk2NyBMMTY5LjU2Niw3MC4wODMgTDE0NS42ODUsNTYuMjk1IEw3MC40MDEsOTkuNzYxIEw3MC40MDEsOTkuNzYxIFoiIGlkPSJGaWxsLTEyIiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE2Ny4yMywxOC45NzkgTDE2Ny4yMyw2OS44NSBMMTM5LjkwOSw4NS42MjMgTDEzMy40NDgsNzEuNDU2IEMxMzIuNTM4LDY5LjQ2IDEzMC4wMiw2OS43MTggMTI3LjgyNCw3Mi4wMyBDMTI2Ljc2OSw3My4xNCAxMjUuOTMxLDc0LjU4NSAxMjUuNDk0LDc2LjA0OCBMMTE5LjAzNCw5Ny42NzYgTDkxLjcxMiwxMTMuNDUgTDkxLjcxMiw2Mi41NzkgTDE2Ny4yMywxOC45NzkiIGlkPSJGaWxsLTEzIiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTkxLjcxMiwxMTMuNTY3IEM5MS42OTIsMTEzLjU2NyA5MS42NzIsMTEzLjU2MSA5MS42NTMsMTEzLjU1MSBDOTEuNjE4LDExMy41MyA5MS41OTUsMTEzLjQ5MiA5MS41OTUsMTEzLjQ1IEw5MS41OTUsNjIuNTc5IEM5MS41OTUsNjIuNTM3IDkxLjYxOCw2Mi40OTkgOTEuNjUzLDYyLjQ3OCBMMTY3LjE3MiwxOC44NzggQzE2Ny4yMDgsMTguODU3IDE2Ny4yNTIsMTguODU3IDE2Ny4yODgsMTguODc4IEMxNjcuMzI0LDE4Ljg5OSAxNjcuMzQ3LDE4LjkzNyAxNjcuMzQ3LDE4Ljk3OSBMMTY3LjM0Nyw2OS44NSBDMTY3LjM0Nyw2OS44OTEgMTY3LjMyNCw2OS45MyAxNjcuMjg4LDY5Ljk1IEwxMzkuOTY3LDg1LjcyNSBDMTM5LjkzOSw4NS43NDEgMTM5LjkwNSw4NS43NDUgMTM5Ljg3Myw4NS43MzUgQzEzOS44NDIsODUuNzI1IDEzOS44MTYsODUuNzAyIDEzOS44MDIsODUuNjcyIEwxMzMuMzQyLDcxLjUwNCBDMTMyLjk2Nyw3MC42ODIgMTMyLjI4LDcwLjIyOSAxMzEuNDA4LDcwLjIyOSBDMTMwLjMxOSw3MC4yMjkgMTI5LjA0NCw3MC45MTUgMTI3LjkwOCw3Mi4xMSBDMTI2Ljg3NCw3My4yIDEyNi4wMzQsNzQuNjQ3IDEyNS42MDYsNzYuMDgyIEwxMTkuMTQ2LDk3LjcwOSBDMTE5LjEzNyw5Ny43MzggMTE5LjExOCw5Ny43NjIgMTE5LjA5Miw5Ny43NzcgTDkxLjc3LDExMy41NTEgQzkxLjc1MiwxMTMuNTYxIDkxLjczMiwxMTMuNTY3IDkxLjcxMiwxMTMuNTY3IEw5MS43MTIsMTEzLjU2NyBaIE05MS44MjksNjIuNjQ3IEw5MS44MjksMTEzLjI0OCBMMTE4LjkzNSw5Ny41OTggTDEyNS4zODIsNzYuMDE1IEMxMjUuODI3LDc0LjUyNSAxMjYuNjY0LDczLjA4MSAxMjcuNzM5LDcxLjk1IEMxMjguOTE5LDcwLjcwOCAxMzAuMjU2LDY5Ljk5NiAxMzEuNDA4LDY5Ljk5NiBDMTMyLjM3Nyw2OS45OTYgMTMzLjEzOSw3MC40OTcgMTMzLjU1NCw3MS40MDcgTDEzOS45NjEsODUuNDU4IEwxNjcuMTEzLDY5Ljc4MiBMMTY3LjExMywxOS4xODEgTDkxLjgyOSw2Mi42NDcgTDkxLjgyOSw2Mi42NDcgWiIgaWQ9IkZpbGwtMTQiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTY4LjU0MywxOS4yMTMgTDE2OC41NDMsNzAuMDgzIEwxNDEuMjIxLDg1Ljg1NyBMMTM0Ljc2MSw3MS42ODkgQzEzMy44NTEsNjkuNjk0IDEzMS4zMzMsNjkuOTUxIDEyOS4xMzcsNzIuMjYzIEMxMjguMDgyLDczLjM3NCAxMjcuMjQ0LDc0LjgxOSAxMjYuODA3LDc2LjI4MiBMMTIwLjM0Niw5Ny45MDkgTDkzLjAyNSwxMTMuNjgzIEw5My4wMjUsNjIuODEzIEwxNjguNTQzLDE5LjIxMyIgaWQ9IkZpbGwtMTUiIGZpbGw9IiNGRkZGRkYiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNOTMuMDI1LDExMy44IEM5My4wMDUsMTEzLjggOTIuOTg0LDExMy43OTUgOTIuOTY2LDExMy43ODUgQzkyLjkzMSwxMTMuNzY0IDkyLjkwOCwxMTMuNzI1IDkyLjkwOCwxMTMuNjg0IEw5Mi45MDgsNjIuODEzIEM5Mi45MDgsNjIuNzcxIDkyLjkzMSw2Mi43MzMgOTIuOTY2LDYyLjcxMiBMMTY4LjQ4NCwxOS4xMTIgQzE2OC41MiwxOS4wOSAxNjguNTY1LDE5LjA5IDE2OC42MDEsMTkuMTEyIEMxNjguNjM3LDE5LjEzMiAxNjguNjYsMTkuMTcxIDE2OC42NiwxOS4yMTIgTDE2OC42Niw3MC4wODMgQzE2OC42Niw3MC4xMjUgMTY4LjYzNyw3MC4xNjQgMTY4LjYwMSw3MC4xODQgTDE0MS4yOCw4NS45NTggQzE0MS4yNTEsODUuOTc1IDE0MS4yMTcsODUuOTc5IDE0MS4xODYsODUuOTY4IEMxNDEuMTU0LDg1Ljk1OCAxNDEuMTI5LDg1LjkzNiAxNDEuMTE1LDg1LjkwNiBMMTM0LjY1NSw3MS43MzggQzEzNC4yOCw3MC45MTUgMTMzLjU5Myw3MC40NjMgMTMyLjcyLDcwLjQ2MyBDMTMxLjYzMiw3MC40NjMgMTMwLjM1Nyw3MS4xNDggMTI5LjIyMSw3Mi4zNDQgQzEyOC4xODYsNzMuNDMzIDEyNy4zNDcsNzQuODgxIDEyNi45MTksNzYuMzE1IEwxMjAuNDU4LDk3Ljk0MyBDMTIwLjQ1LDk3Ljk3MiAxMjAuNDMxLDk3Ljk5NiAxMjAuNDA1LDk4LjAxIEw5My4wODMsMTEzLjc4NSBDOTMuMDY1LDExMy43OTUgOTMuMDQ1LDExMy44IDkzLjAyNSwxMTMuOCBMOTMuMDI1LDExMy44IFogTTkzLjE0Miw2Mi44ODEgTDkzLjE0MiwxMTMuNDgxIEwxMjAuMjQ4LDk3LjgzMiBMMTI2LjY5NSw3Ni4yNDggQzEyNy4xNCw3NC43NTggMTI3Ljk3Nyw3My4zMTUgMTI5LjA1Miw3Mi4xODMgQzEzMC4yMzEsNzAuOTQyIDEzMS41NjgsNzAuMjI5IDEzMi43Miw3MC4yMjkgQzEzMy42ODksNzAuMjI5IDEzNC40NTIsNzAuNzMxIDEzNC44NjcsNzEuNjQxIEwxNDEuMjc0LDg1LjY5MiBMMTY4LjQyNiw3MC4wMTYgTDE2OC40MjYsMTkuNDE1IEw5My4xNDIsNjIuODgxIEw5My4xNDIsNjIuODgxIFoiIGlkPSJGaWxsLTE2IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE2OS44LDcwLjA4MyBMMTQyLjQ3OCw4NS44NTcgTDEzNi4wMTgsNzEuNjg5IEMxMzUuMTA4LDY5LjY5NCAxMzIuNTksNjkuOTUxIDEzMC4zOTMsNzIuMjYzIEMxMjkuMzM5LDczLjM3NCAxMjguNSw3NC44MTkgMTI4LjA2NCw3Ni4yODIgTDEyMS42MDMsOTcuOTA5IEw5NC4yODIsMTEzLjY4MyBMOTQuMjgyLDYyLjgxMyBMMTY5LjgsMTkuMjEzIEwxNjkuOCw3MC4wODMgWiIgaWQ9IkZpbGwtMTciIGZpbGw9IiNGQUZBRkEiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNOTQuMjgyLDExMy45MTcgQzk0LjI0MSwxMTMuOTE3IDk0LjIwMSwxMTMuOTA3IDk0LjE2NSwxMTMuODg2IEM5NC4wOTMsMTEzLjg0NSA5NC4wNDgsMTEzLjc2NyA5NC4wNDgsMTEzLjY4NCBMOTQuMDQ4LDYyLjgxMyBDOTQuMDQ4LDYyLjczIDk0LjA5Myw2Mi42NTIgOTQuMTY1LDYyLjYxMSBMMTY5LjY4MywxOS4wMSBDMTY5Ljc1NSwxOC45NjkgMTY5Ljg0NCwxOC45NjkgMTY5LjkxNywxOS4wMSBDMTY5Ljk4OSwxOS4wNTIgMTcwLjAzMywxOS4xMjkgMTcwLjAzMywxOS4yMTIgTDE3MC4wMzMsNzAuMDgzIEMxNzAuMDMzLDcwLjE2NiAxNjkuOTg5LDcwLjI0NCAxNjkuOTE3LDcwLjI4NSBMMTQyLjU5NSw4Ni4wNiBDMTQyLjUzOCw4Ni4wOTIgMTQyLjQ2OSw4Ni4xIDE0Mi40MDcsODYuMDggQzE0Mi4zNDQsODYuMDYgMTQyLjI5Myw4Ni4wMTQgMTQyLjI2Niw4NS45NTQgTDEzNS44MDUsNzEuNzg2IEMxMzUuNDQ1LDcwLjk5NyAxMzQuODEzLDcwLjU4IDEzMy45NzcsNzAuNTggQzEzMi45MjEsNzAuNTggMTMxLjY3Niw3MS4yNTIgMTMwLjU2Miw3Mi40MjQgQzEyOS41NCw3My41MDEgMTI4LjcxMSw3NC45MzEgMTI4LjI4Nyw3Ni4zNDggTDEyMS44MjcsOTcuOTc2IEMxMjEuODEsOTguMDM0IDEyMS43NzEsOTguMDgyIDEyMS43Miw5OC4xMTIgTDk0LjM5OCwxMTMuODg2IEM5NC4zNjIsMTEzLjkwNyA5NC4zMjIsMTEzLjkxNyA5NC4yODIsMTEzLjkxNyBMOTQuMjgyLDExMy45MTcgWiBNOTQuNTE1LDYyLjk0OCBMOTQuNTE1LDExMy4yNzkgTDEyMS40MDYsOTcuNzU0IEwxMjcuODQsNzYuMjE1IEMxMjguMjksNzQuNzA4IDEyOS4xMzcsNzMuMjQ3IDEzMC4yMjQsNzIuMTAzIEMxMzEuNDI1LDcwLjgzOCAxMzIuNzkzLDcwLjExMiAxMzMuOTc3LDcwLjExMiBDMTM0Ljk5NSw3MC4xMTIgMTM1Ljc5NSw3MC42MzggMTM2LjIzLDcxLjU5MiBMMTQyLjU4NCw4NS41MjYgTDE2OS41NjYsNjkuOTQ4IEwxNjkuNTY2LDE5LjYxNyBMOTQuNTE1LDYyLjk0OCBMOTQuNTE1LDYyLjk0OCBaIiBpZD0iRmlsbC0xOCIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMDkuODk0LDkyLjk0MyBMMTA5Ljg5NCw5Mi45NDMgQzEwOC4xMiw5Mi45NDMgMTA2LjY1Myw5Mi4yMTggMTA1LjY1LDkwLjgyMyBDMTA1LjU4Myw5MC43MzEgMTA1LjU5Myw5MC42MSAxMDUuNjczLDkwLjUyOSBDMTA1Ljc1Myw5MC40NDggMTA1Ljg4LDkwLjQ0IDEwNS45NzQsOTAuNTA2IEMxMDYuNzU0LDkxLjA1MyAxMDcuNjc5LDkxLjMzMyAxMDguNzI0LDkxLjMzMyBDMTEwLjA0Nyw5MS4zMzMgMTExLjQ3OCw5MC44OTQgMTEyLjk4LDkwLjAyNyBDMTE4LjI5MSw4Ni45NiAxMjIuNjExLDc5LjUwOSAxMjIuNjExLDczLjQxNiBDMTIyLjYxMSw3MS40ODkgMTIyLjE2OSw2OS44NTYgMTIxLjMzMyw2OC42OTIgQzEyMS4yNjYsNjguNiAxMjEuMjc2LDY4LjQ3MyAxMjEuMzU2LDY4LjM5MiBDMTIxLjQzNiw2OC4zMTEgMTIxLjU2Myw2OC4yOTkgMTIxLjY1Niw2OC4zNjUgQzEyMy4zMjcsNjkuNTM3IDEyNC4yNDcsNzEuNzQ2IDEyNC4yNDcsNzQuNTg0IEMxMjQuMjQ3LDgwLjgyNiAxMTkuODIxLDg4LjQ0NyAxMTQuMzgyLDkxLjU4NyBDMTEyLjgwOCw5Mi40OTUgMTExLjI5OCw5Mi45NDMgMTA5Ljg5NCw5Mi45NDMgTDEwOS44OTQsOTIuOTQzIFogTTEwNi45MjUsOTEuNDAxIEMxMDcuNzM4LDkyLjA1MiAxMDguNzQ1LDkyLjI3OCAxMDkuODkzLDkyLjI3OCBMMTA5Ljg5NCw5Mi4yNzggQzExMS4yMTUsOTIuMjc4IDExMi42NDcsOTEuOTUxIDExNC4xNDgsOTEuMDg0IEMxMTkuNDU5LDg4LjAxNyAxMjMuNzgsODAuNjIxIDEyMy43OCw3NC41MjggQzEyMy43OCw3Mi41NDkgMTIzLjMxNyw3MC45MjkgMTIyLjQ1NCw2OS43NjcgQzEyMi44NjUsNzAuODAyIDEyMy4wNzksNzIuMDQyIDEyMy4wNzksNzMuNDAyIEMxMjMuMDc5LDc5LjY0NSAxMTguNjUzLDg3LjI4NSAxMTMuMjE0LDkwLjQyNSBDMTExLjY0LDkxLjMzNCAxMTAuMTMsOTEuNzQyIDEwOC43MjQsOTEuNzQyIEMxMDguMDgzLDkxLjc0MiAxMDcuNDgxLDkxLjU5MyAxMDYuOTI1LDkxLjQwMSBMMTA2LjkyNSw5MS40MDEgWiIgaWQ9IkZpbGwtMTkiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTEzLjA5Nyw5MC4yMyBDMTE4LjQ4MSw4Ny4xMjIgMTIyLjg0NSw3OS41OTQgMTIyLjg0NSw3My40MTYgQzEyMi44NDUsNzEuMzY1IDEyMi4zNjIsNjkuNzI0IDEyMS41MjIsNjguNTU2IEMxMTkuNzM4LDY3LjMwNCAxMTcuMTQ4LDY3LjM2MiAxMTQuMjY1LDY5LjAyNiBDMTA4Ljg4MSw3Mi4xMzQgMTA0LjUxNyw3OS42NjIgMTA0LjUxNyw4NS44NCBDMTA0LjUxNyw4Ny44OTEgMTA1LDg5LjUzMiAxMDUuODQsOTAuNyBDMTA3LjYyNCw5MS45NTIgMTEwLjIxNCw5MS44OTQgMTEzLjA5Nyw5MC4yMyIgaWQ9IkZpbGwtMjAiIGZpbGw9IiNGQUZBRkEiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTA4LjcyNCw5MS42MTQgTDEwOC43MjQsOTEuNjE0IEMxMDcuNTgyLDkxLjYxNCAxMDYuNTY2LDkxLjQwMSAxMDUuNzA1LDkwLjc5NyBDMTA1LjY4NCw5MC43ODMgMTA1LjY2NSw5MC44MTEgMTA1LjY1LDkwLjc5IEMxMDQuNzU2LDg5LjU0NiAxMDQuMjgzLDg3Ljg0MiAxMDQuMjgzLDg1LjgxNyBDMTA0LjI4Myw3OS41NzUgMTA4LjcwOSw3MS45NTMgMTE0LjE0OCw2OC44MTIgQzExNS43MjIsNjcuOTA0IDExNy4yMzIsNjcuNDQ5IDExOC42MzgsNjcuNDQ5IEMxMTkuNzgsNjcuNDQ5IDEyMC43OTYsNjcuNzU4IDEyMS42NTYsNjguMzYyIEMxMjEuNjc4LDY4LjM3NyAxMjEuNjk3LDY4LjM5NyAxMjEuNzEyLDY4LjQxOCBDMTIyLjYwNiw2OS42NjIgMTIzLjA3OSw3MS4zOSAxMjMuMDc5LDczLjQxNSBDMTIzLjA3OSw3OS42NTggMTE4LjY1Myw4Ny4xOTggMTEzLjIxNCw5MC4zMzggQzExMS42NCw5MS4yNDcgMTEwLjEzLDkxLjYxNCAxMDguNzI0LDkxLjYxNCBMMTA4LjcyNCw5MS42MTQgWiBNMTA2LjAwNiw5MC41MDUgQzEwNi43OCw5MS4wMzcgMTA3LjY5NCw5MS4yODEgMTA4LjcyNCw5MS4yODEgQzExMC4wNDcsOTEuMjgxIDExMS40NzgsOTAuODY4IDExMi45OCw5MC4wMDEgQzExOC4yOTEsODYuOTM1IDEyMi42MTEsNzkuNDk2IDEyMi42MTEsNzMuNDAzIEMxMjIuNjExLDcxLjQ5NCAxMjIuMTc3LDY5Ljg4IDEyMS4zNTYsNjguNzE4IEMxMjAuNTgyLDY4LjE4NSAxMTkuNjY4LDY3LjkxOSAxMTguNjM4LDY3LjkxOSBDMTE3LjMxNSw2Ny45MTkgMTE1Ljg4Myw2OC4zNiAxMTQuMzgyLDY5LjIyNyBDMTA5LjA3MSw3Mi4yOTMgMTA0Ljc1MSw3OS43MzMgMTA0Ljc1MSw4NS44MjYgQzEwNC43NTEsODcuNzM1IDEwNS4xODUsODkuMzQzIDEwNi4wMDYsOTAuNTA1IEwxMDYuMDA2LDkwLjUwNSBaIiBpZD0iRmlsbC0yMSIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNDkuMzE4LDcuMjYyIEwxMzkuMzM0LDE2LjE0IEwxNTUuMjI3LDI3LjE3MSBMMTYwLjgxNiwyMS4wNTkgTDE0OS4zMTgsNy4yNjIiIGlkPSJGaWxsLTIyIiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE2OS42NzYsMTMuODQgTDE1OS45MjgsMTkuNDY3IEMxNTYuMjg2LDIxLjU3IDE1MC40LDIxLjU4IDE0Ni43ODEsMTkuNDkxIEMxNDMuMTYxLDE3LjQwMiAxNDMuMTgsMTQuMDAzIDE0Ni44MjIsMTEuOSBMMTU2LjMxNyw2LjI5MiBMMTQ5LjU4OCwyLjQwNyBMNjcuNzUyLDQ5LjQ3OCBMMTEzLjY3NSw3NS45OTIgTDExNi43NTYsNzQuMjEzIEMxMTcuMzg3LDczLjg0OCAxMTcuNjI1LDczLjMxNSAxMTcuMzc0LDcyLjgyMyBDMTE1LjAxNyw2OC4xOTEgMTE0Ljc4MSw2My4yNzcgMTE2LjY5MSw1OC41NjEgQzEyMi4zMjksNDQuNjQxIDE0MS4yLDMzLjc0NiAxNjUuMzA5LDMwLjQ5MSBDMTczLjQ3OCwyOS4zODggMTgxLjk4OSwyOS41MjQgMTkwLjAxMywzMC44ODUgQzE5MC44NjUsMzEuMDMgMTkxLjc4OSwzMC44OTMgMTkyLjQyLDMwLjUyOCBMMTk1LjUwMSwyOC43NSBMMTY5LjY3NiwxMy44NCIgaWQ9IkZpbGwtMjMiIGZpbGw9IiNGQUZBRkEiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTEzLjY3NSw3Ni40NTkgQzExMy41OTQsNzYuNDU5IDExMy41MTQsNzYuNDM4IDExMy40NDIsNzYuMzk3IEw2Ny41MTgsNDkuODgyIEM2Ny4zNzQsNDkuNzk5IDY3LjI4NCw0OS42NDUgNjcuMjg1LDQ5LjQ3OCBDNjcuMjg1LDQ5LjMxMSA2Ny4zNzQsNDkuMTU3IDY3LjUxOSw0OS4wNzMgTDE0OS4zNTUsMi4wMDIgQzE0OS40OTksMS45MTkgMTQ5LjY3NywxLjkxOSAxNDkuODIxLDIuMDAyIEwxNTYuNTUsNS44ODcgQzE1Ni43NzQsNi4wMTcgMTU2Ljg1LDYuMzAyIDE1Ni43MjIsNi41MjYgQzE1Ni41OTIsNi43NDkgMTU2LjMwNyw2LjgyNiAxNTYuMDgzLDYuNjk2IEwxNDkuNTg3LDIuOTQ2IEw2OC42ODcsNDkuNDc5IEwxMTMuNjc1LDc1LjQ1MiBMMTE2LjUyMyw3My44MDggQzExNi43MTUsNzMuNjk3IDExNy4xNDMsNzMuMzk5IDExNi45NTgsNzMuMDM1IEMxMTQuNTQyLDY4LjI4NyAxMTQuMyw2My4yMjEgMTE2LjI1OCw1OC4zODUgQzExOS4wNjQsNTEuNDU4IDEyNS4xNDMsNDUuMTQzIDEzMy44NCw0MC4xMjIgQzE0Mi40OTcsMzUuMTI0IDE1My4zNTgsMzEuNjMzIDE2NS4yNDcsMzAuMDI4IEMxNzMuNDQ1LDI4LjkyMSAxODIuMDM3LDI5LjA1OCAxOTAuMDkxLDMwLjQyNSBDMTkwLjgzLDMwLjU1IDE5MS42NTIsMzAuNDMyIDE5Mi4xODYsMzAuMTI0IEwxOTQuNTY3LDI4Ljc1IEwxNjkuNDQyLDE0LjI0NCBDMTY5LjIxOSwxNC4xMTUgMTY5LjE0MiwxMy44MjkgMTY5LjI3MSwxMy42MDYgQzE2OS40LDEzLjM4MiAxNjkuNjg1LDEzLjMwNiAxNjkuOTA5LDEzLjQzNSBMMTk1LjczNCwyOC4zNDUgQzE5NS44NzksMjguNDI4IDE5NS45NjgsMjguNTgzIDE5NS45NjgsMjguNzUgQzE5NS45NjgsMjguOTE2IDE5NS44NzksMjkuMDcxIDE5NS43MzQsMjkuMTU0IEwxOTIuNjUzLDMwLjkzMyBDMTkxLjkzMiwzMS4zNSAxOTAuODksMzEuNTA4IDE4OS45MzUsMzEuMzQ2IEMxODEuOTcyLDI5Ljk5NSAxNzMuNDc4LDI5Ljg2IDE2NS4zNzIsMzAuOTU0IEMxNTMuNjAyLDMyLjU0MyAxNDIuODYsMzUuOTkzIDEzNC4zMDcsNDAuOTMxIEMxMjUuNzkzLDQ1Ljg0NyAxMTkuODUxLDUyLjAwNCAxMTcuMTI0LDU4LjczNiBDMTE1LjI3LDYzLjMxNCAxMTUuNTAxLDY4LjExMiAxMTcuNzksNzIuNjExIEMxMTguMTYsNzMuMzM2IDExNy44NDUsNzQuMTI0IDExNi45OSw3NC42MTcgTDExMy45MDksNzYuMzk3IEMxMTMuODM2LDc2LjQzOCAxMTMuNzU2LDc2LjQ1OSAxMTMuNjc1LDc2LjQ1OSIgaWQ9IkZpbGwtMjQiIGZpbGw9IiM0NTVBNjQiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTUzLjMxNiwyMS4yNzkgQzE1MC45MDMsMjEuMjc5IDE0OC40OTUsMjAuNzUxIDE0Ni42NjQsMTkuNjkzIEMxNDQuODQ2LDE4LjY0NCAxNDMuODQ0LDE3LjIzMiAxNDMuODQ0LDE1LjcxOCBDMTQzLjg0NCwxNC4xOTEgMTQ0Ljg2LDEyLjc2MyAxNDYuNzA1LDExLjY5OCBMMTU2LjE5OCw2LjA5MSBDMTU2LjMwOSw2LjAyNSAxNTYuNDUyLDYuMDYyIDE1Ni41MTgsNi4xNzMgQzE1Ni41ODMsNi4yODQgMTU2LjU0Nyw2LjQyNyAxNTYuNDM2LDYuNDkzIEwxNDYuOTQsMTIuMTAyIEMxNDUuMjQ0LDEzLjA4MSAxNDQuMzEyLDE0LjM2NSAxNDQuMzEyLDE1LjcxOCBDMTQ0LjMxMiwxNy4wNTggMTQ1LjIzLDE4LjMyNiAxNDYuODk3LDE5LjI4OSBDMTUwLjQ0NiwyMS4zMzggMTU2LjI0LDIxLjMyNyAxNTkuODExLDE5LjI2NSBMMTY5LjU1OSwxMy42MzcgQzE2OS42NywxMy41NzMgMTY5LjgxMywxMy42MTEgMTY5Ljg3OCwxMy43MjMgQzE2OS45NDMsMTMuODM0IDE2OS45MDQsMTMuOTc3IDE2OS43OTMsMTQuMDQyIEwxNjAuMDQ1LDE5LjY3IEMxNTguMTg3LDIwLjc0MiAxNTUuNzQ5LDIxLjI3OSAxNTMuMzE2LDIxLjI3OSIgaWQ9IkZpbGwtMjUiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTEzLjY3NSw3NS45OTIgTDY3Ljc2Miw0OS40ODQiIGlkPSJGaWxsLTI2IiBmaWxsPSIjNDU1QTY0Ij48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTExMy42NzUsNzYuMzQyIEMxMTMuNjE1LDc2LjM0MiAxMTMuNTU1LDc2LjMyNyAxMTMuNSw3Ni4yOTUgTDY3LjU4Nyw0OS43ODcgQzY3LjQxOSw0OS42OSA2Ny4zNjIsNDkuNDc2IDY3LjQ1OSw0OS4zMDkgQzY3LjU1Niw0OS4xNDEgNjcuNzcsNDkuMDgzIDY3LjkzNyw0OS4xOCBMMTEzLjg1LDc1LjY4OCBDMTE0LjAxOCw3NS43ODUgMTE0LjA3NSw3NiAxMTMuOTc4LDc2LjE2NyBDMTEzLjkxNCw3Ni4yNzkgMTEzLjc5Niw3Ni4zNDIgMTEzLjY3NSw3Ni4zNDIiIGlkPSJGaWxsLTI3IiBmaWxsPSIjNDU1QTY0Ij48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTY3Ljc2Miw0OS40ODQgTDY3Ljc2MiwxMDMuNDg1IEM2Ny43NjIsMTA0LjU3NSA2OC41MzIsMTA1LjkwMyA2OS40ODIsMTA2LjQ1MiBMMTExLjk1NSwxMzAuOTczIEMxMTIuOTA1LDEzMS41MjIgMTEzLjY3NSwxMzEuMDgzIDExMy42NzUsMTI5Ljk5MyBMMTEzLjY3NSw3NS45OTIiIGlkPSJGaWxsLTI4IiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTExMi43MjcsMTMxLjU2MSBDMTEyLjQzLDEzMS41NjEgMTEyLjEwNywxMzEuNDY2IDExMS43OCwxMzEuMjc2IEw2OS4zMDcsMTA2Ljc1NSBDNjguMjQ0LDEwNi4xNDIgNjcuNDEyLDEwNC43MDUgNjcuNDEyLDEwMy40ODUgTDY3LjQxMiw0OS40ODQgQzY3LjQxMiw0OS4yOSA2Ny41NjksNDkuMTM0IDY3Ljc2Miw0OS4xMzQgQzY3Ljk1Niw0OS4xMzQgNjguMTEzLDQ5LjI5IDY4LjExMyw0OS40ODQgTDY4LjExMywxMDMuNDg1IEM2OC4xMTMsMTA0LjQ0NSA2OC44MiwxMDUuNjY1IDY5LjY1NywxMDYuMTQ4IEwxMTIuMTMsMTMwLjY3IEMxMTIuNDc0LDEzMC44NjggMTEyLjc5MSwxMzAuOTEzIDExMywxMzAuNzkyIEMxMTMuMjA2LDEzMC42NzMgMTEzLjMyNSwxMzAuMzgxIDExMy4zMjUsMTI5Ljk5MyBMMTEzLjMyNSw3NS45OTIgQzExMy4zMjUsNzUuNzk4IDExMy40ODIsNzUuNjQxIDExMy42NzUsNzUuNjQxIEMxMTMuODY5LDc1LjY0MSAxMTQuMDI1LDc1Ljc5OCAxMTQuMDI1LDc1Ljk5MiBMMTE0LjAyNSwxMjkuOTkzIEMxMTQuMDI1LDEzMC42NDggMTEzLjc4NiwxMzEuMTQ3IDExMy4zNSwxMzEuMzk5IEMxMTMuMTYyLDEzMS41MDcgMTEyLjk1MiwxMzEuNTYxIDExMi43MjcsMTMxLjU2MSIgaWQ9IkZpbGwtMjkiIGZpbGw9IiM0NTVBNjQiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTEyLjg2LDQwLjUxMiBDMTEyLjg2LDQwLjUxMiAxMTIuODYsNDAuNTEyIDExMi44NTksNDAuNTEyIEMxMTAuNTQxLDQwLjUxMiAxMDguMzYsMzkuOTkgMTA2LjcxNywzOS4wNDEgQzEwNS4wMTIsMzguMDU3IDEwNC4wNzQsMzYuNzI2IDEwNC4wNzQsMzUuMjkyIEMxMDQuMDc0LDMzLjg0NyAxMDUuMDI2LDMyLjUwMSAxMDYuNzU0LDMxLjUwNCBMMTE4Ljc5NSwyNC41NTEgQzEyMC40NjMsMjMuNTg5IDEyMi42NjksMjMuMDU4IDEyNS4wMDcsMjMuMDU4IEMxMjcuMzI1LDIzLjA1OCAxMjkuNTA2LDIzLjU4MSAxMzEuMTUsMjQuNTMgQzEzMi44NTQsMjUuNTE0IDEzMy43OTMsMjYuODQ1IDEzMy43OTMsMjguMjc4IEMxMzMuNzkzLDI5LjcyNCAxMzIuODQxLDMxLjA2OSAxMzEuMTEzLDMyLjA2NyBMMTE5LjA3MSwzOS4wMTkgQzExNy40MDMsMzkuOTgyIDExNS4xOTcsNDAuNTEyIDExMi44Niw0MC41MTIgTDExMi44Niw0MC41MTIgWiBNMTI1LjAwNywyMy43NTkgQzEyMi43OSwyMy43NTkgMTIwLjcwOSwyNC4yNTYgMTE5LjE0NiwyNS4xNTggTDEwNy4xMDQsMzIuMTEgQzEwNS42MDIsMzIuOTc4IDEwNC43NzQsMzQuMTA4IDEwNC43NzQsMzUuMjkyIEMxMDQuNzc0LDM2LjQ2NSAxMDUuNTg5LDM3LjU4MSAxMDcuMDY3LDM4LjQzNCBDMTA4LjYwNSwzOS4zMjMgMTEwLjY2MywzOS44MTIgMTEyLjg1OSwzOS44MTIgTDExMi44NiwzOS44MTIgQzExNS4wNzYsMzkuODEyIDExNy4xNTgsMzkuMzE1IDExOC43MjEsMzguNDEzIEwxMzAuNzYyLDMxLjQ2IEMxMzIuMjY0LDMwLjU5MyAxMzMuMDkyLDI5LjQ2MyAxMzMuMDkyLDI4LjI3OCBDMTMzLjA5MiwyNy4xMDYgMTMyLjI3OCwyNS45OSAxMzAuOCwyNS4xMzYgQzEyOS4yNjEsMjQuMjQ4IDEyNy4yMDQsMjMuNzU5IDEyNS4wMDcsMjMuNzU5IEwxMjUuMDA3LDIzLjc1OSBaIiBpZD0iRmlsbC0zMCIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNjUuNjMsMTYuMjE5IEwxNTkuODk2LDE5LjUzIEMxNTYuNzI5LDIxLjM1OCAxNTEuNjEsMjEuMzY3IDE0OC40NjMsMTkuNTUgQzE0NS4zMTYsMTcuNzMzIDE0NS4zMzIsMTQuNzc4IDE0OC40OTksMTIuOTQ5IEwxNTQuMjMzLDkuNjM5IEwxNjUuNjMsMTYuMjE5IiBpZD0iRmlsbC0zMSIgZmlsbD0iI0ZBRkFGQSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNTQuMjMzLDEwLjQ0OCBMMTY0LjIyOCwxNi4yMTkgTDE1OS41NDYsMTguOTIzIEMxNTguMTEyLDE5Ljc1IDE1Ni4xOTQsMjAuMjA2IDE1NC4xNDcsMjAuMjA2IEMxNTIuMTE4LDIwLjIwNiAxNTAuMjI0LDE5Ljc1NyAxNDguODE0LDE4Ljk0MyBDMTQ3LjUyNCwxOC4xOTkgMTQ2LjgxNCwxNy4yNDkgMTQ2LjgxNCwxNi4yNjkgQzE0Ni44MTQsMTUuMjc4IDE0Ny41MzcsMTQuMzE0IDE0OC44NSwxMy41NTYgTDE1NC4yMzMsMTAuNDQ4IE0xNTQuMjMzLDkuNjM5IEwxNDguNDk5LDEyLjk0OSBDMTQ1LjMzMiwxNC43NzggMTQ1LjMxNiwxNy43MzMgMTQ4LjQ2MywxOS41NSBDMTUwLjAzMSwyMC40NTUgMTUyLjA4NiwyMC45MDcgMTU0LjE0NywyMC45MDcgQzE1Ni4yMjQsMjAuOTA3IDE1OC4zMDYsMjAuNDQ3IDE1OS44OTYsMTkuNTMgTDE2NS42MywxNi4yMTkgTDE1NC4yMzMsOS42MzkiIGlkPSJGaWxsLTMyIiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0NS40NDUsNzIuNjY3IEwxNDUuNDQ1LDcyLjY2NyBDMTQzLjY3Miw3Mi42NjcgMTQyLjIwNCw3MS44MTcgMTQxLjIwMiw3MC40MjIgQzE0MS4xMzUsNzAuMzMgMTQxLjE0NSw3MC4xNDcgMTQxLjIyNSw3MC4wNjYgQzE0MS4zMDUsNjkuOTg1IDE0MS40MzIsNjkuOTQ2IDE0MS41MjUsNzAuMDExIEMxNDIuMzA2LDcwLjU1OSAxNDMuMjMxLDcwLjgyMyAxNDQuMjc2LDcwLjgyMiBDMTQ1LjU5OCw3MC44MjIgMTQ3LjAzLDcwLjM3NiAxNDguNTMyLDY5LjUwOSBDMTUzLjg0Miw2Ni40NDMgMTU4LjE2Myw1OC45ODcgMTU4LjE2Myw1Mi44OTQgQzE1OC4xNjMsNTAuOTY3IDE1Ny43MjEsNDkuMzMyIDE1Ni44ODQsNDguMTY4IEMxNTYuODE4LDQ4LjA3NiAxNTYuODI4LDQ3Ljk0OCAxNTYuOTA4LDQ3Ljg2NyBDMTU2Ljk4OCw0Ny43ODYgMTU3LjExNCw0Ny43NzQgMTU3LjIwOCw0Ny44NCBDMTU4Ljg3OCw0OS4wMTIgMTU5Ljc5OCw1MS4yMiAxNTkuNzk4LDU0LjA1OSBDMTU5Ljc5OCw2MC4zMDEgMTU1LjM3Myw2OC4wNDYgMTQ5LjkzMyw3MS4xODYgQzE0OC4zNiw3Mi4wOTQgMTQ2Ljg1LDcyLjY2NyAxNDUuNDQ1LDcyLjY2NyBMMTQ1LjQ0NSw3Mi42NjcgWiBNMTQyLjQ3Niw3MSBDMTQzLjI5LDcxLjY1MSAxNDQuMjk2LDcyLjAwMiAxNDUuNDQ1LDcyLjAwMiBDMTQ2Ljc2Nyw3Mi4wMDIgMTQ4LjE5OCw3MS41NSAxNDkuNyw3MC42ODIgQzE1NS4wMSw2Ny42MTcgMTU5LjMzMSw2MC4xNTkgMTU5LjMzMSw1NC4wNjUgQzE1OS4zMzEsNTIuMDg1IDE1OC44NjgsNTAuNDM1IDE1OC4wMDYsNDkuMjcyIEMxNTguNDE3LDUwLjMwNyAxNTguNjMsNTEuNTMyIDE1OC42Myw1Mi44OTIgQzE1OC42Myw1OS4xMzQgMTU0LjIwNSw2Ni43NjcgMTQ4Ljc2NSw2OS45MDcgQzE0Ny4xOTIsNzAuODE2IDE0NS42ODEsNzEuMjgzIDE0NC4yNzYsNzEuMjgzIEMxNDMuNjM0LDcxLjI4MyAxNDMuMDMzLDcxLjE5MiAxNDIuNDc2LDcxIEwxNDIuNDc2LDcxIFoiIGlkPSJGaWxsLTMzIiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0OC42NDgsNjkuNzA0IEMxNTQuMDMyLDY2LjU5NiAxNTguMzk2LDU5LjA2OCAxNTguMzk2LDUyLjg5MSBDMTU4LjM5Niw1MC44MzkgMTU3LjkxMyw0OS4xOTggMTU3LjA3NCw0OC4wMyBDMTU1LjI4OSw0Ni43NzggMTUyLjY5OSw0Ni44MzYgMTQ5LjgxNiw0OC41MDEgQzE0NC40MzMsNTEuNjA5IDE0MC4wNjgsNTkuMTM3IDE0MC4wNjgsNjUuMzE0IEMxNDAuMDY4LDY3LjM2NSAxNDAuNTUyLDY5LjAwNiAxNDEuMzkxLDcwLjE3NCBDMTQzLjE3Niw3MS40MjcgMTQ1Ljc2NSw3MS4zNjkgMTQ4LjY0OCw2OS43MDQiIGlkPSJGaWxsLTM0IiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0NC4yNzYsNzEuMjc2IEwxNDQuMjc2LDcxLjI3NiBDMTQzLjEzMyw3MS4yNzYgMTQyLjExOCw3MC45NjkgMTQxLjI1Nyw3MC4zNjUgQzE0MS4yMzYsNzAuMzUxIDE0MS4yMTcsNzAuMzMyIDE0MS4yMDIsNzAuMzExIEMxNDAuMzA3LDY5LjA2NyAxMzkuODM1LDY3LjMzOSAxMzkuODM1LDY1LjMxNCBDMTM5LjgzNSw1OS4wNzMgMTQ0LjI2LDUxLjQzOSAxNDkuNyw0OC4yOTggQzE1MS4yNzMsNDcuMzkgMTUyLjc4NCw0Ni45MjkgMTU0LjE4OSw0Ni45MjkgQzE1NS4zMzIsNDYuOTI5IDE1Ni4zNDcsNDcuMjM2IDE1Ny4yMDgsNDcuODM5IEMxNTcuMjI5LDQ3Ljg1NCAxNTcuMjQ4LDQ3Ljg3MyAxNTcuMjYzLDQ3Ljg5NCBDMTU4LjE1Nyw0OS4xMzggMTU4LjYzLDUwLjg2NSAxNTguNjMsNTIuODkxIEMxNTguNjMsNTkuMTMyIDE1NC4yMDUsNjYuNzY2IDE0OC43NjUsNjkuOTA3IEMxNDcuMTkyLDcwLjgxNSAxNDUuNjgxLDcxLjI3NiAxNDQuMjc2LDcxLjI3NiBMMTQ0LjI3Niw3MS4yNzYgWiBNMTQxLjU1OCw3MC4xMDQgQzE0Mi4zMzEsNzAuNjM3IDE0My4yNDUsNzEuMDA1IDE0NC4yNzYsNzEuMDA1IEMxNDUuNTk4LDcxLjAwNSAxNDcuMDMsNzAuNDY3IDE0OC41MzIsNjkuNiBDMTUzLjg0Miw2Ni41MzQgMTU4LjE2Myw1OS4wMzMgMTU4LjE2Myw1Mi45MzkgQzE1OC4xNjMsNTEuMDMxIDE1Ny43MjksNDkuMzg1IDE1Ni45MDcsNDguMjIzIEMxNTYuMTMzLDQ3LjY5MSAxNTUuMjE5LDQ3LjQwOSAxNTQuMTg5LDQ3LjQwOSBDMTUyLjg2Nyw0Ny40MDkgMTUxLjQzNSw0Ny44NDIgMTQ5LjkzMyw0OC43MDkgQzE0NC42MjMsNTEuNzc1IDE0MC4zMDIsNTkuMjczIDE0MC4zMDIsNjUuMzY2IEMxNDAuMzAyLDY3LjI3NiAxNDAuNzM2LDY4Ljk0MiAxNDEuNTU4LDcwLjEwNCBMMTQxLjU1OCw3MC4xMDQgWiIgaWQ9IkZpbGwtMzUiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTUwLjcyLDY1LjM2MSBMMTUwLjM1Nyw2NS4wNjYgQzE1MS4xNDcsNjQuMDkyIDE1MS44NjksNjMuMDQgMTUyLjUwNSw2MS45MzggQzE1My4zMTMsNjAuNTM5IDE1My45NzgsNTkuMDY3IDE1NC40ODIsNTcuNTYzIEwxNTQuOTI1LDU3LjcxMiBDMTU0LjQxMiw1OS4yNDUgMTUzLjczMyw2MC43NDUgMTUyLjkxLDYyLjE3MiBDMTUyLjI2Miw2My4yOTUgMTUxLjUyNSw2NC4zNjggMTUwLjcyLDY1LjM2MSIgaWQ9IkZpbGwtMzYiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTE1LjkxNyw4NC41MTQgTDExNS41NTQsODQuMjIgQzExNi4zNDQsODMuMjQ1IDExNy4wNjYsODIuMTk0IDExNy43MDIsODEuMDkyIEMxMTguNTEsNzkuNjkyIDExOS4xNzUsNzguMjIgMTE5LjY3OCw3Ni43MTcgTDEyMC4xMjEsNzYuODY1IEMxMTkuNjA4LDc4LjM5OCAxMTguOTMsNzkuODk5IDExOC4xMDYsODEuMzI2IEMxMTcuNDU4LDgyLjQ0OCAxMTYuNzIyLDgzLjUyMSAxMTUuOTE3LDg0LjUxNCIgaWQ9IkZpbGwtMzciIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTE0LDEzMC40NzYgTDExNCwxMzAuMDA4IEwxMTQsNzYuMDUyIEwxMTQsNzUuNTg0IEwxMTQsNzYuMDUyIEwxMTQsMTMwLjAwOCBMMTE0LDEzMC40NzYiIGlkPSJGaWxsLTM4IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iSW1wb3J0ZWQtTGF5ZXJzLUNvcHkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDYyLjAwMDAwMCwgMC4wMDAwMDApIiBza2V0Y2g6dHlwZT0iTVNTaGFwZUdyb3VwIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTkuODIyLDM3LjQ3NCBDMTkuODM5LDM3LjMzOSAxOS43NDcsMzcuMTk0IDE5LjU1NSwzNy4wODIgQzE5LjIyOCwzNi44OTQgMTguNzI5LDM2Ljg3MiAxOC40NDYsMzcuMDM3IEwxMi40MzQsNDAuNTA4IEMxMi4zMDMsNDAuNTg0IDEyLjI0LDQwLjY4NiAxMi4yNDMsNDAuNzkzIEMxMi4yNDUsNDAuOTI1IDEyLjI0NSw0MS4yNTQgMTIuMjQ1LDQxLjM3MSBMMTIuMjQ1LDQxLjQxNCBMMTIuMjM4LDQxLjU0MiBDOC4xNDgsNDMuODg3IDUuNjQ3LDQ1LjMyMSA1LjY0Nyw0NS4zMjEgQzUuNjQ2LDQ1LjMyMSAzLjU3LDQ2LjM2NyAyLjg2LDUwLjUxMyBDMi44Niw1MC41MTMgMS45NDgsNTcuNDc0IDEuOTYyLDcwLjI1OCBDMS45NzcsODIuODI4IDIuNTY4LDg3LjMyOCAzLjEyOSw5MS42MDkgQzMuMzQ5LDkzLjI5MyA2LjEzLDkzLjczNCA2LjEzLDkzLjczNCBDNi40NjEsOTMuNzc0IDYuODI4LDkzLjcwNyA3LjIxLDkzLjQ4NiBMODIuNDgzLDQ5LjkzNSBDODQuMjkxLDQ4Ljg2NiA4NS4xNSw0Ni4yMTYgODUuNTM5LDQzLjY1MSBDODYuNzUyLDM1LjY2MSA4Ny4yMTQsMTAuNjczIDg1LjI2NCwzLjc3MyBDODUuMDY4LDMuMDggODQuNzU0LDIuNjkgODQuMzk2LDIuNDkxIEw4Mi4zMSwxLjcwMSBDODEuNTgzLDEuNzI5IDgwLjg5NCwyLjE2OCA4MC43NzYsMi4yMzYgQzgwLjYzNiwyLjMxNyA0MS44MDcsMjQuNTg1IDIwLjAzMiwzNy4wNzIgTDE5LjgyMiwzNy40NzQiIGlkPSJGaWxsLTEiIGZpbGw9IiNGRkZGRkYiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNODIuMzExLDEuNzAxIEw4NC4zOTYsMi40OTEgQzg0Ljc1NCwyLjY5IDg1LjA2OCwzLjA4IDg1LjI2NCwzLjc3MyBDODcuMjEzLDEwLjY3MyA4Ni43NTEsMzUuNjYgODUuNTM5LDQzLjY1MSBDODUuMTQ5LDQ2LjIxNiA4NC4yOSw0OC44NjYgODIuNDgzLDQ5LjkzNSBMNy4yMSw5My40ODYgQzYuODk3LDkzLjY2NyA2LjU5NSw5My43NDQgNi4zMTQsOTMuNzQ0IEw2LjEzMSw5My43MzMgQzYuMTMxLDkzLjczNCAzLjM0OSw5My4yOTMgMy4xMjgsOTEuNjA5IEMyLjU2OCw4Ny4zMjcgMS45NzcsODIuODI4IDEuOTYzLDcwLjI1OCBDMS45NDgsNTcuNDc0IDIuODYsNTAuNTEzIDIuODYsNTAuNTEzIEMzLjU3LDQ2LjM2NyA1LjY0Nyw0NS4zMjEgNS42NDcsNDUuMzIxIEM1LjY0Nyw0NS4zMjEgOC4xNDgsNDMuODg3IDEyLjIzOCw0MS41NDIgTDEyLjI0NSw0MS40MTQgTDEyLjI0NSw0MS4zNzEgQzEyLjI0NSw0MS4yNTQgMTIuMjQ1LDQwLjkyNSAxMi4yNDMsNDAuNzkzIEMxMi4yNCw0MC42ODYgMTIuMzAyLDQwLjU4MyAxMi40MzQsNDAuNTA4IEwxOC40NDYsMzcuMDM2IEMxOC41NzQsMzYuOTYyIDE4Ljc0NiwzNi45MjYgMTguOTI3LDM2LjkyNiBDMTkuMTQ1LDM2LjkyNiAxOS4zNzYsMzYuOTc5IDE5LjU1NCwzNy4wODIgQzE5Ljc0NywzNy4xOTQgMTkuODM5LDM3LjM0IDE5LjgyMiwzNy40NzQgTDIwLjAzMywzNy4wNzIgQzQxLjgwNiwyNC41ODUgODAuNjM2LDIuMzE4IDgwLjc3NywyLjIzNiBDODAuODk0LDIuMTY4IDgxLjU4MywxLjcyOSA4Mi4zMTEsMS43MDEgTTgyLjMxMSwwLjcwNCBMODIuMjcyLDAuNzA1IEM4MS42NTQsMC43MjggODAuOTg5LDAuOTQ5IDgwLjI5OCwxLjM2MSBMODAuMjc3LDEuMzczIEM4MC4xMjksMS40NTggNTkuNzY4LDEzLjEzNSAxOS43NTgsMzYuMDc5IEMxOS41LDM1Ljk4MSAxOS4yMTQsMzUuOTI5IDE4LjkyNywzNS45MjkgQzE4LjU2MiwzNS45MjkgMTguMjIzLDM2LjAxMyAxNy45NDcsMzYuMTczIEwxMS45MzUsMzkuNjQ0IEMxMS40OTMsMzkuODk5IDExLjIzNiw0MC4zMzQgMTEuMjQ2LDQwLjgxIEwxMS4yNDcsNDAuOTYgTDUuMTY3LDQ0LjQ0NyBDNC43OTQsNDQuNjQ2IDIuNjI1LDQ1Ljk3OCAxLjg3Nyw1MC4zNDUgTDEuODcxLDUwLjM4NCBDMS44NjIsNTAuNDU0IDAuOTUxLDU3LjU1NyAwLjk2NSw3MC4yNTkgQzAuOTc5LDgyLjg3OSAxLjU2OCw4Ny4zNzUgMi4xMzcsOTEuNzI0IEwyLjEzOSw5MS43MzkgQzIuNDQ3LDk0LjA5NCA1LjYxNCw5NC42NjIgNS45NzUsOTQuNzE5IEw2LjAwOSw5NC43MjMgQzYuMTEsOTQuNzM2IDYuMjEzLDk0Ljc0MiA2LjMxNCw5NC43NDIgQzYuNzksOTQuNzQyIDcuMjYsOTQuNjEgNy43MSw5NC4zNSBMODIuOTgzLDUwLjc5OCBDODQuNzk0LDQ5LjcyNyA4NS45ODIsNDcuMzc1IDg2LjUyNSw0My44MDEgQzg3LjcxMSwzNS45ODcgODguMjU5LDEwLjcwNSA4Ni4yMjQsMy41MDIgQzg1Ljk3MSwyLjYwOSA4NS41MiwxLjk3NSA4NC44ODEsMS42MiBMODQuNzQ5LDEuNTU4IEw4Mi42NjQsMC43NjkgQzgyLjU1MSwwLjcyNSA4Mi40MzEsMC43MDQgODIuMzExLDAuNzA0IiBpZD0iRmlsbC0yIiBmaWxsPSIjNDU1QTY0Ij48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTY2LjI2NywxMS41NjUgTDY3Ljc2MiwxMS45OTkgTDExLjQyMyw0NC4zMjUiIGlkPSJGaWxsLTMiIGZpbGw9IiNGRkZGRkYiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTIuMjAyLDkwLjU0NSBDMTIuMDI5LDkwLjU0NSAxMS44NjIsOTAuNDU1IDExLjc2OSw5MC4yOTUgQzExLjYzMiw5MC4wNTcgMTEuNzEzLDg5Ljc1MiAxMS45NTIsODkuNjE0IEwzMC4zODksNzguOTY5IEMzMC42MjgsNzguODMxIDMwLjkzMyw3OC45MTMgMzEuMDcxLDc5LjE1MiBDMzEuMjA4LDc5LjM5IDMxLjEyNyw3OS42OTYgMzAuODg4LDc5LjgzMyBMMTIuNDUxLDkwLjQ3OCBMMTIuMjAyLDkwLjU0NSIgaWQ9IkZpbGwtNCIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMy43NjQsNDIuNjU0IEwxMy42NTYsNDIuNTkyIEwxMy43MDIsNDIuNDIxIEwxOC44MzcsMzkuNDU3IEwxOS4wMDcsMzkuNTAyIEwxOC45NjIsMzkuNjczIEwxMy44MjcsNDIuNjM3IEwxMy43NjQsNDIuNjU0IiBpZD0iRmlsbC01IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTguNTIsOTAuMzc1IEw4LjUyLDQ2LjQyMSBMOC41ODMsNDYuMzg1IEw3NS44NCw3LjU1NCBMNzUuODQsNTEuNTA4IEw3NS43NzgsNTEuNTQ0IEw4LjUyLDkwLjM3NSBMOC41Miw5MC4zNzUgWiBNOC43Nyw0Ni41NjQgTDguNzcsODkuOTQ0IEw3NS41OTEsNTEuMzY1IEw3NS41OTEsNy45ODUgTDguNzcsNDYuNTY0IEw4Ljc3LDQ2LjU2NCBaIiBpZD0iRmlsbC02IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTI0Ljk4Niw4My4xODIgQzI0Ljc1Niw4My4zMzEgMjQuMzc0LDgzLjU2NiAyNC4xMzcsODMuNzA1IEwxMi42MzIsOTAuNDA2IEMxMi4zOTUsOTAuNTQ1IDEyLjQyNiw5MC42NTggMTIuNyw5MC42NTggTDEzLjI2NSw5MC42NTggQzEzLjU0LDkwLjY1OCAxMy45NTgsOTAuNTQ1IDE0LjE5NSw5MC40MDYgTDI1LjcsODMuNzA1IEMyNS45MzcsODMuNTY2IDI2LjEyOCw4My40NTIgMjYuMTI1LDgzLjQ0OSBDMjYuMTIyLDgzLjQ0NyAyNi4xMTksODMuMjIgMjYuMTE5LDgyLjk0NiBDMjYuMTE5LDgyLjY3MiAyNS45MzEsODIuNTY5IDI1LjcwMSw4Mi43MTkgTDI0Ljk4Niw4My4xODIiIGlkPSJGaWxsLTciIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTMuMjY2LDkwLjc4MiBMMTIuNyw5MC43ODIgQzEyLjUsOTAuNzgyIDEyLjM4NCw5MC43MjYgMTIuMzU0LDkwLjYxNiBDMTIuMzI0LDkwLjUwNiAxMi4zOTcsOTAuMzk5IDEyLjU2OSw5MC4yOTkgTDI0LjA3NCw4My41OTcgQzI0LjMxLDgzLjQ1OSAyNC42ODksODMuMjI2IDI0LjkxOCw4My4wNzggTDI1LjYzMyw4Mi42MTQgQzI1LjcyMyw4Mi41NTUgMjUuODEzLDgyLjUyNSAyNS44OTksODIuNTI1IEMyNi4wNzEsODIuNTI1IDI2LjI0NCw4Mi42NTUgMjYuMjQ0LDgyLjk0NiBDMjYuMjQ0LDgzLjE2IDI2LjI0NSw4My4zMDkgMjYuMjQ3LDgzLjM4MyBMMjYuMjUzLDgzLjM4NyBMMjYuMjQ5LDgzLjQ1NiBDMjYuMjQ2LDgzLjUzMSAyNi4yNDYsODMuNTMxIDI1Ljc2Myw4My44MTIgTDE0LjI1OCw5MC41MTQgQzE0LDkwLjY2NSAxMy41NjQsOTAuNzgyIDEzLjI2Niw5MC43ODIgTDEzLjI2Niw5MC43ODIgWiBNMTIuNjY2LDkwLjUzMiBMMTIuNyw5MC41MzMgTDEzLjI2Niw5MC41MzMgQzEzLjUxOCw5MC41MzMgMTMuOTE1LDkwLjQyNSAxNC4xMzIsOTAuMjk5IEwyNS42MzcsODMuNTk3IEMyNS44MDUsODMuNDk5IDI1LjkzMSw4My40MjQgMjUuOTk4LDgzLjM4MyBDMjUuOTk0LDgzLjI5OSAyNS45OTQsODMuMTY1IDI1Ljk5NCw4Mi45NDYgTDI1Ljg5OSw4Mi43NzUgTDI1Ljc2OCw4Mi44MjQgTDI1LjA1NCw4My4yODcgQzI0LjgyMiw4My40MzcgMjQuNDM4LDgzLjY3MyAyNC4yLDgzLjgxMiBMMTIuNjk1LDkwLjUxNCBMMTIuNjY2LDkwLjUzMiBMMTIuNjY2LDkwLjUzMiBaIiBpZD0iRmlsbC04IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTEzLjI2Niw4OS44NzEgTDEyLjcsODkuODcxIEMxMi41LDg5Ljg3MSAxMi4zODQsODkuODE1IDEyLjM1NCw4OS43MDUgQzEyLjMyNCw4OS41OTUgMTIuMzk3LDg5LjQ4OCAxMi41NjksODkuMzg4IEwyNC4wNzQsODIuNjg2IEMyNC4zMzIsODIuNTM1IDI0Ljc2OCw4Mi40MTggMjUuMDY3LDgyLjQxOCBMMjUuNjMyLDgyLjQxOCBDMjUuODMyLDgyLjQxOCAyNS45NDgsODIuNDc0IDI1Ljk3OCw4Mi41ODQgQzI2LjAwOCw4Mi42OTQgMjUuOTM1LDgyLjgwMSAyNS43NjMsODIuOTAxIEwxNC4yNTgsODkuNjAzIEMxNCw4OS43NTQgMTMuNTY0LDg5Ljg3MSAxMy4yNjYsODkuODcxIEwxMy4yNjYsODkuODcxIFogTTEyLjY2Niw4OS42MjEgTDEyLjcsODkuNjIyIEwxMy4yNjYsODkuNjIyIEMxMy41MTgsODkuNjIyIDEzLjkxNSw4OS41MTUgMTQuMTMyLDg5LjM4OCBMMjUuNjM3LDgyLjY4NiBMMjUuNjY3LDgyLjY2OCBMMjUuNjMyLDgyLjY2NyBMMjUuMDY3LDgyLjY2NyBDMjQuODE1LDgyLjY2NyAyNC40MTgsODIuNzc1IDI0LjIsODIuOTAxIEwxMi42OTUsODkuNjAzIEwxMi42NjYsODkuNjIxIEwxMi42NjYsODkuNjIxIFoiIGlkPSJGaWxsLTkiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTIuMzcsOTAuODAxIEwxMi4zNyw4OS41NTQgTDEyLjM3LDkwLjgwMSIgaWQ9IkZpbGwtMTAiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNi4xMyw5My45MDEgQzUuMzc5LDkzLjgwOCA0LjgxNiw5My4xNjQgNC42OTEsOTIuNTI1IEMzLjg2LDg4LjI4NyAzLjU0LDgzLjc0MyAzLjUyNiw3MS4xNzMgQzMuNTExLDU4LjM4OSA0LjQyMyw1MS40MjggNC40MjMsNTEuNDI4IEM1LjEzNCw0Ny4yODIgNy4yMSw0Ni4yMzYgNy4yMSw0Ni4yMzYgQzcuMjEsNDYuMjM2IDgxLjY2NywzLjI1IDgyLjA2OSwzLjAxNyBDODIuMjkyLDIuODg4IDg0LjU1NiwxLjQzMyA4NS4yNjQsMy45NCBDODcuMjE0LDEwLjg0IDg2Ljc1MiwzNS44MjcgODUuNTM5LDQzLjgxOCBDODUuMTUsNDYuMzgzIDg0LjI5MSw0OS4wMzMgODIuNDgzLDUwLjEwMSBMNy4yMSw5My42NTMgQzYuODI4LDkzLjg3NCA2LjQ2MSw5My45NDEgNi4xMyw5My45MDEgQzYuMTMsOTMuOTAxIDMuMzQ5LDkzLjQ2IDMuMTI5LDkxLjc3NiBDMi41NjgsODcuNDk1IDEuOTc3LDgyLjk5NSAxLjk2Miw3MC40MjUgQzEuOTQ4LDU3LjY0MSAyLjg2LDUwLjY4IDIuODYsNTAuNjggQzMuNTcsNDYuNTM0IDUuNjQ3LDQ1LjQ4OSA1LjY0Nyw0NS40ODkgQzUuNjQ2LDQ1LjQ4OSA4LjA2NSw0NC4wOTIgMTIuMjQ1LDQxLjY3OSBMMTMuMTE2LDQxLjU2IEwxOS43MTUsMzcuNzMgTDE5Ljc2MSwzNy4yNjkgTDYuMTMsOTMuOTAxIiBpZD0iRmlsbC0xMSIgZmlsbD0iI0ZBRkFGQSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik02LjMxNyw5NC4xNjEgTDYuMTAyLDk0LjE0OCBMNi4xMDEsOTQuMTQ4IEw1Ljg1Nyw5NC4xMDEgQzUuMTM4LDkzLjk0NSAzLjA4NSw5My4zNjUgMi44ODEsOTEuODA5IEMyLjMxMyw4Ny40NjkgMS43MjcsODIuOTk2IDEuNzEzLDcwLjQyNSBDMS42OTksNTcuNzcxIDIuNjA0LDUwLjcxOCAyLjYxMyw1MC42NDggQzMuMzM4LDQ2LjQxNyA1LjQ0NSw0NS4zMSA1LjUzNSw0NS4yNjYgTDEyLjE2Myw0MS40MzkgTDEzLjAzMyw0MS4zMiBMMTkuNDc5LDM3LjU3OCBMMTkuNTEzLDM3LjI0NCBDMTkuNTI2LDM3LjEwNyAxOS42NDcsMzcuMDA4IDE5Ljc4NiwzNy4wMjEgQzE5LjkyMiwzNy4wMzQgMjAuMDIzLDM3LjE1NiAyMC4wMDksMzcuMjkzIEwxOS45NSwzNy44ODIgTDEzLjE5OCw0MS44MDEgTDEyLjMyOCw0MS45MTkgTDUuNzcyLDQ1LjcwNCBDNS43NDEsNDUuNzIgMy43ODIsNDYuNzcyIDMuMTA2LDUwLjcyMiBDMy4wOTksNTAuNzgyIDIuMTk4LDU3LjgwOCAyLjIxMiw3MC40MjQgQzIuMjI2LDgyLjk2MyAyLjgwOSw4Ny40MiAzLjM3Myw5MS43MjkgQzMuNDY0LDkyLjQyIDQuMDYyLDkyLjg4MyA0LjY4Miw5My4xODEgQzQuNTY2LDkyLjk4NCA0LjQ4Niw5Mi43NzYgNC40NDYsOTIuNTcyIEMzLjY2NSw4OC41ODggMy4yOTEsODQuMzcgMy4yNzYsNzEuMTczIEMzLjI2Miw1OC41MiA0LjE2Nyw1MS40NjYgNC4xNzYsNTEuMzk2IEM0LjkwMSw0Ny4xNjUgNy4wMDgsNDYuMDU5IDcuMDk4LDQ2LjAxNCBDNy4wOTQsNDYuMDE1IDgxLjU0MiwzLjAzNCA4MS45NDQsMi44MDIgTDgxLjk3MiwyLjc4NSBDODIuODc2LDIuMjQ3IDgzLjY5MiwyLjA5NyA4NC4zMzIsMi4zNTIgQzg0Ljg4NywyLjU3MyA4NS4yODEsMy4wODUgODUuNTA0LDMuODcyIEM4Ny41MTgsMTEgODYuOTY0LDM2LjA5MSA4NS43ODUsNDMuODU1IEM4NS4yNzgsNDcuMTk2IDg0LjIxLDQ5LjM3IDgyLjYxLDUwLjMxNyBMNy4zMzUsOTMuODY5IEM2Ljk5OSw5NC4wNjMgNi42NTgsOTQuMTYxIDYuMzE3LDk0LjE2MSBMNi4zMTcsOTQuMTYxIFogTTYuMTcsOTMuNjU0IEM2LjQ2Myw5My42OSA2Ljc3NCw5My42MTcgNy4wODUsOTMuNDM3IEw4Mi4zNTgsNDkuODg2IEM4NC4xODEsNDguODA4IDg0Ljk2LDQ1Ljk3MSA4NS4yOTIsNDMuNzggQzg2LjQ2NiwzNi4wNDkgODcuMDIzLDExLjA4NSA4NS4wMjQsNC4wMDggQzg0Ljg0NiwzLjM3NyA4NC41NTEsMi45NzYgODQuMTQ4LDIuODE2IEM4My42NjQsMi42MjMgODIuOTgyLDIuNzY0IDgyLjIyNywzLjIxMyBMODIuMTkzLDMuMjM0IEM4MS43OTEsMy40NjYgNy4zMzUsNDYuNDUyIDcuMzM1LDQ2LjQ1MiBDNy4zMDQsNDYuNDY5IDUuMzQ2LDQ3LjUyMSA0LjY2OSw1MS40NzEgQzQuNjYyLDUxLjUzIDMuNzYxLDU4LjU1NiAzLjc3NSw3MS4xNzMgQzMuNzksODQuMzI4IDQuMTYxLDg4LjUyNCA0LjkzNiw5Mi40NzYgQzUuMDI2LDkyLjkzNyA1LjQxMiw5My40NTkgNS45NzMsOTMuNjE1IEM2LjA4Nyw5My42NCA2LjE1OCw5My42NTIgNi4xNjksOTMuNjU0IEw2LjE3LDkzLjY1NCBMNi4xNyw5My42NTQgWiIgaWQ9IkZpbGwtMTIiIGZpbGw9IiM0NTVBNjQiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNy4zMTcsNjguOTgyIEM3LjgwNiw2OC43MDEgOC4yMDIsNjguOTI2IDguMjAyLDY5LjQ4NyBDOC4yMDIsNzAuMDQ3IDcuODA2LDcwLjczIDcuMzE3LDcxLjAxMiBDNi44MjksNzEuMjk0IDYuNDMzLDcxLjA2OSA2LjQzMyw3MC41MDggQzYuNDMzLDY5Ljk0OCA2LjgyOSw2OS4yNjUgNy4zMTcsNjguOTgyIiBpZD0iRmlsbC0xMyIgZmlsbD0iI0ZGRkZGRiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik02LjkyLDcxLjEzMyBDNi42MzEsNzEuMTMzIDYuNDMzLDcwLjkwNSA2LjQzMyw3MC41MDggQzYuNDMzLDY5Ljk0OCA2LjgyOSw2OS4yNjUgNy4zMTcsNjguOTgyIEM3LjQ2LDY4LjkgNy41OTUsNjguODYxIDcuNzE0LDY4Ljg2MSBDOC4wMDMsNjguODYxIDguMjAyLDY5LjA5IDguMjAyLDY5LjQ4NyBDOC4yMDIsNzAuMDQ3IDcuODA2LDcwLjczIDcuMzE3LDcxLjAxMiBDNy4xNzQsNzEuMDk0IDcuMDM5LDcxLjEzMyA2LjkyLDcxLjEzMyBNNy43MTQsNjguNjc0IEM3LjU1Nyw2OC42NzQgNy4zOTIsNjguNzIzIDcuMjI0LDY4LjgyMSBDNi42NzYsNjkuMTM4IDYuMjQ2LDY5Ljg3OSA2LjI0Niw3MC41MDggQzYuMjQ2LDcwLjk5NCA2LjUxNyw3MS4zMiA2LjkyLDcxLjMyIEM3LjA3OCw3MS4zMiA3LjI0Myw3MS4yNzEgNy40MTEsNzEuMTc0IEM3Ljk1OSw3MC44NTcgOC4zODksNzAuMTE3IDguMzg5LDY5LjQ4NyBDOC4zODksNjkuMDAxIDguMTE3LDY4LjY3NCA3LjcxNCw2OC42NzQiIGlkPSJGaWxsLTE0IiBmaWxsPSIjODA5N0EyIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTYuOTIsNzAuOTQ3IEM2LjY0OSw3MC45NDcgNi42MjEsNzAuNjQgNi42MjEsNzAuNTA4IEM2LjYyMSw3MC4wMTcgNi45ODIsNjkuMzkyIDcuNDExLDY5LjE0NSBDNy41MjEsNjkuMDgyIDcuNjI1LDY5LjA0OSA3LjcxNCw2OS4wNDkgQzcuOTg2LDY5LjA0OSA4LjAxNSw2OS4zNTUgOC4wMTUsNjkuNDg3IEM4LjAxNSw2OS45NzggNy42NTIsNzAuNjAzIDcuMjI0LDcwLjg1MSBDNy4xMTUsNzAuOTE0IDcuMDEsNzAuOTQ3IDYuOTIsNzAuOTQ3IE03LjcxNCw2OC44NjEgQzcuNTk1LDY4Ljg2MSA3LjQ2LDY4LjkgNy4zMTcsNjguOTgyIEM2LjgyOSw2OS4yNjUgNi40MzMsNjkuOTQ4IDYuNDMzLDcwLjUwOCBDNi40MzMsNzAuOTA1IDYuNjMxLDcxLjEzMyA2LjkyLDcxLjEzMyBDNy4wMzksNzEuMTMzIDcuMTc0LDcxLjA5NCA3LjMxNyw3MS4wMTIgQzcuODA2LDcwLjczIDguMjAyLDcwLjA0NyA4LjIwMiw2OS40ODcgQzguMjAyLDY5LjA5IDguMDAzLDY4Ljg2MSA3LjcxNCw2OC44NjEiIGlkPSJGaWxsLTE1IiBmaWxsPSIjODA5N0EyIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTcuNDQ0LDg1LjM1IEM3LjcwOCw4NS4xOTggNy45MjEsODUuMzE5IDcuOTIxLDg1LjYyMiBDNy45MjEsODUuOTI1IDcuNzA4LDg2LjI5MiA3LjQ0NCw4Ni40NDQgQzcuMTgxLDg2LjU5NyA2Ljk2Nyw4Ni40NzUgNi45NjcsODYuMTczIEM2Ljk2Nyw4NS44NzEgNy4xODEsODUuNTAyIDcuNDQ0LDg1LjM1IiBpZD0iRmlsbC0xNiIgZmlsbD0iI0ZGRkZGRiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik03LjIzLDg2LjUxIEM3LjA3NCw4Ni41MSA2Ljk2Nyw4Ni4zODcgNi45NjcsODYuMTczIEM2Ljk2Nyw4NS44NzEgNy4xODEsODUuNTAyIDcuNDQ0LDg1LjM1IEM3LjUyMSw4NS4zMDUgNy41OTQsODUuMjg0IDcuNjU4LDg1LjI4NCBDNy44MTQsODUuMjg0IDcuOTIxLDg1LjQwOCA3LjkyMSw4NS42MjIgQzcuOTIxLDg1LjkyNSA3LjcwOCw4Ni4yOTIgNy40NDQsODYuNDQ0IEM3LjM2Nyw4Ni40ODkgNy4yOTQsODYuNTEgNy4yMyw4Ni41MSBNNy42NTgsODUuMDk4IEM3LjU1OCw4NS4wOTggNy40NTUsODUuMTI3IDcuMzUxLDg1LjE4OCBDNy4wMzEsODUuMzczIDYuNzgxLDg1LjgwNiA2Ljc4MSw4Ni4xNzMgQzYuNzgxLDg2LjQ4MiA2Ljk2Niw4Ni42OTcgNy4yMyw4Ni42OTcgQzcuMzMsODYuNjk3IDcuNDMzLDg2LjY2NiA3LjUzOCw4Ni42MDcgQzcuODU4LDg2LjQyMiA4LjEwOCw4NS45ODkgOC4xMDgsODUuNjIyIEM4LjEwOCw4NS4zMTMgNy45MjMsODUuMDk4IDcuNjU4LDg1LjA5OCIgaWQ9IkZpbGwtMTciIGZpbGw9IiM4MDk3QTIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNy4yMyw4Ni4zMjIgTDcuMTU0LDg2LjE3MyBDNy4xNTQsODUuOTM4IDcuMzMzLDg1LjYyOSA3LjUzOCw4NS41MTIgTDcuNjU4LDg1LjQ3MSBMNy43MzQsODUuNjIyIEM3LjczNCw4NS44NTYgNy41NTUsODYuMTY0IDcuMzUxLDg2LjI4MiBMNy4yMyw4Ni4zMjIgTTcuNjU4LDg1LjI4NCBDNy41OTQsODUuMjg0IDcuNTIxLDg1LjMwNSA3LjQ0NCw4NS4zNSBDNy4xODEsODUuNTAyIDYuOTY3LDg1Ljg3MSA2Ljk2Nyw4Ni4xNzMgQzYuOTY3LDg2LjM4NyA3LjA3NCw4Ni41MSA3LjIzLDg2LjUxIEM3LjI5NCw4Ni41MSA3LjM2Nyw4Ni40ODkgNy40NDQsODYuNDQ0IEM3LjcwOCw4Ni4yOTIgNy45MjEsODUuOTI1IDcuOTIxLDg1LjYyMiBDNy45MjEsODUuNDA4IDcuODE0LDg1LjI4NCA3LjY1OCw4NS4yODQiIGlkPSJGaWxsLTE4IiBmaWxsPSIjODA5N0EyIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTc3LjI3OCw3Ljc2OSBMNzcuMjc4LDUxLjQzNiBMMTAuMjA4LDkwLjE2IEwxMC4yMDgsNDYuNDkzIEw3Ny4yNzgsNy43NjkiIGlkPSJGaWxsLTE5IiBmaWxsPSIjNDU1QTY0Ij48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTEwLjA4Myw5MC4zNzUgTDEwLjA4Myw0Ni40MjEgTDEwLjE0Niw0Ni4zODUgTDc3LjQwMyw3LjU1NCBMNzcuNDAzLDUxLjUwOCBMNzcuMzQxLDUxLjU0NCBMMTAuMDgzLDkwLjM3NSBMMTAuMDgzLDkwLjM3NSBaIE0xMC4zMzMsNDYuNTY0IEwxMC4zMzMsODkuOTQ0IEw3Ny4xNTQsNTEuMzY1IEw3Ny4xNTQsNy45ODUgTDEwLjMzMyw0Ni41NjQgTDEwLjMzMyw0Ni41NjQgWiIgaWQ9IkZpbGwtMjAiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMjUuNzM3LDg4LjY0NyBMMTE4LjA5OCw5MS45ODEgTDExOC4wOTgsODQgTDEwNi42MzksODguNzEzIEwxMDYuNjM5LDk2Ljk4MiBMOTksMTAwLjMxNSBMMTEyLjM2OSwxMDMuOTYxIEwxMjUuNzM3LDg4LjY0NyIgaWQ9IkltcG9ydGVkLUxheWVycy1Db3B5LTIiIGZpbGw9IiM0NTVBNjQiIHNrZXRjaDp0eXBlPSJNU1NoYXBlR3JvdXAiPjwvcGF0aD4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+');
			};

			module.exports = RotateInstructions;


			/***/
}),
/* 20 */
/***/ (function (module, exports, __webpack_require__) {

			/*
			 * Copyright 2015 Google Inc. All Rights Reserved.
			 * Licensed under the Apache License, Version 2.0 (the "License");
			 * you may not use this file except in compliance with the License.
			 * You may obtain a copy of the License at
			 *
			 *     http://www.apache.org/licenses/LICENSE-2.0
			 *
			 * Unless required by applicable law or agreed to in writing, software
			 * distributed under the License is distributed on an "AS IS" BASIS,
			 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
			 * See the License for the specific language governing permissions and
			 * limitations under the License.
			 */

			var DeviceInfo = __webpack_require__(5);
			var Util = __webpack_require__(0);

			var DEFAULT_VIEWER = 'CardboardV1';
			var VIEWER_KEY = 'WEBVR_CARDBOARD_VIEWER';
			var CLASS_NAME = 'webvr-polyfill-viewer-selector';

			/**
			 * Creates a viewer selector with the options specified. Supports being shown
			 * and hidden. Generates events when viewer parameters change. Also supports
			 * saving the currently selected index in localStorage.
			 */
			function ViewerSelector() {
				// Try to load the selected key from local storage.
				try {
					this.selectedKey = localStorage.getItem(VIEWER_KEY);
				} catch (error) {
					console.error('Failed to load viewer profile: %s', error);
				}

				//If none exists, or if localstorage is unavailable, use the default key.
				if (!this.selectedKey) {
					this.selectedKey = DEFAULT_VIEWER;
				}

				this.dialog = this.createDialog_(DeviceInfo.Viewers);
				this.root = null;
				this.onChangeCallbacks_ = [];
			}

			ViewerSelector.prototype.show = function (root) {
				this.root = root;

				root.appendChild(this.dialog);

				// Ensure the currently selected item is checked.
				var selected = this.dialog.querySelector('#' + this.selectedKey);
				selected.checked = true;

				// Show the UI.
				this.dialog.style.display = 'block';
			};

			ViewerSelector.prototype.hide = function () {
				if (this.root && this.root.contains(this.dialog)) {
					this.root.removeChild(this.dialog);
				}
				this.dialog.style.display = 'none';
			};

			ViewerSelector.prototype.getCurrentViewer = function () {
				return DeviceInfo.Viewers[this.selectedKey];
			};

			ViewerSelector.prototype.getSelectedKey_ = function () {
				var input = this.dialog.querySelector('input[name=field]:checked');
				if (input) {
					return input.id;
				}
				return null;
			};

			ViewerSelector.prototype.onChange = function (cb) {
				this.onChangeCallbacks_.push(cb);
			};

			ViewerSelector.prototype.fireOnChange_ = function (viewer) {
				for (var i = 0; i < this.onChangeCallbacks_.length; i++) {
					this.onChangeCallbacks_[i](viewer);
				}
			};

			ViewerSelector.prototype.onSave_ = function () {
				this.selectedKey = this.getSelectedKey_();
				if (!this.selectedKey || !DeviceInfo.Viewers[this.selectedKey]) {
					console.error('ViewerSelector.onSave_: this should never happen!');
					return;
				}

				this.fireOnChange_(DeviceInfo.Viewers[this.selectedKey]);

				// Attempt to save the viewer profile, but fails in private mode.
				try {
					localStorage.setItem(VIEWER_KEY, this.selectedKey);
				} catch (error) {
					console.error('Failed to save viewer profile: %s', error);
				}
				this.hide();
			};

			/**
			 * Creates the dialog.
			 */
			ViewerSelector.prototype.createDialog_ = function (options) {
				var container = document.createElement('div');
				container.classList.add(CLASS_NAME);
				container.style.display = 'none';
				// Create an overlay that dims the background, and which goes away when you
				// tap it.
				var overlay = document.createElement('div');
				var s = overlay.style;
				s.position = 'fixed';
				s.left = 0;
				s.top = 0;
				s.width = '100%';
				s.height = '100%';
				s.background = 'rgba(0, 0, 0, 0.3)';
				overlay.addEventListener('click', this.hide.bind(this));

				var width = 280;
				var dialog = document.createElement('div');
				var s = dialog.style;
				s.boxSizing = 'border-box';
				s.position = 'fixed';
				s.top = '24px';
				s.left = '50%';
				s.marginLeft = (-width / 2) + 'px';
				s.width = width + 'px';
				s.padding = '24px';
				s.overflow = 'hidden';
				s.background = '#fafafa';
				s.fontFamily = "'Roboto', sans-serif";
				s.boxShadow = '0px 5px 20px #666';

				dialog.appendChild(this.createH1_('Select your viewer'));
				for (var id in options) {
					dialog.appendChild(this.createChoice_(id, options[id].label));
				}
				dialog.appendChild(this.createButton_('Save', this.onSave_.bind(this)));

				container.appendChild(overlay);
				container.appendChild(dialog);

				return container;
			};

			ViewerSelector.prototype.createH1_ = function (name) {
				var h1 = document.createElement('h1');
				var s = h1.style;
				s.color = 'black';
				s.fontSize = '20px';
				s.fontWeight = 'bold';
				s.marginTop = 0;
				s.marginBottom = '24px';
				h1.innerHTML = name;
				return h1;
			};

			ViewerSelector.prototype.createChoice_ = function (id, name) {
				/*
				<div class="choice">
				<input id="v1" type="radio" name="field" value="v1">
				<label for="v1">Cardboard V1</label>
				</div>
				*/
				var div = document.createElement('div');
				div.style.marginTop = '8px';
				div.style.color = 'black';

				var input = document.createElement('input');
				input.style.fontSize = '30px';
				input.setAttribute('id', id);
				input.setAttribute('type', 'radio');
				input.setAttribute('value', id);
				input.setAttribute('name', 'field');

				var label = document.createElement('label');
				label.style.marginLeft = '4px';
				label.setAttribute('for', id);
				label.innerHTML = name;

				div.appendChild(input);
				div.appendChild(label);

				return div;
			};

			ViewerSelector.prototype.createButton_ = function (label, onclick) {
				var button = document.createElement('button');
				button.innerHTML = label;
				var s = button.style;
				s.float = 'right';
				s.textTransform = 'uppercase';
				s.color = '#1094f7';
				s.fontSize = '14px';
				s.letterSpacing = 0;
				s.border = 0;
				s.background = 'none';
				s.marginTop = '16px';

				button.addEventListener('click', onclick);

				return button;
			};

			module.exports = ViewerSelector;


			/***/
}),
/* 21 */
/***/ (function (module, exports, __webpack_require__) {

			/*
			 * Copyright 2015 Google Inc. All Rights Reserved.
			 * Licensed under the Apache License, Version 2.0 (the "License");
			 * you may not use this file except in compliance with the License.
			 * You may obtain a copy of the License at
			 *
			 *     http://www.apache.org/licenses/LICENSE-2.0
			 *
			 * Unless required by applicable law or agreed to in writing, software
			 * distributed under the License is distributed on an "AS IS" BASIS,
			 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
			 * See the License for the specific language governing permissions and
			 * limitations under the License.
			 */

			var Util = __webpack_require__(0);

			/**
			 * Android and iOS compatible wakelock implementation.
			 *
			 * Refactored thanks to dkovalev@.
			 */
			function AndroidWakeLock() {
				var video = document.createElement('video');
				video.setAttribute('loop', '');

				function addSourceToVideo(element, type, dataURI) {
					var source = document.createElement('source');
					source.src = dataURI;
					source.type = 'video/' + type;
					element.appendChild(source);
				}

				addSourceToVideo(video, 'webm', Util.base64('video/webm', 'GkXfo0AgQoaBAUL3gQFC8oEEQvOBCEKCQAR3ZWJtQoeBAkKFgQIYU4BnQI0VSalmQCgq17FAAw9CQE2AQAZ3aGFtbXlXQUAGd2hhbW15RIlACECPQAAAAAAAFlSua0AxrkAu14EBY8WBAZyBACK1nEADdW5khkAFVl9WUDglhohAA1ZQOIOBAeBABrCBCLqBCB9DtnVAIueBAKNAHIEAAIAwAQCdASoIAAgAAUAmJaQAA3AA/vz0AAA='));
				addSourceToVideo(video, 'mp4', Util.base64('video/mp4', 'AAAAHGZ0eXBpc29tAAACAGlzb21pc28ybXA0MQAAAAhmcmVlAAAAG21kYXQAAAGzABAHAAABthADAowdbb9/AAAC6W1vb3YAAABsbXZoZAAAAAB8JbCAfCWwgAAAA+gAAAAAAAEAAAEAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAIVdHJhawAAAFx0a2hkAAAAD3wlsIB8JbCAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAIAAAACAAAAAABsW1kaWEAAAAgbWRoZAAAAAB8JbCAfCWwgAAAA+gAAAAAVcQAAAAAAC1oZGxyAAAAAAAAAAB2aWRlAAAAAAAAAAAAAAAAVmlkZW9IYW5kbGVyAAAAAVxtaW5mAAAAFHZtaGQAAAABAAAAAAAAAAAAAAAkZGluZgAAABxkcmVmAAAAAAAAAAEAAAAMdXJsIAAAAAEAAAEcc3RibAAAALhzdHNkAAAAAAAAAAEAAACobXA0dgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIAAgASAAAAEgAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABj//wAAAFJlc2RzAAAAAANEAAEABDwgEQAAAAADDUAAAAAABS0AAAGwAQAAAbWJEwAAAQAAAAEgAMSNiB9FAEQBFGMAAAGyTGF2YzUyLjg3LjQGAQIAAAAYc3R0cwAAAAAAAAABAAAAAQAAAAAAAAAcc3RzYwAAAAAAAAABAAAAAQAAAAEAAAABAAAAFHN0c3oAAAAAAAAAEwAAAAEAAAAUc3RjbwAAAAAAAAABAAAALAAAAGB1ZHRhAAAAWG1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAAK2lsc3QAAAAjqXRvbwAAABtkYXRhAAAAAQAAAABMYXZmNTIuNzguMw=='));

				this.request = function () {
					if (video.paused) {
						video.play();
					}
				};

				this.release = function () {
					video.pause();
				};
			}

			function iOSWakeLock() {
				var timer = null;

				this.request = function () {
					if (!timer) {
						timer = setInterval(function () {
							window.location = window.location;
							setTimeout(window.stop, 0);
						}, 30000);
					}
				}

				this.release = function () {
					if (timer) {
						clearInterval(timer);
						timer = null;
					}
				}
			}


			function getWakeLock() {
				var userAgent = navigator.userAgent || navigator.vendor || window.opera;
				if (userAgent.match(/iPhone/i) || userAgent.match(/iPod/i)) {
					return iOSWakeLock;
				} else {
					return AndroidWakeLock;
				}
			}

			module.exports = getWakeLock();

			/***/
}),
/* 22 */
/***/ (function (module, exports, __webpack_require__) {

			/*
			 * Copyright 2016 Google Inc. All Rights Reserved.
			 * Licensed under the Apache License, Version 2.0 (the "License");
			 * you may not use this file except in compliance with the License.
			 * You may obtain a copy of the License at
			 *
			 *     http://www.apache.org/licenses/LICENSE-2.0
			 *
			 * Unless required by applicable law or agreed to in writing, software
			 * distributed under the License is distributed on an "AS IS" BASIS,
			 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
			 * See the License for the specific language governing permissions and
			 * limitations under the License.
			 */

			var VRDisplay = __webpack_require__(1).VRDisplay;
			var MathUtil = __webpack_require__(2);
			var Util = __webpack_require__(0);

			// How much to rotate per key stroke.
			var KEY_SPEED = 0.15;
			var KEY_ANIMATION_DURATION = 80;

			// How much to rotate for mouse events.
			var MOUSE_SPEED_X = 0.5;
			var MOUSE_SPEED_Y = 0.3;

			/**
			 * VRDisplay based on mouse and keyboard input. Designed for desktops/laptops
			 * where orientation events aren't supported. Cannot present.
			 */
			function MouseKeyboardVRDisplay() {
				this.displayName = 'Mouse and Keyboard VRDisplay (webvr-polyfill)';

				this.capabilities.hasOrientation = true;

				// Attach to mouse and keyboard events.
				window.addEventListener('keydown', this.onKeyDown_.bind(this));
				window.addEventListener('mousemove', this.onMouseMove_.bind(this));
				window.addEventListener('mousedown', this.onMouseDown_.bind(this));
				window.addEventListener('mouseup', this.onMouseUp_.bind(this));

				// "Private" members.
				this.phi_ = 0;
				this.theta_ = 0;

				// Variables for keyboard-based rotation animation.
				this.targetAngle_ = null;
				this.angleAnimation_ = null;

				// State variables for calculations.
				this.orientation_ = new MathUtil.Quaternion();

				// Variables for mouse-based rotation.
				this.rotateStart_ = new MathUtil.Vector2();
				this.rotateEnd_ = new MathUtil.Vector2();
				this.rotateDelta_ = new MathUtil.Vector2();
				this.isDragging_ = false;

				this.orientationOut_ = new Float32Array(4);
			}
			MouseKeyboardVRDisplay.prototype = new VRDisplay();

			MouseKeyboardVRDisplay.prototype.getImmediatePose = function () {
				this.orientation_.setFromEulerYXZ(this.phi_, this.theta_, 0);

				this.orientationOut_[0] = this.orientation_.x;
				this.orientationOut_[1] = this.orientation_.y;
				this.orientationOut_[2] = this.orientation_.z;
				this.orientationOut_[3] = this.orientation_.w;

				return {
					position: null,
					orientation: this.orientationOut_,
					linearVelocity: null,
					linearAcceleration: null,
					angularVelocity: null,
					angularAcceleration: null
				};
			};

			MouseKeyboardVRDisplay.prototype.onKeyDown_ = function (e) {
				// Track WASD and arrow keys.
				if (e.keyCode == 38) { // Up key.
					this.animatePhi_(this.phi_ + KEY_SPEED);
				} else if (e.keyCode == 39) { // Right key.
					this.animateTheta_(this.theta_ - KEY_SPEED);
				} else if (e.keyCode == 40) { // Down key.
					this.animatePhi_(this.phi_ - KEY_SPEED);
				} else if (e.keyCode == 37) { // Left key.
					this.animateTheta_(this.theta_ + KEY_SPEED);
				}
			};

			MouseKeyboardVRDisplay.prototype.animateTheta_ = function (targetAngle) {
				this.animateKeyTransitions_('theta_', targetAngle);
			};

			MouseKeyboardVRDisplay.prototype.animatePhi_ = function (targetAngle) {
				// Prevent looking too far up or down.
				targetAngle = Util.clamp(targetAngle, -Math.PI / 2, Math.PI / 2);
				this.animateKeyTransitions_('phi_', targetAngle);
			};

			/**
			 * Start an animation to transition an angle from one value to another.
			 */
			MouseKeyboardVRDisplay.prototype.animateKeyTransitions_ = function (angleName, targetAngle) {
				// If an animation is currently running, cancel it.
				if (this.angleAnimation_) {
					cancelAnimationFrame(this.angleAnimation_);
				}
				var startAngle = this[angleName];
				var startTime = new Date();
				// Set up an interval timer to perform the animation.
				this.angleAnimation_ = requestAnimationFrame(function animate() {
					// Once we're finished the animation, we're done.
					var elapsed = new Date() - startTime;
					if (elapsed >= KEY_ANIMATION_DURATION) {
						this[angleName] = targetAngle;
						cancelAnimationFrame(this.angleAnimation_);
						return;
					}
					// loop with requestAnimationFrame
					this.angleAnimation_ = requestAnimationFrame(animate.bind(this))
					// Linearly interpolate the angle some amount.
					var percent = elapsed / KEY_ANIMATION_DURATION;
					this[angleName] = startAngle + (targetAngle - startAngle) * percent;
				}.bind(this));
			};

			MouseKeyboardVRDisplay.prototype.onMouseDown_ = function (e) {
				this.rotateStart_.set(e.clientX, e.clientY);
				this.isDragging_ = true;
			};

			// Very similar to https://gist.github.com/mrflix/8351020
			MouseKeyboardVRDisplay.prototype.onMouseMove_ = function (e) {
				if (!this.isDragging_ && !this.isPointerLocked_()) {
					return;
				}
				// Support pointer lock API.
				if (this.isPointerLocked_()) {
					var movementX = e.movementX || e.mozMovementX || 0;
					var movementY = e.movementY || e.mozMovementY || 0;
					this.rotateEnd_.set(this.rotateStart_.x - movementX, this.rotateStart_.y - movementY);
				} else {
					this.rotateEnd_.set(e.clientX, e.clientY);
				}
				// Calculate how much we moved in mouse space.
				this.rotateDelta_.subVectors(this.rotateEnd_, this.rotateStart_);
				this.rotateStart_.copy(this.rotateEnd_);

				// Keep track of the cumulative euler angles.
				this.phi_ += 2 * Math.PI * this.rotateDelta_.y / screen.height * MOUSE_SPEED_Y;
				this.theta_ += 2 * Math.PI * this.rotateDelta_.x / screen.width * MOUSE_SPEED_X;

				// Prevent looking too far up or down.
				this.phi_ = Util.clamp(this.phi_, -Math.PI / 2, Math.PI / 2);
			};

			MouseKeyboardVRDisplay.prototype.onMouseUp_ = function (e) {
				this.isDragging_ = false;
			};

			MouseKeyboardVRDisplay.prototype.isPointerLocked_ = function () {
				var el = document.pointerLockElement || document.mozPointerLockElement ||
					document.webkitPointerLockElement;
				return el !== undefined;
			};

			MouseKeyboardVRDisplay.prototype.resetPose = function () {
				this.phi_ = 0;
				this.theta_ = 0;
			};

			module.exports = MouseKeyboardVRDisplay;


			/***/
}),
/* 23 */
/***/ (function (module, exports) {

			module.exports = { "name": "webvr-polyfill", "version": "0.9.40", "homepage": "https://github.com/googlevr/webvr-polyfill", "authors": ["Boris Smus <boris@smus.com>", "Brandon Jones <tojiro@gmail.com>", "Jordan Santell <jordan@jsantell.com>"], "description": "Use WebVR today, on mobile or desktop, without requiring a special browser build.", "devDependencies": { "chai": "^3.5.0", "jsdom": "^9.12.0", "mocha": "^3.2.0", "semver": "^5.3.0", "webpack": "^2.6.1", "webpack-dev-server": "2.7.1" }, "main": "src/node-entry", "keywords": ["vr", "webvr"], "license": "Apache-2.0", "scripts": { "start": "npm run watch", "watch": "webpack-dev-server", "build": "webpack", "test": "mocha" }, "repository": "googlevr/webvr-polyfill", "bugs": { "url": "https://github.com/googlevr/webvr-polyfill/issues" } }

			/***/
})
/******/]);
//# sourceMappingURL=webvr-polyfill.js.map
var fabric = fabric || { version: "1.7.20" }; "undefined" != typeof exports && (exports.fabric = fabric), "undefined" != typeof document && "undefined" != typeof window ? (fabric.document = document, fabric.window = window, window.fabric = fabric) : (fabric.document = require("jsdom").jsdom(decodeURIComponent("%3C!DOCTYPE%20html%3E%3Chtml%3E%3Chead%3E%3C%2Fhead%3E%3Cbody%3E%3C%2Fbody%3E%3C%2Fhtml%3E")), fabric.document.createWindow ? fabric.window = fabric.document.createWindow() : fabric.window = fabric.document.parentWindow), fabric.isTouchSupported = "ontouchstart" in fabric.window, fabric.isLikelyNode = "undefined" != typeof Buffer && "undefined" == typeof window, fabric.SHARED_ATTRIBUTES = ["display", "transform", "fill", "fill-opacity", "fill-rule", "opacity", "stroke", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "id"], fabric.DPI = 96, fabric.reNum = "(?:[-+]?(?:\\d+|\\d*\\.\\d+)(?:e[-+]?\\d+)?)", fabric.fontPaths = {}, fabric.iMatrix = [1, 0, 0, 1, 0, 0], fabric.canvasModule = "canvas", fabric.perfLimitSizeTotal = 2097152, fabric.maxCacheSideLimit = 4096, fabric.minCacheSideLimit = 256, fabric.charWidthsCache = {}, fabric.devicePixelRatio = fabric.window.devicePixelRatio || fabric.window.webkitDevicePixelRatio || fabric.window.mozDevicePixelRatio || 1, function () { function t(t, e) { if (this.__eventListeners[t]) { var i = this.__eventListeners[t]; e ? i[i.indexOf(e)] = !1 : fabric.util.array.fill(i, !1) } } function e(t, e) { if (this.__eventListeners || (this.__eventListeners = {}), 1 === arguments.length) for (var i in t) this.on(i, t[i]); else this.__eventListeners[t] || (this.__eventListeners[t] = []), this.__eventListeners[t].push(e); return this } function i(e, i) { if (this.__eventListeners) { if (0 === arguments.length) for (e in this.__eventListeners) t.call(this, e); else if (1 === arguments.length && "object" == typeof arguments[0]) for (var r in e) t.call(this, r, e[r]); else t.call(this, e, i); return this } } function r(t, e) { if (this.__eventListeners) { var i = this.__eventListeners[t]; if (i) { for (var r = 0, n = i.length; r < n; r++)i[r] && i[r].call(this, e || {}); return this.__eventListeners[t] = i.filter(function (t) { return !1 !== t }), this } } } fabric.Observable = { observe: e, stopObserving: i, fire: r, on: e, off: i, trigger: r } }(), fabric.Collection = { _objects: [], add: function () { if (this._objects.push.apply(this._objects, arguments), this._onObjectAdded) for (var t = 0, e = arguments.length; t < e; t++)this._onObjectAdded(arguments[t]); return this.renderOnAddRemove && this.renderAll(), this }, insertAt: function (t, e, i) { var r = this.getObjects(); return i ? r[e] = t : r.splice(e, 0, t), this._onObjectAdded && this._onObjectAdded(t), this.renderOnAddRemove && this.renderAll(), this }, remove: function () { for (var t, e = this.getObjects(), i = !1, r = 0, n = arguments.length; r < n; r++)-1 !== (t = e.indexOf(arguments[r])) && (i = !0, e.splice(t, 1), this._onObjectRemoved && this._onObjectRemoved(arguments[r])); return this.renderOnAddRemove && i && this.renderAll(), this }, forEachObject: function (t, e) { for (var i = this.getObjects(), r = 0, n = i.length; r < n; r++)t.call(e, i[r], r, i); return this }, getObjects: function (t) { return void 0 === t ? this._objects : this._objects.filter(function (e) { return e.type === t }) }, item: function (t) { return this.getObjects()[t] }, isEmpty: function () { return 0 === this.getObjects().length }, size: function () { return this.getObjects().length }, contains: function (t) { return this.getObjects().indexOf(t) > -1 }, complexity: function () { return this.getObjects().reduce(function (t, e) { return t += e.complexity ? e.complexity() : 0 }, 0) } }, fabric.CommonMethods = { _setOptions: function (t) { for (var e in t) this.set(e, t[e]) }, _initGradient: function (t, e) { !t || !t.colorStops || t instanceof fabric.Gradient || this.set(e, new fabric.Gradient(t)) }, _initPattern: function (t, e, i) { !t || !t.source || t instanceof fabric.Pattern ? i && i() : this.set(e, new fabric.Pattern(t, i)) }, _initClipping: function (t) { if (t.clipTo && "string" == typeof t.clipTo) { var e = fabric.util.getFunctionBody(t.clipTo); void 0 !== e && (this.clipTo = new Function("ctx", e)) } }, _setObject: function (t) { for (var e in t) this._set(e, t[e]) }, set: function (t, e) { return "object" == typeof t ? this._setObject(t) : "function" == typeof e && "clipTo" !== t ? this._set(t, e(this.get(t))) : this._set(t, e), this }, _set: function (t, e) { this[t] = e }, toggle: function (t) { var e = this.get(t); return "boolean" == typeof e && this.set(t, !e), this }, get: function (t) { return this[t] } }, function (t) { var e = Math.sqrt, i = Math.atan2, r = Math.pow, n = Math.abs, s = Math.PI / 180; fabric.util = { removeFromArray: function (t, e) { var i = t.indexOf(e); return -1 !== i && t.splice(i, 1), t }, getRandomInt: function (t, e) { return Math.floor(Math.random() * (e - t + 1)) + t }, degreesToRadians: function (t) { return t * s }, radiansToDegrees: function (t) { return t / s }, rotatePoint: function (t, e, i) { t.subtractEquals(e); var r = fabric.util.rotateVector(t, i); return new fabric.Point(r.x, r.y).addEquals(e) }, rotateVector: function (t, e) { var i = Math.sin(e), r = Math.cos(e); return { x: t.x * r - t.y * i, y: t.x * i + t.y * r } }, transformPoint: function (t, e, i) { return i ? new fabric.Point(e[0] * t.x + e[2] * t.y, e[1] * t.x + e[3] * t.y) : new fabric.Point(e[0] * t.x + e[2] * t.y + e[4], e[1] * t.x + e[3] * t.y + e[5]) }, makeBoundingBoxFromPoints: function (t) { var e = [t[0].x, t[1].x, t[2].x, t[3].x], i = fabric.util.array.min(e), r = fabric.util.array.max(e), n = Math.abs(i - r), s = [t[0].y, t[1].y, t[2].y, t[3].y], o = fabric.util.array.min(s), a = fabric.util.array.max(s); return { left: i, top: o, width: n, height: Math.abs(o - a) } }, invertTransform: function (t) { var e = 1 / (t[0] * t[3] - t[1] * t[2]), i = [e * t[3], -e * t[1], -e * t[2], e * t[0]], r = fabric.util.transformPoint({ x: t[4], y: t[5] }, i, !0); return i[4] = -r.x, i[5] = -r.y, i }, toFixed: function (t, e) { return parseFloat(Number(t).toFixed(e)) }, parseUnit: function (t, e) { var i = /\D{0,2}$/.exec(t), r = parseFloat(t); switch (e || (e = fabric.Text.DEFAULT_SVG_FONT_SIZE), i[0]) { case "mm": return r * fabric.DPI / 25.4; case "cm": return r * fabric.DPI / 2.54; case "in": return r * fabric.DPI; case "pt": return r * fabric.DPI / 72; case "pc": return r * fabric.DPI / 72 * 12; case "em": return r * e; default: return r } }, falseFunction: function () { return !1 }, getKlass: function (t, e) { return t = fabric.util.string.camelize(t.charAt(0).toUpperCase() + t.slice(1)), fabric.util.resolveNamespace(e)[t] }, resolveNamespace: function (e) { if (!e) return fabric; var i, r = e.split("."), n = r.length, s = t || fabric.window; for (i = 0; i < n; ++i)s = s[r[i]]; return s }, loadImage: function (t, e, i, r) { if (t) { var n = fabric.util.createImage(); n.onload = function () { e && e.call(i, n), n = n.onload = n.onerror = null }, n.onerror = function () { fabric.log("Error loading " + n.src), e && e.call(i, null, !0), n = n.onload = n.onerror = null }, 0 !== t.indexOf("data") && r && (n.crossOrigin = r), n.src = t } else e && e.call(i, t) }, enlivenObjects: function (t, e, i, r) { function n() { ++o === a && e && e(s) } var s = [], o = 0, a = (t = t || []).length; a ? t.forEach(function (t, e) { t && t.type ? fabric.util.getKlass(t.type, i).fromObject(t, function (i, o) { o || (s[e] = i), r && r(t, i, o), n() }, !0) : n() }) : e && e(s) }, enlivenPatterns: function (t, e) { function i() { ++n === s && e && e(r) } var r = [], n = 0, s = (t = t || []).length; s ? t.forEach(function (t, e) { t && t.source ? new fabric.Pattern(t, function (t) { r[e] = t, i() }) : (r[e] = t, i()) }) : e && e(r) }, groupSVGElements: function (t, e, i) { var r; return r = new fabric.PathGroup(t, e), void 0 !== i && (r.sourcePath = i), r }, populateWithProperties: function (t, e, i) { if (i && "[object Array]" === Object.prototype.toString.call(i)) for (var r = 0, n = i.length; r < n; r++)i[r] in t && (e[i[r]] = t[i[r]]) }, drawDashedLine: function (t, r, n, s, o, a) { var h = s - r, c = o - n, l = e(h * h + c * c), u = i(c, h), f = a.length, d = 0, g = !0; for (t.save(), t.translate(r, n), t.moveTo(0, 0), t.rotate(u), r = 0; l > r;)(r += a[d++ % f]) > l && (r = l), t[g ? "lineTo" : "moveTo"](r, 0), g = !g; t.restore() }, createCanvasElement: function (t) { return t || (t = fabric.document.createElement("canvas")), t.getContext || "undefined" == typeof G_vmlCanvasManager || G_vmlCanvasManager.initElement(t), t }, createImage: function () { return fabric.isLikelyNode ? new (require("canvas").Image) : fabric.document.createElement("img") }, createAccessors: function (t) { var e, i, r, n, s, o = t.prototype; for (e = o.stateProperties.length; e--;)n = "set" + (r = (i = o.stateProperties[e]).charAt(0).toUpperCase() + i.slice(1)), o[s = "get" + r] || (o[s] = function (t) { return new Function('return this.get("' + t + '")') }(i)), o[n] || (o[n] = function (t) { return new Function("value", 'return this.set("' + t + '", value)') }(i)) }, clipContext: function (t, e) { e.save(), e.beginPath(), t.clipTo(e), e.clip() }, multiplyTransformMatrices: function (t, e, i) { return [t[0] * e[0] + t[2] * e[1], t[1] * e[0] + t[3] * e[1], t[0] * e[2] + t[2] * e[3], t[1] * e[2] + t[3] * e[3], i ? 0 : t[0] * e[4] + t[2] * e[5] + t[4], i ? 0 : t[1] * e[4] + t[3] * e[5] + t[5]] }, qrDecompose: function (t) { var n = i(t[1], t[0]), o = r(t[0], 2) + r(t[1], 2), a = e(o), h = (t[0] * t[3] - t[2] * t[1]) / a, c = i(t[0] * t[2] + t[1] * t[3], o); return { angle: n / s, scaleX: a, scaleY: h, skewX: c / s, skewY: 0, translateX: t[4], translateY: t[5] } }, customTransformMatrix: function (t, e, i) { var r = [1, 0, n(Math.tan(i * s)), 1], o = [n(t), 0, 0, n(e)]; return fabric.util.multiplyTransformMatrices(o, r, !0) }, resetObjectTransform: function (t) { t.scaleX = 1, t.scaleY = 1, t.skewX = 0, t.skewY = 0, t.flipX = !1, t.flipY = !1, t.setAngle(0) }, getFunctionBody: function (t) { return (String(t).match(/function[^{]*\{([\s\S]*)\}/) || {})[1] }, isTransparent: function (t, e, i, r) { r > 0 && (e > r ? e -= r : e = 0, i > r ? i -= r : i = 0); var n, s, o = !0, a = t.getImageData(e, i, 2 * r || 1, 2 * r || 1), h = a.data.length; for (n = 3; n < h && (s = a.data[n], !1 !== (o = s <= 0)); n += 4); return a = null, o }, parsePreserveAspectRatioAttribute: function (t) { var e, i = "meet", r = "Mid", n = "Mid", s = t.split(" "); return s && s.length && ("meet" !== (i = s.pop()) && "slice" !== i ? (e = i, i = "meet") : s.length && (e = s.pop())), r = "none" !== e ? e.slice(1, 4) : "none", n = "none" !== e ? e.slice(5, 8) : "none", { meetOrSlice: i, alignX: r, alignY: n } }, clearFabricFontCache: function (t) { t ? fabric.charWidthsCache[t] && delete fabric.charWidthsCache[t] : fabric.charWidthsCache = {} }, limitDimsByArea: function (t, e) { var i = Math.sqrt(e * t), r = Math.floor(e / i); return { x: Math.floor(i), y: r } }, capValue: function (t, e, i) { return Math.max(t, Math.min(e, i)) } } }("undefined" != typeof exports ? exports : this), function () { function t(t, r, s, o, h, c, l) { var u = a.call(arguments); if (n[u]) return n[u]; var f = Math.PI, d = l * f / 180, g = Math.sin(d), p = Math.cos(d), v = 0, b = 0, m = -p * t * .5 - g * r * .5, _ = -p * r * .5 + g * t * .5, y = (s = Math.abs(s)) * s, x = (o = Math.abs(o)) * o, C = _ * _, S = m * m, w = y * x - y * C - x * S, O = 0; if (w < 0) { var T = Math.sqrt(1 - w / (y * x)); s *= T, o *= T } else O = (h === c ? -1 : 1) * Math.sqrt(w / (y * C + x * S)); var j = O * s * _ / o, k = -O * o * m / s, M = p * j - g * k + .5 * t, D = g * j + p * k + .5 * r, A = i(1, 0, (m - j) / s, (_ - k) / o), P = i((m - j) / s, (_ - k) / o, (-m - j) / s, (-_ - k) / o); 0 === c && P > 0 ? P -= 2 * f : 1 === c && P < 0 && (P += 2 * f); for (var E = Math.ceil(Math.abs(P / f * 2)), I = [], L = P / E, F = 8 / 3 * Math.sin(L / 4) * Math.sin(L / 4) / Math.sin(L / 2), B = A + L, R = 0; R < E; R++)I[R] = e(A, B, p, g, s, o, M, D, F, v, b), v = I[R][4], b = I[R][5], A = B, B += L; return n[u] = I, I } function e(t, e, i, r, n, o, h, c, l, u, f) { var d = a.call(arguments); if (s[d]) return s[d]; var g = Math.cos(t), p = Math.sin(t), v = Math.cos(e), b = Math.sin(e), m = i * n * v - r * o * b + h, _ = r * n * v + i * o * b + c, y = u + l * (-i * n * p - r * o * g), x = f + l * (-r * n * p + i * o * g), C = m + l * (i * n * b + r * o * v), S = _ + l * (r * n * b - i * o * v); return s[d] = [y, x, C, S, m, _], s[d] } function i(t, e, i, r) { var n = Math.atan2(e, t), s = Math.atan2(r, i); return s >= n ? s - n : 2 * Math.PI - (n - s) } function r(t, e, i, r, n, s, h, c) { var l = a.call(arguments); if (o[l]) return o[l]; var u, f, d, g, p, v, b, m, _ = Math.sqrt, y = Math.min, x = Math.max, C = Math.abs, S = [], w = [[], []]; f = 6 * t - 12 * i + 6 * n, u = -3 * t + 9 * i - 9 * n + 3 * h, d = 3 * i - 3 * t; for (var O = 0; O < 2; ++O)if (O > 0 && (f = 6 * e - 12 * r + 6 * s, u = -3 * e + 9 * r - 9 * s + 3 * c, d = 3 * r - 3 * e), C(u) < 1e-12) { if (C(f) < 1e-12) continue; 0 < (g = -d / f) && g < 1 && S.push(g) } else (b = f * f - 4 * d * u) < 0 || (0 < (p = (-f + (m = _(b))) / (2 * u)) && p < 1 && S.push(p), 0 < (v = (-f - m) / (2 * u)) && v < 1 && S.push(v)); for (var T, j, k, M = S.length, D = M; M--;)T = (k = 1 - (g = S[M])) * k * k * t + 3 * k * k * g * i + 3 * k * g * g * n + g * g * g * h, w[0][M] = T, j = k * k * k * e + 3 * k * k * g * r + 3 * k * g * g * s + g * g * g * c, w[1][M] = j; w[0][D] = t, w[1][D] = e, w[0][D + 1] = h, w[1][D + 1] = c; var A = [{ x: y.apply(null, w[0]), y: y.apply(null, w[1]) }, { x: x.apply(null, w[0]), y: x.apply(null, w[1]) }]; return o[l] = A, A } var n = {}, s = {}, o = {}, a = Array.prototype.join; fabric.util.drawArc = function (e, i, r, n) { for (var s = n[0], o = n[1], a = n[2], h = n[3], c = n[4], l = [[], [], [], []], u = t(n[5] - i, n[6] - r, s, o, h, c, a), f = 0, d = u.length; f < d; f++)l[f][0] = u[f][0] + i, l[f][1] = u[f][1] + r, l[f][2] = u[f][2] + i, l[f][3] = u[f][3] + r, l[f][4] = u[f][4] + i, l[f][5] = u[f][5] + r, e.bezierCurveTo.apply(e, l[f]) }, fabric.util.getBoundsOfArc = function (e, i, n, s, o, a, h, c, l) { for (var u, f = 0, d = 0, g = [], p = t(c - e, l - i, n, s, a, h, o), v = 0, b = p.length; v < b; v++)u = r(f, d, p[v][0], p[v][1], p[v][2], p[v][3], p[v][4], p[v][5]), g.push({ x: u[0].x + e, y: u[0].y + i }), g.push({ x: u[1].x + e, y: u[1].y + i }), f = p[v][4], d = p[v][5]; return g }, fabric.util.getBoundsOfCurve = r }(), function () { function t(t, e, i) { if (t && 0 !== t.length) { var r = t.length - 1, n = e ? t[r][e] : t[r]; if (e) for (; r--;)i(t[r][e], n) && (n = t[r][e]); else for (; r--;)i(t[r], n) && (n = t[r]); return n } } var e = Array.prototype.slice; Array.prototype.indexOf || (Array.prototype.indexOf = function (t) { if (void 0 === this || null === this) throw new TypeError; var e = Object(this), i = e.length >>> 0; if (0 === i) return -1; var r = 0; if (arguments.length > 0 && ((r = Number(arguments[1])) !== r ? r = 0 : 0 !== r && r !== Number.POSITIVE_INFINITY && r !== Number.NEGATIVE_INFINITY && (r = (r > 0 || -1) * Math.floor(Math.abs(r)))), r >= i) return -1; for (var n = r >= 0 ? r : Math.max(i - Math.abs(r), 0); n < i; n++)if (n in e && e[n] === t) return n; return -1 }), Array.prototype.forEach || (Array.prototype.forEach = function (t, e) { for (var i = 0, r = this.length >>> 0; i < r; i++)i in this && t.call(e, this[i], i, this) }), Array.prototype.map || (Array.prototype.map = function (t, e) { for (var i = [], r = 0, n = this.length >>> 0; r < n; r++)r in this && (i[r] = t.call(e, this[r], r, this)); return i }), Array.prototype.every || (Array.prototype.every = function (t, e) { for (var i = 0, r = this.length >>> 0; i < r; i++)if (i in this && !t.call(e, this[i], i, this)) return !1; return !0 }), Array.prototype.some || (Array.prototype.some = function (t, e) { for (var i = 0, r = this.length >>> 0; i < r; i++)if (i in this && t.call(e, this[i], i, this)) return !0; return !1 }), Array.prototype.filter || (Array.prototype.filter = function (t, e) { for (var i, r = [], n = 0, s = this.length >>> 0; n < s; n++)n in this && (i = this[n], t.call(e, i, n, this) && r.push(i)); return r }), Array.prototype.reduce || (Array.prototype.reduce = function (t) { var e, i = this.length >>> 0, r = 0; if (arguments.length > 1) e = arguments[1]; else for (; ;) { if (r in this) { e = this[r++]; break } if (++r >= i) throw new TypeError } for (; r < i; r++)r in this && (e = t.call(null, e, this[r], r, this)); return e }), fabric.util.array = { fill: function (t, e) { for (var i = t.length; i--;)t[i] = e; return t }, invoke: function (t, i) { for (var r = e.call(arguments, 2), n = [], s = 0, o = t.length; s < o; s++)n[s] = r.length ? t[s][i].apply(t[s], r) : t[s][i].call(t[s]); return n }, min: function (e, i) { return t(e, i, function (t, e) { return t < e }) }, max: function (e, i) { return t(e, i, function (t, e) { return t >= e }) } } }(), function () { function t(e, i, r) { if (r) if (!fabric.isLikelyNode && i instanceof Element) e = i; else if (i instanceof Array) { e = []; for (var n = 0, s = i.length; n < s; n++)e[n] = t({}, i[n], r) } else if (i && "object" == typeof i) for (var o in i) i.hasOwnProperty(o) && (e[o] = t({}, i[o], r)); else e = i; else for (var o in i) e[o] = i[o]; return e } fabric.util.object = { extend: t, clone: function (e, i) { return t({}, e, i) } } }(), function () { String.prototype.trim || (String.prototype.trim = function () { return this.replace(/^[\s\xA0]+/, "").replace(/[\s\xA0]+$/, "") }), fabric.util.string = { camelize: function (t) { return t.replace(/-+(.)?/g, function (t, e) { return e ? e.toUpperCase() : "" }) }, capitalize: function (t, e) { return t.charAt(0).toUpperCase() + (e ? t.slice(1) : t.slice(1).toLowerCase()) }, escapeXml: function (t) { return t.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;") } } }(), function () { var t = Array.prototype.slice, e = Function.prototype.apply, i = function () { }; Function.prototype.bind || (Function.prototype.bind = function (r) { var n, s = this, o = t.call(arguments, 1); return n = o.length ? function () { return e.call(s, this instanceof i ? this : r, o.concat(t.call(arguments))) } : function () { return e.call(s, this instanceof i ? this : r, arguments) }, i.prototype = this.prototype, n.prototype = new i, n }) }(), function () { function t() { } function e(t) { for (var e = null, r = this; r.constructor.superclass;) { var n = r.constructor.superclass.prototype[t]; if (r[t] !== n) { e = n; break } r = r.constructor.superclass.prototype } return e ? arguments.length > 1 ? e.apply(this, i.call(arguments, 1)) : e.call(this) : console.log("tried to callSuper " + t + ", method not found in prototype chain", this) } var i = Array.prototype.slice, r = function () { }, n = function () { for (var t in { toString: 1 }) if ("toString" === t) return !1; return !0 }(), s = function (t, e, i) { for (var r in e) r in t.prototype && "function" == typeof t.prototype[r] && (e[r] + "").indexOf("callSuper") > -1 ? t.prototype[r] = function (t) { return function () { var r = this.constructor.superclass; this.constructor.superclass = i; var n = e[t].apply(this, arguments); if (this.constructor.superclass = r, "initialize" !== t) return n } }(r) : t.prototype[r] = e[r], n && (e.toString !== Object.prototype.toString && (t.prototype.toString = e.toString), e.valueOf !== Object.prototype.valueOf && (t.prototype.valueOf = e.valueOf)) }; fabric.util.createClass = function () { function n() { this.initialize.apply(this, arguments) } var o = null, a = i.call(arguments, 0); "function" == typeof a[0] && (o = a.shift()), n.superclass = o, n.subclasses = [], o && (t.prototype = o.prototype, n.prototype = new t, o.subclasses.push(n)); for (var h = 0, c = a.length; h < c; h++)s(n, a[h], o); return n.prototype.initialize || (n.prototype.initialize = r), n.prototype.constructor = n, n.prototype.callSuper = e, n } }(), function () { function t(t) { var e, i, r = Array.prototype.slice.call(arguments, 1), n = r.length; for (i = 0; i < n; i++)if (e = typeof t[r[i]], !/^(?:function|object|unknown)$/.test(e)) return !1; return !0 } function e(t, e) { return { handler: e, wrappedHandler: i(t, e) } } function i(t, e) { return function (i) { e.call(s(t), i || fabric.window.event) } } function r(t, e) { return function (i) { if (g[t] && g[t][e]) for (var r = g[t][e], n = 0, s = r.length; n < s; n++)r[n].call(this, i || fabric.window.event) } } function n(t, e, i) { var r = "touchend" === t.type ? "changedTouches" : "touches"; return t[r] && t[r][0] ? t[r][0][e] - (t[r][0][e] - t[r][0][i]) || t[i] : t[i] } var s, o, a = "unknown", h = function () { var t = 0; return function (e) { return e.__uniqueID || (e.__uniqueID = "uniqueID__" + t++) } }(); !function () { var t = {}; s = function (e) { return t[e] }, o = function (e, i) { t[e] = i } }(); var c, l, u = t(fabric.document.documentElement, "addEventListener", "removeEventListener") && t(fabric.window, "addEventListener", "removeEventListener"), f = t(fabric.document.documentElement, "attachEvent", "detachEvent") && t(fabric.window, "attachEvent", "detachEvent"), d = {}, g = {}; u ? (c = function (t, e, i, r) { t && t.addEventListener(e, i, !f && r) }, l = function (t, e, i, r) { t && t.removeEventListener(e, i, !f && r) }) : f ? (c = function (t, i, r) { if (t) { var n = h(t); o(n, t), d[n] || (d[n] = {}), d[n][i] || (d[n][i] = []); var s = e(n, r); d[n][i].push(s), t.attachEvent("on" + i, s.wrappedHandler) } }, l = function (t, e, i) { if (t) { var r, n = h(t); if (d[n] && d[n][e]) for (var s = 0, o = d[n][e].length; s < o; s++)(r = d[n][e][s]) && r.handler === i && (t.detachEvent("on" + e, r.wrappedHandler), d[n][e][s] = null) } }) : (c = function (t, e, i) { if (t) { var n = h(t); if (g[n] || (g[n] = {}), !g[n][e]) { g[n][e] = []; var s = t["on" + e]; s && g[n][e].push(s), t["on" + e] = r(n, e) } g[n][e].push(i) } }, l = function (t, e, i) { if (t) { var r = h(t); if (g[r] && g[r][e]) for (var n = g[r][e], s = 0, o = n.length; s < o; s++)n[s] === i && n.splice(s, 1) } }), fabric.util.addListener = c, fabric.util.removeListener = l; var p = function (t) { return typeof t.clientX !== a ? t.clientX : 0 }, v = function (t) { return typeof t.clientY !== a ? t.clientY : 0 }; fabric.isTouchSupported && (p = function (t) { return n(t, "pageX", "clientX") }, v = function (t) { return n(t, "pageY", "clientY") }), fabric.util.getPointer = function (t) { t || (t = fabric.window.event); var e = t.target || (typeof t.srcElement !== a ? t.srcElement : null), i = fabric.util.getScrollLeftTop(e); return { x: p(t) + i.left, y: v(t) + i.top } }, fabric.util.object.extend(fabric.util, fabric.Observable) }(), function () { var t = fabric.document.createElement("div"), e = "string" == typeof t.style.opacity, i = "string" == typeof t.style.filter, r = /alpha\s*\(\s*opacity\s*=\s*([^\)]+)\)/, n = function (t) { return t }; e ? n = function (t, e) { return t.style.opacity = e, t } : i && (n = function (t, e) { var i = t.style; return t.currentStyle && !t.currentStyle.hasLayout && (i.zoom = 1), r.test(i.filter) ? (e = e >= .9999 ? "" : "alpha(opacity=" + 100 * e + ")", i.filter = i.filter.replace(r, e)) : i.filter += " alpha(opacity=" + 100 * e + ")", t }), fabric.util.setStyle = function (t, e) { var i = t.style; if (!i) return t; if ("string" == typeof e) return t.style.cssText += ";" + e, e.indexOf("opacity") > -1 ? n(t, e.match(/opacity:\s*(\d?\.?\d*)/)[1]) : t; for (var r in e) "opacity" === r ? n(t, e[r]) : i["float" === r || "cssFloat" === r ? void 0 === i.styleFloat ? "cssFloat" : "styleFloat" : r] = e[r]; return t } }(), function () { function t(t, e) { var i = fabric.document.createElement(t); for (var r in e) "class" === r ? i.className = e[r] : "for" === r ? i.htmlFor = e[r] : i.setAttribute(r, e[r]); return i } function e(t) { for (var e = 0, i = 0, r = fabric.document.documentElement, n = fabric.document.body || { scrollLeft: 0, scrollTop: 0 }; t && (t.parentNode || t.host) && ((t = t.parentNode || t.host) === fabric.document ? (e = n.scrollLeft || r.scrollLeft || 0, i = n.scrollTop || r.scrollTop || 0) : (e += t.scrollLeft || 0, i += t.scrollTop || 0), 1 !== t.nodeType || "fixed" !== fabric.util.getElementStyle(t, "position"));); return { left: e, top: i } } var i, r = Array.prototype.slice, n = function (t) { return r.call(t, 0) }; try { i = n(fabric.document.childNodes) instanceof Array } catch (t) { } i || (n = function (t) { for (var e = new Array(t.length), i = t.length; i--;)e[i] = t[i]; return e }); var s; s = fabric.document.defaultView && fabric.document.defaultView.getComputedStyle ? function (t, e) { var i = fabric.document.defaultView.getComputedStyle(t, null); return i ? i[e] : void 0 } : function (t, e) { var i = t.style[e]; return !i && t.currentStyle && (i = t.currentStyle[e]), i }, function () { var t = fabric.document.documentElement.style, e = "userSelect" in t ? "userSelect" : "MozUserSelect" in t ? "MozUserSelect" : "WebkitUserSelect" in t ? "WebkitUserSelect" : "KhtmlUserSelect" in t ? "KhtmlUserSelect" : ""; fabric.util.makeElementUnselectable = function (t) { return void 0 !== t.onselectstart && (t.onselectstart = fabric.util.falseFunction), e ? t.style[e] = "none" : "string" == typeof t.unselectable && (t.unselectable = "on"), t }, fabric.util.makeElementSelectable = function (t) { return void 0 !== t.onselectstart && (t.onselectstart = null), e ? t.style[e] = "" : "string" == typeof t.unselectable && (t.unselectable = ""), t } }(), function () { fabric.util.getScript = function (t, e) { var i = fabric.document.getElementsByTagName("head")[0], r = fabric.document.createElement("script"), n = !0; r.onload = r.onreadystatechange = function (t) { if (n) { if ("string" == typeof this.readyState && "loaded" !== this.readyState && "complete" !== this.readyState) return; n = !1, e(t || fabric.window.event), r = r.onload = r.onreadystatechange = null } }, r.src = t, i.appendChild(r) } }(), fabric.util.getById = function (t) { return "string" == typeof t ? fabric.document.getElementById(t) : t }, fabric.util.toArray = n, fabric.util.makeElement = t, fabric.util.addClass = function (t, e) { t && -1 === (" " + t.className + " ").indexOf(" " + e + " ") && (t.className += (t.className ? " " : "") + e) }, fabric.util.wrapElement = function (e, i, r) { return "string" == typeof i && (i = t(i, r)), e.parentNode && e.parentNode.replaceChild(i, e), i.appendChild(e), i }, fabric.util.getScrollLeftTop = e, fabric.util.getElementOffset = function (t) { var i, r, n = t && t.ownerDocument, o = { left: 0, top: 0 }, a = { left: 0, top: 0 }, h = { borderLeftWidth: "left", borderTopWidth: "top", paddingLeft: "left", paddingTop: "top" }; if (!n) return a; for (var c in h) a[h[c]] += parseInt(s(t, c), 10) || 0; return i = n.documentElement, void 0 !== t.getBoundingClientRect && (o = t.getBoundingClientRect()), r = e(t), { left: o.left + r.left - (i.clientLeft || 0) + a.left, top: o.top + r.top - (i.clientTop || 0) + a.top } }, fabric.util.getElementStyle = s }(), function () { function t(t, e) { return t + (/\?/.test(t) ? "&" : "?") + e } function e() { } var i = function () { for (var t = [function () { return new ActiveXObject("Microsoft.XMLHTTP") }, function () { return new ActiveXObject("Msxml2.XMLHTTP") }, function () { return new ActiveXObject("Msxml2.XMLHTTP.3.0") }, function () { return new XMLHttpRequest }], e = t.length; e--;)try { if (t[e]()) return t[e] } catch (t) { } }(); fabric.util.request = function (r, n) { n || (n = {}); var s = n.method ? n.method.toUpperCase() : "GET", o = n.onComplete || function () { }, a = i(), h = n.body || n.parameters; return a.onreadystatechange = function () { 4 === a.readyState && (o(a), a.onreadystatechange = e) }, "GET" === s && (h = null, "string" == typeof n.parameters && (r = t(r, n.parameters))), a.open(s, r, !0), "POST" !== s && "PUT" !== s || a.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), a.send(h), a } }(), fabric.log = function () { }, fabric.warn = function () { }, "undefined" != typeof console && ["log", "warn"].forEach(function (t) { void 0 !== console[t] && "function" == typeof console[t].apply && (fabric[t] = function () { return console[t].apply(console, arguments) }) }), function () { function t() { return !1 } function e() { return i.apply(fabric.window, arguments) } var i = fabric.window.requestAnimationFrame || fabric.window.webkitRequestAnimationFrame || fabric.window.mozRequestAnimationFrame || fabric.window.oRequestAnimationFrame || fabric.window.msRequestAnimationFrame || function (t) { fabric.window.setTimeout(t, 1e3 / 60) }; fabric.util.animate = function (i) { e(function (r) { i || (i = {}); var n, s = r || +new Date, o = i.duration || 500, a = s + o, h = i.onChange || t, c = i.abort || t, l = i.onComplete || t, u = i.easing || function (t, e, i, r) { return -i * Math.cos(t / r * (Math.PI / 2)) + i + e }, f = "startValue" in i ? i.startValue : 0, d = "endValue" in i ? i.endValue : 100, g = i.byValue || d - f; i.onStart && i.onStart(), function t(r) { if (c()) l(d, 1, 1); else { var p = (n = r || +new Date) > a ? o : n - s, v = p / o, b = u(p, f, g, o), m = Math.abs((b - f) / g); h(b, m, v), n > a ? i.onComplete && i.onComplete() : e(t) } }(s) }) }, fabric.util.requestAnimFrame = e }(), function () { function t(t, e, i) { var r = "rgba(" + parseInt(t[0] + i * (e[0] - t[0]), 10) + "," + parseInt(t[1] + i * (e[1] - t[1]), 10) + "," + parseInt(t[2] + i * (e[2] - t[2]), 10); return r += "," + (t && e ? parseFloat(t[3] + i * (e[3] - t[3])) : 1), r += ")" } fabric.util.animateColor = function (e, i, r, n) { var s = new fabric.Color(e).getSource(), o = new fabric.Color(i).getSource(); n = n || {}, fabric.util.animate(fabric.util.object.extend(n, { duration: r || 500, startValue: s, endValue: o, byValue: o, easing: function (e, i, r, s) { return t(i, r, n.colorEasing ? n.colorEasing(e, s) : 1 - Math.cos(e / s * (Math.PI / 2))) } })) } }(), function () { function t(t, e, i, r) { return t < Math.abs(e) ? (t = e, r = i / 4) : r = 0 === e && 0 === t ? i / (2 * Math.PI) * Math.asin(1) : i / (2 * Math.PI) * Math.asin(e / t), { a: t, c: e, p: i, s: r } } function e(t, e, i) { return t.a * Math.pow(2, 10 * (e -= 1)) * Math.sin((e * i - t.s) * (2 * Math.PI) / t.p) } function i(t, e, i, n) { return i - r(n - t, 0, i, n) + e } function r(t, e, i, r) { return (t /= r) < 1 / 2.75 ? i * (7.5625 * t * t) + e : t < 2 / 2.75 ? i * (7.5625 * (t -= 1.5 / 2.75) * t + .75) + e : t < 2.5 / 2.75 ? i * (7.5625 * (t -= 2.25 / 2.75) * t + .9375) + e : i * (7.5625 * (t -= 2.625 / 2.75) * t + .984375) + e } fabric.util.ease = { easeInQuad: function (t, e, i, r) { return i * (t /= r) * t + e }, easeOutQuad: function (t, e, i, r) { return -i * (t /= r) * (t - 2) + e }, easeInOutQuad: function (t, e, i, r) { return (t /= r / 2) < 1 ? i / 2 * t * t + e : -i / 2 * (--t * (t - 2) - 1) + e }, easeInCubic: function (t, e, i, r) { return i * (t /= r) * t * t + e }, easeOutCubic: function (t, e, i, r) { return i * ((t = t / r - 1) * t * t + 1) + e }, easeInOutCubic: function (t, e, i, r) { return (t /= r / 2) < 1 ? i / 2 * t * t * t + e : i / 2 * ((t -= 2) * t * t + 2) + e }, easeInQuart: function (t, e, i, r) { return i * (t /= r) * t * t * t + e }, easeOutQuart: function (t, e, i, r) { return -i * ((t = t / r - 1) * t * t * t - 1) + e }, easeInOutQuart: function (t, e, i, r) { return (t /= r / 2) < 1 ? i / 2 * t * t * t * t + e : -i / 2 * ((t -= 2) * t * t * t - 2) + e }, easeInQuint: function (t, e, i, r) { return i * (t /= r) * t * t * t * t + e }, easeOutQuint: function (t, e, i, r) { return i * ((t = t / r - 1) * t * t * t * t + 1) + e }, easeInOutQuint: function (t, e, i, r) { return (t /= r / 2) < 1 ? i / 2 * t * t * t * t * t + e : i / 2 * ((t -= 2) * t * t * t * t + 2) + e }, easeInSine: function (t, e, i, r) { return -i * Math.cos(t / r * (Math.PI / 2)) + i + e }, easeOutSine: function (t, e, i, r) { return i * Math.sin(t / r * (Math.PI / 2)) + e }, easeInOutSine: function (t, e, i, r) { return -i / 2 * (Math.cos(Math.PI * t / r) - 1) + e }, easeInExpo: function (t, e, i, r) { return 0 === t ? e : i * Math.pow(2, 10 * (t / r - 1)) + e }, easeOutExpo: function (t, e, i, r) { return t === r ? e + i : i * (1 - Math.pow(2, -10 * t / r)) + e }, easeInOutExpo: function (t, e, i, r) { return 0 === t ? e : t === r ? e + i : (t /= r / 2) < 1 ? i / 2 * Math.pow(2, 10 * (t - 1)) + e : i / 2 * (2 - Math.pow(2, -10 * --t)) + e }, easeInCirc: function (t, e, i, r) { return -i * (Math.sqrt(1 - (t /= r) * t) - 1) + e }, easeOutCirc: function (t, e, i, r) { return i * Math.sqrt(1 - (t = t / r - 1) * t) + e }, easeInOutCirc: function (t, e, i, r) { return (t /= r / 2) < 1 ? -i / 2 * (Math.sqrt(1 - t * t) - 1) + e : i / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + e }, easeInElastic: function (i, r, n, s) { var o = 0, a = n; return 0 === i ? r : 1 == (i /= s) ? r + n : (o || (o = .3 * s), -e(t(a, n, o, 1.70158), i, s) + r) }, easeOutElastic: function (e, i, r, n) { var s = 0, o = r; if (0 === e) return i; if (1 == (e /= n)) return i + r; s || (s = .3 * n); var a = t(o, r, s, 1.70158); return a.a * Math.pow(2, -10 * e) * Math.sin((e * n - a.s) * (2 * Math.PI) / a.p) + a.c + i }, easeInOutElastic: function (i, r, n, s) { var o = 0, a = n; if (0 === i) return r; if (2 == (i /= s / 2)) return r + n; o || (o = s * (.3 * 1.5)); var h = t(a, n, o, 1.70158); return i < 1 ? -.5 * e(h, i, s) + r : h.a * Math.pow(2, -10 * (i -= 1)) * Math.sin((i * s - h.s) * (2 * Math.PI) / h.p) * .5 + h.c + r }, easeInBack: function (t, e, i, r, n) { return void 0 === n && (n = 1.70158), i * (t /= r) * t * ((n + 1) * t - n) + e }, easeOutBack: function (t, e, i, r, n) { return void 0 === n && (n = 1.70158), i * ((t = t / r - 1) * t * ((n + 1) * t + n) + 1) + e }, easeInOutBack: function (t, e, i, r, n) { return void 0 === n && (n = 1.70158), (t /= r / 2) < 1 ? i / 2 * (t * t * ((1 + (n *= 1.525)) * t - n)) + e : i / 2 * ((t -= 2) * t * ((1 + (n *= 1.525)) * t + n) + 2) + e }, easeInBounce: i, easeOutBounce: r, easeInOutBounce: function (t, e, n, s) { return t < s / 2 ? .5 * i(2 * t, 0, n, s) + e : .5 * r(2 * t - s, 0, n, s) + .5 * n + e } } }(), function (t) { "use strict"; function e(t) { return t in O ? O[t] : t } function i(t, e, i, r) { var n, s = "[object Array]" === Object.prototype.toString.call(e); return "fill" !== t && "stroke" !== t || "none" !== e ? "strokeDashArray" === t ? e = "none" === e ? null : e.replace(/,/g, " ").split(/\s+/).map(function (t) { return parseFloat(t) }) : "transformMatrix" === t ? e = i && i.transformMatrix ? y(i.transformMatrix, p.parseTransformAttribute(e)) : p.parseTransformAttribute(e) : "visible" === t ? (e = "none" !== e && "hidden" !== e, i && !1 === i.visible && (e = !1)) : "opacity" === t ? (e = parseFloat(e), i && void 0 !== i.opacity && (e *= i.opacity)) : "originX" === t ? e = "start" === e ? "left" : "end" === e ? "right" : "center" : n = s ? e.map(_) : _(e, r) : e = "", !s && isNaN(n) ? e : n } function r(t) { for (var e in T) if (void 0 !== t[T[e]] && "" !== t[e]) { if (void 0 === t[e]) { if (!p.Object.prototype[e]) continue; t[e] = p.Object.prototype[e] } if (0 !== t[e].indexOf("url(")) { var i = new p.Color(t[e]); t[e] = i.setAlpha(m(i.getAlpha() * t[T[e]], 2)).toRgba() } } return t } function n(t, e) { for (var i, r, n = [], s = 0; s < e.length; s++)i = e[s], r = t.getElementsByTagName(i), n = n.concat(Array.prototype.slice.call(r)); return n } function s(t, e) { var i, r; t.replace(/;\s*$/, "").split(";").forEach(function (t) { var n = t.split(":"); i = n[0].trim().toLowerCase(), r = n[1].trim(), e[i] = r }) } function o(t, e) { var i, r; for (var n in t) void 0 !== t[n] && (i = n.toLowerCase(), r = t[n], e[i] = r) } function a(t, e) { var i = {}; for (var r in p.cssRules[e]) if (h(t, r.split(" "))) for (var n in p.cssRules[e][r]) i[n] = p.cssRules[e][r][n]; return i } function h(t, e) { var i, r = !0; return (i = l(t, e.pop())) && e.length && (r = c(t, e)), i && r && 0 === e.length } function c(t, e) { for (var i, r = !0; t.parentNode && 1 === t.parentNode.nodeType && e.length;)r && (i = e.pop()), r = l(t = t.parentNode, i); return 0 === e.length } function l(t, e) { var i, r = t.nodeName, n = t.getAttribute("class"), s = t.getAttribute("id"); if (i = new RegExp("^" + r, "i"), e = e.replace(i, ""), s && e.length && (i = new RegExp("#" + s + "(?![a-zA-Z\\-]+)", "i"), e = e.replace(i, "")), n && e.length) for (var o = (n = n.split(" ")).length; o--;)i = new RegExp("\\." + n[o] + "(?![a-zA-Z\\-]+)", "i"), e = e.replace(i, ""); return 0 === e.length } function u(t, e) { var i; if (t.getElementById && (i = t.getElementById(e)), i) return i; var r, n, s = t.getElementsByTagName("*"); for (n = 0; n < s.length; n++)if (r = s[n], e === r.getAttribute("id")) return r } function f(t) { for (var e = n(t, ["use", "svg:use"]), i = 0; e.length && i < e.length;) { var r, s, o, a, h = e[i], c = h.getAttribute("xlink:href").substr(1), l = h.getAttribute("x") || 0, f = h.getAttribute("y") || 0, g = u(t, c).cloneNode(!0), p = (g.getAttribute("transform") || "") + " translate(" + l + ", " + f + ")", v = e.length; if (d(g), /^svg$/i.test(g.nodeName)) { var b = g.ownerDocument.createElement("g"); for (s = 0, a = (o = g.attributes).length; s < a; s++)r = o.item(s), b.setAttribute(r.nodeName, r.nodeValue); for (; g.firstChild;)b.appendChild(g.firstChild); g = b } for (s = 0, a = (o = h.attributes).length; s < a; s++)"x" !== (r = o.item(s)).nodeName && "y" !== r.nodeName && "xlink:href" !== r.nodeName && ("transform" === r.nodeName ? p = r.nodeValue + " " + p : g.setAttribute(r.nodeName, r.nodeValue)); g.setAttribute("transform", p), g.setAttribute("instantiated_by_use", "1"), g.removeAttribute("id"), h.parentNode.replaceChild(g, h), e.length === v && i++ } } function d(t) { var e, i, r, n, s = t.getAttribute("viewBox"), o = 1, a = 1, h = 0, c = 0, l = t.getAttribute("width"), u = t.getAttribute("height"), f = t.getAttribute("x") || 0, d = t.getAttribute("y") || 0, g = t.getAttribute("preserveAspectRatio") || "", v = !s || !C.test(t.nodeName) || !(s = s.match(j)), b = !l || !u || "100%" === l || "100%" === u, m = v && b, y = {}, x = ""; if (y.width = 0, y.height = 0, y.toBeParsed = m, m) return y; if (v) return y.width = _(l), y.height = _(u), y; if (h = -parseFloat(s[1]), c = -parseFloat(s[2]), e = parseFloat(s[3]), i = parseFloat(s[4]), b ? (y.width = e, y.height = i) : (y.width = _(l), y.height = _(u), o = y.width / e, a = y.height / i), "none" !== (g = p.util.parsePreserveAspectRatioAttribute(g)).alignX && (a = o = o > a ? a : o), 1 === o && 1 === a && 0 === h && 0 === c && 0 === f && 0 === d) return y; if ((f || d) && (x = " translate(" + _(f) + " " + _(d) + ") "), r = x + " matrix(" + o + " 0 0 " + a + " " + h * o + " " + c * a + ") ", "svg" === t.nodeName) { for (n = t.ownerDocument.createElement("g"); t.firstChild;)n.appendChild(t.firstChild); t.appendChild(n) } else r = (n = t).getAttribute("transform") + r; return n.setAttribute("transform", r), y } function g(t, e) { for (; t && (t = t.parentNode);)if (t.nodeName && e.test(t.nodeName.replace("svg:", "")) && !t.getAttribute("instantiated_by_use")) return !0; return !1 } var p = t.fabric || (t.fabric = {}), v = p.util.object.extend, b = p.util.object.clone, m = p.util.toFixed, _ = p.util.parseUnit, y = p.util.multiplyTransformMatrices, x = /^(path|circle|polygon|polyline|ellipse|rect|line|image|text)$/i, C = /^(symbol|image|marker|pattern|view|svg)$/i, S = /^(?:pattern|defs|symbol|metadata|clipPath|mask)$/i, w = /^(symbol|g|a|svg)$/i, O = { cx: "left", x: "left", r: "radius", cy: "top", y: "top", display: "visible", visibility: "visible", transform: "transformMatrix", "fill-opacity": "fillOpacity", "fill-rule": "fillRule", "font-family": "fontFamily", "font-size": "fontSize", "font-style": "fontStyle", "font-weight": "fontWeight", "stroke-dasharray": "strokeDashArray", "stroke-linecap": "strokeLineCap", "stroke-linejoin": "strokeLineJoin", "stroke-miterlimit": "strokeMiterLimit", "stroke-opacity": "strokeOpacity", "stroke-width": "strokeWidth", "text-decoration": "textDecoration", "text-anchor": "originX", opacity: "opacity" }, T = { stroke: "strokeOpacity", fill: "fillOpacity" }; p.cssRules = {}, p.gradientDefs = {}, p.parseTransformAttribute = function () { function t(t, e) { var i = Math.cos(e[0]), r = Math.sin(e[0]), n = 0, s = 0; 3 === e.length && (n = e[1], s = e[2]), t[0] = i, t[1] = r, t[2] = -r, t[3] = i, t[4] = n - (i * n - r * s), t[5] = s - (r * n + i * s) } function e(t, e) { var i = e[0], r = 2 === e.length ? e[1] : e[0]; t[0] = i, t[3] = r } function i(t, e, i) { t[i] = Math.tan(p.util.degreesToRadians(e[0])) } function r(t, e) { t[4] = e[0], 2 === e.length && (t[5] = e[1]) } var n = [1, 0, 0, 1, 0, 0], s = p.reNum, o = "(?:\\s+,?\\s*|,\\s*)", a = "(?:" + ("(?:(matrix)\\s*\\(\\s*(" + s + ")" + o + "(" + s + ")" + o + "(" + s + ")" + o + "(" + s + ")" + o + "(" + s + ")" + o + "(" + s + ")\\s*\\))") + "|" + ("(?:(translate)\\s*\\(\\s*(" + s + ")(?:" + o + "(" + s + "))?\\s*\\))") + "|" + ("(?:(scale)\\s*\\(\\s*(" + s + ")(?:" + o + "(" + s + "))?\\s*\\))") + "|" + ("(?:(rotate)\\s*\\(\\s*(" + s + ")(?:" + o + "(" + s + ")" + o + "(" + s + "))?\\s*\\))") + "|" + ("(?:(skewX)\\s*\\(\\s*(" + s + ")\\s*\\))") + "|" + ("(?:(skewY)\\s*\\(\\s*(" + s + ")\\s*\\))") + ")", h = "^\\s*(?:" + ("(?:" + a + "(?:" + o + "*" + a + ")*)") + "?)\\s*$", c = new RegExp(h), l = new RegExp(a, "g"); return function (s) { var o = n.concat(), h = []; if (!s || s && !c.test(s)) return o; s.replace(l, function (s) { var c = new RegExp(a).exec(s).filter(function (t) { return !!t }), l = c[1], u = c.slice(2).map(parseFloat); switch (l) { case "translate": r(o, u); break; case "rotate": u[0] = p.util.degreesToRadians(u[0]), t(o, u); break; case "scale": e(o, u); break; case "skewX": i(o, u, 2); break; case "skewY": i(o, u, 1); break; case "matrix": o = u }h.push(o.concat()), o = n.concat() }); for (var u = h[0]; h.length > 1;)h.shift(), u = p.util.multiplyTransformMatrices(u, h[0]); return u } }(); var j = new RegExp("^\\s*(" + p.reNum + "+)\\s*,?\\s*(" + p.reNum + "+)\\s*,?\\s*(" + p.reNum + "+)\\s*,?\\s*(" + p.reNum + "+)\\s*$"); p.parseSVGDocument = function (t, e, i, r) { if (t) { f(t); var n = p.Object.__uid++, s = d(t), o = p.util.toArray(t.getElementsByTagName("*")); if (s.crossOrigin = r && r.crossOrigin, s.svgUid = n, 0 === o.length && p.isLikelyNode) { for (var a = [], h = 0, c = (o = t.selectNodes('//*[name(.)!="svg"]')).length; h < c; h++)a[h] = o[h]; o = a } var l = o.filter(function (t) { return d(t), x.test(t.nodeName.replace("svg:", "")) && !g(t, S) }); !l || l && !l.length ? e && e([], {}) : (p.gradientDefs[n] = p.getGradientDefs(t), p.cssRules[n] = p.getCSSRules(t), p.parseElements(l, function (t) { e && e(t, s) }, b(s), i, r)) } }; var k = new RegExp("(normal|italic)?\\s*(normal|small-caps)?\\s*(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(" + p.reNum + "(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|" + p.reNum + "))?\\s+(.*)"); v(p, { parseFontDeclaration: function (t, e) { var i = t.match(k); if (i) { var r = i[1], n = i[3], s = i[4], o = i[5], a = i[6]; r && (e.fontStyle = r), n && (e.fontWeight = isNaN(parseFloat(n)) ? n : parseFloat(n)), s && (e.fontSize = _(s)), a && (e.fontFamily = a), o && (e.lineHeight = "normal" === o ? 1 : o) } }, getGradientDefs: function (t) { var e, i, r, s = n(t, ["linearGradient", "radialGradient", "svg:linearGradient", "svg:radialGradient"]), o = 0, a = {}, h = {}; for (o = s.length; o--;)r = (e = s[o]).getAttribute("xlink:href"), i = e.getAttribute("id"), r && (h[i] = r.substr(1)), a[i] = e; for (i in h) { var c = a[h[i]].cloneNode(!0); for (e = a[i]; c.firstChild;)e.appendChild(c.firstChild) } return a }, parseAttributes: function (t, n, s) { if (t) { var o, h, c = {}; void 0 === s && (s = t.getAttribute("svgUid")), t.parentNode && w.test(t.parentNode.nodeName) && (c = p.parseAttributes(t.parentNode, n, s)), h = c && c.fontSize || t.getAttribute("font-size") || p.Text.DEFAULT_SVG_FONT_SIZE; var l = n.reduce(function (e, i) { return (o = t.getAttribute(i)) && (e[i] = o), e }, {}); l = v(l, v(a(t, s), p.parseStyleAttribute(t))); var u, f, d = {}; for (var g in l) f = i(u = e(g), l[g], c, h), d[u] = f; d && d.font && p.parseFontDeclaration(d.font, d); var b = v(c, d); return w.test(t.nodeName) ? b : r(b) } }, parseElements: function (t, e, i, r, n) { new p.ElementsParser(t, e, i, r, n).parse() }, parseStyleAttribute: function (t) { var e = {}, i = t.getAttribute("style"); return i ? ("string" == typeof i ? s(i, e) : o(i, e), e) : e }, parsePointsAttribute: function (t) { if (!t) return null; var e, i, r = []; for (e = 0, i = (t = (t = t.replace(/,/g, " ").trim()).split(/\s+/)).length; e < i; e += 2)r.push({ x: parseFloat(t[e]), y: parseFloat(t[e + 1]) }); return r }, getCSSRules: function (t) { for (var e = t.getElementsByTagName("style"), i = {}, r = 0, n = e.length; r < n; r++) { var s = e[r].textContent || e[r].text; "" !== (s = s.replace(/\/\*[\s\S]*?\*\//g, "")).trim() && s.match(/[^{]*\{[\s\S]*?\}/g).map(function (t) { return t.trim() }).forEach(function (t) { for (var e = t.match(/([\s\S]*?)\s*\{([^}]*)\}/), r = {}, n = e[2].trim().replace(/;$/, "").split(/\s*;\s*/), s = 0, o = n.length; s < o; s++) { var a = n[s].split(/\s*:\s*/), h = a[0], c = a[1]; r[h] = c } (t = e[1]).split(",").forEach(function (t) { "" !== (t = t.replace(/^svg/i, "").trim()) && (i[t] ? p.util.object.extend(i[t], r) : i[t] = p.util.object.clone(r)) }) }) } return i }, loadSVGFromURL: function (t, e, i, r) { t = t.replace(/^\n\s*/, "").trim(), new p.util.request(t, { method: "get", onComplete: function (t) { var n = t.responseXML; n && !n.documentElement && p.window.ActiveXObject && t.responseText && ((n = new ActiveXObject("Microsoft.XMLDOM")).async = "false", n.loadXML(t.responseText.replace(/<!DOCTYPE[\s\S]*?(\[[\s\S]*\])*?>/i, ""))), n && n.documentElement || e && e(null), p.parseSVGDocument(n.documentElement, function (t, i) { e && e(t, i) }, i, r) } }) }, loadSVGFromString: function (t, e, i, r) { t = t.trim(); var n; if ("undefined" != typeof DOMParser) { var s = new DOMParser; s && s.parseFromString && (n = s.parseFromString(t, "text/xml")) } else p.window.ActiveXObject && ((n = new ActiveXObject("Microsoft.XMLDOM")).async = "false", n.loadXML(t.replace(/<!DOCTYPE[\s\S]*?(\[[\s\S]*\])*?>/i, ""))); p.parseSVGDocument(n.documentElement, function (t, i) { e(t, i) }, i, r) } }) }("undefined" != typeof exports ? exports : this), fabric.ElementsParser = function (t, e, i, r, n) { this.elements = t, this.callback = e, this.options = i, this.reviver = r, this.svgUid = i && i.svgUid || 0, this.parsingOptions = n }, fabric.ElementsParser.prototype.parse = function () { this.instances = new Array(this.elements.length), this.numElements = this.elements.length, this.createObjects() }, fabric.ElementsParser.prototype.createObjects = function () { for (var t = 0, e = this.elements.length; t < e; t++)this.elements[t].setAttribute("svgUid", this.svgUid), function (t, e) { setTimeout(function () { t.createObject(t.elements[e], e) }, 0) }(this, t) }, fabric.ElementsParser.prototype.createObject = function (t, e) { var i = fabric[fabric.util.string.capitalize(t.tagName.replace("svg:", ""))]; if (i && i.fromElement) try { this._createObject(i, t, e) } catch (t) { fabric.log(t) } else this.checkIfDone() }, fabric.ElementsParser.prototype._createObject = function (t, e, i) { if (t.async) t.fromElement(e, this.createCallback(i, e), this.options); else { var r = t.fromElement(e, this.options); this.resolveGradient(r, "fill"), this.resolveGradient(r, "stroke"), this.reviver && this.reviver(e, r), this.instances[i] = r, this.checkIfDone() } }, fabric.ElementsParser.prototype.createCallback = function (t, e) { var i = this; return function (r) { i.resolveGradient(r, "fill"), i.resolveGradient(r, "stroke"), i.reviver && i.reviver(e, r), i.instances[t] = r, i.checkIfDone() } }, fabric.ElementsParser.prototype.resolveGradient = function (t, e) { var i = t.get(e); if (/^url\(/.test(i)) { var r = i.slice(5, i.length - 1); fabric.gradientDefs[this.svgUid][r] && t.set(e, fabric.Gradient.fromElement(fabric.gradientDefs[this.svgUid][r], t)) } }, fabric.ElementsParser.prototype.checkIfDone = function () { 0 == --this.numElements && (this.instances = this.instances.filter(function (t) { return null != t }), this.callback(this.instances)) }, function (t) { "use strict"; function e(t, e) { this.x = t, this.y = e } var i = t.fabric || (t.fabric = {}); i.Point ? i.warn("fabric.Point is already defined") : (i.Point = e, e.prototype = { type: "point", constructor: e, add: function (t) { return new e(this.x + t.x, this.y + t.y) }, addEquals: function (t) { return this.x += t.x, this.y += t.y, this }, scalarAdd: function (t) { return new e(this.x + t, this.y + t) }, scalarAddEquals: function (t) { return this.x += t, this.y += t, this }, subtract: function (t) { return new e(this.x - t.x, this.y - t.y) }, subtractEquals: function (t) { return this.x -= t.x, this.y -= t.y, this }, scalarSubtract: function (t) { return new e(this.x - t, this.y - t) }, scalarSubtractEquals: function (t) { return this.x -= t, this.y -= t, this }, multiply: function (t) { return new e(this.x * t, this.y * t) }, multiplyEquals: function (t) { return this.x *= t, this.y *= t, this }, divide: function (t) { return new e(this.x / t, this.y / t) }, divideEquals: function (t) { return this.x /= t, this.y /= t, this }, eq: function (t) { return this.x === t.x && this.y === t.y }, lt: function (t) { return this.x < t.x && this.y < t.y }, lte: function (t) { return this.x <= t.x && this.y <= t.y }, gt: function (t) { return this.x > t.x && this.y > t.y }, gte: function (t) { return this.x >= t.x && this.y >= t.y }, lerp: function (t, i) { return void 0 === i && (i = .5), i = Math.max(Math.min(1, i), 0), new e(this.x + (t.x - this.x) * i, this.y + (t.y - this.y) * i) }, distanceFrom: function (t) { var e = this.x - t.x, i = this.y - t.y; return Math.sqrt(e * e + i * i) }, midPointFrom: function (t) { return this.lerp(t) }, min: function (t) { return new e(Math.min(this.x, t.x), Math.min(this.y, t.y)) }, max: function (t) { return new e(Math.max(this.x, t.x), Math.max(this.y, t.y)) }, toString: function () { return this.x + "," + this.y }, setXY: function (t, e) { return this.x = t, this.y = e, this }, setX: function (t) { return this.x = t, this }, setY: function (t) { return this.y = t, this }, setFromPoint: function (t) { return this.x = t.x, this.y = t.y, this }, swap: function (t) { var e = this.x, i = this.y; this.x = t.x, this.y = t.y, t.x = e, t.y = i }, clone: function () { return new e(this.x, this.y) } }) }("undefined" != typeof exports ? exports : this), function (t) { "use strict"; function e(t) { this.status = t, this.points = [] } var i = t.fabric || (t.fabric = {}); i.Intersection ? i.warn("fabric.Intersection is already defined") : (i.Intersection = e, i.Intersection.prototype = { constructor: e, appendPoint: function (t) { return this.points.push(t), this }, appendPoints: function (t) { return this.points = this.points.concat(t), this } }, i.Intersection.intersectLineLine = function (t, r, n, s) { var o, a = (s.x - n.x) * (t.y - n.y) - (s.y - n.y) * (t.x - n.x), h = (r.x - t.x) * (t.y - n.y) - (r.y - t.y) * (t.x - n.x), c = (s.y - n.y) * (r.x - t.x) - (s.x - n.x) * (r.y - t.y); if (0 !== c) { var l = a / c, u = h / c; 0 <= l && l <= 1 && 0 <= u && u <= 1 ? (o = new e("Intersection")).appendPoint(new i.Point(t.x + l * (r.x - t.x), t.y + l * (r.y - t.y))) : o = new e } else o = new e(0 === a || 0 === h ? "Coincident" : "Parallel"); return o }, i.Intersection.intersectLinePolygon = function (t, i, r) { for (var n, s, o, a = new e, h = r.length, c = 0; c < h; c++)n = r[c], s = r[(c + 1) % h], o = e.intersectLineLine(t, i, n, s), a.appendPoints(o.points); return a.points.length > 0 && (a.status = "Intersection"), a }, i.Intersection.intersectPolygonPolygon = function (t, i) { for (var r = new e, n = t.length, s = 0; s < n; s++) { var o = t[s], a = t[(s + 1) % n], h = e.intersectLinePolygon(o, a, i); r.appendPoints(h.points) } return r.points.length > 0 && (r.status = "Intersection"), r }, i.Intersection.intersectPolygonRectangle = function (t, r, n) { var s = r.min(n), o = r.max(n), a = new i.Point(o.x, s.y), h = new i.Point(s.x, o.y), c = e.intersectLinePolygon(s, a, t), l = e.intersectLinePolygon(a, o, t), u = e.intersectLinePolygon(o, h, t), f = e.intersectLinePolygon(h, s, t), d = new e; return d.appendPoints(c.points), d.appendPoints(l.points), d.appendPoints(u.points), d.appendPoints(f.points), d.points.length > 0 && (d.status = "Intersection"), d }) }("undefined" != typeof exports ? exports : this), function (t) { "use strict"; function e(t) { t ? this._tryParsingColor(t) : this.setSource([0, 0, 0, 1]) } function i(t, e, i) { return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + (e - t) * (2 / 3 - i) * 6 : t } var r = t.fabric || (t.fabric = {}); r.Color ? r.warn("fabric.Color is already defined.") : (r.Color = e, r.Color.prototype = { _tryParsingColor: function (t) { var i; t in e.colorNameMap && (t = e.colorNameMap[t]), "transparent" === t && (i = [255, 255, 255, 0]), i || (i = e.sourceFromHex(t)), i || (i = e.sourceFromRgb(t)), i || (i = e.sourceFromHsl(t)), i || (i = [0, 0, 0, 1]), i && this.setSource(i) }, _rgbToHsl: function (t, e, i) { t /= 255, e /= 255, i /= 255; var n, s, o, a = r.util.array.max([t, e, i]), h = r.util.array.min([t, e, i]); if (o = (a + h) / 2, a === h) n = s = 0; else { var c = a - h; switch (s = o > .5 ? c / (2 - a - h) : c / (a + h), a) { case t: n = (e - i) / c + (e < i ? 6 : 0); break; case e: n = (i - t) / c + 2; break; case i: n = (t - e) / c + 4 }n /= 6 } return [Math.round(360 * n), Math.round(100 * s), Math.round(100 * o)] }, getSource: function () { return this._source }, setSource: function (t) { this._source = t }, toRgb: function () { var t = this.getSource(); return "rgb(" + t[0] + "," + t[1] + "," + t[2] + ")" }, toRgba: function () { var t = this.getSource(); return "rgba(" + t[0] + "," + t[1] + "," + t[2] + "," + t[3] + ")" }, toHsl: function () { var t = this.getSource(), e = this._rgbToHsl(t[0], t[1], t[2]); return "hsl(" + e[0] + "," + e[1] + "%," + e[2] + "%)" }, toHsla: function () { var t = this.getSource(), e = this._rgbToHsl(t[0], t[1], t[2]); return "hsla(" + e[0] + "," + e[1] + "%," + e[2] + "%," + t[3] + ")" }, toHex: function () { var t, e, i, r = this.getSource(); return t = r[0].toString(16), t = 1 === t.length ? "0" + t : t, e = r[1].toString(16), e = 1 === e.length ? "0" + e : e, i = r[2].toString(16), i = 1 === i.length ? "0" + i : i, t.toUpperCase() + e.toUpperCase() + i.toUpperCase() }, toHexa: function () { var t; return t = 255 * this.getSource()[3], t = t.toString(16), t = 1 === t.length ? "0" + t : t, this.toHex() + t.toUpperCase() }, getAlpha: function () { return this.getSource()[3] }, setAlpha: function (t) { var e = this.getSource(); return e[3] = t, this.setSource(e), this }, toGrayscale: function () { var t = this.getSource(), e = parseInt((.3 * t[0] + .59 * t[1] + .11 * t[2]).toFixed(0), 10), i = t[3]; return this.setSource([e, e, e, i]), this }, toBlackWhite: function (t) { var e = this.getSource(), i = (.3 * e[0] + .59 * e[1] + .11 * e[2]).toFixed(0), r = e[3]; return t = t || 127, i = Number(i) < Number(t) ? 0 : 255, this.setSource([i, i, i, r]), this }, overlayWith: function (t) { t instanceof e || (t = new e(t)); for (var i = [], r = this.getAlpha(), n = this.getSource(), s = t.getSource(), o = 0; o < 3; o++)i.push(Math.round(.5 * n[o] + .5 * s[o])); return i[3] = r, this.setSource(i), this } }, r.Color.reRGBa = /^rgba?\(\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*(?:\s*,\s*((?:\d*\.?\d+)?)\s*)?\)$/, r.Color.reHSLa = /^hsla?\(\s*(\d{1,3})\s*,\s*(\d{1,3}\%)\s*,\s*(\d{1,3}\%)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/, r.Color.reHex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i, r.Color.colorNameMap = { aqua: "#00FFFF", black: "#000000", blue: "#0000FF", fuchsia: "#FF00FF", gray: "#808080", grey: "#808080", green: "#008000", lime: "#00FF00", maroon: "#800000", navy: "#000080", olive: "#808000", orange: "#FFA500", purple: "#800080", red: "#FF0000", silver: "#C0C0C0", teal: "#008080", white: "#FFFFFF", yellow: "#FFFF00" }, r.Color.fromRgb = function (t) { return e.fromSource(e.sourceFromRgb(t)) }, r.Color.sourceFromRgb = function (t) { var i = t.match(e.reRGBa); if (i) { var r = parseInt(i[1], 10) / (/%$/.test(i[1]) ? 100 : 1) * (/%$/.test(i[1]) ? 255 : 1), n = parseInt(i[2], 10) / (/%$/.test(i[2]) ? 100 : 1) * (/%$/.test(i[2]) ? 255 : 1), s = parseInt(i[3], 10) / (/%$/.test(i[3]) ? 100 : 1) * (/%$/.test(i[3]) ? 255 : 1); return [parseInt(r, 10), parseInt(n, 10), parseInt(s, 10), i[4] ? parseFloat(i[4]) : 1] } }, r.Color.fromRgba = e.fromRgb, r.Color.fromHsl = function (t) { return e.fromSource(e.sourceFromHsl(t)) }, r.Color.sourceFromHsl = function (t) { var r = t.match(e.reHSLa); if (r) { var n, s, o, a = (parseFloat(r[1]) % 360 + 360) % 360 / 360, h = parseFloat(r[2]) / (/%$/.test(r[2]) ? 100 : 1), c = parseFloat(r[3]) / (/%$/.test(r[3]) ? 100 : 1); if (0 === h) n = s = o = c; else { var l = c <= .5 ? c * (h + 1) : c + h - c * h, u = 2 * c - l; n = i(u, l, a + 1 / 3), s = i(u, l, a), o = i(u, l, a - 1 / 3) } return [Math.round(255 * n), Math.round(255 * s), Math.round(255 * o), r[4] ? parseFloat(r[4]) : 1] } }, r.Color.fromHsla = e.fromHsl, r.Color.fromHex = function (t) { return e.fromSource(e.sourceFromHex(t)) }, r.Color.sourceFromHex = function (t) { if (t.match(e.reHex)) { var i = t.slice(t.indexOf("#") + 1), r = 3 === i.length || 4 === i.length, n = 8 === i.length || 4 === i.length, s = r ? i.charAt(0) + i.charAt(0) : i.substring(0, 2), o = r ? i.charAt(1) + i.charAt(1) : i.substring(2, 4), a = r ? i.charAt(2) + i.charAt(2) : i.substring(4, 6), h = n ? r ? i.charAt(3) + i.charAt(3) : i.substring(6, 8) : "FF"; return [parseInt(s, 16), parseInt(o, 16), parseInt(a, 16), parseFloat((parseInt(h, 16) / 255).toFixed(2))] } }, r.Color.fromSource = function (t) { var i = new e; return i.setSource(t), i }) }("undefined" != typeof exports ? exports : this), function () { function t(t) { var e, i, r, n = t.getAttribute("style"), s = t.getAttribute("offset") || 0; if (s = parseFloat(s) / (/%$/.test(s) ? 100 : 1), s = s < 0 ? 0 : s > 1 ? 1 : s, n) { var o = n.split(/\s*;\s*/); "" === o[o.length - 1] && o.pop(); for (var a = o.length; a--;) { var h = o[a].split(/\s*:\s*/), c = h[0].trim(), l = h[1].trim(); "stop-color" === c ? e = l : "stop-opacity" === c && (r = l) } } return e || (e = t.getAttribute("stop-color") || "rgb(0,0,0)"), r || (r = t.getAttribute("stop-opacity")), e = new fabric.Color(e), i = e.getAlpha(), r = isNaN(parseFloat(r)) ? 1 : parseFloat(r), r *= i, { offset: s, color: e.toRgb(), opacity: r } } function e(t) { return { x1: t.getAttribute("x1") || 0, y1: t.getAttribute("y1") || 0, x2: t.getAttribute("x2") || "100%", y2: t.getAttribute("y2") || 0 } } function i(t) { return { x1: t.getAttribute("fx") || t.getAttribute("cx") || "50%", y1: t.getAttribute("fy") || t.getAttribute("cy") || "50%", r1: 0, x2: t.getAttribute("cx") || "50%", y2: t.getAttribute("cy") || "50%", r2: t.getAttribute("r") || "50%" } } function r(t, e, i) { var r, n = 0, s = 1, o = ""; for (var a in e) "Infinity" === e[a] ? e[a] = 1 : "-Infinity" === e[a] && (e[a] = 0), r = parseFloat(e[a], 10), s = "string" == typeof e[a] && /^\d+%$/.test(e[a]) ? .01 : 1, "x1" === a || "x2" === a || "r2" === a ? (s *= "objectBoundingBox" === i ? t.width : 1, n = "objectBoundingBox" === i ? t.left || 0 : 0) : "y1" !== a && "y2" !== a || (s *= "objectBoundingBox" === i ? t.height : 1, n = "objectBoundingBox" === i ? t.top || 0 : 0), e[a] = r * s + n; if ("ellipse" === t.type && null !== e.r2 && "objectBoundingBox" === i && t.rx !== t.ry) { var h = t.ry / t.rx; o = " scale(1, " + h + ")", e.y1 && (e.y1 /= h), e.y2 && (e.y2 /= h) } return o } var n = fabric.util.object.clone; fabric.Gradient = fabric.util.createClass({ offsetX: 0, offsetY: 0, initialize: function (t) { t || (t = {}); var e = {}; this.id = fabric.Object.__uid++ , this.type = t.type || "linear", e = { x1: t.coords.x1 || 0, y1: t.coords.y1 || 0, x2: t.coords.x2 || 0, y2: t.coords.y2 || 0 }, "radial" === this.type && (e.r1 = t.coords.r1 || 0, e.r2 = t.coords.r2 || 0), this.coords = e, this.colorStops = t.colorStops.slice(), t.gradientTransform && (this.gradientTransform = t.gradientTransform), this.offsetX = t.offsetX || this.offsetX, this.offsetY = t.offsetY || this.offsetY }, addColorStop: function (t) { for (var e in t) { var i = new fabric.Color(t[e]); this.colorStops.push({ offset: parseFloat(e), color: i.toRgb(), opacity: i.getAlpha() }) } return this }, toObject: function (t) { var e = { type: this.type, coords: this.coords, colorStops: this.colorStops, offsetX: this.offsetX, offsetY: this.offsetY, gradientTransform: this.gradientTransform ? this.gradientTransform.concat() : this.gradientTransform }; return fabric.util.populateWithProperties(this, e, t), e }, toSVG: function (t) { var e, i, r = n(this.coords, !0), s = n(this.colorStops, !0), o = r.r1 > r.r2; if (s.sort(function (t, e) { return t.offset - e.offset }), !t.group || "path-group" !== t.group.type) for (var a in r) "x1" === a || "x2" === a ? r[a] += this.offsetX - t.width / 2 : "y1" !== a && "y2" !== a || (r[a] += this.offsetY - t.height / 2); if (i = 'id="SVGID_' + this.id + '" gradientUnits="userSpaceOnUse"', this.gradientTransform && (i += ' gradientTransform="matrix(' + this.gradientTransform.join(" ") + ')" '), "linear" === this.type ? e = ["<linearGradient ", i, ' x1="', r.x1, '" y1="', r.y1, '" x2="', r.x2, '" y2="', r.y2, '">\n'] : "radial" === this.type && (e = ["<radialGradient ", i, ' cx="', o ? r.x1 : r.x2, '" cy="', o ? r.y1 : r.y2, '" r="', o ? r.r1 : r.r2, '" fx="', o ? r.x2 : r.x1, '" fy="', o ? r.y2 : r.y1, '">\n']), "radial" === this.type) { if (o) { (s = s.concat()).reverse(); for (l = 0; l < s.length; l++)s[l].offset = 1 - s[l].offset } var h = Math.min(r.r1, r.r2); if (h > 0) for (var c = h / Math.max(r.r1, r.r2), l = 0; l < s.length; l++)s[l].offset += c * (1 - s[l].offset) } for (l = 0; l < s.length; l++) { var u = s[l]; e.push("<stop ", 'offset="', 100 * u.offset + "%", '" style="stop-color:', u.color, null !== u.opacity ? ";stop-opacity: " + u.opacity : ";", '"/>\n') } return e.push("linear" === this.type ? "</linearGradient>\n" : "</radialGradient>\n"), e.join("") }, toLive: function (t, e) { var i, r, n = fabric.util.object.clone(this.coords); if (this.type) { if (e.group && "path-group" === e.group.type) for (r in n) "x1" === r || "x2" === r ? n[r] += -this.offsetX + e.width / 2 : "y1" !== r && "y2" !== r || (n[r] += -this.offsetY + e.height / 2); "linear" === this.type ? i = t.createLinearGradient(n.x1, n.y1, n.x2, n.y2) : "radial" === this.type && (i = t.createRadialGradient(n.x1, n.y1, n.r1, n.x2, n.y2, n.r2)); for (var s = 0, o = this.colorStops.length; s < o; s++) { var a = this.colorStops[s].color, h = this.colorStops[s].opacity, c = this.colorStops[s].offset; void 0 !== h && (a = new fabric.Color(a).setAlpha(h).toRgba()), i.addColorStop(c, a) } return i } } }), fabric.util.object.extend(fabric.Gradient, { fromElement: function (n, s) { var o, a, h, c = n.getElementsByTagName("stop"), l = n.getAttribute("gradientUnits") || "objectBoundingBox", u = n.getAttribute("gradientTransform"), f = []; "linear" === (o = "linearGradient" === n.nodeName || "LINEARGRADIENT" === n.nodeName ? "linear" : "radial") ? a = e(n) : "radial" === o && (a = i(n)); for (var d = c.length; d--;)f.push(t(c[d])); h = r(s, a, l); var g = new fabric.Gradient({ type: o, coords: a, colorStops: f, offsetX: -s.left, offsetY: -s.top }); return (u || "" !== h) && (g.gradientTransform = fabric.parseTransformAttribute((u || "") + h)), g }, forObject: function (t, e) { return e || (e = {}), r(t, e.coords, "userSpaceOnUse"), new fabric.Gradient(e) } }) }(), function () { "use strict"; var t = fabric.util.toFixed; fabric.Pattern = fabric.util.createClass({ repeat: "repeat", offsetX: 0, offsetY: 0, initialize: function (t, e) { if (t || (t = {}), this.id = fabric.Object.__uid++ , this.setOptions(t), !t.source || t.source && "string" != typeof t.source) e && e(this); else if (void 0 !== fabric.util.getFunctionBody(t.source)) this.source = new Function(fabric.util.getFunctionBody(t.source)), e && e(this); else { var i = this; this.source = fabric.util.createImage(), fabric.util.loadImage(t.source, function (t) { i.source = t, e && e(i) }) } }, toObject: function (e) { var i, r, n = fabric.Object.NUM_FRACTION_DIGITS; return "function" == typeof this.source ? i = String(this.source) : "string" == typeof this.source.src ? i = this.source.src : "object" == typeof this.source && this.source.toDataURL && (i = this.source.toDataURL()), r = { type: "pattern", source: i, repeat: this.repeat, offsetX: t(this.offsetX, n), offsetY: t(this.offsetY, n) }, fabric.util.populateWithProperties(this, r, e), r }, toSVG: function (t) { var e = "function" == typeof this.source ? this.source() : this.source, i = e.width / t.width, r = e.height / t.height, n = this.offsetX / t.width, s = this.offsetY / t.height, o = ""; return "repeat-x" !== this.repeat && "no-repeat" !== this.repeat || (r = 1), "repeat-y" !== this.repeat && "no-repeat" !== this.repeat || (i = 1), e.src ? o = e.src : e.toDataURL && (o = e.toDataURL()), '<pattern id="SVGID_' + this.id + '" x="' + n + '" y="' + s + '" width="' + i + '" height="' + r + '">\n<image x="0" y="0" width="' + e.width + '" height="' + e.height + '" xlink:href="' + o + '"></image>\n</pattern>\n' }, setOptions: function (t) { for (var e in t) this[e] = t[e] }, toLive: function (t) { var e = "function" == typeof this.source ? this.source() : this.source; if (!e) return ""; if (void 0 !== e.src) { if (!e.complete) return ""; if (0 === e.naturalWidth || 0 === e.naturalHeight) return "" } return t.createPattern(e, this.repeat) } }) }(), function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.toFixed; e.Shadow ? e.warn("fabric.Shadow is already defined.") : (e.Shadow = e.util.createClass({ color: "rgb(0,0,0)", blur: 0, offsetX: 0, offsetY: 0, affectStroke: !1, includeDefaultValues: !0, initialize: function (t) { "string" == typeof t && (t = this._parseShadow(t)); for (var i in t) this[i] = t[i]; this.id = e.Object.__uid++ }, _parseShadow: function (t) { var i = t.trim(), r = e.Shadow.reOffsetsAndBlur.exec(i) || []; return { color: (i.replace(e.Shadow.reOffsetsAndBlur, "") || "rgb(0,0,0)").trim(), offsetX: parseInt(r[1], 10) || 0, offsetY: parseInt(r[2], 10) || 0, blur: parseInt(r[3], 10) || 0 } }, toString: function () { return [this.offsetX, this.offsetY, this.blur, this.color].join("px ") }, toSVG: function (t) { var r = 40, n = 40, s = e.Object.NUM_FRACTION_DIGITS, o = e.util.rotateVector({ x: this.offsetX, y: this.offsetY }, e.util.degreesToRadians(-t.angle)); return t.width && t.height && (r = 100 * i((Math.abs(o.x) + this.blur) / t.width, s) + 20, n = 100 * i((Math.abs(o.y) + this.blur) / t.height, s) + 20), t.flipX && (o.x *= -1), t.flipY && (o.y *= -1), '<filter id="SVGID_' + this.id + '" y="-' + n + '%" height="' + (100 + 2 * n) + '%" x="-' + r + '%" width="' + (100 + 2 * r) + '%" >\n\t<feGaussianBlur in="SourceAlpha" stdDeviation="' + i(this.blur ? this.blur / 2 : 0, s) + '"></feGaussianBlur>\n\t<feOffset dx="' + i(o.x, s) + '" dy="' + i(o.y, s) + '" result="oBlur" ></feOffset>\n\t<feFlood flood-color="' + this.color + '"/>\n\t<feComposite in2="oBlur" operator="in" />\n\t<feMerge>\n\t\t<feMergeNode></feMergeNode>\n\t\t<feMergeNode in="SourceGraphic"></feMergeNode>\n\t</feMerge>\n</filter>\n' }, toObject: function () { if (this.includeDefaultValues) return { color: this.color, blur: this.blur, offsetX: this.offsetX, offsetY: this.offsetY, affectStroke: this.affectStroke }; var t = {}, i = e.Shadow.prototype; return ["color", "blur", "offsetX", "offsetY", "affectStroke"].forEach(function (e) { this[e] !== i[e] && (t[e] = this[e]) }, this), t } }), e.Shadow.reOffsetsAndBlur = /(?:\s|^)(-?\d+(?:px)?(?:\s?|$))?(-?\d+(?:px)?(?:\s?|$))?(\d+(?:px)?)?(?:\s?|$)(?:$|\s)/) }("undefined" != typeof exports ? exports : this), function () { "use strict"; if (fabric.StaticCanvas) fabric.warn("fabric.StaticCanvas is already defined."); else { var t = fabric.util.object.extend, e = fabric.util.getElementOffset, i = fabric.util.removeFromArray, r = fabric.util.toFixed, n = fabric.util.transformPoint, s = fabric.util.invertTransform, o = new Error("Could not initialize `canvas` element"); fabric.StaticCanvas = fabric.util.createClass(fabric.CommonMethods, { initialize: function (t, e) { e || (e = {}), this._initStatic(t, e) }, backgroundColor: "", backgroundImage: null, overlayColor: "", overlayImage: null, includeDefaultValues: !0, stateful: !1, renderOnAddRemove: !0, clipTo: null, controlsAboveOverlay: !1, allowTouchScrolling: !1, imageSmoothingEnabled: !0, viewportTransform: fabric.iMatrix.concat(), backgroundVpt: !0, overlayVpt: !0, onBeforeScaleRotate: function () { }, enableRetinaScaling: !0, vptCoords: {}, skipOffscreen: !1, _initStatic: function (t, e) { var i = fabric.StaticCanvas.prototype.renderAll.bind(this); this._objects = [], this._createLowerCanvas(t), this._initOptions(e), this._setImageSmoothing(), this.interactive || this._initRetinaScaling(), e.overlayImage && this.setOverlayImage(e.overlayImage, i), e.backgroundImage && this.setBackgroundImage(e.backgroundImage, i), e.backgroundColor && this.setBackgroundColor(e.backgroundColor, i), e.overlayColor && this.setOverlayColor(e.overlayColor, i), this.calcOffset() }, _isRetinaScaling: function () { return 1 !== fabric.devicePixelRatio && this.enableRetinaScaling }, getRetinaScaling: function () { return this._isRetinaScaling() ? fabric.devicePixelRatio : 1 }, _initRetinaScaling: function () { this._isRetinaScaling() && (this.lowerCanvasEl.setAttribute("width", this.width * fabric.devicePixelRatio), this.lowerCanvasEl.setAttribute("height", this.height * fabric.devicePixelRatio), this.contextContainer.scale(fabric.devicePixelRatio, fabric.devicePixelRatio)) }, calcOffset: function () { return this._offset = e(this.lowerCanvasEl), this }, setOverlayImage: function (t, e, i) { return this.__setBgOverlayImage("overlayImage", t, e, i) }, setBackgroundImage: function (t, e, i) { return this.__setBgOverlayImage("backgroundImage", t, e, i) }, setOverlayColor: function (t, e) { return this.__setBgOverlayColor("overlayColor", t, e) }, setBackgroundColor: function (t, e) { return this.__setBgOverlayColor("backgroundColor", t, e) }, _setImageSmoothing: function () { var t = this.getContext(); t.imageSmoothingEnabled = t.imageSmoothingEnabled || t.webkitImageSmoothingEnabled || t.mozImageSmoothingEnabled || t.msImageSmoothingEnabled || t.oImageSmoothingEnabled, t.imageSmoothingEnabled = this.imageSmoothingEnabled }, __setBgOverlayImage: function (t, e, i, r) { return "string" == typeof e ? fabric.util.loadImage(e, function (e) { e && (this[t] = new fabric.Image(e, r)), i && i(e) }, this, r && r.crossOrigin) : (r && e.setOptions(r), this[t] = e, i && i(e)), this }, __setBgOverlayColor: function (t, e, i) { return this[t] = e, this._initGradient(e, t), this._initPattern(e, t, i), this }, _createCanvasElement: function (t) { var e = fabric.util.createCanvasElement(t); if (e.style || (e.style = {}), !e) throw o; if (void 0 === e.getContext) throw o; return e }, _initOptions: function (t) { this._setOptions(t), this.width = this.width || parseInt(this.lowerCanvasEl.width, 10) || 0, this.height = this.height || parseInt(this.lowerCanvasEl.height, 10) || 0, this.lowerCanvasEl.style && (this.lowerCanvasEl.width = this.width, this.lowerCanvasEl.height = this.height, this.lowerCanvasEl.style.width = this.width + "px", this.lowerCanvasEl.style.height = this.height + "px", this.viewportTransform = this.viewportTransform.slice()) }, _createLowerCanvas: function (t) { this.lowerCanvasEl = fabric.util.getById(t) || this._createCanvasElement(t), fabric.util.addClass(this.lowerCanvasEl, "lower-canvas"), this.interactive && this._applyCanvasStyle(this.lowerCanvasEl), this.contextContainer = this.lowerCanvasEl.getContext("2d") }, getWidth: function () { return this.width }, getHeight: function () { return this.height }, setWidth: function (t, e) { return this.setDimensions({ width: t }, e) }, setHeight: function (t, e) { return this.setDimensions({ height: t }, e) }, setDimensions: function (t, e) { var i; e = e || {}; for (var r in t) i = t[r], e.cssOnly || (this._setBackstoreDimension(r, t[r]), i += "px"), e.backstoreOnly || this._setCssDimension(r, i); return this._initRetinaScaling(), this._setImageSmoothing(), this.calcOffset(), e.cssOnly || this.renderAll(), this }, _setBackstoreDimension: function (t, e) { return this.lowerCanvasEl[t] = e, this.upperCanvasEl && (this.upperCanvasEl[t] = e), this.cacheCanvasEl && (this.cacheCanvasEl[t] = e), this[t] = e, this }, _setCssDimension: function (t, e) { return this.lowerCanvasEl.style[t] = e, this.upperCanvasEl && (this.upperCanvasEl.style[t] = e), this.wrapperEl && (this.wrapperEl.style[t] = e), this }, getZoom: function () { return this.viewportTransform[0] }, setViewportTransform: function (t) { var e, i = this._activeGroup; this.viewportTransform = t; for (var r = 0, n = this._objects.length; r < n; r++)(e = this._objects[r]).group || e.setCoords(!1, !0); return i && i.setCoords(!1, !0), this.calcViewportBoundaries(), this.renderAll(), this }, zoomToPoint: function (t, e) { var i = t, r = this.viewportTransform.slice(0); t = n(t, s(this.viewportTransform)), r[0] = e, r[3] = e; var o = n(t, r); return r[4] += i.x - o.x, r[5] += i.y - o.y, this.setViewportTransform(r) }, setZoom: function (t) { return this.zoomToPoint(new fabric.Point(0, 0), t), this }, absolutePan: function (t) { var e = this.viewportTransform.slice(0); return e[4] = -t.x, e[5] = -t.y, this.setViewportTransform(e) }, relativePan: function (t) { return this.absolutePan(new fabric.Point(-t.x - this.viewportTransform[4], -t.y - this.viewportTransform[5])) }, getElement: function () { return this.lowerCanvasEl }, _onObjectAdded: function (t) { this.stateful && t.setupState(), t._set("canvas", this), t.setCoords(), this.fire("object:added", { target: t }), t.fire("added") }, _onObjectRemoved: function (t) { this.fire("object:removed", { target: t }), t.fire("removed"), delete t.canvas }, clearContext: function (t) { return t.clearRect(0, 0, this.width, this.height), this }, getContext: function () { return this.contextContainer }, clear: function () { return this._objects.length = 0, this.backgroundImage = null, this.overlayImage = null, this.backgroundColor = "", this.overlayColor = "", this._hasITextHandlers && (this.off("mouse:up", this._mouseUpITextHandler), this._iTextInstances = null, this._hasITextHandlers = !1), this.clearContext(this.contextContainer), this.fire("canvas:cleared"), this.renderAll(), this }, renderAll: function () { var t = this.contextContainer; return this.renderCanvas(t, this._objects), this }, calcViewportBoundaries: function () { var t = {}, e = this.getWidth(), i = this.getHeight(), r = s(this.viewportTransform); return t.tl = n({ x: 0, y: 0 }, r), t.br = n({ x: e, y: i }, r), t.tr = new fabric.Point(t.br.x, t.tl.y), t.bl = new fabric.Point(t.tl.x, t.br.y), this.vptCoords = t, t }, renderCanvas: function (t, e) { this.calcViewportBoundaries(), this.clearContext(t), this.fire("before:render"), this.clipTo && fabric.util.clipContext(this, t), this._renderBackground(t), t.save(), t.transform.apply(t, this.viewportTransform), this._renderObjects(t, e), t.restore(), !this.controlsAboveOverlay && this.interactive && this.drawControls(t), this.clipTo && t.restore(), this._renderOverlay(t), this.controlsAboveOverlay && this.interactive && this.drawControls(t), this.fire("after:render") }, _renderObjects: function (t, e) { for (var i = 0, r = e.length; i < r; ++i)e[i] && e[i].render(t) }, _renderBackgroundOrOverlay: function (t, e) { var i = this[e + "Color"]; i && (t.fillStyle = i.toLive ? i.toLive(t, this) : i, t.fillRect(i.offsetX || 0, i.offsetY || 0, this.width, this.height)), (i = this[e + "Image"]) && (this[e + "Vpt"] && (t.save(), t.transform.apply(t, this.viewportTransform)), i.render(t), this[e + "Vpt"] && t.restore()) }, _renderBackground: function (t) { this._renderBackgroundOrOverlay(t, "background") }, _renderOverlay: function (t) { this._renderBackgroundOrOverlay(t, "overlay") }, getCenter: function () { return { top: this.getHeight() / 2, left: this.getWidth() / 2 } }, centerObjectH: function (t) { return this._centerObject(t, new fabric.Point(this.getCenter().left, t.getCenterPoint().y)) }, centerObjectV: function (t) { return this._centerObject(t, new fabric.Point(t.getCenterPoint().x, this.getCenter().top)) }, centerObject: function (t) { var e = this.getCenter(); return this._centerObject(t, new fabric.Point(e.left, e.top)) }, viewportCenterObject: function (t) { var e = this.getVpCenter(); return this._centerObject(t, e) }, viewportCenterObjectH: function (t) { var e = this.getVpCenter(); return this._centerObject(t, new fabric.Point(e.x, t.getCenterPoint().y)), this }, viewportCenterObjectV: function (t) { var e = this.getVpCenter(); return this._centerObject(t, new fabric.Point(t.getCenterPoint().x, e.y)) }, getVpCenter: function () { var t = this.getCenter(), e = s(this.viewportTransform); return n({ x: t.left, y: t.top }, e) }, _centerObject: function (t, e) { return t.setPositionByOrigin(e, "center", "center"), this.renderAll(), this }, toDatalessJSON: function (t) { return this.toDatalessObject(t) }, toObject: function (t) { return this._toObjectMethod("toObject", t) }, toDatalessObject: function (t) { return this._toObjectMethod("toDatalessObject", t) }, _toObjectMethod: function (e, i) { var r = { objects: this._toObjects(e, i) }; return t(r, this.__serializeBgOverlay(e, i)), fabric.util.populateWithProperties(this, r, i), r }, _toObjects: function (t, e) { return this.getObjects().filter(function (t) { return !t.excludeFromExport }).map(function (i) { return this._toObject(i, t, e) }, this) }, _toObject: function (t, e, i) { var r; this.includeDefaultValues || (r = t.includeDefaultValues, t.includeDefaultValues = !1); var n = t[e](i); return this.includeDefaultValues || (t.includeDefaultValues = r), n }, __serializeBgOverlay: function (t, e) { var i = {}, r = this.backgroundImage, n = this.overlayImage; return this.backgroundColor && (i.background = this.backgroundColor.toObject ? this.backgroundColor.toObject(e) : this.backgroundColor), this.overlayColor && (i.overlay = this.overlayColor.toObject ? this.overlayColor.toObject(e) : this.overlayColor), r && !r.excludeFromExport && (i.backgroundImage = this._toObject(r, t, e)), n && !n.excludeFromExport && (i.overlayImage = this._toObject(n, t, e)), i }, svgViewportTransformation: !0, toSVG: function (t, e) { t || (t = {}); var i = []; return this._setSVGPreamble(i, t), this._setSVGHeader(i, t), this._setSVGBgOverlayColor(i, "backgroundColor"), this._setSVGBgOverlayImage(i, "backgroundImage", e), this._setSVGObjects(i, e), this._setSVGBgOverlayColor(i, "overlayColor"), this._setSVGBgOverlayImage(i, "overlayImage", e), i.push("</svg>"), i.join("") }, _setSVGPreamble: function (t, e) { e.suppressPreamble || t.push('<?xml version="1.0" encoding="', e.encoding || "UTF-8", '" standalone="no" ?>\n', '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ', '"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n') }, _setSVGHeader: function (t, e) { var i, n = e.width || this.width, s = e.height || this.height, o = 'viewBox="0 0 ' + this.width + " " + this.height + '" ', a = fabric.Object.NUM_FRACTION_DIGITS; e.viewBox ? o = 'viewBox="' + e.viewBox.x + " " + e.viewBox.y + " " + e.viewBox.width + " " + e.viewBox.height + '" ' : this.svgViewportTransformation && (i = this.viewportTransform, o = 'viewBox="' + r(-i[4] / i[0], a) + " " + r(-i[5] / i[3], a) + " " + r(this.width / i[0], a) + " " + r(this.height / i[3], a) + '" '), t.push("<svg ", 'xmlns="http://www.w3.org/2000/svg" ', 'xmlns:xlink="http://www.w3.org/1999/xlink" ', 'version="1.1" ', 'width="', n, '" ', 'height="', s, '" ', o, 'xml:space="preserve">\n', "<desc>Created with Fabric.js ", fabric.version, "</desc>\n", "<defs>\n", this.createSVGFontFacesMarkup(), this.createSVGRefElementsMarkup(), "</defs>\n") }, createSVGRefElementsMarkup: function () { var t = this; return ["backgroundColor", "overlayColor"].map(function (e) { var i = t[e]; if (i && i.toLive) return i.toSVG(t, !1) }).join("") }, createSVGFontFacesMarkup: function () { for (var t, e, i, r, n, s, o = "", a = {}, h = fabric.fontPaths, c = this.getObjects(), l = 0, u = c.length; l < u; l++)if (t = c[l], e = t.fontFamily, -1 !== t.type.indexOf("text") && !a[e] && h[e] && (a[e] = !0, t.styles)) { i = t.styles; for (n in i) { r = i[n]; for (s in r) !a[e = r[s].fontFamily] && h[e] && (a[e] = !0) } } for (var f in a) o += ["\t\t@font-face {\n", "\t\t\tfont-family: '", f, "';\n", "\t\t\tsrc: url('", h[f], "');\n", "\t\t}\n"].join(""); return o && (o = ['\t<style type="text/css">', "<![CDATA[\n", o, "]]>", "</style>\n"].join("")), o }, _setSVGObjects: function (t, e) { for (var i, r = 0, n = this.getObjects(), s = n.length; r < s; r++)(i = n[r]).excludeFromExport || this._setSVGObject(t, i, e) }, _setSVGObject: function (t, e, i) { t.push(e.toSVG(i)) }, _setSVGBgOverlayImage: function (t, e, i) { this[e] && this[e].toSVG && t.push(this[e].toSVG(i)) }, _setSVGBgOverlayColor: function (t, e) { var i = this[e]; if (i) if (i.toLive) { var r = i.repeat; t.push('<rect transform="translate(', this.width / 2, ",", this.height / 2, ')"', ' x="', i.offsetX - this.width / 2, '" y="', i.offsetY - this.height / 2, '" ', 'width="', "repeat-y" === r || "no-repeat" === r ? i.source.width : this.width, '" height="', "repeat-x" === r || "no-repeat" === r ? i.source.height : this.height, '" fill="url(#SVGID_' + i.id + ')"', "></rect>\n") } else t.push('<rect x="0" y="0" ', 'width="', this.width, '" height="', this.height, '" fill="', this[e], '"', "></rect>\n") }, sendToBack: function (t) { if (!t) return this; var e, r, n, s = this._activeGroup; if (t === s) for (e = (n = s._objects).length; e--;)r = n[e], i(this._objects, r), this._objects.unshift(r); else i(this._objects, t), this._objects.unshift(t); return this.renderAll && this.renderAll() }, bringToFront: function (t) { if (!t) return this; var e, r, n, s = this._activeGroup; if (t === s) for (n = s._objects, e = 0; e < n.length; e++)r = n[e], i(this._objects, r), this._objects.push(r); else i(this._objects, t), this._objects.push(t); return this.renderAll && this.renderAll() }, sendBackwards: function (t, e) { if (!t) return this; var r, n, s, o, a, h = this._activeGroup, c = 0; if (t === h) for (a = h._objects, r = 0; r < a.length; r++)n = a[r], (s = this._objects.indexOf(n)) > 0 + c && (o = s - 1, i(this._objects, n), this._objects.splice(o, 0, n)), c++; else 0 !== (s = this._objects.indexOf(t)) && (o = this._findNewLowerIndex(t, s, e), i(this._objects, t), this._objects.splice(o, 0, t)); return this.renderAll && this.renderAll(), this }, _findNewLowerIndex: function (t, e, i) { var r; if (i) { r = e; for (var n = e - 1; n >= 0; --n)if (t.intersectsWithObject(this._objects[n]) || t.isContainedWithinObject(this._objects[n]) || this._objects[n].isContainedWithinObject(t)) { r = n; break } } else r = e - 1; return r }, bringForward: function (t, e) { if (!t) return this; var r, n, s, o, a, h = this._activeGroup, c = 0; if (t === h) for (r = (a = h._objects).length; r--;)n = a[r], (s = this._objects.indexOf(n)) < this._objects.length - 1 - c && (o = s + 1, i(this._objects, n), this._objects.splice(o, 0, n)), c++; else (s = this._objects.indexOf(t)) !== this._objects.length - 1 && (o = this._findNewUpperIndex(t, s, e), i(this._objects, t), this._objects.splice(o, 0, t)); return this.renderAll && this.renderAll(), this }, _findNewUpperIndex: function (t, e, i) { var r; if (i) { r = e; for (var n = e + 1; n < this._objects.length; ++n)if (t.intersectsWithObject(this._objects[n]) || t.isContainedWithinObject(this._objects[n]) || this._objects[n].isContainedWithinObject(t)) { r = n; break } } else r = e + 1; return r }, moveTo: function (t, e) { return i(this._objects, t), this._objects.splice(e, 0, t), this.renderAll && this.renderAll() }, dispose: function () { return this.clear(), this }, toString: function () { return "#<fabric.Canvas (" + this.complexity() + "): { objects: " + this.getObjects().length + " }>" } }), t(fabric.StaticCanvas.prototype, fabric.Observable), t(fabric.StaticCanvas.prototype, fabric.Collection), t(fabric.StaticCanvas.prototype, fabric.DataURLExporter), t(fabric.StaticCanvas, { EMPTY_JSON: '{"objects": [], "background": "white"}', supports: function (t) { var e = fabric.util.createCanvasElement(); if (!e || !e.getContext) return null; var i = e.getContext("2d"); if (!i) return null; switch (t) { case "getImageData": return void 0 !== i.getImageData; case "setLineDash": return void 0 !== i.setLineDash; case "toDataURL": return void 0 !== e.toDataURL; case "toDataURLWithQuality": try { return e.toDataURL("image/jpeg", 0), !0 } catch (t) { } return !1; default: return null } } }), fabric.StaticCanvas.prototype.toJSON = fabric.StaticCanvas.prototype.toObject } }(), fabric.BaseBrush = fabric.util.createClass({ color: "rgb(0, 0, 0)", width: 1, shadow: null, strokeLineCap: "round", strokeLineJoin: "round", strokeDashArray: null, setShadow: function (t) { return this.shadow = new fabric.Shadow(t), this }, _setBrushStyles: function () { var t = this.canvas.contextTop; t.strokeStyle = this.color, t.lineWidth = this.width, t.lineCap = this.strokeLineCap, t.lineJoin = this.strokeLineJoin, this.strokeDashArray && fabric.StaticCanvas.supports("setLineDash") && t.setLineDash(this.strokeDashArray) }, _setShadow: function () { if (this.shadow) { var t = this.canvas.contextTop, e = this.canvas.getZoom(); t.shadowColor = this.shadow.color, t.shadowBlur = this.shadow.blur * e, t.shadowOffsetX = this.shadow.offsetX * e, t.shadowOffsetY = this.shadow.offsetY * e } }, _resetShadow: function () { var t = this.canvas.contextTop; t.shadowColor = "", t.shadowBlur = t.shadowOffsetX = t.shadowOffsetY = 0 } }), fabric.PencilBrush = fabric.util.createClass(fabric.BaseBrush, { initialize: function (t) { this.canvas = t, this._points = [] }, onMouseDown: function (t) { this._prepareForDrawing(t), this._captureDrawingPath(t), this._render() }, onMouseMove: function (t) { this._captureDrawingPath(t), this.canvas.clearContext(this.canvas.contextTop), this._render() }, onMouseUp: function () { this._finalizeAndAddPath() }, _prepareForDrawing: function (t) { var e = new fabric.Point(t.x, t.y); this._reset(), this._addPoint(e), this.canvas.contextTop.moveTo(e.x, e.y) }, _addPoint: function (t) { this._points.length > 1 && t.eq(this._points[this._points.length - 1]) || this._points.push(t) }, _reset: function () { this._points.length = 0, this._setBrushStyles(), this._setShadow() }, _captureDrawingPath: function (t) { var e = new fabric.Point(t.x, t.y); this._addPoint(e) }, _render: function () { var t, e, i = this.canvas.contextTop, r = this.canvas.viewportTransform, n = this._points[0], s = this._points[1]; if (i.save(), i.transform(r[0], r[1], r[2], r[3], r[4], r[5]), i.beginPath(), 2 === this._points.length && n.x === s.x && n.y === s.y) { var o = this.width / 1e3; n = new fabric.Point(n.x, n.y), s = new fabric.Point(s.x, s.y), n.x -= o, s.x += o } for (i.moveTo(n.x, n.y), t = 1, e = this._points.length; t < e; t++) { var a = n.midPointFrom(s); i.quadraticCurveTo(n.x, n.y, a.x, a.y), n = this._points[t], s = this._points[t + 1] } i.lineTo(n.x, n.y), i.stroke(), i.restore() }, convertPointsToSVGPath: function (t) { var e, i, r, n = [], s = this.width / 1e3, o = new fabric.Point(t[0].x, t[0].y), a = new fabric.Point(t[1].x, t[1].y), h = t.length, c = h > 2; for (c && (i = t[2].x < a.x ? -1 : t[2].x === a.x ? 0 : 1, r = t[2].y < a.y ? -1 : t[2].y === a.y ? 0 : 1), n.push("M ", o.x - i * s, " ", o.y - r * s, " "), e = 1; e < h; e++) { if (!o.eq(a)) { var l = o.midPointFrom(a); n.push("Q ", o.x, " ", o.y, " ", l.x, " ", l.y, " ") } o = t[e], e + 1 < t.length && (a = t[e + 1]) } return c && (i = o.x > t[e - 2].x ? 1 : o.x === t[e - 2].x ? 0 : -1, r = o.y > t[e - 2].y ? 1 : o.y === t[e - 2].y ? 0 : -1), n.push("L ", o.x + i * s, " ", o.y + r * s), n }, createPath: function (t) { var e = new fabric.Path(t, { fill: null, stroke: this.color, strokeWidth: this.width, strokeLineCap: this.strokeLineCap, strokeLineJoin: this.strokeLineJoin, strokeDashArray: this.strokeDashArray }), i = new fabric.Point(e.left + e.width / 2, e.top + e.height / 2); return i = e.translateToGivenOrigin(i, "center", "center", e.originX, e.originY), e.top = i.y, e.left = i.x, this.shadow && (this.shadow.affectStroke = !0, e.setShadow(this.shadow)), e }, _finalizeAndAddPath: function () { this.canvas.contextTop.closePath(); var t = this.convertPointsToSVGPath(this._points).join(""); if ("M 0 0 Q 0 0 0 0 L 0 0" !== t) { var e = this.createPath(t); this.canvas.add(e), e.setCoords(), this.canvas.clearContext(this.canvas.contextTop), this._resetShadow(), this.canvas.renderAll(), this.canvas.fire("path:created", { path: e }) } else this.canvas.renderAll() } }), fabric.CircleBrush = fabric.util.createClass(fabric.BaseBrush, { width: 10, initialize: function (t) { this.canvas = t, this.points = [] }, drawDot: function (t) { var e = this.addPoint(t), i = this.canvas.contextTop, r = this.canvas.viewportTransform; i.save(), i.transform(r[0], r[1], r[2], r[3], r[4], r[5]), i.fillStyle = e.fill, i.beginPath(), i.arc(e.x, e.y, e.radius, 0, 2 * Math.PI, !1), i.closePath(), i.fill(), i.restore() }, onMouseDown: function (t) { this.points.length = 0, this.canvas.clearContext(this.canvas.contextTop), this._setShadow(), this.drawDot(t) }, onMouseMove: function (t) { this.drawDot(t) }, onMouseUp: function () { var t = this.canvas.renderOnAddRemove; this.canvas.renderOnAddRemove = !1; for (var e = [], i = 0, r = this.points.length; i < r; i++) { var n = this.points[i], s = new fabric.Circle({ radius: n.radius, left: n.x, top: n.y, originX: "center", originY: "center", fill: n.fill }); this.shadow && s.setShadow(this.shadow), e.push(s) } var o = new fabric.Group(e, { originX: "center", originY: "center" }); o.canvas = this.canvas, this.canvas.add(o), this.canvas.fire("path:created", { path: o }), this.canvas.clearContext(this.canvas.contextTop), this._resetShadow(), this.canvas.renderOnAddRemove = t, this.canvas.renderAll() }, addPoint: function (t) { var e = new fabric.Point(t.x, t.y), i = fabric.util.getRandomInt(Math.max(0, this.width - 20), this.width + 20) / 2, r = new fabric.Color(this.color).setAlpha(fabric.util.getRandomInt(0, 100) / 100).toRgba(); return e.radius = i, e.fill = r, this.points.push(e), e } }), fabric.SprayBrush = fabric.util.createClass(fabric.BaseBrush, { width: 10, density: 20, dotWidth: 1, dotWidthVariance: 1, randomOpacity: !1, optimizeOverlapping: !0, initialize: function (t) { this.canvas = t, this.sprayChunks = [] }, onMouseDown: function (t) { this.sprayChunks.length = 0, this.canvas.clearContext(this.canvas.contextTop), this._setShadow(), this.addSprayChunk(t), this.render() }, onMouseMove: function (t) { this.addSprayChunk(t), this.render() }, onMouseUp: function () { var t = this.canvas.renderOnAddRemove; this.canvas.renderOnAddRemove = !1; for (var e = [], i = 0, r = this.sprayChunks.length; i < r; i++)for (var n = this.sprayChunks[i], s = 0, o = n.length; s < o; s++) { var a = new fabric.Rect({ width: n[s].width, height: n[s].width, left: n[s].x + 1, top: n[s].y + 1, originX: "center", originY: "center", fill: this.color }); this.shadow && a.setShadow(this.shadow), e.push(a) } this.optimizeOverlapping && (e = this._getOptimizedRects(e)); var h = new fabric.Group(e, { originX: "center", originY: "center" }); h.canvas = this.canvas, this.canvas.add(h), this.canvas.fire("path:created", { path: h }), this.canvas.clearContext(this.canvas.contextTop), this._resetShadow(), this.canvas.renderOnAddRemove = t, this.canvas.renderAll() }, _getOptimizedRects: function (t) { for (var e, i = {}, r = 0, n = t.length; r < n; r++)i[e = t[r].left + "" + t[r].top] || (i[e] = t[r]); var s = []; for (e in i) s.push(i[e]); return s }, render: function () { var t = this.canvas.contextTop; t.fillStyle = this.color; var e = this.canvas.viewportTransform; t.save(), t.transform(e[0], e[1], e[2], e[3], e[4], e[5]); for (var i = 0, r = this.sprayChunkPoints.length; i < r; i++) { var n = this.sprayChunkPoints[i]; void 0 !== n.opacity && (t.globalAlpha = n.opacity), t.fillRect(n.x, n.y, n.width, n.width) } t.restore() }, addSprayChunk: function (t) { this.sprayChunkPoints = []; for (var e, i, r, n = this.width / 2, s = 0; s < this.density; s++) { e = fabric.util.getRandomInt(t.x - n, t.x + n), i = fabric.util.getRandomInt(t.y - n, t.y + n), r = this.dotWidthVariance ? fabric.util.getRandomInt(Math.max(1, this.dotWidth - this.dotWidthVariance), this.dotWidth + this.dotWidthVariance) : this.dotWidth; var o = new fabric.Point(e, i); o.width = r, this.randomOpacity && (o.opacity = fabric.util.getRandomInt(0, 100) / 100), this.sprayChunkPoints.push(o) } this.sprayChunks.push(this.sprayChunkPoints) } }), fabric.PatternBrush = fabric.util.createClass(fabric.PencilBrush, { getPatternSrc: function () { var t = fabric.document.createElement("canvas"), e = t.getContext("2d"); return t.width = t.height = 25, e.fillStyle = this.color, e.beginPath(), e.arc(10, 10, 10, 0, 2 * Math.PI, !1), e.closePath(), e.fill(), t }, getPatternSrcFunction: function () { return String(this.getPatternSrc).replace("this.color", '"' + this.color + '"') }, getPattern: function () { return this.canvas.contextTop.createPattern(this.source || this.getPatternSrc(), "repeat") }, _setBrushStyles: function () { this.callSuper("_setBrushStyles"), this.canvas.contextTop.strokeStyle = this.getPattern() }, createPath: function (t) { var e = this.callSuper("createPath", t), i = e._getLeftTopCoords().scalarAdd(e.strokeWidth / 2); return e.stroke = new fabric.Pattern({ source: this.source || this.getPatternSrcFunction(), offsetX: -i.x, offsetY: -i.y }), e } }), function () { var t = fabric.util.getPointer, e = fabric.util.degreesToRadians, i = fabric.util.radiansToDegrees, r = Math.atan2, n = Math.abs, s = fabric.StaticCanvas.supports("setLineDash"); fabric.Canvas = fabric.util.createClass(fabric.StaticCanvas, { initialize: function (t, e) { e || (e = {}), this._initStatic(t, e), this._initInteractive(), this._createCacheCanvas() }, uniScaleTransform: !1, uniScaleKey: "shiftKey", centeredScaling: !1, centeredRotation: !1, centeredKey: "altKey", altActionKey: "shiftKey", interactive: !0, selection: !0, selectionKey: "shiftKey", altSelectionKey: null, selectionColor: "rgba(100, 100, 255, 0.3)", selectionDashArray: [], selectionBorderColor: "rgba(255, 255, 255, 0.3)", selectionLineWidth: 1, hoverCursor: "move", moveCursor: "move", defaultCursor: "default", freeDrawingCursor: "crosshair", rotationCursor: "crosshair", containerClass: "canvas-container", perPixelTargetFind: !1, targetFindTolerance: 0, skipTargetFind: !1, isDrawingMode: !1, preserveObjectStacking: !1, snapAngle: 0, snapThreshold: null, stopContextMenu: !1, fireRightClick: !1, fireMiddleClick: !1, _initInteractive: function () { this._currentTransform = null, this._groupSelector = null, this._initWrapperElement(), this._createUpperCanvas(), this._initEventListeners(), this._initRetinaScaling(), this.freeDrawingBrush = fabric.PencilBrush && new fabric.PencilBrush(this), this.calcOffset() }, _chooseObjectsToRender: function () { var t, e = this.getActiveGroup(), i = this.getActiveObject(), r = [], n = []; if (!e && !i || this.preserveObjectStacking) r = this._objects; else { for (var s = 0, o = this._objects.length; s < o; s++)t = this._objects[s], e && e.contains(t) || t === i ? n.push(t) : r.push(t); e && (e._set("_objects", n), r.push(e)), i && r.push(i) } return r }, renderAll: function () { !this.contextTopDirty || this._groupSelector || this.isDrawingMode || (this.clearContext(this.contextTop), this.contextTopDirty = !1); var t = this.contextContainer; return this.renderCanvas(t, this._chooseObjectsToRender()), this }, renderTop: function () { var t = this.contextTop; return this.clearContext(t), this.selection && this._groupSelector && this._drawSelection(t), this.fire("after:render"), this.contextTopDirty = !0, this }, _resetCurrentTransform: function () { var t = this._currentTransform; t.target.set({ scaleX: t.original.scaleX, scaleY: t.original.scaleY, skewX: t.original.skewX, skewY: t.original.skewY, left: t.original.left, top: t.original.top }), this._shouldCenterTransform(t.target) ? "rotate" === t.action ? this._setOriginToCenter(t.target) : ("center" !== t.originX && ("right" === t.originX ? t.mouseXSign = -1 : t.mouseXSign = 1), "center" !== t.originY && ("bottom" === t.originY ? t.mouseYSign = -1 : t.mouseYSign = 1), t.originX = "center", t.originY = "center") : (t.originX = t.original.originX, t.originY = t.original.originY) }, containsPoint: function (t, e, i) { var r, n = i || this.getPointer(t, !0); return r = e.group && e.group === this.getActiveGroup() ? this._normalizePointer(e.group, n) : { x: n.x, y: n.y }, e.containsPoint(r) || e._findTargetCorner(n) }, _normalizePointer: function (t, e) { var i = t.calcTransformMatrix(), r = fabric.util.invertTransform(i), n = this.restorePointerVpt(e); return fabric.util.transformPoint(n, r) }, isTargetTransparent: function (t, e, i) { var r = t.hasBorders, n = t.transparentCorners, s = this.contextCache, o = t.selectionBackgroundColor; t.hasBorders = t.transparentCorners = !1, t.selectionBackgroundColor = "", s.save(), s.transform.apply(s, this.viewportTransform), t.render(s), s.restore(), t.active && t._renderControls(s), t.hasBorders = r, t.transparentCorners = n, t.selectionBackgroundColor = o; var a = fabric.util.isTransparent(s, e, i, this.targetFindTolerance); return this.clearContext(s), a }, _shouldClearSelection: function (t, e) { var i = this.getActiveGroup(), r = this.getActiveObject(); return !e || e && i && !i.contains(e) && i !== e && !t[this.selectionKey] || e && !e.evented || e && !e.selectable && r && r !== e }, _shouldCenterTransform: function (t) { if (t) { var e, i = this._currentTransform; return "scale" === i.action || "scaleX" === i.action || "scaleY" === i.action ? e = this.centeredScaling || t.centeredScaling : "rotate" === i.action && (e = this.centeredRotation || t.centeredRotation), e ? !i.altKey : i.altKey } }, _getOriginFromCorner: function (t, e) { var i = { x: t.originX, y: t.originY }; return "ml" === e || "tl" === e || "bl" === e ? i.x = "right" : "mr" !== e && "tr" !== e && "br" !== e || (i.x = "left"), "tl" === e || "mt" === e || "tr" === e ? i.y = "bottom" : "bl" !== e && "mb" !== e && "br" !== e || (i.y = "top"), i }, _getActionFromCorner: function (t, e, i) { if (!e) return "drag"; switch (e) { case "mtr": return "rotate"; case "ml": case "mr": return i[this.altActionKey] ? "skewY" : "scaleX"; case "mt": case "mb": return i[this.altActionKey] ? "skewX" : "scaleY"; default: return "scale" } }, _setupCurrentTransform: function (t, i) { if (i) { var r = this.getPointer(t), n = i._findTargetCorner(this.getPointer(t, !0)), s = this._getActionFromCorner(i, n, t), o = this._getOriginFromCorner(i, n); this._currentTransform = { target: i, action: s, corner: n, scaleX: i.scaleX, scaleY: i.scaleY, skewX: i.skewX, skewY: i.skewY, offsetX: r.x - i.left, offsetY: r.y - i.top, originX: o.x, originY: o.y, ex: r.x, ey: r.y, lastX: r.x, lastY: r.y, left: i.left, top: i.top, theta: e(i.angle), width: i.width * i.scaleX, mouseXSign: 1, mouseYSign: 1, shiftKey: t.shiftKey, altKey: t[this.centeredKey] }, this._currentTransform.original = { left: i.left, top: i.top, scaleX: i.scaleX, scaleY: i.scaleY, skewX: i.skewX, skewY: i.skewY, originX: o.x, originY: o.y }, this._resetCurrentTransform() } }, _translateObject: function (t, e) { var i = this._currentTransform, r = i.target, n = t - i.offsetX, s = e - i.offsetY, o = !r.get("lockMovementX") && r.left !== n, a = !r.get("lockMovementY") && r.top !== s; return o && r.set("left", n), a && r.set("top", s), o || a }, _changeSkewTransformOrigin: function (t, e, i) { var r = "originX", n = { 0: "center" }, s = e.target.skewX, o = "left", a = "right", h = "mt" === e.corner || "ml" === e.corner ? 1 : -1, c = 1; t = t > 0 ? 1 : -1, "y" === i && (s = e.target.skewY, o = "top", a = "bottom", r = "originY"), n[-1] = o, n[1] = a, e.target.flipX && (c *= -1), e.target.flipY && (c *= -1), 0 === s ? (e.skewSign = -h * t * c, e[r] = n[-t]) : (s = s > 0 ? 1 : -1, e.skewSign = s, e[r] = n[s * h * c]) }, _skewObject: function (t, e, i) { var r = this._currentTransform, n = r.target, s = !1, o = n.get("lockSkewingX"), a = n.get("lockSkewingY"); if (o && "x" === i || a && "y" === i) return !1; var h, c, l = n.getCenterPoint(), u = n.toLocalPoint(new fabric.Point(t, e), "center", "center")[i], f = n.toLocalPoint(new fabric.Point(r.lastX, r.lastY), "center", "center")[i], d = n._getTransformedDimensions(); return this._changeSkewTransformOrigin(u - f, r, i), h = n.toLocalPoint(new fabric.Point(t, e), r.originX, r.originY)[i], c = n.translateToOriginPoint(l, r.originX, r.originY), s = this._setObjectSkew(h, r, i, d), r.lastX = t, r.lastY = e, n.setPositionByOrigin(c, r.originX, r.originY), s }, _setObjectSkew: function (t, e, i, r) { var n, s, o, a, h, c, l, u, f, d = e.target, g = !1, p = e.skewSign; return "x" === i ? (a = "y", h = "Y", c = "X", u = 0, f = d.skewY) : (a = "x", h = "X", c = "Y", u = d.skewX, f = 0), o = d._getTransformedDimensions(u, f), (l = 2 * Math.abs(t) - o[i]) <= 2 ? n = 0 : (n = p * Math.atan(l / d["scale" + c] / (o[a] / d["scale" + h])), n = fabric.util.radiansToDegrees(n)), g = d["skew" + c] !== n, d.set("skew" + c, n), 0 !== d["skew" + h] && (s = d._getTransformedDimensions(), n = r[a] / s[a] * d["scale" + h], d.set("scale" + h, n)), g }, _scaleObject: function (t, e, i) { var r = this._currentTransform, n = r.target, s = n.get("lockScalingX"), o = n.get("lockScalingY"), a = n.get("lockScalingFlip"); if (s && o) return !1; var h = n.translateToOriginPoint(n.getCenterPoint(), r.originX, r.originY), c = n.toLocalPoint(new fabric.Point(t, e), r.originX, r.originY), l = n._getTransformedDimensions(), u = !1; return this._setLocalMouse(c, r), u = this._setObjectScale(c, r, s, o, i, a, l), n.setPositionByOrigin(h, r.originX, r.originY), u }, _setObjectScale: function (t, e, i, r, n, s, o) { var a, h, c, l, u = e.target, f = !1, d = !1, g = !1; return c = t.x * u.scaleX / o.x, l = t.y * u.scaleY / o.y, a = u.scaleX !== c, h = u.scaleY !== l, s && c <= 0 && c < u.scaleX && (f = !0), s && l <= 0 && l < u.scaleY && (d = !0), "equally" !== n || i || r ? n ? "x" !== n || u.get("lockUniScaling") ? "y" !== n || u.get("lockUniScaling") || d || r || u.set("scaleY", l) && (g = g || h) : f || i || u.set("scaleX", c) && (g = g || a) : (f || i || u.set("scaleX", c) && (g = g || a), d || r || u.set("scaleY", l) && (g = g || h)) : f || d || (g = this._scaleObjectEqually(t, u, e, o)), e.newScaleX = c, e.newScaleY = l, f || d || this._flipObject(e, n), g }, _scaleObjectEqually: function (t, e, i, r) { var n, s = t.y + t.x, o = r.y * i.original.scaleY / e.scaleY + r.x * i.original.scaleX / e.scaleX, a = t.x / Math.abs(t.x), h = t.y / Math.abs(t.y); return i.newScaleX = a * Math.abs(i.original.scaleX * s / o), i.newScaleY = h * Math.abs(i.original.scaleY * s / o), n = i.newScaleX !== e.scaleX || i.newScaleY !== e.scaleY, e.set("scaleX", i.newScaleX), e.set("scaleY", i.newScaleY), n }, _flipObject: function (t, e) { t.newScaleX < 0 && "y" !== e && ("left" === t.originX ? t.originX = "right" : "right" === t.originX && (t.originX = "left")), t.newScaleY < 0 && "x" !== e && ("top" === t.originY ? t.originY = "bottom" : "bottom" === t.originY && (t.originY = "top")) }, _setLocalMouse: function (t, e) { var i = e.target, r = this.getZoom(), s = i.padding / r; "right" === e.originX ? t.x *= -1 : "center" === e.originX && (t.x *= 2 * e.mouseXSign, t.x < 0 && (e.mouseXSign = -e.mouseXSign)), "bottom" === e.originY ? t.y *= -1 : "center" === e.originY && (t.y *= 2 * e.mouseYSign, t.y < 0 && (e.mouseYSign = -e.mouseYSign)), n(t.x) > s ? t.x < 0 ? t.x += s : t.x -= s : t.x = 0, n(t.y) > s ? t.y < 0 ? t.y += s : t.y -= s : t.y = 0 }, _rotateObject: function (t, e) { var n = this._currentTransform; if (n.target.get("lockRotation")) return !1; var s = r(n.ey - n.top, n.ex - n.left), o = r(e - n.top, t - n.left), a = i(o - s + n.theta), h = !0; if (n.target.snapAngle > 0) { var c = n.target.snapAngle, l = n.target.snapThreshold || c, u = Math.ceil(a / c) * c, f = Math.floor(a / c) * c; Math.abs(a - f) < l ? a = f : Math.abs(a - u) < l && (a = u) } return a < 0 && (a = 360 + a), a %= 360, n.target.angle === a ? h = !1 : n.target.angle = a, h }, setCursor: function (t) { this.upperCanvasEl.style.cursor = t }, _resetObjectTransform: function (t) { t.scaleX = 1, t.scaleY = 1, t.skewX = 0, t.skewY = 0, t.setAngle(0) }, _drawSelection: function (t) { var e = this._groupSelector, i = e.left, r = e.top, o = n(i), a = n(r); if (this.selectionColor && (t.fillStyle = this.selectionColor, t.fillRect(e.ex - (i > 0 ? 0 : -i), e.ey - (r > 0 ? 0 : -r), o, a)), this.selectionLineWidth && this.selectionBorderColor) if (t.lineWidth = this.selectionLineWidth, t.strokeStyle = this.selectionBorderColor, this.selectionDashArray.length > 1 && !s) { var h = e.ex + .5 - (i > 0 ? 0 : o), c = e.ey + .5 - (r > 0 ? 0 : a); t.beginPath(), fabric.util.drawDashedLine(t, h, c, h + o, c, this.selectionDashArray), fabric.util.drawDashedLine(t, h, c + a - 1, h + o, c + a - 1, this.selectionDashArray), fabric.util.drawDashedLine(t, h, c, h, c + a, this.selectionDashArray), fabric.util.drawDashedLine(t, h + o - 1, c, h + o - 1, c + a, this.selectionDashArray), t.closePath(), t.stroke() } else fabric.Object.prototype._setLineDash.call(this, t, this.selectionDashArray), t.strokeRect(e.ex + .5 - (i > 0 ? 0 : o), e.ey + .5 - (r > 0 ? 0 : a), o, a) }, findTarget: function (t, e) { if (!this.skipTargetFind) { var i, r, n = this.getPointer(t, !0), s = this.getActiveGroup(), o = this.getActiveObject(); if (this.targets = [], s && !e && s === this._searchPossibleTargets([s], n)) return this._fireOverOutEvents(s, t), s; if (o && o._findTargetCorner(n)) return this._fireOverOutEvents(o, t), o; if (o && o === this._searchPossibleTargets([o], n)) { if (!this.preserveObjectStacking) return this._fireOverOutEvents(o, t), o; i = o, r = this.targets, this.targets = [] } var a = this._searchPossibleTargets(this._objects, n); return t[this.altSelectionKey] && a && i && a !== i && (a = i, this.targets = r), this._fireOverOutEvents(a, t), a } }, _fireOverOutEvents: function (t, e) { var i, r, n = this._hoveredTarget; n !== t && (i = { e: e, target: t, previousTarget: this._hoveredTarget }, r = { e: e, target: this._hoveredTarget, nextTarget: t }, this._hoveredTarget = t), t ? n !== t && (n && (this.fire("mouse:out", r), n.fire("mouseout", r)), this.fire("mouse:over", i), t.fire("mouseover", i)) : n && (this.fire("mouse:out", r), n.fire("mouseout", r)) }, _checkTarget: function (t, e) { if (e && e.visible && e.evented && this.containsPoint(null, e, t)) { if (!this.perPixelTargetFind && !e.perPixelTargetFind || e.isEditing) return !0; if (!this.isTargetTransparent(e, t.x, t.y)) return !0 } }, _searchPossibleTargets: function (t, e) { for (var i, r, n, s = t.length; s--;)if (this._checkTarget(e, t[s])) { "group" === (i = t[s]).type && i.subTargetCheck && (r = this._normalizePointer(i, e), (n = this._searchPossibleTargets(i._objects, r)) && this.targets.push(n)); break } return i }, restorePointerVpt: function (t) { return fabric.util.transformPoint(t, fabric.util.invertTransform(this.viewportTransform)) }, getPointer: function (e, i, r) { r || (r = this.upperCanvasEl); var n, s = t(e), o = r.getBoundingClientRect(), a = o.width || 0, h = o.height || 0; return a && h || ("top" in o && "bottom" in o && (h = Math.abs(o.top - o.bottom)), "right" in o && "left" in o && (a = Math.abs(o.right - o.left))), this.calcOffset(), s.x = s.x - this._offset.left, s.y = s.y - this._offset.top, i || (s = this.restorePointerVpt(s)), n = 0 === a || 0 === h ? { width: 1, height: 1 } : { width: r.width / a, height: r.height / h }, { x: s.x * n.width, y: s.y * n.height } }, _createUpperCanvas: function () { var t = this.lowerCanvasEl.className.replace(/\s*lower-canvas\s*/, ""); this.upperCanvasEl ? this.upperCanvasEl.className = "" : this.upperCanvasEl = this._createCanvasElement(), fabric.util.addClass(this.upperCanvasEl, "upper-canvas " + t), this.wrapperEl.appendChild(this.upperCanvasEl), this._copyCanvasStyle(this.lowerCanvasEl, this.upperCanvasEl), this._applyCanvasStyle(this.upperCanvasEl), this.contextTop = this.upperCanvasEl.getContext("2d") }, _createCacheCanvas: function () { this.cacheCanvasEl = this._createCanvasElement(), this.cacheCanvasEl.setAttribute("width", this.width), this.cacheCanvasEl.setAttribute("height", this.height), this.contextCache = this.cacheCanvasEl.getContext("2d") }, _initWrapperElement: function () { this.wrapperEl = fabric.util.wrapElement(this.lowerCanvasEl, "div", { class: this.containerClass }), fabric.util.setStyle(this.wrapperEl, { width: this.getWidth() + "px", height: this.getHeight() + "px", position: "relative" }), fabric.util.makeElementUnselectable(this.wrapperEl) }, _applyCanvasStyle: function (t) { var e = this.getWidth() || t.width, i = this.getHeight() || t.height; fabric.util.setStyle(t, { position: "absolute", width: e + "px", height: i + "px", left: 0, top: 0, "touch-action": "none" }), t.width = e, t.height = i, fabric.util.makeElementUnselectable(t) }, _copyCanvasStyle: function (t, e) { e.style.cssText = t.style.cssText }, getSelectionContext: function () { return this.contextTop }, getSelectionElement: function () { return this.upperCanvasEl }, _setActiveObject: function (t) { var e = this._activeObject; e && (e.set("active", !1), t !== e && e.onDeselect && "function" == typeof e.onDeselect && e.onDeselect()), this._activeObject = t, t.set("active", !0) }, setActiveObject: function (t, e) { var i = this.getActiveObject(); return i && i !== t && i.fire("deselected", { e: e }), this._setActiveObject(t), this.fire("object:selected", { target: t, e: e }), t.fire("selected", { e: e }), this.renderAll(), this }, getActiveObject: function () { return this._activeObject }, _onObjectRemoved: function (t) { this.getActiveObject() === t && (this.fire("before:selection:cleared", { target: t }), this._discardActiveObject(), this.fire("selection:cleared", { target: t }), t.fire("deselected")), this._hoveredTarget === t && (this._hoveredTarget = null), this.callSuper("_onObjectRemoved", t) }, _discardActiveObject: function () { var t = this._activeObject; t && (t.set("active", !1), t.onDeselect && "function" == typeof t.onDeselect && t.onDeselect()), this._activeObject = null }, discardActiveObject: function (t) { var e = this._activeObject; return e && (this.fire("before:selection:cleared", { target: e, e: t }), this._discardActiveObject(), this.fire("selection:cleared", { e: t }), e.fire("deselected", { e: t })), this }, _setActiveGroup: function (t) { this._activeGroup = t, t && t.set("active", !0) }, setActiveGroup: function (t, e) { return this._setActiveGroup(t), t && (this.fire("object:selected", { target: t, e: e }), t.fire("selected", { e: e })), this }, getActiveGroup: function () { return this._activeGroup }, _discardActiveGroup: function () { var t = this.getActiveGroup(); t && t.destroy(), this.setActiveGroup(null) }, discardActiveGroup: function (t) { var e = this.getActiveGroup(); return e && (this.fire("before:selection:cleared", { e: t, target: e }), this._discardActiveGroup(), this.fire("selection:cleared", { e: t })), this }, deactivateAll: function () { for (var t, e = this.getObjects(), i = 0, r = e.length; i < r; i++)(t = e[i]) && t.set("active", !1); return this._discardActiveGroup(), this._discardActiveObject(), this }, deactivateAllWithDispatch: function (t) { for (var e, i = this.getObjects(), r = 0, n = i.length; r < n; r++)(e = i[r]) && e.set("active", !1); return this.discardActiveGroup(t), this.discardActiveObject(t), this }, dispose: function () { fabric.StaticCanvas.prototype.dispose.call(this); var t = this.wrapperEl; return this.removeListeners(), t.removeChild(this.upperCanvasEl), t.removeChild(this.lowerCanvasEl), delete this.upperCanvasEl, t.parentNode && t.parentNode.replaceChild(this.lowerCanvasEl, this.wrapperEl), delete this.wrapperEl, this }, clear: function () { return this.discardActiveGroup(), this.discardActiveObject(), this.clearContext(this.contextTop), this.callSuper("clear") }, drawControls: function (t) { var e = this.getActiveGroup(); e ? e._renderControls(t) : this._drawObjectsControls(t) }, _drawObjectsControls: function (t) { for (var e = 0, i = this._objects.length; e < i; ++e)this._objects[e] && this._objects[e].active && this._objects[e]._renderControls(t) }, _toObject: function (t, e, i) { var r = this._realizeGroupTransformOnObject(t), n = this.callSuper("_toObject", t, e, i); return this._unwindGroupTransformOnObject(t, r), n }, _realizeGroupTransformOnObject: function (t) { if (t.group && t.group === this.getActiveGroup()) { var e = {}; return ["angle", "flipX", "flipY", "left", "scaleX", "scaleY", "skewX", "skewY", "top"].forEach(function (i) { e[i] = t[i] }), this.getActiveGroup().realizeTransform(t), e } return null }, _unwindGroupTransformOnObject: function (t, e) { e && t.set(e) }, _setSVGObject: function (t, e, i) { var r; r = this._realizeGroupTransformOnObject(e), this.callSuper("_setSVGObject", t, e, i), this._unwindGroupTransformOnObject(e, r) } }); for (var o in fabric.StaticCanvas) "prototype" !== o && (fabric.Canvas[o] = fabric.StaticCanvas[o]); fabric.isTouchSupported && (fabric.Canvas.prototype._setCursorFromEvent = function () { }), fabric.Element = fabric.Canvas }(), function () { function t(t, e) { return "which" in t ? t.which === e : t.button === e - 1 } var e = { mt: 0, tr: 1, mr: 2, br: 3, mb: 4, bl: 5, ml: 6, tl: 7 }, i = fabric.util.addListener, r = fabric.util.removeListener; fabric.util.object.extend(fabric.Canvas.prototype, { cursorMap: ["n-resize", "ne-resize", "e-resize", "se-resize", "s-resize", "sw-resize", "w-resize", "nw-resize"], _initEventListeners: function () { this.removeListeners(), this._bindEvents(), i(fabric.window, "resize", this._onResize), i(this.upperCanvasEl, "mousedown", this._onMouseDown), i(this.upperCanvasEl, "mousemove", this._onMouseMove), i(this.upperCanvasEl, "mouseout", this._onMouseOut), i(this.upperCanvasEl, "mouseenter", this._onMouseEnter), i(this.upperCanvasEl, "wheel", this._onMouseWheel), i(this.upperCanvasEl, "contextmenu", this._onContextMenu), i(this.upperCanvasEl, "touchstart", this._onMouseDown, { passive: !1 }), i(this.upperCanvasEl, "touchmove", this._onMouseMove, { passive: !1 }), "undefined" != typeof eventjs && "add" in eventjs && (eventjs.add(this.upperCanvasEl, "gesture", this._onGesture), eventjs.add(this.upperCanvasEl, "drag", this._onDrag), eventjs.add(this.upperCanvasEl, "orientation", this._onOrientationChange), eventjs.add(this.upperCanvasEl, "shake", this._onShake), eventjs.add(this.upperCanvasEl, "longpress", this._onLongPress)) }, _bindEvents: function () { this.eventsBinded || (this._onMouseDown = this._onMouseDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), this._onMouseUp = this._onMouseUp.bind(this), this._onResize = this._onResize.bind(this), this._onGesture = this._onGesture.bind(this), this._onDrag = this._onDrag.bind(this), this._onShake = this._onShake.bind(this), this._onLongPress = this._onLongPress.bind(this), this._onOrientationChange = this._onOrientationChange.bind(this), this._onMouseWheel = this._onMouseWheel.bind(this), this._onMouseOut = this._onMouseOut.bind(this), this._onMouseEnter = this._onMouseEnter.bind(this), this._onContextMenu = this._onContextMenu.bind(this), this.eventsBinded = !0) }, removeListeners: function () { r(fabric.window, "resize", this._onResize), r(this.upperCanvasEl, "mousedown", this._onMouseDown), r(this.upperCanvasEl, "mousemove", this._onMouseMove), r(this.upperCanvasEl, "mouseout", this._onMouseOut), r(this.upperCanvasEl, "mouseenter", this._onMouseEnter), r(this.upperCanvasEl, "wheel", this._onMouseWheel), r(this.upperCanvasEl, "contextmenu", this._onContextMenu), r(this.upperCanvasEl, "touchstart", this._onMouseDown), r(this.upperCanvasEl, "touchmove", this._onMouseMove), "undefined" != typeof eventjs && "remove" in eventjs && (eventjs.remove(this.upperCanvasEl, "gesture", this._onGesture), eventjs.remove(this.upperCanvasEl, "drag", this._onDrag), eventjs.remove(this.upperCanvasEl, "orientation", this._onOrientationChange), eventjs.remove(this.upperCanvasEl, "shake", this._onShake), eventjs.remove(this.upperCanvasEl, "longpress", this._onLongPress)) }, _onGesture: function (t, e) { this.__onTransformGesture && this.__onTransformGesture(t, e) }, _onDrag: function (t, e) { this.__onDrag && this.__onDrag(t, e) }, _onMouseWheel: function (t) { this.__onMouseWheel(t) }, _onMouseOut: function (t) { var e = this._hoveredTarget; this.fire("mouse:out", { target: e, e: t }), this._hoveredTarget = null, e && e.fire("mouseout", { e: t }), this._iTextInstances && this._iTextInstances.forEach(function (t) { t.isEditing && t.hiddenTextarea.focus() }) }, _onMouseEnter: function (t) { this.findTarget(t) || (this.fire("mouse:over", { target: null, e: t }), this._hoveredTarget = null) }, _onOrientationChange: function (t, e) { this.__onOrientationChange && this.__onOrientationChange(t, e) }, _onShake: function (t, e) { this.__onShake && this.__onShake(t, e) }, _onLongPress: function (t, e) { this.__onLongPress && this.__onLongPress(t, e) }, _onContextMenu: function (t) { return this.stopContextMenu && (t.stopPropagation(), t.preventDefault()), !1 }, _onMouseDown: function (t) { this.__onMouseDown(t), i(fabric.document, "touchend", this._onMouseUp, { passive: !1 }), i(fabric.document, "touchmove", this._onMouseMove, { passive: !1 }), r(this.upperCanvasEl, "mousemove", this._onMouseMove), r(this.upperCanvasEl, "touchmove", this._onMouseMove), "touchstart" === t.type ? r(this.upperCanvasEl, "mousedown", this._onMouseDown) : (i(fabric.document, "mouseup", this._onMouseUp), i(fabric.document, "mousemove", this._onMouseMove)) }, _onMouseUp: function (t) { if (this.__onMouseUp(t), r(fabric.document, "mouseup", this._onMouseUp), r(fabric.document, "touchend", this._onMouseUp), r(fabric.document, "mousemove", this._onMouseMove), r(fabric.document, "touchmove", this._onMouseMove), i(this.upperCanvasEl, "mousemove", this._onMouseMove), i(this.upperCanvasEl, "touchmove", this._onMouseMove, { passive: !1 }), "touchend" === t.type) { var e = this; setTimeout(function () { i(e.upperCanvasEl, "mousedown", e._onMouseDown) }, 400) } }, _onMouseMove: function (t) { !this.allowTouchScrolling && t.preventDefault && t.preventDefault(), this.__onMouseMove(t) }, _onResize: function () { this.calcOffset() }, _shouldRender: function (t, e) { var i = this.getActiveGroup() || this.getActiveObject(); return (!i || !i.isEditing || t !== i) && !!(t && (t.isMoving || t !== i) || !t && i || !t && !i && !this._groupSelector || e && this._previousPointer && this.selection && (e.x !== this._previousPointer.x || e.y !== this._previousPointer.y)) }, __onMouseUp: function (e) { var i; if (t(e, 3)) this.fireRightClick && this._handleEvent(e, "up", i, 3); else if (t(e, 2)) this.fireMiddleClick && this._handleEvent(e, "up", i, 2); else if (this.isDrawingMode && this._isCurrentlyDrawing) this._onMouseUpInDrawingMode(e); else { var r = !0, n = this._currentTransform, s = this._groupSelector, o = !s || 0 === s.left && 0 === s.top; n && (this._finalizeCurrentTransform(e), r = !n.actionPerformed), i = r ? this.findTarget(e, !0) : n.target; var a = this._shouldRender(i, this.getPointer(e)); i || !o ? this._maybeGroupObjects(e) : (this._groupSelector = null, this._currentTransform = null), i && (i.isMoving = !1), this._setCursorFromEvent(e, i), this._handleEvent(e, "up", i || null, 1, o), i && (i.__corner = 0), a && this.renderAll() } }, _handleEvent: function (t, e, i, r, n) { var s = void 0 === i ? this.findTarget(t) : i, o = this.targets || [], a = { e: t, target: s, subTargets: o, button: r || 1, isClick: n || !1 }; this.fire("mouse:" + e, a), s && s.fire("mouse" + e, a); for (var h = 0; h < o.length; h++)o[h].fire("mouse" + e, a) }, _finalizeCurrentTransform: function (t) { var e = this._currentTransform, i = e.target; i._scaling && (i._scaling = !1), i.setCoords(), this._restoreOriginXY(i), (e.actionPerformed || this.stateful && i.hasStateChanged()) && (this.fire("object:modified", { target: i, e: t }), i.fire("modified", { e: t })) }, _restoreOriginXY: function (t) { if (this._previousOriginX && this._previousOriginY) { var e = t.translateToOriginPoint(t.getCenterPoint(), this._previousOriginX, this._previousOriginY); t.originX = this._previousOriginX, t.originY = this._previousOriginY, t.left = e.x, t.top = e.y, this._previousOriginX = null, this._previousOriginY = null } }, _onMouseDownInDrawingMode: function (t) { this._isCurrentlyDrawing = !0, this.discardActiveObject(t).renderAll(), this.clipTo && fabric.util.clipContext(this, this.contextTop); var e = this.getPointer(t); this.freeDrawingBrush.onMouseDown(e), this._handleEvent(t, "down") }, _onMouseMoveInDrawingMode: function (t) { if (this._isCurrentlyDrawing) { var e = this.getPointer(t); this.freeDrawingBrush.onMouseMove(e) } this.setCursor(this.freeDrawingCursor), this._handleEvent(t, "move") }, _onMouseUpInDrawingMode: function (t) { this._isCurrentlyDrawing = !1, this.clipTo && this.contextTop.restore(), this.freeDrawingBrush.onMouseUp(), this._handleEvent(t, "up") }, __onMouseDown: function (e) { var i = this.findTarget(e); if (t(e, 3)) this.fireRightClick && this._handleEvent(e, "down", i || null, 3); else if (t(e, 2)) this.fireMiddleClick && this._handleEvent(e, "down", i || null, 2); else if (this.isDrawingMode) this._onMouseDownInDrawingMode(e); else if (!this._currentTransform) { var r = this.getPointer(e, !0); this._previousPointer = r; var n = this._shouldRender(i, r), s = this._shouldGroup(e, i); if (this._shouldClearSelection(e, i) ? this.deactivateAllWithDispatch(e) : s && (this._handleGrouping(e, i), i = this.getActiveGroup()), !this.selection || i && (i.selectable || i.isEditing) || (this._groupSelector = { ex: r.x, ey: r.y, top: 0, left: 0 }), i) { !i.selectable || !i.__corner && s || (this._beforeTransform(e, i), this._setupCurrentTransform(e, i)); var o = this.getActiveObject(); i !== this.getActiveGroup() && i !== o && (this.deactivateAll(), i.selectable && (o && o.fire("deselected", { e: e }), this.setActiveObject(i, e))) } this._handleEvent(e, "down", i || null), n && this.renderAll() } }, _beforeTransform: function (t, e) { this.stateful && e.saveState(), e._findTargetCorner(this.getPointer(t)) && this.onBeforeScaleRotate(e) }, _setOriginToCenter: function (t) { this._previousOriginX = this._currentTransform.target.originX, this._previousOriginY = this._currentTransform.target.originY; var e = t.getCenterPoint(); t.originX = "center", t.originY = "center", t.left = e.x, t.top = e.y, this._currentTransform.left = t.left, this._currentTransform.top = t.top }, _setCenterToOrigin: function (t) { var e = t.translateToOriginPoint(t.getCenterPoint(), this._previousOriginX, this._previousOriginY); t.originX = this._previousOriginX, t.originY = this._previousOriginY, t.left = e.x, t.top = e.y, this._previousOriginX = null, this._previousOriginY = null }, __onMouseMove: function (t) { var e, i; if (this.isDrawingMode) this._onMouseMoveInDrawingMode(t); else if (!(void 0 !== t.touches && t.touches.length > 1)) { var r = this._groupSelector; r ? (i = this.getPointer(t, !0), r.left = i.x - r.ex, r.top = i.y - r.ey, this.renderTop()) : this._currentTransform ? this._transformObject(t) : (e = this.findTarget(t), this._setCursorFromEvent(t, e)), this._handleEvent(t, "move", e || null) } }, __onMouseWheel: function (t) { this._handleEvent(t, "wheel") }, _transformObject: function (t) { var e = this.getPointer(t), i = this._currentTransform; i.reset = !1, i.target.isMoving = !0, i.shiftKey = t.shiftKey, i.altKey = t[this.centeredKey], this._beforeScaleTransform(t, i), this._performTransformAction(t, i, e), i.actionPerformed && this.renderAll() }, _performTransformAction: function (t, e, i) { var r = i.x, n = i.y, s = e.target, o = e.action, a = !1; "rotate" === o ? (a = this._rotateObject(r, n)) && this._fire("rotating", s, t) : "scale" === o ? (a = this._onScale(t, e, r, n)) && this._fire("scaling", s, t) : "scaleX" === o ? (a = this._scaleObject(r, n, "x")) && this._fire("scaling", s, t) : "scaleY" === o ? (a = this._scaleObject(r, n, "y")) && this._fire("scaling", s, t) : "skewX" === o ? (a = this._skewObject(r, n, "x")) && this._fire("skewing", s, t) : "skewY" === o ? (a = this._skewObject(r, n, "y")) && this._fire("skewing", s, t) : (a = this._translateObject(r, n)) && (this._fire("moving", s, t), this.setCursor(s.moveCursor || this.moveCursor)), e.actionPerformed = e.actionPerformed || a }, _fire: function (t, e, i) { this.fire("object:" + t, { target: e, e: i }), e.fire(t, { e: i }) }, _beforeScaleTransform: function (t, e) { if ("scale" === e.action || "scaleX" === e.action || "scaleY" === e.action) { var i = this._shouldCenterTransform(e.target); (i && ("center" !== e.originX || "center" !== e.originY) || !i && "center" === e.originX && "center" === e.originY) && (this._resetCurrentTransform(), e.reset = !0) } }, _onScale: function (t, e, i, r) { return !t[this.uniScaleKey] && !this.uniScaleTransform || e.target.get("lockUniScaling") ? (e.reset || "scale" !== e.currentAction || this._resetCurrentTransform(), e.currentAction = "scaleEqually", this._scaleObject(i, r, "equally")) : (e.currentAction = "scale", this._scaleObject(i, r)) }, _setCursorFromEvent: function (t, e) { if (!e) return this.setCursor(this.defaultCursor), !1; var i = e.hoverCursor || this.hoverCursor, r = this.getActiveGroup(), n = e._findTargetCorner && (!r || !r.contains(e)) && e._findTargetCorner(this.getPointer(t, !0)); return n ? this._setCornerCursor(n, e, t) : this.setCursor(i), !0 }, _setCornerCursor: function (t, i, r) { if (t in e) this.setCursor(this._getRotatedCornerCursor(t, i, r)); else { if ("mtr" !== t || !i.hasRotatingPoint) return this.setCursor(this.defaultCursor), !1; this.setCursor(this.rotationCursor) } }, _getRotatedCornerCursor: function (t, i, r) { var n = Math.round(i.getAngle() % 360 / 45); return n < 0 && (n += 8), n += e[t], r[this.altActionKey] && e[t] % 2 == 0 && (n += 2), n %= 8, this.cursorMap[n] } }) }(), function () { var t = Math.min, e = Math.max; fabric.util.object.extend(fabric.Canvas.prototype, { _shouldGroup: function (t, e) { var i = this.getActiveObject(); return t[this.selectionKey] && e && e.selectable && (this.getActiveGroup() || i && i !== e) && this.selection }, _handleGrouping: function (t, e) { var i = this.getActiveGroup(); (e !== i || (e = this.findTarget(t, !0))) && (i ? this._updateActiveGroup(e, t) : this._createActiveGroup(e, t), this._activeGroup && this._activeGroup.saveCoords()) }, _updateActiveGroup: function (t, e) { var i = this.getActiveGroup(); if (i.contains(t)) { if (i.removeWithUpdate(t), t.set("active", !1), 1 === i.size()) return this.discardActiveGroup(e), void this.setActiveObject(i.item(0), e) } else i.addWithUpdate(t); this.fire("selection:created", { target: i, e: e }), i.set("active", !0) }, _createActiveGroup: function (t, e) { if (this._activeObject && t !== this._activeObject) { var i = this._createGroup(t); i.addWithUpdate(), this.setActiveGroup(i, e), this._activeObject = null, this.fire("selection:created", { target: i, e: e }) } t.set("active", !0) }, _createGroup: function (t) { var e = this.getObjects(), i = e.indexOf(this._activeObject) < e.indexOf(t) ? [this._activeObject, t] : [t, this._activeObject]; return this._activeObject.isEditing && this._activeObject.exitEditing(), new fabric.Group(i, { canvas: this }) }, _groupSelectedObjects: function (t) { var e = this._collectObjects(); 1 === e.length ? this.setActiveObject(e[0], t) : e.length > 1 && ((e = new fabric.Group(e.reverse(), { canvas: this })).addWithUpdate(), this.setActiveGroup(e, t), e.saveCoords(), this.fire("selection:created", { target: e, e: t }), this.renderAll()) }, _collectObjects: function () { for (var i, r = [], n = this._groupSelector.ex, s = this._groupSelector.ey, o = n + this._groupSelector.left, a = s + this._groupSelector.top, h = new fabric.Point(t(n, o), t(s, a)), c = new fabric.Point(e(n, o), e(s, a)), l = n === o && s === a, u = this._objects.length; u-- && !((i = this._objects[u]) && i.selectable && i.visible && (i.intersectsWithRect(h, c) || i.isContainedWithinRect(h, c) || i.containsPoint(h) || i.containsPoint(c)) && (i.set("active", !0), r.push(i), l));); return r }, _maybeGroupObjects: function (t) { this.selection && this._groupSelector && this._groupSelectedObjects(t); var e = this.getActiveGroup(); e && (e.setObjectsCoords().setCoords(), e.isMoving = !1, this.setCursor(this.defaultCursor)), this._groupSelector = null, this._currentTransform = null } }) }(), function () { var t = fabric.StaticCanvas.supports("toDataURLWithQuality"); fabric.util.object.extend(fabric.StaticCanvas.prototype, { toDataURL: function (t) { t || (t = {}); var e = t.format || "png", i = t.quality || 1, r = t.multiplier || 1, n = { left: t.left || 0, top: t.top || 0, width: t.width || 0, height: t.height || 0 }; return this.__toDataURLWithMultiplier(e, i, n, r) }, __toDataURLWithMultiplier: function (t, e, i, r) { var n = this.getWidth(), s = this.getHeight(), o = (i.width || this.getWidth()) * r, a = (i.height || this.getHeight()) * r, h = this.getZoom() * r, c = this.viewportTransform, l = [h, 0, 0, h, (c[4] - i.left) * r, (c[5] - i.top) * r], u = this.interactive; this.viewportTransform = l, this.interactive && (this.interactive = !1), n !== o || s !== a ? this.setDimensions({ width: o, height: a }) : this.renderAll(); var f = this.__toDataURL(t, e, i); return u && (this.interactive = u), this.viewportTransform = c, this.setDimensions({ width: n, height: s }), f }, __toDataURL: function (e, i) { var r = this.contextContainer.canvas; return "jpg" === e && (e = "jpeg"), t ? r.toDataURL("image/" + e, i) : r.toDataURL("image/" + e) }, toDataURLWithMultiplier: function (t, e, i) { return this.toDataURL({ format: t, multiplier: e, quality: i }) } }) }(), fabric.util.object.extend(fabric.StaticCanvas.prototype, { loadFromDatalessJSON: function (t, e, i) { return this.loadFromJSON(t, e, i) }, loadFromJSON: function (t, e, i) { if (t) { var r = "string" == typeof t ? JSON.parse(t) : fabric.util.object.clone(t), n = this, s = this.renderOnAddRemove; return this.renderOnAddRemove = !1, this._enlivenObjects(r.objects, function (t) { n.clear(), n._setBgOverlay(r, function () { t.forEach(function (t, e) { n.insertAt(t, e) }), n.renderOnAddRemove = s, delete r.objects, delete r.backgroundImage, delete r.overlayImage, delete r.background, delete r.overlay, n._setOptions(r), n.renderAll(), e && e() }) }, i), this } }, _setBgOverlay: function (t, e) { var i = { backgroundColor: !1, overlayColor: !1, backgroundImage: !1, overlayImage: !1 }; if (t.backgroundImage || t.overlayImage || t.background || t.overlay) { var r = function () { i.backgroundImage && i.overlayImage && i.backgroundColor && i.overlayColor && e && e() }; this.__setBgOverlay("backgroundImage", t.backgroundImage, i, r), this.__setBgOverlay("overlayImage", t.overlayImage, i, r), this.__setBgOverlay("backgroundColor", t.background, i, r), this.__setBgOverlay("overlayColor", t.overlay, i, r) } else e && e() }, __setBgOverlay: function (t, e, i, r) { var n = this; if (!e) return i[t] = !0, void (r && r()); "backgroundImage" === t || "overlayImage" === t ? fabric.util.enlivenObjects([e], function (e) { n[t] = e[0], i[t] = !0, r && r() }) : this["set" + fabric.util.string.capitalize(t, !0)](e, function () { i[t] = !0, r && r() }) }, _enlivenObjects: function (t, e, i) { t && 0 !== t.length ? fabric.util.enlivenObjects(t, function (t) { e && e(t) }, null, i) : e && e([]) }, _toDataURL: function (t, e) { this.clone(function (i) { e(i.toDataURL(t)) }) }, _toDataURLWithMultiplier: function (t, e, i) { this.clone(function (r) { i(r.toDataURLWithMultiplier(t, e)) }) }, clone: function (t, e) { var i = JSON.stringify(this.toJSON(e)); this.cloneWithoutData(function (e) { e.loadFromJSON(i, function () { t && t(e) }) }) }, cloneWithoutData: function (t) { var e = fabric.document.createElement("canvas"); e.width = this.getWidth(), e.height = this.getHeight(); var i = new fabric.Canvas(e); i.clipTo = this.clipTo, this.backgroundImage ? (i.setBackgroundImage(this.backgroundImage.src, function () { i.renderAll(), t && t(i) }), i.backgroundImageOpacity = this.backgroundImageOpacity, i.backgroundImageStretch = this.backgroundImageStretch) : t && t(i) } }), function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.object.extend, r = e.util.object.clone, n = e.util.toFixed, s = e.util.string.capitalize, o = e.util.degreesToRadians, a = e.StaticCanvas.supports("setLineDash"), h = !e.isLikelyNode; e.Object || (e.Object = e.util.createClass(e.CommonMethods, { type: "object", originX: "left", originY: "top", top: 0, left: 0, width: 0, height: 0, scaleX: 1, scaleY: 1, flipX: !1, flipY: !1, opacity: 1, angle: 0, skewX: 0, skewY: 0, cornerSize: 13, transparentCorners: !0, hoverCursor: null, moveCursor: null, padding: 0, borderColor: "rgba(102,153,255,0.75)", borderDashArray: null, cornerColor: "rgba(102,153,255,0.5)", cornerStrokeColor: null, cornerStyle: "rect", cornerDashArray: null, centeredScaling: !1, centeredRotation: !0, fill: "rgb(0,0,0)", fillRule: "nonzero", globalCompositeOperation: "source-over", backgroundColor: "", selectionBackgroundColor: "", stroke: null, strokeWidth: 1, strokeDashArray: null, strokeLineCap: "butt", strokeLineJoin: "miter", strokeMiterLimit: 10, shadow: null, borderOpacityWhenMoving: .4, borderScaleFactor: 1, transformMatrix: null, minScaleLimit: .01, selectable: !0, evented: !0, visible: !0, hasControls: !0, hasBorders: !0, hasRotatingPoint: !0, rotatingPointOffset: 40, perPixelTargetFind: !1, includeDefaultValues: !0, clipTo: null, lockMovementX: !1, lockMovementY: !1, lockRotation: !1, lockScalingX: !1, lockScalingY: !1, lockUniScaling: !1, lockSkewingX: !1, lockSkewingY: !1, lockScalingFlip: !1, excludeFromExport: !1, objectCaching: h, statefullCache: !1, noScaleCache: !0, dirty: !0, stateProperties: "top left width height scaleX scaleY flipX flipY originX originY transformMatrix stroke strokeWidth strokeDashArray strokeLineCap strokeLineJoin strokeMiterLimit angle opacity fill globalCompositeOperation shadow clipTo visible backgroundColor skewX skewY fillRule".split(" "), cacheProperties: "fill stroke strokeWidth strokeDashArray width height strokeLineCap strokeLineJoin strokeMiterLimit backgroundColor".split(" "), initialize: function (t) { (t = t || {}) && this.setOptions(t) }, _createCacheCanvas: function () { this._cacheProperties = {}, this._cacheCanvas = e.document.createElement("canvas"), this._cacheContext = this._cacheCanvas.getContext("2d"), this._updateCacheCanvas() }, _limitCacheSize: function (t) { var i = e.perfLimitSizeTotal, r = e.cacheSideLimit, n = t.width, s = t.height, o = n / s, a = e.util.limitDimsByArea(o, i, r), h = e.util.capValue, c = e.maxCacheSideLimit, l = e.minCacheSideLimit, u = h(l, a.x, c), f = h(l, a.y, c); return n > u ? (t.zoomX /= n / u, t.width = u) : n < l && (t.width = l), s > f ? (t.zoomY /= s / f, t.height = f) : s < l && (t.height = l), t }, _getCacheCanvasDimensions: function () { var t = this.canvas && this.canvas.getZoom() || 1, i = this.getObjectScaling(), r = this.canvas && this.canvas._isRetinaScaling() ? e.devicePixelRatio : 1, n = this._getNonTransformedDimensions(), s = i.scaleX * t * r, o = i.scaleY * t * r; return { width: n.x * s + 2, height: n.y * o + 2, zoomX: s, zoomY: o, x: n.x, y: n.y } }, _updateCacheCanvas: function () { if (this.noScaleCache && this.canvas && this.canvas._currentTransform) { var t = this.canvas._currentTransform.target, i = this.canvas._currentTransform.action; if (this === t && i.slice && "scale" === i.slice(0, 5)) return !1 } var r, n, s = this._cacheCanvas, o = this._limitCacheSize(this._getCacheCanvasDimensions()), a = e.minCacheSideLimit, h = o.width, c = o.height, l = o.zoomX, u = o.zoomY, f = h !== this.cacheWidth || c !== this.cacheHeight, d = this.zoomX !== l || this.zoomY !== u, g = f || d, p = 0, v = 0, b = !1; if (f) { var m = this._cacheCanvas.width, _ = this._cacheCanvas.height, y = h > m || c > _, x = (h < .9 * m || c < .9 * _) && m > a && _ > a; b = y || x, y && (p = .1 * h, v = .1 * c) } return !!g && (b ? (s.width = Math.max(Math.ceil(h + p), a), s.height = Math.max(Math.ceil(c + v), a)) : (this._cacheContext.setTransform(1, 0, 0, 1, 0, 0), this._cacheContext.clearRect(0, 0, s.width, s.height)), r = o.x * l / 2, n = o.y * u / 2, this.cacheTranslationX = Math.round(s.width / 2 - r) + r, this.cacheTranslationY = Math.round(s.height / 2 - n) + n, this.cacheWidth = h, this.cacheHeight = c, this._cacheContext.translate(this.cacheTranslationX, this.cacheTranslationY), this._cacheContext.scale(l, u), this.zoomX = l, this.zoomY = u, !0) }, setOptions: function (t) { this._setOptions(t), this._initGradient(t.fill, "fill"), this._initGradient(t.stroke, "stroke"), this._initClipping(t), this._initPattern(t.fill, "fill"), this._initPattern(t.stroke, "stroke") }, transform: function (t, e) { this.group && !this.group._transformDone && this.group === this.canvas._activeGroup && this.group.transform(t); var i = e ? this._getLeftTopCoords() : this.getCenterPoint(); t.translate(i.x, i.y), this.angle && t.rotate(o(this.angle)), t.scale(this.scaleX * (this.flipX ? -1 : 1), this.scaleY * (this.flipY ? -1 : 1)), this.skewX && t.transform(1, 0, Math.tan(o(this.skewX)), 1, 0, 0), this.skewY && t.transform(1, Math.tan(o(this.skewY)), 0, 1, 0, 0) }, toObject: function (t) { var i = e.Object.NUM_FRACTION_DIGITS, r = { type: this.type, originX: this.originX, originY: this.originY, left: n(this.left, i), top: n(this.top, i), width: n(this.width, i), height: n(this.height, i), fill: this.fill && this.fill.toObject ? this.fill.toObject() : this.fill, stroke: this.stroke && this.stroke.toObject ? this.stroke.toObject() : this.stroke, strokeWidth: n(this.strokeWidth, i), strokeDashArray: this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray, strokeLineCap: this.strokeLineCap, strokeLineJoin: this.strokeLineJoin, strokeMiterLimit: n(this.strokeMiterLimit, i), scaleX: n(this.scaleX, i), scaleY: n(this.scaleY, i), angle: n(this.getAngle(), i), flipX: this.flipX, flipY: this.flipY, opacity: n(this.opacity, i), shadow: this.shadow && this.shadow.toObject ? this.shadow.toObject() : this.shadow, visible: this.visible, clipTo: this.clipTo && String(this.clipTo), backgroundColor: this.backgroundColor, fillRule: this.fillRule, globalCompositeOperation: this.globalCompositeOperation, transformMatrix: this.transformMatrix ? this.transformMatrix.concat() : null, skewX: n(this.skewX, i), skewY: n(this.skewY, i) }; return e.util.populateWithProperties(this, r, t), this.includeDefaultValues || (r = this._removeDefaultValues(r)), r }, toDatalessObject: function (t) { return this.toObject(t) }, _removeDefaultValues: function (t) { var i = e.util.getKlass(t.type).prototype; return i.stateProperties.forEach(function (e) { t[e] === i[e] && delete t[e], "[object Array]" === Object.prototype.toString.call(t[e]) && "[object Array]" === Object.prototype.toString.call(i[e]) && 0 === t[e].length && 0 === i[e].length && delete t[e] }), t }, toString: function () { return "#<fabric." + s(this.type) + ">" }, getObjectScaling: function () { var t = this.scaleX, e = this.scaleY; if (this.group) { var i = this.group.getObjectScaling(); t *= i.scaleX, e *= i.scaleY } return { scaleX: t, scaleY: e } }, _set: function (t, i) { var r = "scaleX" === t || "scaleY" === t, n = this[t] !== i; return r && (i = this._constrainScale(i)), "scaleX" === t && i < 0 ? (this.flipX = !this.flipX, i *= -1) : "scaleY" === t && i < 0 ? (this.flipY = !this.flipY, i *= -1) : "shadow" !== t || !i || i instanceof e.Shadow ? "dirty" === t && this.group && this.group.set("dirty", i) : i = new e.Shadow(i), this[t] = i, n && this.cacheProperties.indexOf(t) > -1 && (this.group && this.group.set("dirty", !0), this.dirty = !0), n && this.group && this.stateProperties.indexOf(t) > -1 && this.group.set("dirty", !0), "width" !== t && "height" !== t || (this.minScaleLimit = Math.min(.1, 1 / Math.max(this.width, this.height))), this }, setOnGroup: function () { }, setSourcePath: function (t) { return this.sourcePath = t, this }, getViewportTransform: function () { return this.canvas && this.canvas.viewportTransform ? this.canvas.viewportTransform : e.iMatrix.concat() }, isNotVisible: function () { return 0 === this.opacity || 0 === this.width && 0 === this.height || !this.visible }, render: function (t, i) { this.isNotVisible() || this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (t.save(), this._setupCompositeOperation(t), this.drawSelectionBackground(t), i || this.transform(t), this._setOpacity(t), this._setShadow(t), this.transformMatrix && t.transform.apply(t, this.transformMatrix), this.clipTo && e.util.clipContext(this, t), this.shouldCache(i) ? (this._cacheCanvas || this._createCacheCanvas(), this.isCacheDirty(i) && (this.statefullCache && this.saveState({ propertySet: "cacheProperties" }), this.drawObject(this._cacheContext, i), this.dirty = !1), this.drawCacheOnCanvas(t)) : (this._removeCacheCanvas(), this.dirty = !1, this.drawObject(t, i), i && this.objectCaching && this.statefullCache && this.saveState({ propertySet: "cacheProperties" })), this.clipTo && t.restore(), t.restore()) }, _removeCacheCanvas: function () { this._cacheCanvas = null, this.cacheWidth = 0, this.cacheHeight = 0 }, needsItsOwnCache: function () { return !1 }, shouldCache: function (t) { return !t && this.objectCaching && (!this.group || this.needsItsOwnCache() || !this.group.isCaching()) }, willDrawShadow: function () { return !!this.shadow && (0 !== this.shadow.offsetX || 0 !== this.shadow.offsetY) }, drawObject: function (t, e) { this._renderBackground(t), this._setStrokeStyles(t), this._setFillStyles(t), this._render(t, e) }, drawCacheOnCanvas: function (t) { t.scale(1 / this.zoomX, 1 / this.zoomY), t.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY) }, isCacheDirty: function (t) { if (this.isNotVisible()) return !1; if (this._cacheCanvas && !t && this._updateCacheCanvas()) return !0; if (this.dirty || this.statefullCache && this.hasStateChanged("cacheProperties")) { if (this._cacheCanvas && !t) { var e = this.cacheWidth / this.zoomX, i = this.cacheHeight / this.zoomY; this._cacheContext.clearRect(-e / 2, -i / 2, e, i) } return !0 } return !1 }, _renderBackground: function (t) { if (this.backgroundColor) { var e = this._getNonTransformedDimensions(); t.fillStyle = this.backgroundColor, t.fillRect(-e.x / 2, -e.y / 2, e.x, e.y), this._removeShadow(t) } }, _setOpacity: function (t) { t.globalAlpha *= this.opacity }, _setStrokeStyles: function (t) { this.stroke && (t.lineWidth = this.strokeWidth, t.lineCap = this.strokeLineCap, t.lineJoin = this.strokeLineJoin, t.miterLimit = this.strokeMiterLimit, t.strokeStyle = this.stroke.toLive ? this.stroke.toLive(t, this) : this.stroke) }, _setFillStyles: function (t) { this.fill && (t.fillStyle = this.fill.toLive ? this.fill.toLive(t, this) : this.fill) }, _setLineDash: function (t, e, i) { e && (1 & e.length && e.push.apply(e, e), a ? t.setLineDash(e) : i && i(t)) }, _renderControls: function (t) { if (this.active && (!this.group || this.group === this.canvas.getActiveGroup())) { var i, r = this.getViewportTransform(), n = this.calcTransformMatrix(); n = e.util.multiplyTransformMatrices(r, n), i = e.util.qrDecompose(n), t.save(), t.translate(i.translateX, i.translateY), t.lineWidth = 1 * this.borderScaleFactor, this.group || (t.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1), this.group && this.group === this.canvas.getActiveGroup() ? (t.rotate(o(i.angle)), this.drawBordersInGroup(t, i)) : (t.rotate(o(this.angle)), this.drawBorders(t)), this.drawControls(t), t.restore() } }, _setShadow: function (t) { if (this.shadow) { var i = this.canvas && this.canvas.viewportTransform[0] || 1, r = this.canvas && this.canvas.viewportTransform[3] || 1, n = this.getObjectScaling(); this.canvas && this.canvas._isRetinaScaling() && (i *= e.devicePixelRatio, r *= e.devicePixelRatio), t.shadowColor = this.shadow.color, t.shadowBlur = this.shadow.blur * (i + r) * (n.scaleX + n.scaleY) / 4, t.shadowOffsetX = this.shadow.offsetX * i * n.scaleX, t.shadowOffsetY = this.shadow.offsetY * r * n.scaleY } }, _removeShadow: function (t) { this.shadow && (t.shadowColor = "", t.shadowBlur = t.shadowOffsetX = t.shadowOffsetY = 0) }, _applyPatternGradientTransform: function (t, e) { if (e.toLive) { var i = e.gradientTransform || e.patternTransform; i && t.transform.apply(t, i); var r = -this.width / 2 + e.offsetX || 0, n = -this.height / 2 + e.offsetY || 0; t.translate(r, n) } }, _renderFill: function (t) { this.fill && (t.save(), this._applyPatternGradientTransform(t, this.fill), "evenodd" === this.fillRule ? t.fill("evenodd") : t.fill(), t.restore()) }, _renderStroke: function (t) { this.stroke && 0 !== this.strokeWidth && (this.shadow && !this.shadow.affectStroke && this._removeShadow(t), t.save(), this._setLineDash(t, this.strokeDashArray, this._renderDashedStroke), this._applyPatternGradientTransform(t, this.stroke), t.stroke(), t.restore()) }, clone: function (t, i) { return this.constructor.fromObject ? this.constructor.fromObject(this.toObject(i), t) : new e.Object(this.toObject(i)) }, cloneAsImage: function (t, i) { var r = this.toDataURL(i); return e.util.loadImage(r, function (i) { t && t(new e.Image(i)) }), this }, toDataURL: function (t) { t || (t = {}); var i = e.util.createCanvasElement(), r = this.getBoundingRect(); i.width = r.width, i.height = r.height, e.util.wrapElement(i, "div"); var n = new e.StaticCanvas(i, { enableRetinaScaling: t.enableRetinaScaling }); "jpg" === t.format && (t.format = "jpeg"), "jpeg" === t.format && (n.backgroundColor = "#fff"); var s = { active: this.get("active"), left: this.getLeft(), top: this.getTop() }; this.set("active", !1), this.setPositionByOrigin(new e.Point(n.getWidth() / 2, n.getHeight() / 2), "center", "center"); var o = this.canvas; n.add(this); var a = n.toDataURL(t); return this.set(s).setCoords(), this.canvas = o, n.dispose(), n = null, a }, isType: function (t) { return this.type === t }, complexity: function () { return 1 }, toJSON: function (t) { return this.toObject(t) }, setGradient: function (t, i) { i || (i = {}); var r = { colorStops: [] }; return r.type = i.type || (i.r1 || i.r2 ? "radial" : "linear"), r.coords = { x1: i.x1, y1: i.y1, x2: i.x2, y2: i.y2 }, (i.r1 || i.r2) && (r.coords.r1 = i.r1, r.coords.r2 = i.r2), r.gradientTransform = i.gradientTransform, e.Gradient.prototype.addColorStop.call(r, i.colorStops), this.set(t, e.Gradient.forObject(this, r)) }, setPatternFill: function (t) { return this.set("fill", new e.Pattern(t)) }, setShadow: function (t) { return this.set("shadow", t ? new e.Shadow(t) : null) }, setColor: function (t) { return this.set("fill", t), this }, setAngle: function (t) { var e = ("center" !== this.originX || "center" !== this.originY) && this.centeredRotation; return e && this._setOriginToCenter(), this.set("angle", t), e && this._resetOrigin(), this }, centerH: function () { return this.canvas && this.canvas.centerObjectH(this), this }, viewportCenterH: function () { return this.canvas && this.canvas.viewportCenterObjectH(this), this }, centerV: function () { return this.canvas && this.canvas.centerObjectV(this), this }, viewportCenterV: function () { return this.canvas && this.canvas.viewportCenterObjectV(this), this }, center: function () { return this.canvas && this.canvas.centerObject(this), this }, viewportCenter: function () { return this.canvas && this.canvas.viewportCenterObject(this), this }, remove: function () { return this.canvas && (this.group && this.group === this.canvas._activeGroup && this.group.remove(this), this.canvas.remove(this)), this }, getLocalPointer: function (t, i) { i = i || this.canvas.getPointer(t); var r = new e.Point(i.x, i.y), n = this._getLeftTopCoords(); return this.angle && (r = e.util.rotatePoint(r, n, o(-this.angle))), { x: r.x - n.x, y: r.y - n.y } }, _setupCompositeOperation: function (t) { this.globalCompositeOperation && (t.globalCompositeOperation = this.globalCompositeOperation) } }), e.util.createAccessors(e.Object), e.Object.prototype.rotate = e.Object.prototype.setAngle, i(e.Object.prototype, e.Observable), e.Object.NUM_FRACTION_DIGITS = 2, e.Object._fromObject = function (t, i, n, s, o) { var a = e[t]; if (i = r(i, !0), !s) { var h = o ? new a(i[o], i) : new a(i); return n && n(h), h } e.util.enlivenPatterns([i.fill, i.stroke], function (t) { void 0 !== t[0] && (i.fill = t[0]), void 0 !== t[1] && (i.stroke = t[1]); var e = o ? new a(i[o], i) : new a(i); n && n(e) }) }, e.Object.__uid = 0) }("undefined" != typeof exports ? exports : this), function () { var t = fabric.util.degreesToRadians, e = { left: -.5, center: 0, right: .5 }, i = { top: -.5, center: 0, bottom: .5 }; fabric.util.object.extend(fabric.Object.prototype, { translateToGivenOrigin: function (t, r, n, s, o) { var a, h, c, l = t.x, u = t.y; return "string" == typeof r ? r = e[r] : r -= .5, "string" == typeof s ? s = e[s] : s -= .5, a = s - r, "string" == typeof n ? n = i[n] : n -= .5, "string" == typeof o ? o = i[o] : o -= .5, h = o - n, (a || h) && (c = this._getTransformedDimensions(), l = t.x + a * c.x, u = t.y + h * c.y), new fabric.Point(l, u) }, translateToCenterPoint: function (e, i, r) { var n = this.translateToGivenOrigin(e, i, r, "center", "center"); return this.angle ? fabric.util.rotatePoint(n, e, t(this.angle)) : n }, translateToOriginPoint: function (e, i, r) { var n = this.translateToGivenOrigin(e, "center", "center", i, r); return this.angle ? fabric.util.rotatePoint(n, e, t(this.angle)) : n }, getCenterPoint: function () { var t = new fabric.Point(this.left, this.top); return this.translateToCenterPoint(t, this.originX, this.originY) }, getPointByOrigin: function (t, e) { var i = this.getCenterPoint(); return this.translateToOriginPoint(i, t, e) }, toLocalPoint: function (e, i, r) { var n, s, o = this.getCenterPoint(); return n = void 0 !== i && void 0 !== r ? this.translateToGivenOrigin(o, "center", "center", i, r) : new fabric.Point(this.left, this.top), s = new fabric.Point(e.x, e.y), this.angle && (s = fabric.util.rotatePoint(s, o, -t(this.angle))), s.subtractEquals(n) }, setPositionByOrigin: function (t, e, i) { var r = this.translateToCenterPoint(t, e, i), n = this.translateToOriginPoint(r, this.originX, this.originY); this.set("left", n.x), this.set("top", n.y) }, adjustPosition: function (i) { var r, n, s = t(this.angle), o = this.getWidth(), a = Math.cos(s) * o, h = Math.sin(s) * o; r = "string" == typeof this.originX ? e[this.originX] : this.originX - .5, n = "string" == typeof i ? e[i] : i - .5, this.left += a * (n - r), this.top += h * (n - r), this.setCoords(), this.originX = i }, _setOriginToCenter: function () { this._originalOriginX = this.originX, this._originalOriginY = this.originY; var t = this.getCenterPoint(); this.originX = "center", this.originY = "center", this.left = t.x, this.top = t.y }, _resetOrigin: function () { var t = this.translateToOriginPoint(this.getCenterPoint(), this._originalOriginX, this._originalOriginY); this.originX = this._originalOriginX, this.originY = this._originalOriginY, this.left = t.x, this.top = t.y, this._originalOriginX = null, this._originalOriginY = null }, _getLeftTopCoords: function () { return this.translateToOriginPoint(this.getCenterPoint(), "left", "top") }, onDeselect: function () { } }) }(), function () { function t(t) { return [new fabric.Point(t.tl.x, t.tl.y), new fabric.Point(t.tr.x, t.tr.y), new fabric.Point(t.br.x, t.br.y), new fabric.Point(t.bl.x, t.bl.y)] } var e = fabric.util.degreesToRadians, i = fabric.util.multiplyTransformMatrices; fabric.util.object.extend(fabric.Object.prototype, { oCoords: null, aCoords: null, getCoords: function (e, i) { this.oCoords || this.setCoords(); var r = e ? this.aCoords : this.oCoords; return t(i ? this.calcCoords(e) : r) }, intersectsWithRect: function (t, e, i, r) { var n = this.getCoords(i, r); return "Intersection" === fabric.Intersection.intersectPolygonRectangle(n, t, e).status }, intersectsWithObject: function (t, e, i) { return "Intersection" === fabric.Intersection.intersectPolygonPolygon(this.getCoords(e, i), t.getCoords(e, i)).status || t.isContainedWithinObject(this, e, i) || this.isContainedWithinObject(t, e, i) }, isContainedWithinObject: function (t, e, i) { for (var r = this.getCoords(e, i), n = 0, s = t._getImageLines(i ? t.calcCoords(e) : e ? t.aCoords : t.oCoords); n < 4; n++)if (!t.containsPoint(r[n], s)) return !1; return !0 }, isContainedWithinRect: function (t, e, i, r) { var n = this.getBoundingRect(i, r); return n.left >= t.x && n.left + n.width <= e.x && n.top >= t.y && n.top + n.height <= e.y }, containsPoint: function (t, e, i, r) { var e = e || this._getImageLines(r ? this.calcCoords(i) : i ? this.aCoords : this.oCoords), n = this._findCrossPoints(t, e); return 0 !== n && n % 2 == 1 }, isOnScreen: function (t) { if (!this.canvas) return !1; for (var e, i = this.canvas.vptCoords.tl, r = this.canvas.vptCoords.br, n = this.getCoords(!0, t), s = 0; s < 4; s++)if ((e = n[s]).x <= r.x && e.x >= i.x && e.y <= r.y && e.y >= i.y) return !0; if (this.intersectsWithRect(i, r, !0)) return !0; var o = { x: (i.x + r.x) / 2, y: (i.y + r.y) / 2 }; return !!this.containsPoint(o, null, !0) }, _getImageLines: function (t) { return { topline: { o: t.tl, d: t.tr }, rightline: { o: t.tr, d: t.br }, bottomline: { o: t.br, d: t.bl }, leftline: { o: t.bl, d: t.tl } } }, _findCrossPoints: function (t, e) { var i, r, n, s, o = 0; for (var a in e) if (!((s = e[a]).o.y < t.y && s.d.y < t.y || s.o.y >= t.y && s.d.y >= t.y || (s.o.x === s.d.x && s.o.x >= t.x ? n = s.o.x : (i = 0, r = (s.d.y - s.o.y) / (s.d.x - s.o.x), n = -(t.y - i * t.x - (s.o.y - r * s.o.x)) / (i - r)), n >= t.x && (o += 1), 2 !== o))) break; return o }, getBoundingRectWidth: function () { return this.getBoundingRect().width }, getBoundingRectHeight: function () { return this.getBoundingRect().height }, getBoundingRect: function (t, e) { var i = this.getCoords(t, e); return fabric.util.makeBoundingBoxFromPoints(i) }, getWidth: function () { return this._getTransformedDimensions().x }, getHeight: function () { return this._getTransformedDimensions().y }, _constrainScale: function (t) { return Math.abs(t) < this.minScaleLimit ? t < 0 ? -this.minScaleLimit : this.minScaleLimit : t }, scale: function (t) { return (t = this._constrainScale(t)) < 0 && (this.flipX = !this.flipX, this.flipY = !this.flipY, t *= -1), this.scaleX = t, this.scaleY = t, this.setCoords() }, scaleToWidth: function (t) { var e = this.getBoundingRect().width / this.getWidth(); return this.scale(t / this.width / e) }, scaleToHeight: function (t) { var e = this.getBoundingRect().height / this.getHeight(); return this.scale(t / this.height / e) }, calcCoords: function (t) { var i = e(this.angle), r = this.getViewportTransform(), n = t ? this._getTransformedDimensions() : this._calculateCurrentDimensions(), s = n.x, o = n.y, a = Math.sin(i), h = Math.cos(i), c = s > 0 ? Math.atan(o / s) : 0, l = s / Math.cos(c) / 2, u = Math.cos(c + i) * l, f = Math.sin(c + i) * l, d = this.getCenterPoint(), g = t ? d : fabric.util.transformPoint(d, r), p = new fabric.Point(g.x - u, g.y - f), v = new fabric.Point(p.x + s * h, p.y + s * a), b = new fabric.Point(p.x - o * a, p.y + o * h), m = new fabric.Point(g.x + u, g.y + f); if (!t) var _ = new fabric.Point((p.x + b.x) / 2, (p.y + b.y) / 2), y = new fabric.Point((v.x + p.x) / 2, (v.y + p.y) / 2), x = new fabric.Point((m.x + v.x) / 2, (m.y + v.y) / 2), C = new fabric.Point((m.x + b.x) / 2, (m.y + b.y) / 2), S = new fabric.Point(y.x + a * this.rotatingPointOffset, y.y - h * this.rotatingPointOffset); g = { tl: p, tr: v, br: m, bl: b }; return t || (g.ml = _, g.mt = y, g.mr = x, g.mb = C, g.mtr = S), g }, setCoords: function (t, e) { return this.oCoords = this.calcCoords(t), e || (this.aCoords = this.calcCoords(!0)), t || this._setCornerCoords && this._setCornerCoords(), this }, _calcRotateMatrix: function () { if (this.angle) { var t = e(this.angle), i = Math.cos(t), r = Math.sin(t); return 6.123233995736766e-17 !== i && -1.8369701987210297e-16 !== i || (i = 0), [i, r, -r, i, 0, 0] } return fabric.iMatrix.concat() }, calcTransformMatrix: function (t) { var e, r, n = this.getCenterPoint(), s = [1, 0, 0, 1, n.x, n.y], o = this._calcDimensionsTransformMatrix(this.skewX, this.skewY, !0); return r = this.group && !t ? i(this.group.calcTransformMatrix(), s) : s, this.angle && (e = this._calcRotateMatrix(), r = i(r, e)), r = i(r, o) }, _calcDimensionsTransformMatrix: function (t, r, n) { var s, o = [this.scaleX * (n && this.flipX ? -1 : 1), 0, 0, this.scaleY * (n && this.flipY ? -1 : 1), 0, 0]; return t && (s = [1, 0, Math.tan(e(t)), 1], o = i(o, s, !0)), r && (s = [1, Math.tan(e(r)), 0, 1], o = i(o, s, !0)), o }, _getNonTransformedDimensions: function () { var t = this.strokeWidth; return { x: this.width + t, y: this.height + t } }, _getTransformedDimensions: function (t, e) { void 0 === t && (t = this.skewX), void 0 === e && (e = this.skewY); var i, r, n = this._getNonTransformedDimensions(), s = n.x / 2, o = n.y / 2, a = [{ x: -s, y: -o }, { x: s, y: -o }, { x: -s, y: o }, { x: s, y: o }], h = this._calcDimensionsTransformMatrix(t, e, !1); for (i = 0; i < a.length; i++)a[i] = fabric.util.transformPoint(a[i], h); return r = fabric.util.makeBoundingBoxFromPoints(a), { x: r.width, y: r.height } }, _calculateCurrentDimensions: function () { var t = this.getViewportTransform(), e = this._getTransformedDimensions(); return fabric.util.transformPoint(e, t, !0).scalarAdd(2 * this.padding) } }) }(), fabric.util.object.extend(fabric.Object.prototype, { sendToBack: function () { return this.group ? fabric.StaticCanvas.prototype.sendToBack.call(this.group, this) : this.canvas.sendToBack(this), this }, bringToFront: function () { return this.group ? fabric.StaticCanvas.prototype.bringToFront.call(this.group, this) : this.canvas.bringToFront(this), this }, sendBackwards: function (t) { return this.group ? fabric.StaticCanvas.prototype.sendBackwards.call(this.group, this, t) : this.canvas.sendBackwards(this, t), this }, bringForward: function (t) { return this.group ? fabric.StaticCanvas.prototype.bringForward.call(this.group, this, t) : this.canvas.bringForward(this, t), this }, moveTo: function (t) { return this.group ? fabric.StaticCanvas.prototype.moveTo.call(this.group, this, t) : this.canvas.moveTo(this, t), this } }), function () { function t(t, e) { if (e) { if (e.toLive) return t + ": url(#SVGID_" + e.id + "); "; var i = new fabric.Color(e), r = t + ": " + i.toRgb() + "; ", n = i.getAlpha(); return 1 !== n && (r += t + "-opacity: " + n.toString() + "; "), r } return t + ": none; " } fabric.util.object.extend(fabric.Object.prototype, { getSvgStyles: function (e) { var i = this.fillRule, r = this.strokeWidth ? this.strokeWidth : "0", n = this.strokeDashArray ? this.strokeDashArray.join(" ") : "none", s = this.strokeLineCap ? this.strokeLineCap : "butt", o = this.strokeLineJoin ? this.strokeLineJoin : "miter", a = this.strokeMiterLimit ? this.strokeMiterLimit : "4", h = void 0 !== this.opacity ? this.opacity : "1", c = this.visible ? "" : " visibility: hidden;", l = e ? "" : this.getSvgFilter(), u = t("fill", this.fill); return [t("stroke", this.stroke), "stroke-width: ", r, "; ", "stroke-dasharray: ", n, "; ", "stroke-linecap: ", s, "; ", "stroke-linejoin: ", o, "; ", "stroke-miterlimit: ", a, "; ", u, "fill-rule: ", i, "; ", "opacity: ", h, ";", l, c].join("") }, getSvgFilter: function () { return this.shadow ? "filter: url(#SVGID_" + this.shadow.id + ");" : "" }, getSvgId: function () { return this.id ? 'id="' + this.id + '" ' : "" }, getSvgTransform: function () { if (this.group && "path-group" === this.group.type) return ""; var t = fabric.util.toFixed, e = this.getAngle(), i = this.getSkewX() % 360, r = this.getSkewY() % 360, n = this.getCenterPoint(), s = fabric.Object.NUM_FRACTION_DIGITS, o = "path-group" === this.type ? "" : "translate(" + t(n.x, s) + " " + t(n.y, s) + ")", a = 0 !== e ? " rotate(" + t(e, s) + ")" : "", h = 1 === this.scaleX && 1 === this.scaleY ? "" : " scale(" + t(this.scaleX, s) + " " + t(this.scaleY, s) + ")", c = 0 !== i ? " skewX(" + t(i, s) + ")" : "", l = 0 !== r ? " skewY(" + t(r, s) + ")" : "", u = "path-group" === this.type ? this.width : 0, f = this.flipX ? " matrix(-1 0 0 1 " + u + " 0) " : "", d = "path-group" === this.type ? this.height : 0; return [o, a, h, f, this.flipY ? " matrix(1 0 0 -1 0 " + d + ")" : "", c, l].join("") }, getSvgTransformMatrix: function () { return this.transformMatrix ? " matrix(" + this.transformMatrix.join(" ") + ") " : "" }, _createBaseSVGMarkup: function () { var t = []; return this.fill && this.fill.toLive && t.push(this.fill.toSVG(this, !1)), this.stroke && this.stroke.toLive && t.push(this.stroke.toSVG(this, !1)), this.shadow && t.push(this.shadow.toSVG(this)), t } }) }(), function () { function t(t, e, r) { var n = {}; r.forEach(function (e) { n[e] = t[e] }), i(t[e], n, !0) } function e(t, i, r) { if (t === i) return !0; if (Array.isArray(t)) { if (t.length !== i.length) return !1; for (var n = 0, s = t.length; n < s; n++)if (!e(t[n], i[n])) return !1; return !0 } if (t && "object" == typeof t) { var o, a = Object.keys(t); if (!r && a.length !== Object.keys(i).length) return !1; for (var n = 0, s = a.length; n < s; n++)if (o = a[n], !e(t[o], i[o])) return !1; return !0 } } var i = fabric.util.object.extend; fabric.util.object.extend(fabric.Object.prototype, { hasStateChanged: function (t) { var i = "_" + (t = t || "stateProperties"); return Object.keys(this[i]).length < this[t].length || !e(this[i], this, !0) }, saveState: function (e) { var i = e && e.propertySet || "stateProperties", r = "_" + i; return this[r] ? (t(this, r, this[i]), e && e.stateProperties && t(this, r, e.stateProperties), this) : this.setupState(e) }, setupState: function (t) { var e = (t = t || {}).propertySet || "stateProperties"; return t.propertySet = e, this["_" + e] = {}, this.saveState(t), this } }) }(), function () { var t = fabric.util.degreesToRadians, e = function () { return "undefined" != typeof G_vmlCanvasManager }; fabric.util.object.extend(fabric.Object.prototype, { _controlsVisibility: null, _findTargetCorner: function (t) { if (!this.hasControls || !this.active) return !1; var e, i, r = t.x, n = t.y; this.__corner = 0; for (var s in this.oCoords) if (this.isControlVisible(s) && ("mtr" !== s || this.hasRotatingPoint) && (!this.get("lockUniScaling") || "mt" !== s && "mr" !== s && "mb" !== s && "ml" !== s) && (i = this._getImageLines(this.oCoords[s].corner), 0 !== (e = this._findCrossPoints({ x: r, y: n }, i)) && e % 2 == 1)) return this.__corner = s, s; return !1 }, _setCornerCoords: function () { var e, i, r = this.oCoords, n = t(45 - this.angle), s = .707106 * this.cornerSize, o = s * Math.cos(n), a = s * Math.sin(n); for (var h in r) e = r[h].x, i = r[h].y, r[h].corner = { tl: { x: e - a, y: i - o }, tr: { x: e + o, y: i - a }, bl: { x: e - o, y: i + a }, br: { x: e + a, y: i + o } } }, drawSelectionBackground: function (e) { if (!this.selectionBackgroundColor || this.group || !this.active || this.canvas && !this.canvas.interactive) return this; e.save(); var i = this.getCenterPoint(), r = this._calculateCurrentDimensions(), n = this.canvas.viewportTransform; return e.translate(i.x, i.y), e.scale(1 / n[0], 1 / n[3]), e.rotate(t(this.angle)), e.fillStyle = this.selectionBackgroundColor, e.fillRect(-r.x / 2, -r.y / 2, r.x, r.y), e.restore(), this }, drawBorders: function (t) { if (!this.hasBorders) return this; var e = this._calculateCurrentDimensions(), i = 1 / this.borderScaleFactor, r = e.x + i, n = e.y + i; if (t.save(), t.strokeStyle = this.borderColor, this._setLineDash(t, this.borderDashArray, null), t.strokeRect(-r / 2, -n / 2, r, n), this.hasRotatingPoint && this.isControlVisible("mtr") && !this.get("lockRotation") && this.hasControls) { var s = -n / 2; t.beginPath(), t.moveTo(0, s), t.lineTo(0, s - this.rotatingPointOffset), t.closePath(), t.stroke() } return t.restore(), this }, drawBordersInGroup: function (t, e) { if (!this.hasBorders) return this; var i = this._getNonTransformedDimensions(), r = fabric.util.customTransformMatrix(e.scaleX, e.scaleY, e.skewX), n = fabric.util.transformPoint(i, r), s = 1 / this.borderScaleFactor, o = n.x + s, a = n.y + s; return t.save(), this._setLineDash(t, this.borderDashArray, null), t.strokeStyle = this.borderColor, t.strokeRect(-o / 2, -a / 2, o, a), t.restore(), this }, drawControls: function (t) { if (!this.hasControls) return this; var e = this._calculateCurrentDimensions(), i = e.x, r = e.y, n = this.cornerSize, s = -(i + n) / 2, o = -(r + n) / 2, a = this.transparentCorners ? "stroke" : "fill"; return t.save(), t.strokeStyle = t.fillStyle = this.cornerColor, this.transparentCorners || (t.strokeStyle = this.cornerStrokeColor), this._setLineDash(t, this.cornerDashArray, null), this._drawControl("tl", t, a, s, o), this._drawControl("tr", t, a, s + i, o), this._drawControl("bl", t, a, s, o + r), this._drawControl("br", t, a, s + i, o + r), this.get("lockUniScaling") || (this._drawControl("mt", t, a, s + i / 2, o), this._drawControl("mb", t, a, s + i / 2, o + r), this._drawControl("mr", t, a, s + i, o + r / 2), this._drawControl("ml", t, a, s, o + r / 2)), this.hasRotatingPoint && this._drawControl("mtr", t, a, s + i / 2, o - this.rotatingPointOffset), t.restore(), this }, _drawControl: function (t, i, r, n, s) { if (this.isControlVisible(t)) { var o = this.cornerSize, a = !this.transparentCorners && this.cornerStrokeColor; switch (this.cornerStyle) { case "circle": i.beginPath(), i.arc(n + o / 2, s + o / 2, o / 2, 0, 2 * Math.PI, !1), i[r](), a && i.stroke(); break; default: e() || this.transparentCorners || i.clearRect(n, s, o, o), i[r + "Rect"](n, s, o, o), a && i.strokeRect(n, s, o, o) } } }, isControlVisible: function (t) { return this._getControlsVisibility()[t] }, setControlVisible: function (t, e) { return this._getControlsVisibility()[t] = e, this }, setControlsVisibility: function (t) { t || (t = {}); for (var e in t) this.setControlVisible(e, t[e]); return this }, _getControlsVisibility: function () { return this._controlsVisibility || (this._controlsVisibility = { tl: !0, tr: !0, br: !0, bl: !0, ml: !0, mt: !0, mr: !0, mb: !0, mtr: !0 }), this._controlsVisibility } }) }(), fabric.util.object.extend(fabric.StaticCanvas.prototype, { FX_DURATION: 500, fxCenterObjectH: function (t, e) { var i = function () { }, r = (e = e || {}).onComplete || i, n = e.onChange || i, s = this; return fabric.util.animate({ startValue: t.get("left"), endValue: this.getCenter().left, duration: this.FX_DURATION, onChange: function (e) { t.set("left", e), s.renderAll(), n() }, onComplete: function () { t.setCoords(), r() } }), this }, fxCenterObjectV: function (t, e) { var i = function () { }, r = (e = e || {}).onComplete || i, n = e.onChange || i, s = this; return fabric.util.animate({ startValue: t.get("top"), endValue: this.getCenter().top, duration: this.FX_DURATION, onChange: function (e) { t.set("top", e), s.renderAll(), n() }, onComplete: function () { t.setCoords(), r() } }), this }, fxRemove: function (t, e) { var i = function () { }, r = (e = e || {}).onComplete || i, n = e.onChange || i, s = this; return fabric.util.animate({ startValue: t.get("opacity"), endValue: 0, duration: this.FX_DURATION, onStart: function () { t.set("active", !1) }, onChange: function (e) { t.set("opacity", e), s.renderAll(), n() }, onComplete: function () { s.remove(t), r() } }), this } }), fabric.util.object.extend(fabric.Object.prototype, { animate: function () { if (arguments[0] && "object" == typeof arguments[0]) { var t, e, i = []; for (t in arguments[0]) i.push(t); for (var r = 0, n = i.length; r < n; r++)t = i[r], e = r !== n - 1, this._animate(t, arguments[0][t], arguments[1], e) } else this._animate.apply(this, arguments); return this }, _animate: function (t, e, i, r) { var n, s = this; e = e.toString(), i = i ? fabric.util.object.clone(i) : {}, ~t.indexOf(".") && (n = t.split(".")); var o = n ? this.get(n[0])[n[1]] : this.get(t); "from" in i || (i.from = o), e = ~e.indexOf("=") ? o + parseFloat(e.replace("=", "")) : parseFloat(e), fabric.util.animate({ startValue: i.from, endValue: e, byValue: i.by, easing: i.easing, duration: i.duration, abort: i.abort && function () { return i.abort.call(s) }, onChange: function (e, o, a) { n ? s[n[0]][n[1]] = e : s.set(t, e), r || i.onChange && i.onChange(e, o, a) }, onComplete: function (t, e, n) { r || (s.setCoords(), i.onComplete && i.onComplete(t, e, n)) } }) } }), function (t) { "use strict"; function e(t, e) { var i = t.origin, r = t.axis1, n = t.axis2, s = t.dimension, o = e.nearest, a = e.center, h = e.farthest; return function () { switch (this.get(i)) { case o: return Math.min(this.get(r), this.get(n)); case a: return Math.min(this.get(r), this.get(n)) + .5 * this.get(s); case h: return Math.max(this.get(r), this.get(n)) } } } var i = t.fabric || (t.fabric = {}), r = i.util.object.extend, n = i.util.object.clone, s = { x1: 1, x2: 1, y1: 1, y2: 1 }, o = i.StaticCanvas.supports("setLineDash"); if (i.Line) i.warn("fabric.Line is already defined"); else { var a = i.Object.prototype.cacheProperties.concat(); a.push("x1", "x2", "y1", "y2"), i.Line = i.util.createClass(i.Object, { type: "line", x1: 0, y1: 0, x2: 0, y2: 0, cacheProperties: a, initialize: function (t, e) { t || (t = [0, 0, 0, 0]), this.callSuper("initialize", e), this.set("x1", t[0]), this.set("y1", t[1]), this.set("x2", t[2]), this.set("y2", t[3]), this._setWidthHeight(e) }, _setWidthHeight: function (t) { t || (t = {}), this.width = Math.abs(this.x2 - this.x1), this.height = Math.abs(this.y2 - this.y1), this.left = "left" in t ? t.left : this._getLeftToOriginX(), this.top = "top" in t ? t.top : this._getTopToOriginY() }, _set: function (t, e) { return this.callSuper("_set", t, e), void 0 !== s[t] && this._setWidthHeight(), this }, _getLeftToOriginX: e({ origin: "originX", axis1: "x1", axis2: "x2", dimension: "width" }, { nearest: "left", center: "center", farthest: "right" }), _getTopToOriginY: e({ origin: "originY", axis1: "y1", axis2: "y2", dimension: "height" }, { nearest: "top", center: "center", farthest: "bottom" }), _render: function (t, e) { if (t.beginPath(), e) { var i = this.getCenterPoint(), r = this.strokeWidth / 2; t.translate(i.x - ("butt" === this.strokeLineCap && 0 === this.height ? 0 : r), i.y - ("butt" === this.strokeLineCap && 0 === this.width ? 0 : r)) } if (!this.strokeDashArray || this.strokeDashArray && o) { var n = this.calcLinePoints(); t.moveTo(n.x1, n.y1), t.lineTo(n.x2, n.y2) } t.lineWidth = this.strokeWidth; var s = t.strokeStyle; t.strokeStyle = this.stroke || t.fillStyle, this.stroke && this._renderStroke(t), t.strokeStyle = s }, _renderDashedStroke: function (t) { var e = this.calcLinePoints(); t.beginPath(), i.util.drawDashedLine(t, e.x1, e.y1, e.x2, e.y2, this.strokeDashArray), t.closePath() }, toObject: function (t) { return r(this.callSuper("toObject", t), this.calcLinePoints()) }, _getNonTransformedDimensions: function () { var t = this.callSuper("_getNonTransformedDimensions"); return "butt" === this.strokeLineCap && (0 === this.width && (t.y -= this.strokeWidth), 0 === this.height && (t.x -= this.strokeWidth)), t }, calcLinePoints: function () { var t = this.x1 <= this.x2 ? -1 : 1, e = this.y1 <= this.y2 ? -1 : 1, i = t * this.width * .5, r = e * this.height * .5; return { x1: i, x2: t * this.width * -.5, y1: r, y2: e * this.height * -.5 } }, toSVG: function (t) { var e = this._createBaseSVGMarkup(), i = { x1: this.x1, x2: this.x2, y1: this.y1, y2: this.y2 }; return this.group && "path-group" === this.group.type || (i = this.calcLinePoints()), e.push("<line ", this.getSvgId(), 'x1="', i.x1, '" y1="', i.y1, '" x2="', i.x2, '" y2="', i.y2, '" style="', this.getSvgStyles(), '" transform="', this.getSvgTransform(), this.getSvgTransformMatrix(), '"/>\n'), t ? t(e.join("")) : e.join("") } }), i.Line.ATTRIBUTE_NAMES = i.SHARED_ATTRIBUTES.concat("x1 y1 x2 y2".split(" ")), i.Line.fromElement = function (t, e) { e = e || {}; var n = i.parseAttributes(t, i.Line.ATTRIBUTE_NAMES), s = [n.x1 || 0, n.y1 || 0, n.x2 || 0, n.y2 || 0]; return e.originX = "left", e.originY = "top", new i.Line(s, r(n, e)) }, i.Line.fromObject = function (t, e, r) { var s = n(t, !0); s.points = [t.x1, t.y1, t.x2, t.y2]; var o = i.Object._fromObject("Line", s, function (t) { delete t.points, e && e(t) }, r, "points"); return o && delete o.points, o } } }("undefined" != typeof exports ? exports : this), function (t) { "use strict"; function e(t) { return "radius" in t && t.radius >= 0 } var i = t.fabric || (t.fabric = {}), r = Math.PI, n = i.util.object.extend; if (i.Circle) i.warn("fabric.Circle is already defined."); else { var s = i.Object.prototype.cacheProperties.concat(); s.push("radius"), i.Circle = i.util.createClass(i.Object, { type: "circle", radius: 0, startAngle: 0, endAngle: 2 * r, cacheProperties: s, initialize: function (t) { this.callSuper("initialize", t), this.set("radius", t && t.radius || 0) }, _set: function (t, e) { return this.callSuper("_set", t, e), "radius" === t && this.setRadius(e), this }, toObject: function (t) { return this.callSuper("toObject", ["radius", "startAngle", "endAngle"].concat(t)) }, toSVG: function (t) { var e = this._createBaseSVGMarkup(), i = 0, n = 0, s = (this.endAngle - this.startAngle) % (2 * r); if (0 === s) this.group && "path-group" === this.group.type && (i = this.left + this.radius, n = this.top + this.radius), e.push("<circle ", this.getSvgId(), 'cx="' + i + '" cy="' + n + '" ', 'r="', this.radius, '" style="', this.getSvgStyles(), '" transform="', this.getSvgTransform(), " ", this.getSvgTransformMatrix(), '"/>\n'); else { var o = Math.cos(this.startAngle) * this.radius, a = Math.sin(this.startAngle) * this.radius, h = Math.cos(this.endAngle) * this.radius, c = Math.sin(this.endAngle) * this.radius, l = s > r ? "1" : "0"; e.push('<path d="M ' + o + " " + a, " A " + this.radius + " " + this.radius, " 0 ", +l + " 1", " " + h + " " + c, '" style="', this.getSvgStyles(), '" transform="', this.getSvgTransform(), " ", this.getSvgTransformMatrix(), '"/>\n') } return t ? t(e.join("")) : e.join("") }, _render: function (t, e) { t.beginPath(), t.arc(e ? this.left + this.radius : 0, e ? this.top + this.radius : 0, this.radius, this.startAngle, this.endAngle, !1), this._renderFill(t), this._renderStroke(t) }, getRadiusX: function () { return this.get("radius") * this.get("scaleX") }, getRadiusY: function () { return this.get("radius") * this.get("scaleY") }, setRadius: function (t) { return this.radius = t, this.set("width", 2 * t).set("height", 2 * t) } }), i.Circle.ATTRIBUTE_NAMES = i.SHARED_ATTRIBUTES.concat("cx cy r".split(" ")), i.Circle.fromElement = function (t, r) { r || (r = {}); var s = i.parseAttributes(t, i.Circle.ATTRIBUTE_NAMES); if (!e(s)) throw new Error("value of `r` attribute is required and can not be negative"); s.left = s.left || 0, s.top = s.top || 0; var o = new i.Circle(n(s, r)); return o.left -= o.radius, o.top -= o.radius, o }, i.Circle.fromObject = function (t, e, r) { return i.Object._fromObject("Circle", t, e, r) } } }("undefined" != typeof exports ? exports : this), function (t) { "use strict"; var e = t.fabric || (t.fabric = {}); e.Triangle ? e.warn("fabric.Triangle is already defined") : (e.Triangle = e.util.createClass(e.Object, { type: "triangle", initialize: function (t) { this.callSuper("initialize", t), this.set("width", t && t.width || 100).set("height", t && t.height || 100) }, _render: function (t) { var e = this.width / 2, i = this.height / 2; t.beginPath(), t.moveTo(-e, i), t.lineTo(0, -i), t.lineTo(e, i), t.closePath(), this._renderFill(t), this._renderStroke(t) }, _renderDashedStroke: function (t) { var i = this.width / 2, r = this.height / 2; t.beginPath(), e.util.drawDashedLine(t, -i, r, 0, -r, this.strokeDashArray), e.util.drawDashedLine(t, 0, -r, i, r, this.strokeDashArray), e.util.drawDashedLine(t, i, r, -i, r, this.strokeDashArray), t.closePath() }, toSVG: function (t) { var e = this._createBaseSVGMarkup(), i = this.width / 2, r = this.height / 2, n = [-i + " " + r, "0 " + -r, i + " " + r].join(","); return e.push("<polygon ", this.getSvgId(), 'points="', n, '" style="', this.getSvgStyles(), '" transform="', this.getSvgTransform(), '"/>'), t ? t(e.join("")) : e.join("") } }), e.Triangle.fromObject = function (t, i, r) { return e.Object._fromObject("Triangle", t, i, r) }) }("undefined" != typeof exports ? exports : this), function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = 2 * Math.PI, r = e.util.object.extend; if (e.Ellipse) e.warn("fabric.Ellipse is already defined."); else { var n = e.Object.prototype.cacheProperties.concat(); n.push("rx", "ry"), e.Ellipse = e.util.createClass(e.Object, { type: "ellipse", rx: 0, ry: 0, cacheProperties: n, initialize: function (t) { this.callSuper("initialize", t), this.set("rx", t && t.rx || 0), this.set("ry", t && t.ry || 0) }, _set: function (t, e) { switch (this.callSuper("_set", t, e), t) { case "rx": this.rx = e, this.set("width", 2 * e); break; case "ry": this.ry = e, this.set("height", 2 * e) }return this }, getRx: function () { return this.get("rx") * this.get("scaleX") }, getRy: function () { return this.get("ry") * this.get("scaleY") }, toObject: function (t) { return this.callSuper("toObject", ["rx", "ry"].concat(t)) }, toSVG: function (t) { var e = this._createBaseSVGMarkup(), i = 0, r = 0; return this.group && "path-group" === this.group.type && (i = this.left + this.rx, r = this.top + this.ry), e.push("<ellipse ", this.getSvgId(), 'cx="', i, '" cy="', r, '" ', 'rx="', this.rx, '" ry="', this.ry, '" style="', this.getSvgStyles(), '" transform="', this.getSvgTransform(), this.getSvgTransformMatrix(), '"/>\n'), t ? t(e.join("")) : e.join("") }, _render: function (t, e) { t.beginPath(), t.save(), t.transform(1, 0, 0, this.ry / this.rx, 0, 0), t.arc(e ? this.left + this.rx : 0, e ? (this.top + this.ry) * this.rx / this.ry : 0, this.rx, 0, i, !1), t.restore(), this._renderFill(t), this._renderStroke(t) } }), e.Ellipse.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat("cx cy rx ry".split(" ")), e.Ellipse.fromElement = function (t, i) { i || (i = {}); var n = e.parseAttributes(t, e.Ellipse.ATTRIBUTE_NAMES); n.left = n.left || 0, n.top = n.top || 0; var s = new e.Ellipse(r(n, i)); return s.top -= s.ry, s.left -= s.rx, s }, e.Ellipse.fromObject = function (t, i, r) { return e.Object._fromObject("Ellipse", t, i, r) } } }("undefined" != typeof exports ? exports : this), function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.object.extend; if (e.Rect) e.warn("fabric.Rect is already defined"); else { var r = e.Object.prototype.stateProperties.concat(); r.push("rx", "ry"); var n = e.Object.prototype.cacheProperties.concat(); n.push("rx", "ry"), e.Rect = e.util.createClass(e.Object, { stateProperties: r, type: "rect", rx: 0, ry: 0, cacheProperties: n, initialize: function (t) { this.callSuper("initialize", t), this._initRxRy() }, _initRxRy: function () { this.rx && !this.ry ? this.ry = this.rx : this.ry && !this.rx && (this.rx = this.ry) }, _render: function (t, e) { if (1 !== this.width || 1 !== this.height) { var i = this.rx ? Math.min(this.rx, this.width / 2) : 0, r = this.ry ? Math.min(this.ry, this.height / 2) : 0, n = this.width, s = this.height, o = e ? this.left : -this.width / 2, a = e ? this.top : -this.height / 2, h = 0 !== i || 0 !== r, c = .4477152502; t.beginPath(), t.moveTo(o + i, a), t.lineTo(o + n - i, a), h && t.bezierCurveTo(o + n - c * i, a, o + n, a + c * r, o + n, a + r), t.lineTo(o + n, a + s - r), h && t.bezierCurveTo(o + n, a + s - c * r, o + n - c * i, a + s, o + n - i, a + s), t.lineTo(o + i, a + s), h && t.bezierCurveTo(o + c * i, a + s, o, a + s - c * r, o, a + s - r), t.lineTo(o, a + r), h && t.bezierCurveTo(o, a + c * r, o + c * i, a, o + i, a), t.closePath(), this._renderFill(t), this._renderStroke(t) } else t.fillRect(-.5, -.5, 1, 1) }, _renderDashedStroke: function (t) { var i = -this.width / 2, r = -this.height / 2, n = this.width, s = this.height; t.beginPath(), e.util.drawDashedLine(t, i, r, i + n, r, this.strokeDashArray), e.util.drawDashedLine(t, i + n, r, i + n, r + s, this.strokeDashArray), e.util.drawDashedLine(t, i + n, r + s, i, r + s, this.strokeDashArray), e.util.drawDashedLine(t, i, r + s, i, r, this.strokeDashArray), t.closePath() }, toObject: function (t) { return this.callSuper("toObject", ["rx", "ry"].concat(t)) }, toSVG: function (t) { var e = this._createBaseSVGMarkup(), i = this.left, r = this.top; return this.group && "path-group" === this.group.type || (i = -this.width / 2, r = -this.height / 2), e.push("<rect ", this.getSvgId(), 'x="', i, '" y="', r, '" rx="', this.get("rx"), '" ry="', this.get("ry"), '" width="', this.width, '" height="', this.height, '" style="', this.getSvgStyles(), '" transform="', this.getSvgTransform(), this.getSvgTransformMatrix(), '"/>\n'), t ? t(e.join("")) : e.join("") } }), e.Rect.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat("x y rx ry width height".split(" ")), e.Rect.fromElement = function (t, r) { if (!t) return null; r = r || {}; var n = e.parseAttributes(t, e.Rect.ATTRIBUTE_NAMES); n.left = n.left || 0, n.top = n.top || 0; var s = new e.Rect(i(r ? e.util.object.clone(r) : {}, n)); return s.visible = s.visible && s.width > 0 && s.height > 0, s }, e.Rect.fromObject = function (t, i, r) { return e.Object._fromObject("Rect", t, i, r) } } }("undefined" != typeof exports ? exports : this), function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.object.extend, r = e.util.array.min, n = e.util.array.max, s = e.util.toFixed, o = e.Object.NUM_FRACTION_DIGITS; if (e.Polyline) e.warn("fabric.Polyline is already defined"); else { var a = e.Object.prototype.cacheProperties.concat(); a.push("points"), e.Polyline = e.util.createClass(e.Object, { type: "polyline", points: null, minX: 0, minY: 0, cacheProperties: a, initialize: function (t, e) { e = e || {}, this.points = t || [], this.callSuper("initialize", e), this._calcDimensions(), "top" in e || (this.top = this.minY), "left" in e || (this.left = this.minX), this.pathOffset = { x: this.minX + this.width / 2, y: this.minY + this.height / 2 } }, _calcDimensions: function () { var t = this.points, e = r(t, "x"), i = r(t, "y"), s = n(t, "x"), o = n(t, "y"); this.width = s - e || 0, this.height = o - i || 0, this.minX = e || 0, this.minY = i || 0 }, toObject: function (t) { return i(this.callSuper("toObject", t), { points: this.points.concat() }) }, toSVG: function (t) { var e = [], i = 0, r = 0, n = this._createBaseSVGMarkup(); this.group && "path-group" === this.group.type || (i = this.pathOffset.x, r = this.pathOffset.y); for (var a = 0, h = this.points.length; a < h; a++)e.push(s(this.points[a].x - i, o), ",", s(this.points[a].y - r, o), " "); return n.push("<", this.type, " ", this.getSvgId(), 'points="', e.join(""), '" style="', this.getSvgStyles(), '" transform="', this.getSvgTransform(), " ", this.getSvgTransformMatrix(), '"/>\n'), t ? t(n.join("")) : n.join("") }, commonRender: function (t, e) { var i, r = this.points.length, n = e ? 0 : this.pathOffset.x, s = e ? 0 : this.pathOffset.y; if (!r || isNaN(this.points[r - 1].y)) return !1; t.beginPath(), t.moveTo(this.points[0].x - n, this.points[0].y - s); for (var o = 0; o < r; o++)i = this.points[o], t.lineTo(i.x - n, i.y - s); return !0 }, _render: function (t, e) { this.commonRender(t, e) && (this._renderFill(t), this._renderStroke(t)) }, _renderDashedStroke: function (t) { var i, r; t.beginPath(); for (var n = 0, s = this.points.length; n < s; n++)i = this.points[n], r = this.points[n + 1] || i, e.util.drawDashedLine(t, i.x, i.y, r.x, r.y, this.strokeDashArray) }, complexity: function () { return this.get("points").length } }), e.Polyline.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat(), e.Polyline.fromElement = function (t, i) { if (!t) return null; i || (i = {}); var r = e.parsePointsAttribute(t.getAttribute("points")), n = e.parseAttributes(t, e.Polyline.ATTRIBUTE_NAMES); return new e.Polyline(r, e.util.object.extend(n, i)) }, e.Polyline.fromObject = function (t, i, r) { return e.Object._fromObject("Polyline", t, i, r, "points") } } }("undefined" != typeof exports ? exports : this), function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.object.extend; e.Polygon ? e.warn("fabric.Polygon is already defined") : (e.Polygon = e.util.createClass(e.Polyline, { type: "polygon", _render: function (t, e) { this.commonRender(t, e) && (t.closePath(), this._renderFill(t), this._renderStroke(t)) }, _renderDashedStroke: function (t) { this.callSuper("_renderDashedStroke", t), t.closePath() } }), e.Polygon.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat(), e.Polygon.fromElement = function (t, r) { if (!t) return null; r || (r = {}); var n = e.parsePointsAttribute(t.getAttribute("points")), s = e.parseAttributes(t, e.Polygon.ATTRIBUTE_NAMES); return new e.Polygon(n, i(s, r)) }, e.Polygon.fromObject = function (t, i, r) { return e.Object._fromObject("Polygon", t, i, r, "points") }) }("undefined" != typeof exports ? exports : this), function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.array.min, r = e.util.array.max, n = e.util.object.extend, s = Object.prototype.toString, o = e.util.drawArc, a = { m: 2, l: 2, h: 1, v: 1, c: 6, s: 4, q: 4, t: 2, a: 7 }, h = { m: "l", M: "L" }; if (e.Path) e.warn("fabric.Path is already defined"); else { var c = e.Object.prototype.stateProperties.concat(); c.push("path"); var l = e.Object.prototype.cacheProperties.concat(); l.push("path", "fillRule"), e.Path = e.util.createClass(e.Object, { type: "path", path: null, minX: 0, minY: 0, cacheProperties: l, stateProperties: c, initialize: function (t, e) { e = e || {}, this.callSuper("initialize", e), t || (t = []); var i = "[object Array]" === s.call(t); this.path = i ? t : t.match && t.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi), this.path && (i || (this.path = this._parsePath()), this._setPositionDimensions(e)) }, _setPositionDimensions: function (t) { var e = this._parseDimensions(); this.minX = e.left, this.minY = e.top, this.width = e.width, this.height = e.height, void 0 === t.left && (this.left = e.left + ("center" === this.originX ? this.width / 2 : "right" === this.originX ? this.width : 0)), void 0 === t.top && (this.top = e.top + ("center" === this.originY ? this.height / 2 : "bottom" === this.originY ? this.height : 0)), this.pathOffset = this.pathOffset || { x: this.minX + this.width / 2, y: this.minY + this.height / 2 } }, _renderPathCommands: function (t) { var e, i, r, n = null, s = 0, a = 0, h = 0, c = 0, l = 0, u = 0, f = -this.pathOffset.x, d = -this.pathOffset.y; this.group && "path-group" === this.group.type && (f = 0, d = 0), t.beginPath(); for (var g = 0, p = this.path.length; g < p; ++g) { switch ((e = this.path[g])[0]) { case "l": h += e[1], c += e[2], t.lineTo(h + f, c + d); break; case "L": h = e[1], c = e[2], t.lineTo(h + f, c + d); break; case "h": h += e[1], t.lineTo(h + f, c + d); break; case "H": h = e[1], t.lineTo(h + f, c + d); break; case "v": c += e[1], t.lineTo(h + f, c + d); break; case "V": c = e[1], t.lineTo(h + f, c + d); break; case "m": s = h += e[1], a = c += e[2], t.moveTo(h + f, c + d); break; case "M": s = h = e[1], a = c = e[2], t.moveTo(h + f, c + d); break; case "c": i = h + e[5], r = c + e[6], l = h + e[3], u = c + e[4], t.bezierCurveTo(h + e[1] + f, c + e[2] + d, l + f, u + d, i + f, r + d), h = i, c = r; break; case "C": h = e[5], c = e[6], l = e[3], u = e[4], t.bezierCurveTo(e[1] + f, e[2] + d, l + f, u + d, h + f, c + d); break; case "s": i = h + e[3], r = c + e[4], null === n[0].match(/[CcSs]/) ? (l = h, u = c) : (l = 2 * h - l, u = 2 * c - u), t.bezierCurveTo(l + f, u + d, h + e[1] + f, c + e[2] + d, i + f, r + d), l = h + e[1], u = c + e[2], h = i, c = r; break; case "S": i = e[3], r = e[4], null === n[0].match(/[CcSs]/) ? (l = h, u = c) : (l = 2 * h - l, u = 2 * c - u), t.bezierCurveTo(l + f, u + d, e[1] + f, e[2] + d, i + f, r + d), h = i, c = r, l = e[1], u = e[2]; break; case "q": i = h + e[3], r = c + e[4], l = h + e[1], u = c + e[2], t.quadraticCurveTo(l + f, u + d, i + f, r + d), h = i, c = r; break; case "Q": i = e[3], r = e[4], t.quadraticCurveTo(e[1] + f, e[2] + d, i + f, r + d), h = i, c = r, l = e[1], u = e[2]; break; case "t": i = h + e[1], r = c + e[2], null === n[0].match(/[QqTt]/) ? (l = h, u = c) : (l = 2 * h - l, u = 2 * c - u), t.quadraticCurveTo(l + f, u + d, i + f, r + d), h = i, c = r; break; case "T": i = e[1], r = e[2], null === n[0].match(/[QqTt]/) ? (l = h, u = c) : (l = 2 * h - l, u = 2 * c - u), t.quadraticCurveTo(l + f, u + d, i + f, r + d), h = i, c = r; break; case "a": o(t, h + f, c + d, [e[1], e[2], e[3], e[4], e[5], e[6] + h + f, e[7] + c + d]), h += e[6], c += e[7]; break; case "A": o(t, h + f, c + d, [e[1], e[2], e[3], e[4], e[5], e[6] + f, e[7] + d]), h = e[6], c = e[7]; break; case "z": case "Z": h = s, c = a, t.closePath() }n = e } }, _render: function (t) { this._renderPathCommands(t), this._renderFill(t), this._renderStroke(t) }, toString: function () { return "#<fabric.Path (" + this.complexity() + '): { "top": ' + this.top + ', "left": ' + this.left + " }>" }, toObject: function (t) { return n(this.callSuper("toObject", ["sourcePath", "pathOffset"].concat(t)), { path: this.path.map(function (t) { return t.slice() }), top: this.top, left: this.left }) }, toDatalessObject: function (t) { var e = this.toObject(t); return this.sourcePath && (e.path = this.sourcePath), delete e.sourcePath, e }, toSVG: function (t) { for (var e = [], i = this._createBaseSVGMarkup(), r = "", n = 0, s = this.path.length; n < s; n++)e.push(this.path[n].join(" ")); var o = e.join(" "); return this.group && "path-group" === this.group.type || (r = " translate(" + -this.pathOffset.x + ", " + -this.pathOffset.y + ") "), i.push("<path ", this.getSvgId(), 'd="', o, '" style="', this.getSvgStyles(), '" transform="', this.getSvgTransform(), r, this.getSvgTransformMatrix(), '" stroke-linecap="round" ', "/>\n"), t ? t(i.join("")) : i.join("") }, complexity: function () { return this.path.length }, _parsePath: function () { for (var t, e, i, r, n, s = [], o = [], c = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/gi, l = 0, u = this.path.length; l < u; l++) { for (r = (t = this.path[l]).slice(1).trim(), o.length = 0; i = c.exec(r);)o.push(i[0]); n = [t.charAt(0)]; for (var f = 0, d = o.length; f < d; f++)e = parseFloat(o[f]), isNaN(e) || n.push(e); var g = n[0], p = a[g.toLowerCase()], v = h[g] || g; if (n.length - 1 > p) for (var b = 1, m = n.length; b < m; b += p)s.push([g].concat(n.slice(b, b + p))), g = v; else s.push(n) } return s }, _parseDimensions: function () { for (var t, n, s, o, a = [], h = [], c = null, l = 0, u = 0, f = 0, d = 0, g = 0, p = 0, v = 0, b = this.path.length; v < b; ++v) { switch ((t = this.path[v])[0]) { case "l": f += t[1], d += t[2], o = []; break; case "L": f = t[1], d = t[2], o = []; break; case "h": f += t[1], o = []; break; case "H": f = t[1], o = []; break; case "v": d += t[1], o = []; break; case "V": d = t[1], o = []; break; case "m": l = f += t[1], u = d += t[2], o = []; break; case "M": l = f = t[1], u = d = t[2], o = []; break; case "c": n = f + t[5], s = d + t[6], g = f + t[3], p = d + t[4], o = e.util.getBoundsOfCurve(f, d, f + t[1], d + t[2], g, p, n, s), f = n, d = s; break; case "C": g = t[3], p = t[4], o = e.util.getBoundsOfCurve(f, d, t[1], t[2], g, p, t[5], t[6]), f = t[5], d = t[6]; break; case "s": n = f + t[3], s = d + t[4], null === c[0].match(/[CcSs]/) ? (g = f, p = d) : (g = 2 * f - g, p = 2 * d - p), o = e.util.getBoundsOfCurve(f, d, g, p, f + t[1], d + t[2], n, s), g = f + t[1], p = d + t[2], f = n, d = s; break; case "S": n = t[3], s = t[4], null === c[0].match(/[CcSs]/) ? (g = f, p = d) : (g = 2 * f - g, p = 2 * d - p), o = e.util.getBoundsOfCurve(f, d, g, p, t[1], t[2], n, s), f = n, d = s, g = t[1], p = t[2]; break; case "q": n = f + t[3], s = d + t[4], g = f + t[1], p = d + t[2], o = e.util.getBoundsOfCurve(f, d, g, p, g, p, n, s), f = n, d = s; break; case "Q": g = t[1], p = t[2], o = e.util.getBoundsOfCurve(f, d, g, p, g, p, t[3], t[4]), f = t[3], d = t[4]; break; case "t": n = f + t[1], s = d + t[2], null === c[0].match(/[QqTt]/) ? (g = f, p = d) : (g = 2 * f - g, p = 2 * d - p), o = e.util.getBoundsOfCurve(f, d, g, p, g, p, n, s), f = n, d = s; break; case "T": n = t[1], s = t[2], null === c[0].match(/[QqTt]/) ? (g = f, p = d) : (g = 2 * f - g, p = 2 * d - p), o = e.util.getBoundsOfCurve(f, d, g, p, g, p, n, s), f = n, d = s; break; case "a": o = e.util.getBoundsOfArc(f, d, t[1], t[2], t[3], t[4], t[5], t[6] + f, t[7] + d), f += t[6], d += t[7]; break; case "A": o = e.util.getBoundsOfArc(f, d, t[1], t[2], t[3], t[4], t[5], t[6], t[7]), f = t[6], d = t[7]; break; case "z": case "Z": f = l, d = u }c = t, o.forEach(function (t) { a.push(t.x), h.push(t.y) }), a.push(f), h.push(d) } var m = i(a) || 0, _ = i(h) || 0; return { left: m, top: _, width: (r(a) || 0) - m, height: (r(h) || 0) - _ } } }), e.Path.fromObject = function (t, i, r) { var n; if ("string" != typeof t.path) return e.Object._fromObject("Path", t, i, r, "path"); e.loadSVGFromURL(t.path, function (e) { var r = t.path; n = e[0], delete t.path, n.setOptions(t), n.setSourcePath(r), i && i(n) }) }, e.Path.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat(["d"]), e.Path.fromElement = function (t, i, r) { var s = e.parseAttributes(t, e.Path.ATTRIBUTE_NAMES); i && i(new e.Path(s.d, n(s, r))) }, e.Path.async = !0 } }("undefined" != typeof exports ? exports : this), function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.object.extend; e.PathGroup ? e.warn("fabric.PathGroup is already defined") : (e.PathGroup = e.util.createClass(e.Object, { type: "path-group", fill: "", cacheProperties: [], initialize: function (t, e) { e = e || {}, this.paths = t || []; for (var i = this.paths.length; i--;)this.paths[i].group = this; e.toBeParsed && (this.parseDimensionsFromPaths(e), delete e.toBeParsed), this.setOptions(e), this.setCoords() }, parseDimensionsFromPaths: function (t) { for (var i, r, n, s, o, a, h = [], c = [], l = this.paths.length; l--;) { s = (n = this.paths[l]).height + n.strokeWidth, o = n.width + n.strokeWidth, i = [{ x: n.left, y: n.top }, { x: n.left + o, y: n.top }, { x: n.left, y: n.top + s }, { x: n.left + o, y: n.top + s }], a = this.paths[l].transformMatrix; for (var u = 0; u < i.length; u++)r = i[u], a && (r = e.util.transformPoint(r, a, !1)), h.push(r.x), c.push(r.y) } t.width = Math.max.apply(null, h), t.height = Math.max.apply(null, c) }, drawObject: function (t) { t.save(), t.translate(-this.width / 2, -this.height / 2); for (var e = 0, i = this.paths.length; e < i; ++e)this.paths[e].render(t, !0); t.restore() }, shouldCache: function () { var t = this.objectCaching && (!this.group || this.needsItsOwnCache() || !this.group.isCaching()); if (this.caching = t, t) for (var e = 0, i = this.paths.length; e < i; e++)if (this.paths[e].willDrawShadow()) return this.caching = !1, !1; return t }, willDrawShadow: function () { if (this.shadow) return !0; for (var t = 0, e = this.paths.length; t < e; t++)if (this.paths[t].willDrawShadow()) return !0; return !1 }, isCaching: function () { return this.caching || this.group && this.group.isCaching() }, isCacheDirty: function () { if (this.callSuper("isCacheDirty")) return !0; if (!this.statefullCache) return !1; for (var t = 0, e = this.paths.length; t < e; t++)if (this.paths[t].isCacheDirty(!0)) { if (this._cacheCanvas) { var i = this.cacheWidth / this.zoomX, r = this.cacheHeight / this.zoomY; this._cacheContext.clearRect(-i / 2, -r / 2, i, r) } return !0 } return !1 }, _set: function (t, e) { if ("fill" === t && e && this.isSameColor()) for (var i = this.paths.length; i--;)this.paths[i]._set(t, e); return this.callSuper("_set", t, e) }, toObject: function (t) { var e = this.paths.map(function (e) { var i = e.includeDefaultValues; e.includeDefaultValues = e.group.includeDefaultValues; var r = e.toObject(t); return e.includeDefaultValues = i, r }); return i(this.callSuper("toObject", ["sourcePath"].concat(t)), { paths: e }) }, toDatalessObject: function (t) { var e = this.toObject(t); return this.sourcePath && (e.paths = this.sourcePath), e }, toSVG: function (t) { var e = this.getObjects(), i = this.getPointByOrigin("left", "top"), r = "translate(" + i.x + " " + i.y + ")", n = this._createBaseSVGMarkup(); n.push("<g ", this.getSvgId(), 'style="', this.getSvgStyles(), '" ', 'transform="', this.getSvgTransformMatrix(), r, this.getSvgTransform(), '" ', ">\n"); for (var s = 0, o = e.length; s < o; s++)n.push("\t", e[s].toSVG(t)); return n.push("</g>\n"), t ? t(n.join("")) : n.join("") }, toString: function () { return "#<fabric.PathGroup (" + this.complexity() + "): { top: " + this.top + ", left: " + this.left + " }>" }, isSameColor: function () { var t = this.getObjects()[0].get("fill") || ""; return "string" == typeof t && (t = t.toLowerCase(), this.getObjects().every(function (e) { var i = e.get("fill") || ""; return "string" == typeof i && i.toLowerCase() === t })) }, complexity: function () { return this.paths.reduce(function (t, e) { return t + (e && e.complexity ? e.complexity() : 0) }, 0) }, getObjects: function () { return this.paths } }), e.PathGroup.fromObject = function (t, i) { var r = t.paths; delete t.paths, "string" == typeof r ? e.loadSVGFromURL(r, function (n) { var s = r, o = e.util.groupSVGElements(n, t, s); t.paths = r, i(o) }) : e.util.enlivenObjects(r, function (n) { var s = new e.PathGroup(n, t); t.paths = r, i(s) }) }, e.PathGroup.async = !0) }("undefined" != typeof exports ? exports : this), function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.object.extend, r = e.util.array.min, n = e.util.array.max; if (!e.Group) { var s = { lockMovementX: !0, lockMovementY: !0, lockRotation: !0, lockScalingX: !0, lockScalingY: !0, lockUniScaling: !0 }; e.Group = e.util.createClass(e.Object, e.Collection, { type: "group", strokeWidth: 0, subTargetCheck: !1, cacheProperties: [], initialize: function (t, e, i) { e = e || {}, this._objects = [], i && this.callSuper("initialize", e), this._objects = t || []; for (var r = this._objects.length; r--;)this._objects[r].group = this; e.originX && (this.originX = e.originX), e.originY && (this.originY = e.originY), i ? (this._updateObjectsCoords(!0), this._updateObjectsACoords()) : (this._calcBounds(), this._updateObjectsCoords(), this.callSuper("initialize", e)), this.setCoords(), this.saveCoords() }, _updateObjectsACoords: function () { for (var t = this._objects.length; t--;)this._objects[t].setCoords(!0, !0) }, _updateObjectsCoords: function (t) { for (var e = this.getCenterPoint(), i = this._objects.length; i--;)this._updateObjectCoords(this._objects[i], e, t) }, _updateObjectCoords: function (t, e, i) { if (t.__origHasControls = t.hasControls, t.hasControls = !1, !i) { var r = t.getLeft(), n = t.getTop(); t.set({ left: r - e.x, top: n - e.y }), t.setCoords(!0, !0) } }, toString: function () { return "#<fabric.Group: (" + this.complexity() + ")>" }, addWithUpdate: function (t) { return this._restoreObjectsState(), e.util.resetObjectTransform(this), t && (this._objects.push(t), t.group = this, t._set("canvas", this.canvas)), this.forEachObject(this._setObjectActive, this), this._calcBounds(), this._updateObjectsCoords(), this.setCoords(), this.dirty = !0, this }, _setObjectActive: function (t) { t.set("active", !0), t.group = this }, removeWithUpdate: function (t) { return this._restoreObjectsState(), e.util.resetObjectTransform(this), this.forEachObject(this._setObjectActive, this), this.remove(t), this._calcBounds(), this._updateObjectsCoords(), this.setCoords(), this.dirty = !0, this }, _onObjectAdded: function (t) { this.dirty = !0, t.group = this, t._set("canvas", this.canvas) }, _onObjectRemoved: function (t) { this.dirty = !0, delete t.group, t.set("active", !1) }, delegatedProperties: { fill: !0, stroke: !0, strokeWidth: !0, fontFamily: !0, fontWeight: !0, fontSize: !0, fontStyle: !0, lineHeight: !0, textDecoration: !0, textAlign: !0, backgroundColor: !0 }, _set: function (t, e) { var i = this._objects.length; if (this.delegatedProperties[t] || "canvas" === t) for (; i--;)this._objects[i].set(t, e); else for (; i--;)this._objects[i].setOnGroup(t, e); this.callSuper("_set", t, e) }, toObject: function (t) { var e = this.getObjects().map(function (e) { var i = e.includeDefaultValues; e.includeDefaultValues = e.group.includeDefaultValues; var r = e.toObject(t); return e.includeDefaultValues = i, r }); return i(this.callSuper("toObject", t), { objects: e }) }, toDatalessObject: function (t) { var e = this.getObjects().map(function (e) { var i = e.includeDefaultValues; e.includeDefaultValues = e.group.includeDefaultValues; var r = e.toDatalessObject(t); return e.includeDefaultValues = i, r }); return i(this.callSuper("toDatalessObject", t), { objects: e }) }, render: function (t) { this._transformDone = !0, this.callSuper("render", t), this._transformDone = !1 }, shouldCache: function () { var t = this.objectCaching && (!this.group || this.needsItsOwnCache() || !this.group.isCaching()); if (this.caching = t, t) for (var e = 0, i = this._objects.length; e < i; e++)if (this._objects[e].willDrawShadow()) return this.caching = !1, !1; return t }, willDrawShadow: function () { if (this.callSuper("willDrawShadow")) return !0; for (var t = 0, e = this._objects.length; t < e; t++)if (this._objects[t].willDrawShadow()) return !0; return !1 }, isCaching: function () { return this.caching || this.group && this.group.isCaching() }, drawObject: function (t) { for (var e = 0, i = this._objects.length; e < i; e++)this._renderObject(this._objects[e], t) }, isCacheDirty: function () { if (this.callSuper("isCacheDirty")) return !0; if (!this.statefullCache) return !1; for (var t = 0, e = this._objects.length; t < e; t++)if (this._objects[t].isCacheDirty(!0)) { if (this._cacheCanvas) { var i = this.cacheWidth / this.zoomX, r = this.cacheHeight / this.zoomY; this._cacheContext.clearRect(-i / 2, -r / 2, i, r) } return !0 } return !1 }, _renderControls: function (t, e) { t.save(), t.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1, this.callSuper("_renderControls", t, e); for (var i = 0, r = this._objects.length; i < r; i++)this._objects[i]._renderControls(t); t.restore() }, _renderObject: function (t, e) { if (t.visible) { var i = t.hasRotatingPoint; t.hasRotatingPoint = !1, t.render(e), t.hasRotatingPoint = i } }, _restoreObjectsState: function () { return this._objects.forEach(this._restoreObjectState, this), this }, realizeTransform: function (t) { var i = t.calcTransformMatrix(), r = e.util.qrDecompose(i), n = new e.Point(r.translateX, r.translateY); return t.flipX = !1, t.flipY = !1, t.set("scaleX", r.scaleX), t.set("scaleY", r.scaleY), t.skewX = r.skewX, t.skewY = r.skewY, t.angle = r.angle, t.setPositionByOrigin(n, "center", "center"), t }, _restoreObjectState: function (t) { return this.realizeTransform(t), t.setCoords(), t.hasControls = t.__origHasControls, delete t.__origHasControls, t.set("active", !1), delete t.group, this }, destroy: function () { return this._objects.forEach(function (t) { t.set("dirty", !0) }), this._restoreObjectsState() }, saveCoords: function () { return this._originalLeft = this.get("left"), this._originalTop = this.get("top"), this }, hasMoved: function () { return this._originalLeft !== this.get("left") || this._originalTop !== this.get("top") }, setObjectsCoords: function () { return this.forEachObject(function (t) { t.setCoords(!0, !0) }), this }, _calcBounds: function (t) { for (var e, i, r, n = [], s = [], o = ["tr", "br", "bl", "tl"], a = 0, h = this._objects.length, c = o.length; a < h; ++a)for ((e = this._objects[a]).setCoords(!0), r = 0; r < c; r++)i = o[r], n.push(e.oCoords[i].x), s.push(e.oCoords[i].y); this.set(this._getBounds(n, s, t)) }, _getBounds: function (t, i, s) { var o = new e.Point(r(t), r(i)), a = new e.Point(n(t), n(i)), h = { width: a.x - o.x || 0, height: a.y - o.y || 0 }; return s || (h.left = o.x || 0, h.top = o.y || 0, "center" === this.originX && (h.left += h.width / 2), "right" === this.originX && (h.left += h.width), "center" === this.originY && (h.top += h.height / 2), "bottom" === this.originY && (h.top += h.height)), h }, toSVG: function (t) { var e = this._createBaseSVGMarkup(); e.push("<g ", this.getSvgId(), 'transform="', this.getSvgTransform(), this.getSvgTransformMatrix(), '" style="', this.getSvgFilter(), '">\n'); for (var i = 0, r = this._objects.length; i < r; i++)e.push("\t", this._objects[i].toSVG(t)); return e.push("</g>\n"), t ? t(e.join("")) : e.join("") }, get: function (t) { if (t in s) { if (this[t]) return this[t]; for (var e = 0, i = this._objects.length; e < i; e++)if (this._objects[e][t]) return !0; return !1 } return t in this.delegatedProperties ? this._objects[0] && this._objects[0].get(t) : this[t] } }), e.Group.fromObject = function (t, i) { e.util.enlivenObjects(t.objects, function (r) { var n = e.util.object.clone(t, !0); delete n.objects, i && i(new e.Group(r, n, !0)) }) }, e.Group.async = !0 } }("undefined" != typeof exports ? exports : this), function (t) { "use strict"; var e = fabric.util.object.extend; if (t.fabric || (t.fabric = {}), t.fabric.Image) fabric.warn("fabric.Image is already defined."); else { var i = fabric.Object.prototype.stateProperties.concat(); i.push("alignX", "alignY", "meetOrSlice"), fabric.Image = fabric.util.createClass(fabric.Object, { type: "image", crossOrigin: "", alignX: "none", alignY: "none", meetOrSlice: "meet", strokeWidth: 0, _lastScaleX: 1, _lastScaleY: 1, minimumScaleTrigger: .5, stateProperties: i, objectCaching: !1, initialize: function (t, e, i) { e || (e = {}), this.filters = [], this.resizeFilters = [], this.callSuper("initialize", e), this._initElement(t, e, i) }, getElement: function () { return this._element }, setElement: function (t, e, i) { var r, n; return this._element = t, this._originalElement = t, this._initConfig(i), 0 === this.resizeFilters.length ? r = e : (n = this, r = function () { n.applyFilters(e, n.resizeFilters, n._filteredEl || n._originalElement, !0) }), 0 !== this.filters.length ? this.applyFilters(r) : r && r(this), this }, setCrossOrigin: function (t) { return this.crossOrigin = t, this._element.crossOrigin = t, this }, getOriginalSize: function () { var t = this.getElement(); return { width: t.width, height: t.height } }, _stroke: function (t) { if (this.stroke && 0 !== this.strokeWidth) { var e = this.width / 2, i = this.height / 2; t.beginPath(), t.moveTo(-e, -i), t.lineTo(e, -i), t.lineTo(e, i), t.lineTo(-e, i), t.lineTo(-e, -i), t.closePath() } }, _renderDashedStroke: function (t) { var e = -this.width / 2, i = -this.height / 2, r = this.width, n = this.height; t.save(), this._setStrokeStyles(t), t.beginPath(), fabric.util.drawDashedLine(t, e, i, e + r, i, this.strokeDashArray), fabric.util.drawDashedLine(t, e + r, i, e + r, i + n, this.strokeDashArray), fabric.util.drawDashedLine(t, e + r, i + n, e, i + n, this.strokeDashArray), fabric.util.drawDashedLine(t, e, i + n, e, i, this.strokeDashArray), t.closePath(), t.restore() }, toObject: function (t) { var i = [], r = [], n = 1, s = 1; this.filters.forEach(function (t) { t && ("Resize" === t.type && (n *= t.scaleX, s *= t.scaleY), i.push(t.toObject())) }), this.resizeFilters.forEach(function (t) { t && r.push(t.toObject()) }); var o = e(this.callSuper("toObject", ["crossOrigin", "alignX", "alignY", "meetOrSlice"].concat(t)), { src: this.getSrc(), filters: i, resizeFilters: r }); return o.width /= n, o.height /= s, o }, toSVG: function (t) { var e = this._createBaseSVGMarkup(), i = -this.width / 2, r = -this.height / 2, n = "none"; if (this.group && "path-group" === this.group.type && (i = this.left, r = this.top), "none" !== this.alignX && "none" !== this.alignY && (n = "x" + this.alignX + "Y" + this.alignY + " " + this.meetOrSlice), e.push('<g transform="', this.getSvgTransform(), this.getSvgTransformMatrix(), '">\n', "<image ", this.getSvgId(), 'xlink:href="', this.getSvgSrc(!0), '" x="', i, '" y="', r, '" style="', this.getSvgStyles(), '" width="', this.width, '" height="', this.height, '" preserveAspectRatio="', n, '"', "></image>\n"), this.stroke || this.strokeDashArray) { var s = this.fill; this.fill = null, e.push("<rect ", 'x="', i, '" y="', r, '" width="', this.width, '" height="', this.height, '" style="', this.getSvgStyles(), '"/>\n'), this.fill = s } return e.push("</g>\n"), t ? t(e.join("")) : e.join("") }, getSrc: function (t) { var e = t ? this._element : this._originalElement; return e ? fabric.isLikelyNode ? e._src : e.src : this.src || "" }, setSrc: function (t, e, i) { fabric.util.loadImage(t, function (t) { return this.setElement(t, e, i) }, this, i && i.crossOrigin) }, toString: function () { return '#<fabric.Image: { src: "' + this.getSrc() + '" }>' }, applyFilters: function (t, e, i, r) { if (e = e || this.filters, i = i || this._originalElement) { var n, s, o = fabric.util.createImage(), a = this.canvas ? this.canvas.getRetinaScaling() : fabric.devicePixelRatio, h = this.minimumScaleTrigger / a, c = this; if (0 === e.length) return this._element = i, t && t(this), i; var l = fabric.util.createCanvasElement(); return l.width = i.width, l.height = i.height, l.getContext("2d").drawImage(i, 0, 0, i.width, i.height), e.forEach(function (t) { t && (r ? (n = c.scaleX < h ? c.scaleX : 1, s = c.scaleY < h ? c.scaleY : 1, n * a < 1 && (n *= a), s * a < 1 && (s *= a)) : (n = t.scaleX, s = t.scaleY), t.applyTo(l, n, s), r || "Resize" !== t.type || (c.width *= t.scaleX, c.height *= t.scaleY)) }), o.width = l.width, o.height = l.height, fabric.isLikelyNode ? (o.src = l.toBuffer(void 0, fabric.Image.pngCompression), c._element = o, !r && (c._filteredEl = o), t && t(c)) : (o.onload = function () { c._element = o, !r && (c._filteredEl = o), t && t(c), o.onload = l = null }, o.src = l.toDataURL("image/png")), l } }, _render: function (t, e) { var i, r, n, s = this._findMargins(); i = e ? this.left : -this.width / 2, r = e ? this.top : -this.height / 2, "slice" === this.meetOrSlice && (t.beginPath(), t.rect(i, r, this.width, this.height), t.clip()), !1 === this.isMoving && this.resizeFilters.length && this._needsResize() ? (this._lastScaleX = this.scaleX, this._lastScaleY = this.scaleY, n = this.applyFilters(null, this.resizeFilters, this._filteredEl || this._originalElement, !0)) : n = this._element, n && t.drawImage(n, i + s.marginX, r + s.marginY, s.width, s.height), this._stroke(t), this._renderStroke(t) }, _needsResize: function () { return this.scaleX !== this._lastScaleX || this.scaleY !== this._lastScaleY }, _findMargins: function () { var t, e, i = this.width, r = this.height, n = 0, s = 0; return "none" === this.alignX && "none" === this.alignY || (t = [this.width / this._element.width, this.height / this._element.height], e = "meet" === this.meetOrSlice ? Math.min.apply(null, t) : Math.max.apply(null, t), i = this._element.width * e, r = this._element.height * e, "Mid" === this.alignX && (n = (this.width - i) / 2), "Max" === this.alignX && (n = this.width - i), "Mid" === this.alignY && (s = (this.height - r) / 2), "Max" === this.alignY && (s = this.height - r)), { width: i, height: r, marginX: n, marginY: s } }, _resetWidthHeight: function () { var t = this.getElement(); this.set("width", t.width), this.set("height", t.height) }, _initElement: function (t, e, i) { this.setElement(fabric.util.getById(t), i, e), fabric.util.addClass(this.getElement(), fabric.Image.CSS_CANVAS) }, _initConfig: function (t) { t || (t = {}), this.setOptions(t), this._setWidthHeight(t), this._element && this.crossOrigin && (this._element.crossOrigin = this.crossOrigin) }, _initFilters: function (t, e) { t && t.length ? fabric.util.enlivenObjects(t, function (t) { e && e(t) }, "fabric.Image.filters") : e && e() }, _setWidthHeight: function (t) { this.width = "width" in t ? t.width : this.getElement() ? this.getElement().width || 0 : 0, this.height = "height" in t ? t.height : this.getElement() ? this.getElement().height || 0 : 0 } }), fabric.Image.CSS_CANVAS = "canvas-img", fabric.Image.prototype.getSvgSrc = fabric.Image.prototype.getSrc, fabric.Image.fromObject = function (t, e) { fabric.util.loadImage(t.src, function (i, r) { r ? e && e(null, r) : fabric.Image.prototype._initFilters.call(t, t.filters, function (r) { t.filters = r || [], fabric.Image.prototype._initFilters.call(t, t.resizeFilters, function (r) { return t.resizeFilters = r || [], new fabric.Image(i, t, e) }) }) }, null, t.crossOrigin) }, fabric.Image.fromURL = function (t, e, i) { fabric.util.loadImage(t, function (t) { e && e(new fabric.Image(t, i)) }, null, i && i.crossOrigin) }, fabric.Image.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat("x y width height preserveAspectRatio xlink:href crossOrigin".split(" ")), fabric.Image.fromElement = function (t, i, r) { var n, s = fabric.parseAttributes(t, fabric.Image.ATTRIBUTE_NAMES); s.preserveAspectRatio && (n = fabric.util.parsePreserveAspectRatioAttribute(s.preserveAspectRatio), e(s, n)), fabric.Image.fromURL(s["xlink:href"], i, e(r ? fabric.util.object.clone(r) : {}, s)) }, fabric.Image.async = !0, fabric.Image.pngCompression = 1 } }("undefined" != typeof exports ? exports : this), fabric.util.object.extend(fabric.Object.prototype, { _getAngleValueForStraighten: function () { var t = this.getAngle() % 360; return t > 0 ? 90 * Math.round((t - 1) / 90) : 90 * Math.round(t / 90) }, straighten: function () { return this.setAngle(this._getAngleValueForStraighten()), this }, fxStraighten: function (t) { var e = function () { }, i = (t = t || {}).onComplete || e, r = t.onChange || e, n = this; return fabric.util.animate({ startValue: this.get("angle"), endValue: this._getAngleValueForStraighten(), duration: this.FX_DURATION, onChange: function (t) { n.setAngle(t), r() }, onComplete: function () { n.setCoords(), i() }, onStart: function () { n.set("active", !1) } }), this } }), fabric.util.object.extend(fabric.StaticCanvas.prototype, { straightenObject: function (t) { return t.straighten(), this.renderAll(), this }, fxStraightenObject: function (t) { return t.fxStraighten({ onChange: this.renderAll.bind(this) }), this } }), fabric.Image.filters = fabric.Image.filters || {}, fabric.Image.filters.BaseFilter = fabric.util.createClass({ type: "BaseFilter", initialize: function (t) { t && this.setOptions(t) }, setOptions: function (t) { for (var e in t) this[e] = t[e] }, toObject: function () { return { type: this.type } }, toJSON: function () { return this.toObject() } }), fabric.Image.filters.BaseFilter.fromObject = function (t, e) { var i = new fabric.Image.filters[t.type](t); return e && e(i), i }, function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.object.extend, r = e.Image.filters, n = e.util.createClass; r.Brightness = n(r.BaseFilter, { type: "Brightness", initialize: function (t) { t = t || {}, this.brightness = t.brightness || 0 }, applyTo: function (t) { for (var e = t.getContext("2d"), i = e.getImageData(0, 0, t.width, t.height), r = i.data, n = this.brightness, s = 0, o = r.length; s < o; s += 4)r[s] += n, r[s + 1] += n, r[s + 2] += n; e.putImageData(i, 0, 0) }, toObject: function () { return i(this.callSuper("toObject"), { brightness: this.brightness }) } }), e.Image.filters.Brightness.fromObject = e.Image.filters.BaseFilter.fromObject }("undefined" != typeof exports ? exports : this), function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.object.extend, r = e.Image.filters, n = e.util.createClass; r.Convolute = n(r.BaseFilter, { type: "Convolute", initialize: function (t) { t = t || {}, this.opaque = t.opaque, this.matrix = t.matrix || [0, 0, 0, 0, 1, 0, 0, 0, 0] }, applyTo: function (t) { for (var e, i, r, n, s, o, a, h, c, l = this.matrix, u = t.getContext("2d"), f = u.getImageData(0, 0, t.width, t.height), d = Math.round(Math.sqrt(l.length)), g = Math.floor(d / 2), p = f.data, v = f.width, b = f.height, m = u.createImageData(v, b), _ = m.data, y = this.opaque ? 1 : 0, x = 0; x < b; x++)for (var C = 0; C < v; C++) { s = 4 * (x * v + C), e = 0, i = 0, r = 0, n = 0; for (var S = 0; S < d; S++)for (var w = 0; w < d; w++)o = C + w - g, (a = x + S - g) < 0 || a > b || o < 0 || o > v || (h = 4 * (a * v + o), c = l[S * d + w], e += p[h] * c, i += p[h + 1] * c, r += p[h + 2] * c, n += p[h + 3] * c); _[s] = e, _[s + 1] = i, _[s + 2] = r, _[s + 3] = n + y * (255 - n) } u.putImageData(m, 0, 0) }, toObject: function () { return i(this.callSuper("toObject"), { opaque: this.opaque, matrix: this.matrix }) } }), e.Image.filters.Convolute.fromObject = e.Image.filters.BaseFilter.fromObject }("undefined" != typeof exports ? exports : this), function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.object.extend, r = e.Image.filters, n = e.util.createClass; r.GradientTransparency = n(r.BaseFilter, { type: "GradientTransparency", initialize: function (t) { t = t || {}, this.threshold = t.threshold || 100 }, applyTo: function (t) { for (var e = t.getContext("2d"), i = e.getImageData(0, 0, t.width, t.height), r = i.data, n = this.threshold, s = r.length, o = 0, a = r.length; o < a; o += 4)r[o + 3] = n + 255 * (s - o) / s; e.putImageData(i, 0, 0) }, toObject: function () { return i(this.callSuper("toObject"), { threshold: this.threshold }) } }), e.Image.filters.GradientTransparency.fromObject = e.Image.filters.BaseFilter.fromObject }("undefined" != typeof exports ? exports : this), function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.Image.filters, r = e.util.createClass; i.Grayscale = r(i.BaseFilter, { type: "Grayscale", applyTo: function (t) { for (var e, i = t.getContext("2d"), r = i.getImageData(0, 0, t.width, t.height), n = r.data, s = r.width * r.height * 4, o = 0; o < s;)e = (n[o] + n[o + 1] + n[o + 2]) / 3, n[o] = e, n[o + 1] = e, n[o + 2] = e, o += 4; i.putImageData(r, 0, 0) } }), e.Image.filters.Grayscale.fromObject = function (t, i) { return t = t || {}, t.type = "Grayscale", e.Image.filters.BaseFilter.fromObject(t, i) } }("undefined" != typeof exports ? exports : this), function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.Image.filters, r = e.util.createClass; i.Invert = r(i.BaseFilter, { type: "Invert", applyTo: function (t) { var e, i = t.getContext("2d"), r = i.getImageData(0, 0, t.width, t.height), n = r.data, s = n.length; for (e = 0; e < s; e += 4)n[e] = 255 - n[e], n[e + 1] = 255 - n[e + 1], n[e + 2] = 255 - n[e + 2]; i.putImageData(r, 0, 0) } }), e.Image.filters.Invert.fromObject = function (t, i) { return t = t || {}, t.type = "Invert", e.Image.filters.BaseFilter.fromObject(t, i) } }("undefined" != typeof exports ? exports : this), function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.object.extend, r = e.Image.filters, n = e.util.createClass; r.Mask = n(r.BaseFilter, { type: "Mask", initialize: function (t) { t = t || {}, this.mask = t.mask, this.channel = [0, 1, 2, 3].indexOf(t.channel) > -1 ? t.channel : 0 }, applyTo: function (t) { if (this.mask) { var i, r = t.getContext("2d"), n = r.getImageData(0, 0, t.width, t.height), s = n.data, o = this.mask.getElement(), a = e.util.createCanvasElement(), h = this.channel, c = n.width * n.height * 4; a.width = t.width, a.height = t.height, a.getContext("2d").drawImage(o, 0, 0, t.width, t.height); var l = a.getContext("2d").getImageData(0, 0, t.width, t.height).data; for (i = 0; i < c; i += 4)s[i + 3] = l[i + h]; r.putImageData(n, 0, 0) } }, toObject: function () { return i(this.callSuper("toObject"), { mask: this.mask.toObject(), channel: this.channel }) } }), e.Image.filters.Mask.fromObject = function (t, i) { e.util.loadImage(t.mask.src, function (r) { return t.mask = new e.Image(r, t.mask), e.Image.filters.BaseFilter.fromObject(t, i) }) }, e.Image.filters.Mask.async = !0 }("undefined" != typeof exports ? exports : this), function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.object.extend, r = e.Image.filters, n = e.util.createClass; r.Noise = n(r.BaseFilter, { type: "Noise", initialize: function (t) { t = t || {}, this.noise = t.noise || 0 }, applyTo: function (t) { for (var e, i = t.getContext("2d"), r = i.getImageData(0, 0, t.width, t.height), n = r.data, s = this.noise, o = 0, a = n.length; o < a; o += 4)e = (.5 - Math.random()) * s, n[o] += e, n[o + 1] += e, n[o + 2] += e; i.putImageData(r, 0, 0) }, toObject: function () { return i(this.callSuper("toObject"), { noise: this.noise }) } }), e.Image.filters.Noise.fromObject = e.Image.filters.BaseFilter.fromObject }("undefined" != typeof exports ? exports : this), function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.object.extend, r = e.Image.filters, n = e.util.createClass; r.Pixelate = n(r.BaseFilter, { type: "Pixelate", initialize: function (t) { t = t || {}, this.blocksize = t.blocksize || 4 }, applyTo: function (t) { var e, i, r, n, s, o, a, h = t.getContext("2d"), c = h.getImageData(0, 0, t.width, t.height), l = c.data, u = c.height, f = c.width; for (i = 0; i < u; i += this.blocksize)for (r = 0; r < f; r += this.blocksize) { n = l[e = 4 * i * f + 4 * r], s = l[e + 1], o = l[e + 2], a = l[e + 3]; for (var d = i, g = i + this.blocksize; d < g; d++)for (var p = r, v = r + this.blocksize; p < v; p++)l[e = 4 * d * f + 4 * p] = n, l[e + 1] = s, l[e + 2] = o, l[e + 3] = a } h.putImageData(c, 0, 0) }, toObject: function () { return i(this.callSuper("toObject"), { blocksize: this.blocksize }) } }), e.Image.filters.Pixelate.fromObject = e.Image.filters.BaseFilter.fromObject }("undefined" != typeof exports ? exports : this), function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.object.extend, r = e.Image.filters, n = e.util.createClass; r.RemoveWhite = n(r.BaseFilter, { type: "RemoveWhite", initialize: function (t) { t = t || {}, this.threshold = t.threshold || 30, this.distance = t.distance || 20 }, applyTo: function (t) { for (var e, i, r, n = t.getContext("2d"), s = n.getImageData(0, 0, t.width, t.height), o = s.data, a = this.threshold, h = this.distance, c = 255 - a, l = Math.abs, u = 0, f = o.length; u < f; u += 4)e = o[u], i = o[u + 1], r = o[u + 2], e > c && i > c && r > c && l(e - i) < h && l(e - r) < h && l(i - r) < h && (o[u + 3] = 0); n.putImageData(s, 0, 0) }, toObject: function () { return i(this.callSuper("toObject"), { threshold: this.threshold, distance: this.distance }) } }), e.Image.filters.RemoveWhite.fromObject = e.Image.filters.BaseFilter.fromObject }("undefined" != typeof exports ? exports : this), function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.Image.filters, r = e.util.createClass; i.Sepia = r(i.BaseFilter, { type: "Sepia", applyTo: function (t) { var e, i, r = t.getContext("2d"), n = r.getImageData(0, 0, t.width, t.height), s = n.data, o = s.length; for (e = 0; e < o; e += 4)i = .3 * s[e] + .59 * s[e + 1] + .11 * s[e + 2], s[e] = i + 100, s[e + 1] = i + 50, s[e + 2] = i + 255; r.putImageData(n, 0, 0) } }), e.Image.filters.Sepia.fromObject = function (t, i) { return t = t || {}, t.type = "Sepia", new e.Image.filters.BaseFilter.fromObject(t, i) } }("undefined" != typeof exports ? exports : this), function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.Image.filters, r = e.util.createClass; i.Sepia2 = r(i.BaseFilter, { type: "Sepia2", applyTo: function (t) { var e, i, r, n, s = t.getContext("2d"), o = s.getImageData(0, 0, t.width, t.height), a = o.data, h = a.length; for (e = 0; e < h; e += 4)i = a[e], r = a[e + 1], n = a[e + 2], a[e] = (.393 * i + .769 * r + .189 * n) / 1.351, a[e + 1] = (.349 * i + .686 * r + .168 * n) / 1.203, a[e + 2] = (.272 * i + .534 * r + .131 * n) / 2.14; s.putImageData(o, 0, 0) } }), e.Image.filters.Sepia2.fromObject = function (t, i) { return t = t || {}, t.type = "Sepia2", new e.Image.filters.BaseFilter.fromObject(t, i) } }("undefined" != typeof exports ? exports : this), function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.object.extend, r = e.Image.filters, n = e.util.createClass; r.Tint = n(r.BaseFilter, { type: "Tint", initialize: function (t) { t = t || {}, this.color = t.color || "#000000", this.opacity = void 0 !== t.opacity ? t.opacity : new e.Color(this.color).getAlpha() }, applyTo: function (t) { var i, r, n, s, o, a, h, c, l, u = t.getContext("2d"), f = u.getImageData(0, 0, t.width, t.height), d = f.data, g = d.length; for (r = (l = new e.Color(this.color).getSource())[0] * this.opacity, n = l[1] * this.opacity, s = l[2] * this.opacity, c = 1 - this.opacity, i = 0; i < g; i += 4)o = d[i], a = d[i + 1], h = d[i + 2], d[i] = r + o * c, d[i + 1] = n + a * c, d[i + 2] = s + h * c; u.putImageData(f, 0, 0) }, toObject: function () { return i(this.callSuper("toObject"), { color: this.color, opacity: this.opacity }) } }), e.Image.filters.Tint.fromObject = e.Image.filters.BaseFilter.fromObject }("undefined" != typeof exports ? exports : this), function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.object.extend, r = e.Image.filters, n = e.util.createClass; r.Multiply = n(r.BaseFilter, { type: "Multiply", initialize: function (t) { t = t || {}, this.color = t.color || "#000000" }, applyTo: function (t) { var i, r, n = t.getContext("2d"), s = n.getImageData(0, 0, t.width, t.height), o = s.data, a = o.length; for (r = new e.Color(this.color).getSource(), i = 0; i < a; i += 4)o[i] *= r[0] / 255, o[i + 1] *= r[1] / 255, o[i + 2] *= r[2] / 255; n.putImageData(s, 0, 0) }, toObject: function () { return i(this.callSuper("toObject"), { color: this.color }) } }), e.Image.filters.Multiply.fromObject = e.Image.filters.BaseFilter.fromObject }("undefined" != typeof exports ? exports : this), function (t) { "use strict"; var e = t.fabric, i = e.Image.filters, r = e.util.createClass; i.Blend = r(i.BaseFilter, { type: "Blend", initialize: function (t) { t = t || {}, this.color = t.color || "#000", this.image = t.image || !1, this.mode = t.mode || "multiply", this.alpha = t.alpha || 1 }, applyTo: function (t) { var i, r, n, s, o, a, h, c, l, u, f = t.getContext("2d"), d = f.getImageData(0, 0, t.width, t.height), g = d.data, p = !1; if (this.image) { p = !0; var v = e.util.createCanvasElement(); v.width = this.image.width, v.height = this.image.height; var b = new e.StaticCanvas(v); b.add(this.image), u = b.getContext("2d").getImageData(0, 0, b.width, b.height).data } else i = (u = new e.Color(this.color).getSource())[0] * this.alpha, r = u[1] * this.alpha, n = u[2] * this.alpha; for (var m = 0, _ = g.length; m < _; m += 4)switch (s = g[m], o = g[m + 1], a = g[m + 2], p && (i = u[m] * this.alpha, r = u[m + 1] * this.alpha, n = u[m + 2] * this.alpha), this.mode) { case "multiply": g[m] = s * i / 255, g[m + 1] = o * r / 255, g[m + 2] = a * n / 255; break; case "screen": g[m] = 1 - (1 - s) * (1 - i), g[m + 1] = 1 - (1 - o) * (1 - r), g[m + 2] = 1 - (1 - a) * (1 - n); break; case "add": g[m] = Math.min(255, s + i), g[m + 1] = Math.min(255, o + r), g[m + 2] = Math.min(255, a + n); break; case "diff": case "difference": g[m] = Math.abs(s - i), g[m + 1] = Math.abs(o - r), g[m + 2] = Math.abs(a - n); break; case "subtract": h = s - i, c = o - r, l = a - n, g[m] = h < 0 ? 0 : h, g[m + 1] = c < 0 ? 0 : c, g[m + 2] = l < 0 ? 0 : l; break; case "darken": g[m] = Math.min(s, i), g[m + 1] = Math.min(o, r), g[m + 2] = Math.min(a, n); break; case "lighten": g[m] = Math.max(s, i), g[m + 1] = Math.max(o, r), g[m + 2] = Math.max(a, n) }f.putImageData(d, 0, 0) }, toObject: function () { return { color: this.color, image: this.image, mode: this.mode, alpha: this.alpha } } }), e.Image.filters.Blend.fromObject = e.Image.filters.BaseFilter.fromObject }("undefined" != typeof exports ? exports : this), function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = Math.pow, r = Math.floor, n = Math.sqrt, s = Math.abs, o = Math.max, a = Math.round, h = Math.sin, c = Math.ceil, l = e.Image.filters, u = e.util.createClass; l.Resize = u(l.BaseFilter, { type: "Resize", resizeType: "hermite", scaleX: 0, scaleY: 0, lanczosLobes: 3, applyTo: function (t, e, i) { if (1 !== e || 1 !== i) { this.rcpScaleX = 1 / e, this.rcpScaleY = 1 / i; var r, n = t.width, s = t.height, o = a(n * e), h = a(s * i); "sliceHack" === this.resizeType && (r = this.sliceByTwo(t, n, s, o, h)), "hermite" === this.resizeType && (r = this.hermiteFastResize(t, n, s, o, h)), "bilinear" === this.resizeType && (r = this.bilinearFiltering(t, n, s, o, h)), "lanczos" === this.resizeType && (r = this.lanczosResize(t, n, s, o, h)), t.width = o, t.height = h, t.getContext("2d").putImageData(r, 0, 0) } }, sliceByTwo: function (t, i, n, s, a) { var h, c = t.getContext("2d"), l = .5, u = .5, f = 1, d = 1, g = !1, p = !1, v = i, b = n, m = e.util.createCanvasElement(), _ = m.getContext("2d"); for (s = r(s), a = r(a), m.width = o(s, i), m.height = o(a, n), s > i && (l = 2, f = -1), a > n && (u = 2, d = -1), h = c.getImageData(0, 0, i, n), t.width = o(s, i), t.height = o(a, n), c.putImageData(h, 0, 0); !g || !p;)i = v, n = b, s * f < r(v * l * f) ? v = r(v * l) : (v = s, g = !0), a * d < r(b * u * d) ? b = r(b * u) : (b = a, p = !0), h = c.getImageData(0, 0, i, n), _.putImageData(h, 0, 0), c.clearRect(0, 0, v, b), c.drawImage(m, 0, 0, i, n, 0, 0, v, b); return c.getImageData(0, 0, s, a) }, lanczosResize: function (t, e, o, a, l) { function u(t) { var h, c, f, d, j, k, M, D, A, P, E; for (O.x = (t + .5) * m, T.x = r(O.x), h = 0; h < l; h++) { for (O.y = (h + .5) * _, T.y = r(O.y), j = 0, k = 0, M = 0, D = 0, A = 0, c = T.x - C; c <= T.x + C; c++)if (!(c < 0 || c >= e)) { P = r(1e3 * s(c - O.x)), w[P] || (w[P] = {}); for (var I = T.y - S; I <= T.y + S; I++)I < 0 || I >= o || (E = r(1e3 * s(I - O.y)), w[P][E] || (w[P][E] = b(n(i(P * y, 2) + i(E * x, 2)) / 1e3)), (f = w[P][E]) > 0 && (j += f, k += f * p[d = 4 * (I * e + c)], M += f * p[d + 1], D += f * p[d + 2], A += f * p[d + 3])) } v[d = 4 * (h * a + t)] = k / j, v[d + 1] = M / j, v[d + 2] = D / j, v[d + 3] = A / j } return ++t < a ? u(t) : g } var f = t.getContext("2d"), d = f.getImageData(0, 0, e, o), g = f.getImageData(0, 0, a, l), p = d.data, v = g.data, b = function (t) { return function (e) { if (e > t) return 0; if (e *= Math.PI, s(e) < 1e-16) return 1; var i = e / t; return h(e) * h(i) / e / i } }(this.lanczosLobes), m = this.rcpScaleX, _ = this.rcpScaleY, y = 2 / this.rcpScaleX, x = 2 / this.rcpScaleY, C = c(m * this.lanczosLobes / 2), S = c(_ * this.lanczosLobes / 2), w = {}, O = {}, T = {}; return u(0) }, bilinearFiltering: function (t, e, i, n, s) { var o, a, h, c, l, u, f, d, g, p = 0, v = this.rcpScaleX, b = this.rcpScaleY, m = t.getContext("2d"), _ = 4 * (e - 1), y = m.getImageData(0, 0, e, i).data, x = m.getImageData(0, 0, n, s), C = x.data; for (h = 0; h < s; h++)for (c = 0; c < n; c++)for (l = v * c - (o = r(v * c)), u = b * h - (a = r(b * h)), g = 4 * (a * e + o), f = 0; f < 4; f++)d = y[g + f] * (1 - l) * (1 - u) + y[g + 4 + f] * l * (1 - u) + y[g + _ + f] * u * (1 - l) + y[g + _ + 4 + f] * l * u, C[p++] = d; return x }, hermiteFastResize: function (t, e, i, o, a) { for (var h = this.rcpScaleX, l = this.rcpScaleY, u = c(h / 2), f = c(l / 2), d = t.getContext("2d"), g = d.getImageData(0, 0, e, i).data, p = d.getImageData(0, 0, o, a), v = p.data, b = 0; b < a; b++)for (var m = 0; m < o; m++) { for (var _ = 4 * (m + b * o), y = 0, x = 0, C = 0, S = 0, w = 0, O = 0, T = 0, j = (b + .5) * l, k = r(b * l); k < (b + 1) * l; k++)for (var M = s(j - (k + .5)) / f, D = (m + .5) * h, A = M * M, P = r(m * h); P < (m + 1) * h; P++) { var E = s(D - (P + .5)) / u, I = n(A + E * E); I > 1 && I < -1 || (y = 2 * I * I * I - 3 * I * I + 1) > 0 && (T += y * g[(E = 4 * (P + k * e)) + 3], C += y, g[E + 3] < 255 && (y = y * g[E + 3] / 250), S += y * g[E], w += y * g[E + 1], O += y * g[E + 2], x += y) } v[_] = S / x, v[_ + 1] = w / x, v[_ + 2] = O / x, v[_ + 3] = T / C } return p }, toObject: function () { return { type: this.type, scaleX: this.scaleX, scaleY: this.scaleY, resizeType: this.resizeType, lanczosLobes: this.lanczosLobes } } }), e.Image.filters.Resize.fromObject = e.Image.filters.BaseFilter.fromObject }("undefined" != typeof exports ? exports : this), function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.object.extend, r = e.Image.filters, n = e.util.createClass; r.ColorMatrix = n(r.BaseFilter, { type: "ColorMatrix", initialize: function (t) { t || (t = {}), this.matrix = t.matrix || [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0] }, applyTo: function (t) { var e, i, r, n, s, o = t.getContext("2d"), a = o.getImageData(0, 0, t.width, t.height), h = a.data, c = h.length, l = this.matrix; for (e = 0; e < c; e += 4)i = h[e], r = h[e + 1], n = h[e + 2], s = h[e + 3], h[e] = i * l[0] + r * l[1] + n * l[2] + s * l[3] + l[4], h[e + 1] = i * l[5] + r * l[6] + n * l[7] + s * l[8] + l[9], h[e + 2] = i * l[10] + r * l[11] + n * l[12] + s * l[13] + l[14], h[e + 3] = i * l[15] + r * l[16] + n * l[17] + s * l[18] + l[19]; o.putImageData(a, 0, 0) }, toObject: function () { return i(this.callSuper("toObject"), { type: this.type, matrix: this.matrix }) } }), e.Image.filters.ColorMatrix.fromObject = e.Image.filters.BaseFilter.fromObject }("undefined" != typeof exports ? exports : this), function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.object.extend, r = e.Image.filters, n = e.util.createClass; r.Contrast = n(r.BaseFilter, { type: "Contrast", initialize: function (t) { t = t || {}, this.contrast = t.contrast || 0 }, applyTo: function (t) { for (var e = t.getContext("2d"), i = e.getImageData(0, 0, t.width, t.height), r = i.data, n = 259 * (this.contrast + 255) / (255 * (259 - this.contrast)), s = 0, o = r.length; s < o; s += 4)r[s] = n * (r[s] - 128) + 128, r[s + 1] = n * (r[s + 1] - 128) + 128, r[s + 2] = n * (r[s + 2] - 128) + 128; e.putImageData(i, 0, 0) }, toObject: function () { return i(this.callSuper("toObject"), { contrast: this.contrast }) } }), e.Image.filters.Contrast.fromObject = e.Image.filters.BaseFilter.fromObject }("undefined" != typeof exports ? exports : this), function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.object.extend, r = e.Image.filters, n = e.util.createClass; r.Saturate = n(r.BaseFilter, { type: "Saturate", initialize: function (t) { t = t || {}, this.saturate = t.saturate || 0 }, applyTo: function (t) { for (var e, i = t.getContext("2d"), r = i.getImageData(0, 0, t.width, t.height), n = r.data, s = .01 * -this.saturate, o = 0, a = n.length; o < a; o += 4)e = Math.max(n[o], n[o + 1], n[o + 2]), n[o] += e !== n[o] ? (e - n[o]) * s : 0, n[o + 1] += e !== n[o + 1] ? (e - n[o + 1]) * s : 0, n[o + 2] += e !== n[o + 2] ? (e - n[o + 2]) * s : 0; i.putImageData(r, 0, 0) }, toObject: function () { return i(this.callSuper("toObject"), { saturate: this.saturate }) } }), e.Image.filters.Saturate.fromObject = e.Image.filters.BaseFilter.fromObject }("undefined" != typeof exports ? exports : this), function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.toFixed, r = e.Object.NUM_FRACTION_DIGITS; if (e.Text) e.warn("fabric.Text is already defined"); else { var n = e.Object.prototype.stateProperties.concat(); n.push("fontFamily", "fontWeight", "fontSize", "text", "textDecoration", "textAlign", "fontStyle", "lineHeight", "textBackgroundColor", "charSpacing"); var s = e.Object.prototype.cacheProperties.concat(); s.push("fontFamily", "fontWeight", "fontSize", "text", "textDecoration", "textAlign", "fontStyle", "lineHeight", "textBackgroundColor", "charSpacing", "styles"), e.Text = e.util.createClass(e.Object, { _dimensionAffectingProps: ["fontSize", "fontWeight", "fontFamily", "fontStyle", "lineHeight", "text", "charSpacing", "textAlign"], _reNewline: /\r?\n/, _reSpacesAndTabs: /[ \t\r]+/g, type: "text", fontSize: 40, fontWeight: "normal", fontFamily: "Times New Roman", textDecoration: "", textAlign: "left", fontStyle: "", lineHeight: 1.16, textBackgroundColor: "", stateProperties: n, cacheProperties: s, stroke: null, shadow: null, _fontSizeFraction: .25, _fontSizeMult: 1.13, charSpacing: 0, initialize: function (t, e) { e = e || {}, this.text = t, this.__skipDimension = !0, this.callSuper("initialize", e), this.__skipDimension = !1, this._initDimensions(), this.setCoords(), this.setupState({ propertySet: "_dimensionAffectingProps" }) }, _initDimensions: function (t) { this.__skipDimension || (t || (t = e.util.createCanvasElement().getContext("2d"), this._setTextStyles(t)), this._textLines = this._splitTextIntoLines(), this._clearCache(), this.width = this._getTextWidth(t) || this.cursorWidth || 2, this.height = this._getTextHeight(t), this.setCoords()) }, toString: function () { return "#<fabric.Text (" + this.complexity() + '): { "text": "' + this.text + '", "fontFamily": "' + this.fontFamily + '" }>' }, _getCacheCanvasDimensions: function () { var t = this.callSuper("_getCacheCanvasDimensions"), e = this.fontSize; return t.width += e * t.zoomX, t.height += e * t.zoomY, t }, _render: function (t) { this._setTextStyles(t), this.group && "path-group" === this.group.type && t.translate(this.left, this.top), this._renderTextLinesBackground(t), this._renderText(t), this._renderTextDecoration(t) }, _renderText: function (t) { this._renderTextFill(t), this._renderTextStroke(t) }, _setTextStyles: function (t) { t.textBaseline = "alphabetic", t.font = this._getFontDeclaration() }, _getTextHeight: function () { return this._getHeightOfSingleLine() + (this._textLines.length - 1) * this._getHeightOfLine() }, _getTextWidth: function (t) { for (var e = this._getLineWidth(t, 0), i = 1, r = this._textLines.length; i < r; i++) { var n = this._getLineWidth(t, i); n > e && (e = n) } return e }, _renderChars: function (t, e, i, r, n) { var s, o, a = t.slice(0, -4); if (this[a].toLive) { var h = -this.width / 2 + this[a].offsetX || 0, c = -this.height / 2 + this[a].offsetY || 0; e.save(), e.translate(h, c), r -= h, n -= c } if (0 !== this.charSpacing) for (var l = this._getWidthOfCharSpacing(), u = 0, f = (i = i.split("")).length; u < f; u++)s = i[u], o = e.measureText(s).width + l, e[t](s, r, n), r += o > 0 ? o : 0; else e[t](i, r, n); this[a].toLive && e.restore() }, _renderTextLine: function (t, e, i, r, n, s) { n -= this.fontSize * this._fontSizeFraction; var o = this._getLineWidth(e, s); if ("justify" !== this.textAlign || this.width < o) this._renderChars(t, e, i, r, n, s); else for (var a, h = i.split(/\s+/), c = 0, l = this._getWidthOfWords(e, h.join(" "), s, 0), u = this.width - l, f = h.length - 1, d = f > 0 ? u / f : 0, g = 0, p = 0, v = h.length; p < v; p++) { for (; " " === i[c] && c < i.length;)c++; a = h[p], this._renderChars(t, e, a, r + g, n, s, c), g += this._getWidthOfWords(e, a, s, c) + d, c += a.length } }, _getWidthOfWords: function (t, e) { var i = t.measureText(e).width; return 0 !== this.charSpacing && (i += e.split("").length * this._getWidthOfCharSpacing()), i > 0 ? i : 0 }, _getLeftOffset: function () { return -this.width / 2 }, _getTopOffset: function () { return -this.height / 2 }, isEmptyStyles: function () { return !0 }, _renderTextCommon: function (t, e) { for (var i = 0, r = this._getLeftOffset(), n = this._getTopOffset(), s = 0, o = this._textLines.length; s < o; s++) { var a = this._getHeightOfLine(t, s), h = a / this.lineHeight, c = this._getLineWidth(t, s), l = this._getLineLeftOffset(c); this._renderTextLine(e, t, this._textLines[s], r + l, n + i + h, s), i += a } }, _renderTextFill: function (t) { !this.fill && this.isEmptyStyles() || this._renderTextCommon(t, "fillText") }, _renderTextStroke: function (t) { (this.stroke && 0 !== this.strokeWidth || !this.isEmptyStyles()) && (this.shadow && !this.shadow.affectStroke && this._removeShadow(t), t.save(), this._setLineDash(t, this.strokeDashArray), t.beginPath(), this._renderTextCommon(t, "strokeText"), t.closePath(), t.restore()) }, _getHeightOfLine: function () { return this._getHeightOfSingleLine() * this.lineHeight }, _getHeightOfSingleLine: function () { return this.fontSize * this._fontSizeMult }, _renderTextLinesBackground: function (t) { if (this.textBackgroundColor) { var e, i, r, n = 0, s = t.fillStyle; t.fillStyle = this.textBackgroundColor; for (var o = 0, a = this._textLines.length; o < a; o++)e = this._getHeightOfLine(t, o), (i = this._getLineWidth(t, o)) > 0 && (r = this._getLineLeftOffset(i), t.fillRect(this._getLeftOffset() + r, this._getTopOffset() + n, i, e / this.lineHeight)), n += e; t.fillStyle = s, this._removeShadow(t) } }, _getLineLeftOffset: function (t) { return "center" === this.textAlign ? (this.width - t) / 2 : "right" === this.textAlign ? this.width - t : 0 }, _clearCache: function () { this.__lineWidths = [], this.__lineHeights = [] }, _shouldClearDimensionCache: function () { var t = this._forceClearCache; return t || (t = this.hasStateChanged("_dimensionAffectingProps")), t && (this.saveState({ propertySet: "_dimensionAffectingProps" }), this.dirty = !0), t }, _getLineWidth: function (t, e) { if (this.__lineWidths[e]) return -1 === this.__lineWidths[e] ? this.width : this.__lineWidths[e]; var i, r = this._textLines[e]; return i = "" === r ? 0 : this._measureLine(t, e), this.__lineWidths[e] = i, i && "justify" === this.textAlign && r.split(/\s+/).length > 1 && (this.__lineWidths[e] = -1), i }, _getWidthOfCharSpacing: function () { return 0 !== this.charSpacing ? this.fontSize * this.charSpacing / 1e3 : 0 }, _measureLine: function (t, e) { var i, r = this._textLines[e], n = t.measureText(r).width, s = 0; return 0 !== this.charSpacing && (s = (r.split("").length - 1) * this._getWidthOfCharSpacing()), (i = n + s) > 0 ? i : 0 }, _renderTextDecoration: function (t) { if (this.textDecoration) { var e = this.height / 2, i = this, r = []; this.textDecoration.indexOf("underline") > -1 && r.push(.85), this.textDecoration.indexOf("line-through") > -1 && r.push(.43), this.textDecoration.indexOf("overline") > -1 && r.push(-.12), r.length > 0 && function (r) { var n, s, o, a, h, c, l, u = 0; for (n = 0, s = i._textLines.length; n < s; n++) { for (h = i._getLineWidth(t, n), c = i._getLineLeftOffset(h), l = i._getHeightOfLine(t, n), o = 0, a = r.length; o < a; o++)t.fillRect(i._getLeftOffset() + c, u + (i._fontSizeMult - 1 + r[o]) * i.fontSize - e, h, i.fontSize / 15); u += l } }(r) } }, _getFontDeclaration: function () { return [e.isLikelyNode ? this.fontWeight : this.fontStyle, e.isLikelyNode ? this.fontStyle : this.fontWeight, this.fontSize + "px", e.isLikelyNode ? '"' + this.fontFamily + '"' : this.fontFamily].join(" ") }, render: function (t, e) { this.visible && (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (this._shouldClearDimensionCache() && (this._setTextStyles(t), this._initDimensions(t)), this.callSuper("render", t, e))) }, _splitTextIntoLines: function () { return this.text.split(this._reNewline) }, toObject: function (t) { var e = ["text", "fontSize", "fontWeight", "fontFamily", "fontStyle", "lineHeight", "textDecoration", "textAlign", "textBackgroundColor", "charSpacing"].concat(t); return this.callSuper("toObject", e) }, toSVG: function (t) { this.ctx || (this.ctx = e.util.createCanvasElement().getContext("2d")); var i = this._createBaseSVGMarkup(), r = this._getSVGLeftTopOffsets(this.ctx), n = this._getSVGTextAndBg(r.textTop, r.textLeft); return this._wrapSVGTextAndBg(i, n), t ? t(i.join("")) : i.join("") }, _getSVGLeftTopOffsets: function (t) { var e = this._getHeightOfLine(t, 0); return { textLeft: -this.width / 2 + (this.group && "path-group" === this.group.type ? this.left : 0), textTop: 0 + (this.group && "path-group" === this.group.type ? -this.top : 0), lineTop: e } }, _wrapSVGTextAndBg: function (t, e) { var i = this.getSvgFilter(), r = "" === i ? "" : ' style="' + i + '"'; t.push("\t<g ", this.getSvgId(), 'transform="', this.getSvgTransform(), this.getSvgTransformMatrix(), '"', r, ">\n", e.textBgRects.join(""), '\t\t<text xml:space="preserve" ', this.fontFamily ? 'font-family="' + this.fontFamily.replace(/"/g, "'") + '" ' : "", this.fontSize ? 'font-size="' + this.fontSize + '" ' : "", this.fontStyle ? 'font-style="' + this.fontStyle + '" ' : "", this.fontWeight ? 'font-weight="' + this.fontWeight + '" ' : "", this.textDecoration ? 'text-decoration="' + this.textDecoration + '" ' : "", 'style="', this.getSvgStyles(!0), '" >\n', e.textSpans.join(""), "\t\t</text>\n", "\t</g>\n") }, getSvgStyles: function (t) { return e.Object.prototype.getSvgStyles.call(this, t) + " white-space: pre;" }, _getSVGTextAndBg: function (t, e) { var i = [], r = [], n = 0; this._setSVGBg(r); for (var s = 0, o = this._textLines.length; s < o; s++)this.textBackgroundColor && this._setSVGTextLineBg(r, s, e, t, n), this._setSVGTextLineText(s, i, n, e, t, r), n += this._getHeightOfLine(this.ctx, s); return { textSpans: i, textBgRects: r } }, _setSVGTextLineText: function (t, n, s, o, a) { var h = this.fontSize * (this._fontSizeMult - this._fontSizeFraction) - a + s - this.height / 2; "justify" !== this.textAlign ? n.push('\t\t\t<tspan x="', i(o + this._getLineLeftOffset(this._getLineWidth(this.ctx, t)), r), '" ', 'y="', i(h, r), '" ', this._getFillAttributes(this.fill), ">", e.util.string.escapeXml(this._textLines[t]), "</tspan>\n") : this._setSVGTextLineJustifed(t, n, h, o) }, _setSVGTextLineJustifed: function (t, n, s, o) { var a = e.util.createCanvasElement().getContext("2d"); this._setTextStyles(a); var h, c, l = this._textLines[t].split(/\s+/), u = this._getWidthOfWords(a, l.join("")), f = this.width - u, d = l.length - 1, g = d > 0 ? f / d : 0, p = this._getFillAttributes(this.fill); for (o += this._getLineLeftOffset(this._getLineWidth(a, t)), t = 0, c = l.length; t < c; t++)h = l[t], n.push('\t\t\t<tspan x="', i(o, r), '" ', 'y="', i(s, r), '" ', p, ">", e.util.string.escapeXml(h), "</tspan>\n"), o += this._getWidthOfWords(a, h) + g }, _setSVGTextLineBg: function (t, e, n, s, o) { t.push("\t\t<rect ", this._getFillAttributes(this.textBackgroundColor), ' x="', i(n + this._getLineLeftOffset(this._getLineWidth(this.ctx, e)), r), '" y="', i(o - this.height / 2, r), '" width="', i(this._getLineWidth(this.ctx, e), r), '" height="', i(this._getHeightOfLine(this.ctx, e) / this.lineHeight, r), '"></rect>\n') }, _setSVGBg: function (t) { this.backgroundColor && t.push("\t\t<rect ", this._getFillAttributes(this.backgroundColor), ' x="', i(-this.width / 2, r), '" y="', i(-this.height / 2, r), '" width="', i(this.width, r), '" height="', i(this.height, r), '"></rect>\n') }, _getFillAttributes: function (t) { var i = t && "string" == typeof t ? new e.Color(t) : ""; return i && i.getSource() && 1 !== i.getAlpha() ? 'opacity="' + i.getAlpha() + '" fill="' + i.setAlpha(1).toRgb() + '"' : 'fill="' + t + '"' }, _set: function (t, e) { this.callSuper("_set", t, e), this._dimensionAffectingProps.indexOf(t) > -1 && (this._initDimensions(), this.setCoords()) }, complexity: function () { return 1 } }), e.Text.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat("x y dx dy font-family font-style font-weight font-size text-decoration text-anchor".split(" ")), e.Text.DEFAULT_SVG_FONT_SIZE = 16, e.Text.fromElement = function (t, i) { if (!t) return null; var r = e.parseAttributes(t, e.Text.ATTRIBUTE_NAMES); (i = e.util.object.extend(i ? e.util.object.clone(i) : {}, r)).top = i.top || 0, i.left = i.left || 0, "dx" in r && (i.left += r.dx), "dy" in r && (i.top += r.dy), "fontSize" in i || (i.fontSize = e.Text.DEFAULT_SVG_FONT_SIZE), i.originX || (i.originX = "left"); var n = ""; "textContent" in t ? n = t.textContent : "firstChild" in t && null !== t.firstChild && "data" in t.firstChild && null !== t.firstChild.data && (n = t.firstChild.data), n = n.replace(/^\s+|\s+$|\n+/g, "").replace(/\s+/g, " "); var s = new e.Text(n, i), o = s.getHeight() / s.height, a = ((s.height + s.strokeWidth) * s.lineHeight - s.height) * o, h = s.getHeight() + a, c = 0; return "left" === s.originX && (c = s.getWidth() / 2), "right" === s.originX && (c = -s.getWidth() / 2), s.set({ left: s.getLeft() + c, top: s.getTop() - h / 2 + s.fontSize * (.18 + s._fontSizeFraction) / s.lineHeight }), s }, e.Text.fromObject = function (t, i, r) { return e.Object._fromObject("Text", t, i, r, "text") }, e.util.createAccessors(e.Text) } }("undefined" != typeof exports ? exports : this), function () { var t = fabric.util.object.clone; fabric.IText = fabric.util.createClass(fabric.Text, fabric.Observable, { type: "i-text", selectionStart: 0, selectionEnd: 0, selectionColor: "rgba(17,119,255,0.3)", isEditing: !1, editable: !0, editingBorderColor: "rgba(102,153,255,0.25)", cursorWidth: 2, cursorColor: "#333", cursorDelay: 1e3, cursorDuration: 600, styles: null, caching: !0, _reSpace: /\s|\n/, _currentCursorOpacity: 0, _selectionDirection: null, _abortCursorAnimation: !1, __widthOfSpace: [], initialize: function (t, e) { this.styles = e ? e.styles || {} : {}, this.callSuper("initialize", t, e), this.initBehavior() }, _clearCache: function () { this.callSuper("_clearCache"), this.__widthOfSpace = [] }, isEmptyStyles: function () { if (!this.styles) return !0; var t = this.styles; for (var e in t) for (var i in t[e]) for (var r in t[e][i]) return !1; return !0 }, setSelectionStart: function (t) { t = Math.max(t, 0), this._updateAndFire("selectionStart", t) }, setSelectionEnd: function (t) { t = Math.min(t, this.text.length), this._updateAndFire("selectionEnd", t) }, _updateAndFire: function (t, e) { this[t] !== e && (this._fireSelectionChanged(), this[t] = e), this._updateTextarea() }, _fireSelectionChanged: function () { this.fire("selection:changed"), this.canvas && this.canvas.fire("text:selection:changed", { target: this }) }, getSelectionStyles: function (t, e) { if (2 === arguments.length) { for (var i = [], r = t; r < e; r++)i.push(this.getSelectionStyles(r)); return i } var n = this.get2DCursorLocation(t); return this._getStyleDeclaration(n.lineIndex, n.charIndex) || {} }, setSelectionStyles: function (t) { if (this.selectionStart === this.selectionEnd) this._extendStyles(this.selectionStart, t); else for (var e = this.selectionStart; e < this.selectionEnd; e++)this._extendStyles(e, t); return this._forceClearCache = !0, this }, _extendStyles: function (t, e) { var i = this.get2DCursorLocation(t); this._getLineStyle(i.lineIndex) || this._setLineStyle(i.lineIndex, {}), this._getStyleDeclaration(i.lineIndex, i.charIndex) || this._setStyleDeclaration(i.lineIndex, i.charIndex, {}), fabric.util.object.extend(this._getStyleDeclaration(i.lineIndex, i.charIndex), e) }, _initDimensions: function (t) { t || this.clearContextTop(), this.callSuper("_initDimensions", t) }, render: function (t, e) { this.clearContextTop(), this.callSuper("render", t, e), this.cursorOffsetCache = {}, this.renderCursorOrSelection() }, _render: function (t) { this.callSuper("_render", t), this.ctx = t }, clearContextTop: function () { if (this.active && this.isEditing && this.canvas && this.canvas.contextTop) { var t = this.canvas.contextTop; t.save(), t.transform.apply(t, this.canvas.viewportTransform), this.transform(t), this.transformMatrix && t.transform.apply(t, this.transformMatrix), this._clearTextArea(t), t.restore() } }, renderCursorOrSelection: function () { if (this.active && this.isEditing) { var t, e, i = this.text.split(""); this.canvas && this.canvas.contextTop ? ((e = this.canvas.contextTop).save(), e.transform.apply(e, this.canvas.viewportTransform), this.transform(e), this.transformMatrix && e.transform.apply(e, this.transformMatrix), this._clearTextArea(e)) : (e = this.ctx).save(), this.selectionStart === this.selectionEnd ? (t = this._getCursorBoundaries(i, "cursor"), this.renderCursor(t, e)) : (t = this._getCursorBoundaries(i, "selection"), this.renderSelection(i, t, e)), e.restore() } }, _clearTextArea: function (t) { var e = this.width + 4, i = this.height + 4; t.clearRect(-e / 2, -i / 2, e, i) }, get2DCursorLocation: function (t) { void 0 === t && (t = this.selectionStart); for (var e = this._textLines.length, i = 0; i < e; i++) { if (t <= this._textLines[i].length) return { lineIndex: i, charIndex: t }; t -= this._textLines[i].length + 1 } return { lineIndex: i - 1, charIndex: this._textLines[i - 1].length < t ? this._textLines[i - 1].length : t } }, getCurrentCharStyle: function (t, e) { var i = this._getStyleDeclaration(t, 0 === e ? 0 : e - 1); return { fontSize: i && i.fontSize || this.fontSize, fill: i && i.fill || this.fill, textBackgroundColor: i && i.textBackgroundColor || this.textBackgroundColor, textDecoration: i && i.textDecoration || this.textDecoration, fontFamily: i && i.fontFamily || this.fontFamily, fontWeight: i && i.fontWeight || this.fontWeight, fontStyle: i && i.fontStyle || this.fontStyle, stroke: i && i.stroke || this.stroke, strokeWidth: i && i.strokeWidth || this.strokeWidth } }, getCurrentCharFontSize: function (t, e) { var i = this._getStyleDeclaration(t, 0 === e ? 0 : e - 1); return i && i.fontSize ? i.fontSize : this.fontSize }, getCurrentCharColor: function (t, e) { var i = this._getStyleDeclaration(t, 0 === e ? 0 : e - 1); return i && i.fill ? i.fill : this.cursorColor }, _getCursorBoundaries: function (t, e) { var i = Math.round(this._getLeftOffset()), r = this._getTopOffset(), n = this._getCursorBoundariesOffsets(t, e); return { left: i, top: r, leftOffset: n.left + n.lineLeft, topOffset: n.top } }, _getCursorBoundariesOffsets: function (t, e) { if (this.cursorOffsetCache && "top" in this.cursorOffsetCache) return this.cursorOffsetCache; for (var i, r = 0, n = 0, s = 0, o = 0, a = 0, h = 0; h < this.selectionStart; h++)"\n" === t[h] ? (a = 0, o += this._getHeightOfLine(this.ctx, n), n++ , s = 0) : (a += this._getWidthOfChar(this.ctx, t[h], n, s), s++), r = this._getLineLeftOffset(this._getLineWidth(this.ctx, n)); return "cursor" === e && (o += (1 - this._fontSizeFraction) * this._getHeightOfLine(this.ctx, n) / this.lineHeight - this.getCurrentCharFontSize(n, s) * (1 - this._fontSizeFraction)), 0 !== this.charSpacing && s === this._textLines[n].length && (a -= this._getWidthOfCharSpacing()), i = { top: o, left: a > 0 ? a : 0, lineLeft: r }, this.cursorOffsetCache = i, this.cursorOffsetCache }, renderCursor: function (t, e) { var i = this.get2DCursorLocation(), r = i.lineIndex, n = i.charIndex, s = this.getCurrentCharFontSize(r, n), o = t.leftOffset, a = this.scaleX * this.canvas.getZoom(), h = this.cursorWidth / a; e.fillStyle = this.getCurrentCharColor(r, n), e.globalAlpha = this.__isMousedown ? 1 : this._currentCursorOpacity, e.fillRect(t.left + o - h / 2, t.top + t.topOffset, h, s) }, renderSelection: function (t, e, i) { i.fillStyle = this.selectionColor; for (var r = this.get2DCursorLocation(this.selectionStart), n = this.get2DCursorLocation(this.selectionEnd), s = r.lineIndex, o = n.lineIndex, a = s; a <= o; a++) { var h = this._getLineLeftOffset(this._getLineWidth(i, a)) || 0, c = this._getHeightOfLine(this.ctx, a), l = 0, u = 0, f = this._textLines[a]; if (a === s) { for (var d = 0, g = f.length; d < g; d++)d >= r.charIndex && (a !== o || d < n.charIndex) && (u += this._getWidthOfChar(i, f[d], a, d)), d < r.charIndex && (h += this._getWidthOfChar(i, f[d], a, d)); d === f.length && (u -= this._getWidthOfCharSpacing()) } else if (a > s && a < o) u += this._getLineWidth(i, a) || 5; else if (a === o) { for (var p = 0, v = n.charIndex; p < v; p++)u += this._getWidthOfChar(i, f[p], a, p); n.charIndex === f.length && (u -= this._getWidthOfCharSpacing()) } l = c, (this.lineHeight < 1 || a === o && this.lineHeight > 1) && (c /= this.lineHeight), i.fillRect(e.left + h, e.top + e.topOffset, u > 0 ? u : 0, c), e.topOffset += l } }, _renderChars: function (t, e, i, r, n, s, o) { if (this.isEmptyStyles()) return this._renderCharsFast(t, e, i, r, n); o = o || 0; var a, h, c = this._getHeightOfLine(e, s), l = ""; e.save(), n -= c / this.lineHeight * this._fontSizeFraction; for (var u = o, f = i.length + o; u <= f; u++)a = a || this.getCurrentCharStyle(s, u), h = this.getCurrentCharStyle(s, u + 1), (this._hasStyleChanged(a, h) || u === f) && (this._renderChar(t, e, s, u - 1, l, r, n, c), l = "", a = h), l += i[u - o]; e.restore() }, _renderCharsFast: function (t, e, i, r, n) { "fillText" === t && this.fill && this.callSuper("_renderChars", t, e, i, r, n), "strokeText" === t && (this.stroke && this.strokeWidth > 0 || this.skipFillStrokeCheck) && this.callSuper("_renderChars", t, e, i, r, n) }, _renderChar: function (t, e, i, r, n, s, o, a) { var h, c, l, u, f, d, g, p, v, b = this._getStyleDeclaration(i, r); if (b ? (c = this._getHeightOfChar(e, n, i, r), u = b.stroke, l = b.fill, d = b.textDecoration) : c = this.fontSize, u = (u || this.stroke) && "strokeText" === t, l = (l || this.fill) && "fillText" === t, b && e.save(), h = this._applyCharStylesGetWidth(e, n, i, r, b || null), d = d || this.textDecoration, b && b.textBackgroundColor && this._removeShadow(e), 0 !== this.charSpacing) { p = this._getWidthOfCharSpacing(), h = 0; for (var m, _ = 0, y = (g = n.split("")).length; _ < y; _++)m = g[_], l && e.fillText(m, s + h, o), u && e.strokeText(m, s + h, o), h += (v = e.measureText(m).width + p) > 0 ? v : 0 } else l && e.fillText(n, s, o), u && e.strokeText(n, s, o); (d || "" !== d) && (f = this._fontSizeFraction * a / this.lineHeight, this._renderCharDecoration(e, d, s, o, f, h, c)), b && e.restore(), e.translate(h, 0) }, _hasStyleChanged: function (t, e) { return t.fill !== e.fill || t.fontSize !== e.fontSize || t.textBackgroundColor !== e.textBackgroundColor || t.textDecoration !== e.textDecoration || t.fontFamily !== e.fontFamily || t.fontWeight !== e.fontWeight || t.fontStyle !== e.fontStyle || t.stroke !== e.stroke || t.strokeWidth !== e.strokeWidth }, _renderCharDecoration: function (t, e, i, r, n, s, o) { if (e) { var a, h, c = o / 15, l = { underline: r + o / 10, "line-through": r - o * (this._fontSizeFraction + this._fontSizeMult - 1) + c, overline: r - (this._fontSizeMult - this._fontSizeFraction) * o }, u = ["underline", "line-through", "overline"]; for (a = 0; a < u.length; a++)h = u[a], e.indexOf(h) > -1 && t.fillRect(i, l[h], s, c) } }, _renderTextLine: function (t, e, i, r, n, s) { this.isEmptyStyles() || (n += this.fontSize * (this._fontSizeFraction + .03)), this.callSuper("_renderTextLine", t, e, i, r, n, s) }, _renderTextDecoration: function (t) { if (this.isEmptyStyles()) return this.callSuper("_renderTextDecoration", t) }, _renderTextLinesBackground: function (t) { this.callSuper("_renderTextLinesBackground", t); var e, i, r, n, s, o, a, h, c, l, u = 0, f = this._getLeftOffset(), d = this._getTopOffset(), g = ""; t.save(); for (var p = 0, v = this._textLines.length; p < v; p++)if (e = this._getHeightOfLine(t, p), "" !== (n = this._textLines[p]) && this.styles && this._getLineStyle(p)) { i = this._getLineWidth(t, p), r = this._getLineLeftOffset(i), a = h = c = l = 0; for (var b = 0, m = n.length; b < m; b++)g !== (o = this._getStyleDeclaration(p, b) || {}).textBackgroundColor && (l && c && (t.fillStyle = g, t.fillRect(a, h, c, l)), a = h = c = l = 0, g = o.textBackgroundColor || ""), o.textBackgroundColor ? (s = n[b], g === o.textBackgroundColor && (g = o.textBackgroundColor, a || (a = f + r + this._getWidthOfCharsAt(t, p, b)), h = d + u, c += this._getWidthOfChar(t, s, p, b), l = e / this.lineHeight)) : g = ""; l && c && (t.fillStyle = g, t.fillRect(a, h, c, l), a = h = c = l = 0), u += e } else u += e; t.restore() }, _getCacheProp: function (t, e) { return t + e.fontSize + e.fontWeight + e.fontStyle }, _getFontCache: function (t) { return fabric.charWidthsCache[t] || (fabric.charWidthsCache[t] = {}), fabric.charWidthsCache[t] }, _applyCharStylesGetWidth: function (e, i, r, n, s) { var o, a, h, c = s || this._getStyleDeclaration(r, n), l = t(c); if (this._applyFontStyles(l), h = this._getFontCache(l.fontFamily), a = this._getCacheProp(i, l), !c && h[a] && this.caching) return h[a]; "string" == typeof l.shadow && (l.shadow = new fabric.Shadow(l.shadow)); var u = l.fill || this.fill; return e.fillStyle = u.toLive ? u.toLive(e, this) : u, l.stroke && (e.strokeStyle = l.stroke && l.stroke.toLive ? l.stroke.toLive(e, this) : l.stroke), e.lineWidth = l.strokeWidth || this.strokeWidth, e.font = this._getFontDeclaration.call(l), l.shadow && (l.scaleX = this.scaleX, l.scaleY = this.scaleY, l.canvas = this.canvas, l.getObjectScaling = this.getObjectScaling, this._setShadow.call(l, e)), this.caching && h[a] ? h[a] : (o = e.measureText(i).width, this.caching && (h[a] = o), o) }, _applyFontStyles: function (t) { t.fontFamily || (t.fontFamily = this.fontFamily), t.fontSize || (t.fontSize = this.fontSize), t.fontWeight || (t.fontWeight = this.fontWeight), t.fontStyle || (t.fontStyle = this.fontStyle) }, _getStyleDeclaration: function (e, i, r) { return r ? this.styles[e] && this.styles[e][i] ? t(this.styles[e][i]) : {} : this.styles[e] && this.styles[e][i] ? this.styles[e][i] : null }, _setStyleDeclaration: function (t, e, i) { this.styles[t][e] = i }, _deleteStyleDeclaration: function (t, e) { delete this.styles[t][e] }, _getLineStyle: function (t) { return this.styles[t] }, _setLineStyle: function (t, e) { this.styles[t] = e }, _deleteLineStyle: function (t) { delete this.styles[t] }, _getWidthOfChar: function (t, e, i, r) { if (!this._isMeasuring && "justify" === this.textAlign && this._reSpacesAndTabs.test(e)) return this._getWidthOfSpace(t, i); t.save(); var n = this._applyCharStylesGetWidth(t, e, i, r); return 0 !== this.charSpacing && (n += this._getWidthOfCharSpacing()), t.restore(), n > 0 ? n : 0 }, _getHeightOfChar: function (t, e, i) { var r = this._getStyleDeclaration(e, i); return r && r.fontSize ? r.fontSize : this.fontSize }, _getWidthOfCharsAt: function (t, e, i) { var r, n, s = 0; for (r = 0; r < i; r++)n = this._textLines[e][r], s += this._getWidthOfChar(t, n, e, r); return s }, _measureLine: function (t, e) { this._isMeasuring = !0; var i = this._getWidthOfCharsAt(t, e, this._textLines[e].length); return 0 !== this.charSpacing && (i -= this._getWidthOfCharSpacing()), this._isMeasuring = !1, i > 0 ? i : 0 }, _getWidthOfSpace: function (t, e) { if (this.__widthOfSpace[e]) return this.__widthOfSpace[e]; var i = this._textLines[e], r = this._getWidthOfWords(t, i, e, 0), n = this.width - r, s = i.length - i.replace(this._reSpacesAndTabs, "").length, o = Math.max(n / s, t.measureText(" ").width); return this.__widthOfSpace[e] = o, o }, _getWidthOfWords: function (t, e, i, r) { for (var n = 0, s = 0; s < e.length; s++) { var o = e[s]; o.match(/\s/) || (n += this._getWidthOfChar(t, o, i, s + r)) } return n }, _getHeightOfLine: function (t, e) { if (this.__lineHeights[e]) return this.__lineHeights[e]; for (var i = this._textLines[e], r = this._getHeightOfChar(t, e, 0), n = 1, s = i.length; n < s; n++) { var o = this._getHeightOfChar(t, e, n); o > r && (r = o) } return this.__lineHeights[e] = r * this.lineHeight * this._fontSizeMult, this.__lineHeights[e] }, _getTextHeight: function (t) { for (var e, i = 0, r = 0, n = this._textLines.length; r < n; r++)e = this._getHeightOfLine(t, r), i += r === n - 1 ? e / this.lineHeight : e; return i }, toObject: function (e) { return fabric.util.object.extend(this.callSuper("toObject", e), { styles: t(this.styles, !0) }) } }), fabric.IText.fromObject = function (t, e, i) { return fabric.Object._fromObject("IText", t, e, i, "text") } }(), function () { var t = fabric.util.object.clone; fabric.util.object.extend(fabric.IText.prototype, { initBehavior: function () { this.initAddedHandler(), this.initRemovedHandler(), this.initCursorSelectionHandlers(), this.initDoubleClickSimulation(), this.mouseMoveHandler = this.mouseMoveHandler.bind(this) }, onDeselect: function () { this.isEditing && this.exitEditing(), this.selected = !1, this.callSuper("onDeselect") }, initAddedHandler: function () { var t = this; this.on("added", function () { var e = t.canvas; e && (e._hasITextHandlers || (e._hasITextHandlers = !0, t._initCanvasHandlers(e)), e._iTextInstances = e._iTextInstances || [], e._iTextInstances.push(t)) }) }, initRemovedHandler: function () { var t = this; this.on("removed", function () { var e = t.canvas; e && (e._iTextInstances = e._iTextInstances || [], fabric.util.removeFromArray(e._iTextInstances, t), 0 === e._iTextInstances.length && (e._hasITextHandlers = !1, t._removeCanvasHandlers(e))) }) }, _initCanvasHandlers: function (t) { t._mouseUpITextHandler = function () { t._iTextInstances && t._iTextInstances.forEach(function (t) { t.__isMousedown = !1 }) }.bind(this), t.on("mouse:up", t._mouseUpITextHandler) }, _removeCanvasHandlers: function (t) { t.off("mouse:up", t._mouseUpITextHandler) }, _tick: function () { this._currentTickState = this._animateCursor(this, 1, this.cursorDuration, "_onTickComplete") }, _animateCursor: function (t, e, i, r) { var n; return n = { isAborted: !1, abort: function () { this.isAborted = !0 } }, t.animate("_currentCursorOpacity", e, { duration: i, onComplete: function () { n.isAborted || t[r]() }, onChange: function () { t.canvas && t.selectionStart === t.selectionEnd && t.renderCursorOrSelection() }, abort: function () { return n.isAborted } }), n }, _onTickComplete: function () { var t = this; this._cursorTimeout1 && clearTimeout(this._cursorTimeout1), this._cursorTimeout1 = setTimeout(function () { t._currentTickCompleteState = t._animateCursor(t, 0, this.cursorDuration / 2, "_tick") }, 100) }, initDelayedCursor: function (t) { var e = this, i = t ? 0 : this.cursorDelay; this.abortCursorAnimation(), this._currentCursorOpacity = 1, this._cursorTimeout2 = setTimeout(function () { e._tick() }, i) }, abortCursorAnimation: function () { var t = this._currentTickState || this._currentTickCompleteState; this._currentTickState && this._currentTickState.abort(), this._currentTickCompleteState && this._currentTickCompleteState.abort(), clearTimeout(this._cursorTimeout1), clearTimeout(this._cursorTimeout2), this._currentCursorOpacity = 0, t && this.canvas && this.canvas.clearContext(this.canvas.contextTop || this.ctx) }, selectAll: function () { this.selectionStart = 0, this.selectionEnd = this.text.length, this._fireSelectionChanged(), this._updateTextarea() }, getSelectedText: function () { return this.text.slice(this.selectionStart, this.selectionEnd) }, findWordBoundaryLeft: function (t) { var e = 0, i = t - 1; if (this._reSpace.test(this.text.charAt(i))) for (; this._reSpace.test(this.text.charAt(i));)e++ , i--; for (; /\S/.test(this.text.charAt(i)) && i > -1;)e++ , i--; return t - e }, findWordBoundaryRight: function (t) { var e = 0, i = t; if (this._reSpace.test(this.text.charAt(i))) for (; this._reSpace.test(this.text.charAt(i));)e++ , i++; for (; /\S/.test(this.text.charAt(i)) && i < this.text.length;)e++ , i++; return t + e }, findLineBoundaryLeft: function (t) { for (var e = 0, i = t - 1; !/\n/.test(this.text.charAt(i)) && i > -1;)e++ , i--; return t - e }, findLineBoundaryRight: function (t) { for (var e = 0, i = t; !/\n/.test(this.text.charAt(i)) && i < this.text.length;)e++ , i++; return t + e }, getNumNewLinesInSelectedText: function () { for (var t = this.getSelectedText(), e = 0, i = 0, r = t.length; i < r; i++)"\n" === t[i] && e++; return e }, searchWordBoundary: function (t, e) { for (var i = this._reSpace.test(this.text.charAt(t)) ? t - 1 : t, r = this.text.charAt(i), n = /[ \n\.,;!\?\-]/; !n.test(r) && i > 0 && i < this.text.length;)i += e, r = this.text.charAt(i); return n.test(r) && "\n" !== r && (i += 1 === e ? 0 : 1), i }, selectWord: function (t) { t = t || this.selectionStart; var e = this.searchWordBoundary(t, -1), i = this.searchWordBoundary(t, 1); this.selectionStart = e, this.selectionEnd = i, this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection() }, selectLine: function (t) { t = t || this.selectionStart; var e = this.findLineBoundaryLeft(t), i = this.findLineBoundaryRight(t); this.selectionStart = e, this.selectionEnd = i, this._fireSelectionChanged(), this._updateTextarea() }, enterEditing: function (t) { if (!this.isEditing && this.editable) return this.canvas && this.exitEditingOnOthers(this.canvas), this.isEditing = !0, this.selected = !0, this.initHiddenTextarea(t), this.hiddenTextarea.focus(), this._updateTextarea(), this._saveEditingProps(), this._setEditingProps(), this._textBeforeEdit = this.text, this._tick(), this.fire("editing:entered"), this._fireSelectionChanged(), this.canvas ? (this.canvas.fire("text:editing:entered", { target: this }), this.initMouseMoveHandler(), this.canvas.renderAll(), this) : this }, exitEditingOnOthers: function (t) { t._iTextInstances && t._iTextInstances.forEach(function (t) { t.selected = !1, t.isEditing && t.exitEditing() }) }, initMouseMoveHandler: function () { this.canvas.on("mouse:move", this.mouseMoveHandler) }, mouseMoveHandler: function (t) { if (this.__isMousedown && this.isEditing) { var e = this.getSelectionStartFromPointer(t.e), i = this.selectionStart, r = this.selectionEnd; (e === this.__selectionStartOnMouseDown && i !== r || i !== e && r !== e) && (e > this.__selectionStartOnMouseDown ? (this.selectionStart = this.__selectionStartOnMouseDown, this.selectionEnd = e) : (this.selectionStart = e, this.selectionEnd = this.__selectionStartOnMouseDown), this.selectionStart === i && this.selectionEnd === r || (this.restartCursorIfNeeded(), this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection())) } }, _setEditingProps: function () { this.hoverCursor = "text", this.canvas && (this.canvas.defaultCursor = this.canvas.moveCursor = "text"), this.borderColor = this.editingBorderColor, this.hasControls = this.selectable = !1, this.lockMovementX = this.lockMovementY = !0 }, _updateTextarea: function () { if (this.hiddenTextarea && !this.inCompositionMode && (this.cursorOffsetCache = {}, this.hiddenTextarea.value = this.text, this.hiddenTextarea.selectionStart = this.selectionStart, this.hiddenTextarea.selectionEnd = this.selectionEnd, this.selectionStart === this.selectionEnd)) { var t = this._calcTextareaPosition(); this.hiddenTextarea.style.left = t.left, this.hiddenTextarea.style.top = t.top, this.hiddenTextarea.style.fontSize = t.fontSize } }, _calcTextareaPosition: function () { if (!this.canvas) return { x: 1, y: 1 }; var t = this.text.split(""), e = this._getCursorBoundaries(t, "cursor"), i = this.get2DCursorLocation(), r = i.lineIndex, n = i.charIndex, s = this.getCurrentCharFontSize(r, n), o = e.leftOffset, a = this.calcTransformMatrix(), h = { x: e.left + o, y: e.top + e.topOffset + s }, c = this.canvas.upperCanvasEl, l = c.width - s, u = c.height - s; return h = fabric.util.transformPoint(h, a), (h = fabric.util.transformPoint(h, this.canvas.viewportTransform)).x < 0 && (h.x = 0), h.x > l && (h.x = l), h.y < 0 && (h.y = 0), h.y > u && (h.y = u), h.x += this.canvas._offset.left, h.y += this.canvas._offset.top, { left: h.x + "px", top: h.y + "px", fontSize: s } }, _saveEditingProps: function () { this._savedProps = { hasControls: this.hasControls, borderColor: this.borderColor, lockMovementX: this.lockMovementX, lockMovementY: this.lockMovementY, hoverCursor: this.hoverCursor, defaultCursor: this.canvas && this.canvas.defaultCursor, moveCursor: this.canvas && this.canvas.moveCursor } }, _restoreEditingProps: function () { this._savedProps && (this.hoverCursor = this._savedProps.overCursor, this.hasControls = this._savedProps.hasControls, this.borderColor = this._savedProps.borderColor, this.lockMovementX = this._savedProps.lockMovementX, this.lockMovementY = this._savedProps.lockMovementY, this.canvas && (this.canvas.defaultCursor = this._savedProps.defaultCursor, this.canvas.moveCursor = this._savedProps.moveCursor)) }, exitEditing: function () { var t = this._textBeforeEdit !== this.text; return this.selected = !1, this.isEditing = !1, this.selectable = !0, this.selectionEnd = this.selectionStart, this.hiddenTextarea && (this.hiddenTextarea.blur && this.hiddenTextarea.blur(), this.canvas && this.hiddenTextarea.parentNode.removeChild(this.hiddenTextarea), this.hiddenTextarea = null), this.abortCursorAnimation(), this._restoreEditingProps(), this._currentCursorOpacity = 0, this.fire("editing:exited"), t && this.fire("modified"), this.canvas && (this.canvas.off("mouse:move", this.mouseMoveHandler), this.canvas.fire("text:editing:exited", { target: this }), t && this.canvas.fire("object:modified", { target: this })), this }, _removeExtraneousStyles: function () { for (var t in this.styles) this._textLines[t] || delete this.styles[t] }, _removeCharsFromTo: function (t, e) { for (; e !== t;)this._removeSingleCharAndStyle(t + 1), e--; this.selectionStart = t, this.selectionEnd = t }, _removeSingleCharAndStyle: function (t) { var e = "\n" === this.text[t - 1], i = e ? t : t - 1; this.removeStyleObject(e, i), this.text = this.text.slice(0, t - 1) + this.text.slice(t), this._textLines = this._splitTextIntoLines() }, insertChars: function (t, e) { var i; if (this.selectionEnd - this.selectionStart > 1 && this._removeCharsFromTo(this.selectionStart, this.selectionEnd), e || !this.isEmptyStyles()) for (var r = 0, n = t.length; r < n; r++)e && (i = fabric.util.object.clone(fabric.copiedTextStyle[r], !0)), this.insertChar(t[r], r < n - 1, i); else this.insertChar(t, !1) }, insertChar: function (t, e, i) { var r = "\n" === this.text[this.selectionStart]; this.text = this.text.slice(0, this.selectionStart) + t + this.text.slice(this.selectionEnd), this._textLines = this._splitTextIntoLines(), this.insertStyleObjects(t, r, i), this.selectionStart += t.length, this.selectionEnd = this.selectionStart, e || (this._updateTextarea(), this.setCoords(), this._fireSelectionChanged(), this.fire("changed"), this.restartCursorIfNeeded(), this.canvas && (this.canvas.fire("text:changed", { target: this }), this.canvas.renderAll())) }, restartCursorIfNeeded: function () { this._currentTickState && !this._currentTickState.isAborted && this._currentTickCompleteState && !this._currentTickCompleteState.isAborted || this.initDelayedCursor() }, insertNewlineStyleObject: function (e, i, r) { this.shiftLineStyles(e, 1); var n = {}, s = {}; if (this.styles[e] && this.styles[e][i - 1] && (n = this.styles[e][i - 1]), r && n) s[0] = t(n), this.styles[e + 1] = s; else { var o = !1; for (var a in this.styles[e]) { var h = parseInt(a, 10); h >= i && (o = !0, s[h - i] = this.styles[e][a], delete this.styles[e][a]) } o && (this.styles[e + 1] = s) } this._forceClearCache = !0 }, insertCharStyleObject: function (e, i, r) { var n = this.styles[e], s = t(n); 0 !== i || r || (i = 1); for (var o in s) { var a = parseInt(o, 10); a >= i && (n[a + 1] = s[a], s[a - 1] || delete n[a]) } var h = r || t(n[i - 1]); h && (this.styles[e][i] = h), this._forceClearCache = !0 }, insertStyleObjects: function (t, e, i) { var r = this.get2DCursorLocation(), n = r.lineIndex, s = r.charIndex; this._getLineStyle(n) || this._setLineStyle(n, {}), "\n" === t ? this.insertNewlineStyleObject(n, s, e) : this.insertCharStyleObject(n, s, i) }, shiftLineStyles: function (e, i) { var r = t(this.styles); for (var n in r) (s = parseInt(n, 10)) <= e && delete r[s]; for (var n in this.styles) { var s = parseInt(n, 10); s > e && (this.styles[s + i] = r[s], r[s - i] || delete this.styles[s]) } }, removeStyleObject: function (t, e) { var i = this.get2DCursorLocation(e), r = i.lineIndex, n = i.charIndex; this._removeStyleObject(t, i, r, n) }, _getTextOnPreviousLine: function (t) { return this._textLines[t - 1] }, _removeStyleObject: function (e, i, r, n) { if (e) { var s = this._getTextOnPreviousLine(i.lineIndex), o = s ? s.length : 0; this.styles[r - 1] || (this.styles[r - 1] = {}); for (n in this.styles[r]) this.styles[r - 1][parseInt(n, 10) + o] = this.styles[r][n]; this.shiftLineStyles(i.lineIndex, -1) } else { var a = this.styles[r]; a && delete a[n]; var h = t(a); for (var c in h) { var l = parseInt(c, 10); l >= n && 0 !== l && (a[l - 1] = h[l], delete a[l]) } } }, insertNewline: function () { this.insertChars("\n") }, setSelectionStartEndWithShift: function (t, e, i) { i <= t ? (e === t ? this._selectionDirection = "left" : "right" === this._selectionDirection && (this._selectionDirection = "left", this.selectionEnd = t), this.selectionStart = i) : i > t && i < e ? "right" === this._selectionDirection ? this.selectionEnd = i : this.selectionStart = i : (e === t ? this._selectionDirection = "right" : "left" === this._selectionDirection && (this._selectionDirection = "right", this.selectionStart = e), this.selectionEnd = i) }, setSelectionInBoundaries: function () { var t = this.text.length; this.selectionStart > t ? this.selectionStart = t : this.selectionStart < 0 && (this.selectionStart = 0), this.selectionEnd > t ? this.selectionEnd = t : this.selectionEnd < 0 && (this.selectionEnd = 0) } }) }(), fabric.util.object.extend(fabric.IText.prototype, { initDoubleClickSimulation: function () { this.__lastClickTime = +new Date, this.__lastLastClickTime = +new Date, this.__lastPointer = {}, this.on("mousedown", this.onMouseDown.bind(this)) }, onMouseDown: function (t) { this.__newClickTime = +new Date; var e = this.canvas.getPointer(t.e); this.isTripleClick(e, t.e) ? (this.fire("tripleclick", t), this._stopEvent(t.e)) : this.isDoubleClick(e) && (this.fire("dblclick", t), this._stopEvent(t.e)), this.__lastLastClickTime = this.__lastClickTime, this.__lastClickTime = this.__newClickTime, this.__lastPointer = e, this.__lastIsEditing = this.isEditing, this.__lastSelected = this.selected }, isDoubleClick: function (t) { return this.__newClickTime - this.__lastClickTime < 500 && this.__lastPointer.x === t.x && this.__lastPointer.y === t.y && this.__lastIsEditing }, isTripleClick: function (t) { return this.__newClickTime - this.__lastClickTime < 500 && this.__lastClickTime - this.__lastLastClickTime < 500 && this.__lastPointer.x === t.x && this.__lastPointer.y === t.y }, _stopEvent: function (t) { t.preventDefault && t.preventDefault(), t.stopPropagation && t.stopPropagation() }, initCursorSelectionHandlers: function () { this.initMousedownHandler(), this.initMouseupHandler(), this.initClicks() }, initClicks: function () { this.on("dblclick", function (t) { this.selectWord(this.getSelectionStartFromPointer(t.e)) }), this.on("tripleclick", function (t) { this.selectLine(this.getSelectionStartFromPointer(t.e)) }) }, initMousedownHandler: function () { this.on("mousedown", function (t) { if (this.editable && (!t.e.button || 1 === t.e.button)) { var e = this.canvas.getPointer(t.e); this.__mousedownX = e.x, this.__mousedownY = e.y, this.__isMousedown = !0, this.selected && this.setCursorByClick(t.e), this.isEditing && (this.__selectionStartOnMouseDown = this.selectionStart, this.selectionStart === this.selectionEnd && this.abortCursorAnimation(), this.renderCursorOrSelection()) } }) }, _isObjectMoved: function (t) { var e = this.canvas.getPointer(t); return this.__mousedownX !== e.x || this.__mousedownY !== e.y }, initMouseupHandler: function () { this.on("mouseup", function (t) { this.__isMousedown = !1, !this.editable || this._isObjectMoved(t.e) || t.e.button && 1 !== t.e.button || (this.__lastSelected && !this.__corner && (this.enterEditing(t.e), this.selectionStart === this.selectionEnd ? this.initDelayedCursor(!0) : this.renderCursorOrSelection()), this.selected = !0) }) }, setCursorByClick: function (t) { var e = this.getSelectionStartFromPointer(t), i = this.selectionStart, r = this.selectionEnd; t.shiftKey ? this.setSelectionStartEndWithShift(i, r, e) : (this.selectionStart = e, this.selectionEnd = e), this.isEditing && (this._fireSelectionChanged(), this._updateTextarea()) }, getSelectionStartFromPointer: function (t) { for (var e, i = this.getLocalPointer(t), r = 0, n = 0, s = 0, o = 0, a = 0, h = this._textLines.length; a < h; a++) { e = this._textLines[a], s += this._getHeightOfLine(this.ctx, a) * this.scaleY; var c = this._getLineWidth(this.ctx, a); n = this._getLineLeftOffset(c) * this.scaleX; for (var l = 0, u = e.length; l < u; l++) { if (r = n, n += this._getWidthOfChar(this.ctx, e[l], a, this.flipX ? u - l : l) * this.scaleX, !(s <= i.y || n <= i.x)) return this._getNewSelectionStartFromOffset(i, r, n, o + a, u); o++ } if (i.y < s) return this._getNewSelectionStartFromOffset(i, r, n, o + a - 1, u) } return this.text.length }, _getNewSelectionStartFromOffset: function (t, e, i, r, n) { var s = t.x - e, o = r + (i - t.x > s ? 0 : 1); return this.flipX && (o = n - o), o > this.text.length && (o = this.text.length), o } }), fabric.util.object.extend(fabric.IText.prototype, { initHiddenTextarea: function () { this.hiddenTextarea = fabric.document.createElement("textarea"), this.hiddenTextarea.setAttribute("autocapitalize", "off"), this.hiddenTextarea.setAttribute("autocorrect", "off"), this.hiddenTextarea.setAttribute("autocomplete", "off"), this.hiddenTextarea.setAttribute("spellcheck", "false"), this.hiddenTextarea.setAttribute("data-fabric-hiddentextarea", ""), this.hiddenTextarea.setAttribute("wrap", "off"); var t = this._calcTextareaPosition(); this.hiddenTextarea.style.cssText = "position: absolute; top: " + t.top + "; left: " + t.left + "; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px; line-height: 1px; paddingtop: " + t.fontSize + ";", fabric.document.body.appendChild(this.hiddenTextarea), fabric.util.addListener(this.hiddenTextarea, "keydown", this.onKeyDown.bind(this)), fabric.util.addListener(this.hiddenTextarea, "keyup", this.onKeyUp.bind(this)), fabric.util.addListener(this.hiddenTextarea, "input", this.onInput.bind(this)), fabric.util.addListener(this.hiddenTextarea, "copy", this.copy.bind(this)), fabric.util.addListener(this.hiddenTextarea, "cut", this.cut.bind(this)), fabric.util.addListener(this.hiddenTextarea, "paste", this.paste.bind(this)), fabric.util.addListener(this.hiddenTextarea, "compositionstart", this.onCompositionStart.bind(this)), fabric.util.addListener(this.hiddenTextarea, "compositionupdate", this.onCompositionUpdate.bind(this)), fabric.util.addListener(this.hiddenTextarea, "compositionend", this.onCompositionEnd.bind(this)), !this._clickHandlerInitialized && this.canvas && (fabric.util.addListener(this.canvas.upperCanvasEl, "click", this.onClick.bind(this)), this._clickHandlerInitialized = !0) }, keysMap: { 8: "removeChars", 9: "exitEditing", 27: "exitEditing", 13: "insertNewline", 33: "moveCursorUp", 34: "moveCursorDown", 35: "moveCursorRight", 36: "moveCursorLeft", 37: "moveCursorLeft", 38: "moveCursorUp", 39: "moveCursorRight", 40: "moveCursorDown", 46: "forwardDelete" }, ctrlKeysMapUp: { 67: "copy", 88: "cut" }, ctrlKeysMapDown: { 65: "selectAll" }, onClick: function () { this.hiddenTextarea && this.hiddenTextarea.focus() }, onKeyDown: function (t) { if (this.isEditing) { if (t.keyCode in this.keysMap) this[this.keysMap[t.keyCode]](t); else { if (!(t.keyCode in this.ctrlKeysMapDown && (t.ctrlKey || t.metaKey))) return; this[this.ctrlKeysMapDown[t.keyCode]](t) } t.stopImmediatePropagation(), t.preventDefault(), t.keyCode >= 33 && t.keyCode <= 40 ? (this.clearContextTop(), this.renderCursorOrSelection()) : this.canvas && this.canvas.renderAll() } }, onKeyUp: function (t) { this.isEditing && !this._copyDone ? t.keyCode in this.ctrlKeysMapUp && (t.ctrlKey || t.metaKey) && (this[this.ctrlKeysMapUp[t.keyCode]](t), t.stopImmediatePropagation(), t.preventDefault(), this.canvas && this.canvas.renderAll()) : this._copyDone = !1 }, onInput: function (t) { if (this.isEditing && !this.inCompositionMode) { var e, i, r, n = this.selectionStart || 0, s = this.selectionEnd || 0, o = this.text.length, a = this.hiddenTextarea.value.length; a > o ? (r = "left" === this._selectionDirection ? s : n, e = a - o, i = this.hiddenTextarea.value.slice(r, r + e)) : (e = a - o + s - n, i = this.hiddenTextarea.value.slice(n, n + e)), this.insertChars(i), t.stopPropagation() } }, onCompositionStart: function () { this.inCompositionMode = !0, this.prevCompositionLength = 0, this.compositionStart = this.selectionStart }, onCompositionEnd: function () { this.inCompositionMode = !1 }, onCompositionUpdate: function (t) { var e = t.data; this.selectionStart = this.compositionStart, this.selectionEnd = this.selectionEnd === this.selectionStart ? this.compositionStart + this.prevCompositionLength : this.selectionEnd, this.insertChars(e, !1), this.prevCompositionLength = e.length }, forwardDelete: function (t) { if (this.selectionStart === this.selectionEnd) { if (this.selectionStart === this.text.length) return; this.moveCursorRight(t) } this.removeChars(t) }, copy: function (t) { if (this.selectionStart !== this.selectionEnd) { var e = this.getSelectedText(), i = this._getClipboardData(t); i && i.setData("text", e), fabric.copiedText = e, fabric.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd), t.stopImmediatePropagation(), t.preventDefault(), this._copyDone = !0 } }, paste: function (t) { var e = null, i = this._getClipboardData(t), r = !0; i ? (e = i.getData("text").replace(/\r/g, ""), fabric.copiedTextStyle && fabric.copiedText === e || (r = !1)) : e = fabric.copiedText, e && this.insertChars(e, r), t.stopImmediatePropagation(), t.preventDefault() }, cut: function (t) { this.selectionStart !== this.selectionEnd && (this.copy(t), this.removeChars(t)) }, _getClipboardData: function (t) { return t && t.clipboardData || fabric.window.clipboardData }, _getWidthBeforeCursor: function (t, e) { for (var i, r = this._textLines[t].slice(0, e), n = this._getLineWidth(this.ctx, t), s = this._getLineLeftOffset(n), o = 0, a = r.length; o < a; o++)i = r[o], s += this._getWidthOfChar(this.ctx, i, t, o); return s }, getDownCursorOffset: function (t, e) { var i = this._getSelectionForOffset(t, e), r = this.get2DCursorLocation(i), n = r.lineIndex; if (n === this._textLines.length - 1 || t.metaKey || 34 === t.keyCode) return this.text.length - i; var s = r.charIndex, o = this._getWidthBeforeCursor(n, s), a = this._getIndexOnLine(n + 1, o); return this._textLines[n].slice(s).length + a + 2 }, _getSelectionForOffset: function (t, e) { return t.shiftKey && this.selectionStart !== this.selectionEnd && e ? this.selectionEnd : this.selectionStart }, getUpCursorOffset: function (t, e) { var i = this._getSelectionForOffset(t, e), r = this.get2DCursorLocation(i), n = r.lineIndex; if (0 === n || t.metaKey || 33 === t.keyCode) return -i; var s = r.charIndex, o = this._getWidthBeforeCursor(n, s), a = this._getIndexOnLine(n - 1, o), h = this._textLines[n].slice(0, s); return -this._textLines[n - 1].length + a - h.length }, _getIndexOnLine: function (t, e) { for (var i, r = this._getLineWidth(this.ctx, t), n = this._textLines[t], s = this._getLineLeftOffset(r), o = 0, a = 0, h = n.length; a < h; a++) { var c = n[a], l = this._getWidthOfChar(this.ctx, c, t, a); if ((s += l) > e) { i = !0; var u = s - l, f = s, d = Math.abs(u - e); o = Math.abs(f - e) < d ? a : a - 1; break } } return i || (o = n.length - 1), o }, moveCursorDown: function (t) { this.selectionStart >= this.text.length && this.selectionEnd >= this.text.length || this._moveCursorUpOrDown("Down", t) }, moveCursorUp: function (t) { 0 === this.selectionStart && 0 === this.selectionEnd || this._moveCursorUpOrDown("Up", t) }, _moveCursorUpOrDown: function (t, e) { var i = this["get" + t + "CursorOffset"](e, "right" === this._selectionDirection); e.shiftKey ? this.moveCursorWithShift(i) : this.moveCursorWithoutShift(i), 0 !== i && (this.setSelectionInBoundaries(), this.abortCursorAnimation(), this._currentCursorOpacity = 1, this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea()) }, moveCursorWithShift: function (t) { var e = "left" === this._selectionDirection ? this.selectionStart + t : this.selectionEnd + t; return this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, e), 0 !== t }, moveCursorWithoutShift: function (t) { return t < 0 ? (this.selectionStart += t, this.selectionEnd = this.selectionStart) : (this.selectionEnd += t, this.selectionStart = this.selectionEnd), 0 !== t }, moveCursorLeft: function (t) { 0 === this.selectionStart && 0 === this.selectionEnd || this._moveCursorLeftOrRight("Left", t) }, _move: function (t, e, i) { var r; if (t.altKey) r = this["findWordBoundary" + i](this[e]); else { if (!t.metaKey && 35 !== t.keyCode && 36 !== t.keyCode) return this[e] += "Left" === i ? -1 : 1, !0; r = this["findLineBoundary" + i](this[e]) } if (void 0 !== typeof r && this[e] !== r) return this[e] = r, !0 }, _moveLeft: function (t, e) { return this._move(t, e, "Left") }, _moveRight: function (t, e) { return this._move(t, e, "Right") }, moveCursorLeftWithoutShift: function (t) { var e = !0; return this._selectionDirection = "left", this.selectionEnd === this.selectionStart && 0 !== this.selectionStart && (e = this._moveLeft(t, "selectionStart")), this.selectionEnd = this.selectionStart, e }, moveCursorLeftWithShift: function (t) { return "right" === this._selectionDirection && this.selectionStart !== this.selectionEnd ? this._moveLeft(t, "selectionEnd") : 0 !== this.selectionStart ? (this._selectionDirection = "left", this._moveLeft(t, "selectionStart")) : void 0 }, moveCursorRight: function (t) { this.selectionStart >= this.text.length && this.selectionEnd >= this.text.length || this._moveCursorLeftOrRight("Right", t) }, _moveCursorLeftOrRight: function (t, e) { var i = "moveCursor" + t + "With"; this._currentCursorOpacity = 1, e.shiftKey ? i += "Shift" : i += "outShift", this[i](e) && (this.abortCursorAnimation(), this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea()) }, moveCursorRightWithShift: function (t) { return "left" === this._selectionDirection && this.selectionStart !== this.selectionEnd ? this._moveRight(t, "selectionStart") : this.selectionEnd !== this.text.length ? (this._selectionDirection = "right", this._moveRight(t, "selectionEnd")) : void 0 }, moveCursorRightWithoutShift: function (t) { var e = !0; return this._selectionDirection = "right", this.selectionStart === this.selectionEnd ? (e = this._moveRight(t, "selectionStart"), this.selectionEnd = this.selectionStart) : this.selectionStart = this.selectionEnd, e }, removeChars: function (t) { this.selectionStart === this.selectionEnd ? this._removeCharsNearCursor(t) : this._removeCharsFromTo(this.selectionStart, this.selectionEnd), this.set("dirty", !0), this.setSelectionEnd(this.selectionStart), this._removeExtraneousStyles(), this.canvas && this.canvas.renderAll(), this.setCoords(), this.fire("changed"), this.canvas && this.canvas.fire("text:changed", { target: this }) }, _removeCharsNearCursor: function (t) { if (0 !== this.selectionStart) if (t.metaKey) { var e = this.findLineBoundaryLeft(this.selectionStart); this._removeCharsFromTo(e, this.selectionStart), this.setSelectionStart(e) } else if (t.altKey) { var i = this.findWordBoundaryLeft(this.selectionStart); this._removeCharsFromTo(i, this.selectionStart), this.setSelectionStart(i) } else this._removeSingleCharAndStyle(this.selectionStart), this.setSelectionStart(this.selectionStart - 1) } }), function () { var t = fabric.util.toFixed, e = fabric.Object.NUM_FRACTION_DIGITS; fabric.util.object.extend(fabric.IText.prototype, { _setSVGTextLineText: function (t, e, i, r, n, s) { this._getLineStyle(t) ? this._setSVGTextLineChars(t, e, i, r, s) : fabric.Text.prototype._setSVGTextLineText.call(this, t, e, i, r, n) }, _setSVGTextLineChars: function (t, e, i, r, n) { for (var s = this._textLines[t], o = 0, a = this._getLineLeftOffset(this._getLineWidth(this.ctx, t)) - this.width / 2, h = this._getSVGLineTopOffset(t), c = this._getHeightOfLine(this.ctx, t), l = 0, u = s.length; l < u; l++) { var f = this._getStyleDeclaration(t, l) || {}; e.push(this._createTextCharSpan(s[l], f, a, h.lineTop + h.offset, o)); var d = this._getWidthOfChar(this.ctx, s[l], t, l); f.textBackgroundColor && n.push(this._createTextCharBg(f, a, h.lineTop, c, d, o)), o += d } }, _getSVGLineTopOffset: function (t) { for (var e = 0, i = 0, r = 0; r < t; r++)e += this._getHeightOfLine(this.ctx, r); return i = this._getHeightOfLine(this.ctx, r), { lineTop: e, offset: (this._fontSizeMult - this._fontSizeFraction) * i / (this.lineHeight * this._fontSizeMult) } }, _createTextCharBg: function (i, r, n, s, o, a) { return ['\t\t<rect fill="', i.textBackgroundColor, '" x="', t(r + a, e), '" y="', t(n - this.height / 2, e), '" width="', t(o, e), '" height="', t(s / this.lineHeight, e), '"></rect>\n'].join("") }, _createTextCharSpan: function (i, r, n, s, o) { var a = this.getSvgStyles.call(fabric.util.object.extend({ visible: !0, fill: this.fill, stroke: this.stroke, type: "text", getSvgFilter: fabric.Object.prototype.getSvgFilter }, r)); return ['\t\t\t<tspan x="', t(n + o, e), '" y="', t(s - this.height / 2, e), '" ', r.fontFamily ? 'font-family="' + r.fontFamily.replace(/"/g, "'") + '" ' : "", r.fontSize ? 'font-size="' + r.fontSize + '" ' : "", r.fontStyle ? 'font-style="' + r.fontStyle + '" ' : "", r.fontWeight ? 'font-weight="' + r.fontWeight + '" ' : "", r.textDecoration ? 'text-decoration="' + r.textDecoration + '" ' : "", 'style="', a, '">', fabric.util.string.escapeXml(i), "</tspan>\n"].join("") } }) }(), function (t) { "use strict"; var e = t.fabric || (t.fabric = {}); e.Textbox = e.util.createClass(e.IText, e.Observable, { type: "textbox", minWidth: 20, dynamicMinWidth: 2, __cachedLines: null, lockScalingY: !0, lockScalingFlip: !0, noScaleCache: !1, initialize: function (t, i) { this.callSuper("initialize", t, i), this.setControlsVisibility(e.Textbox.getTextboxControlVisibility()), this.ctx = this.objectCaching ? this._cacheContext : e.util.createCanvasElement().getContext("2d"), this._dimensionAffectingProps.push("width") }, _initDimensions: function (t) { this.__skipDimension || (t || (t = e.util.createCanvasElement().getContext("2d"), this._setTextStyles(t), this.clearContextTop()), this.dynamicMinWidth = 0, this._textLines = this._splitTextIntoLines(t), this.dynamicMinWidth > this.width && this._set("width", this.dynamicMinWidth), this._clearCache(), this.height = this._getTextHeight(t), this.setCoords()) }, _generateStyleMap: function () { for (var t = 0, e = 0, i = 0, r = {}, n = 0; n < this._textLines.length; n++)"\n" === this.text[i] && n > 0 ? (e = 0, i++ , t++) : " " === this.text[i] && n > 0 && (e++ , i++), r[n] = { line: t, offset: e }, i += this._textLines[n].length, e += this._textLines[n].length; return r }, _getStyleDeclaration: function (t, e, i) { if (this._styleMap) { var r = this._styleMap[t]; if (!r) return i ? {} : null; t = r.line, e = r.offset + e } return this.callSuper("_getStyleDeclaration", t, e, i) }, _setStyleDeclaration: function (t, e, i) { var r = this._styleMap[t]; t = r.line, e = r.offset + e, this.styles[t][e] = i }, _deleteStyleDeclaration: function (t, e) { var i = this._styleMap[t]; t = i.line, e = i.offset + e, delete this.styles[t][e] }, _getLineStyle: function (t) { var e = this._styleMap[t]; return this.styles[e.line] }, _setLineStyle: function (t, e) { var i = this._styleMap[t]; this.styles[i.line] = e }, _deleteLineStyle: function (t) { var e = this._styleMap[t]; delete this.styles[e.line] }, _wrapText: function (t, e) { var i, r = e.split(this._reNewline), n = []; for (i = 0; i < r.length; i++)n = n.concat(this._wrapLine(t, r[i], i)); return n }, _measureText: function (t, e, i, r) { var n = 0; r = r || 0; for (var s = 0, o = e.length; s < o; s++)n += this._getWidthOfChar(t, e[s], i, s + r); return n }, _wrapLine: function (t, e, i) { for (var r = 0, n = [], s = "", o = e.split(" "), a = "", h = 0, c = 0, l = 0, u = 0, f = !0, d = this._getWidthOfCharSpacing(), g = 0; g < o.length; g++)a = o[g], c = this._measureText(t, a, i, h), h += a.length, (r += l + c - d) >= this.width && !f ? (n.push(s), s = "", r = c, f = !0) : r += d, f || (s += " "), s += a, l = this._measureText(t, " ", i, h), h++ , f = !1, c > u && (u = c); return g && n.push(s), u > this.dynamicMinWidth && (this.dynamicMinWidth = u - d), n }, _splitTextIntoLines: function (t) { t = t || this.ctx; var e = this.textAlign; this._styleMap = null, t.save(), this._setTextStyles(t), this.textAlign = "left"; var i = this._wrapText(t, this.text); return this.textAlign = e, t.restore(), this._textLines = i, this._styleMap = this._generateStyleMap(), i }, setOnGroup: function (t, e) { "scaleX" === t && (this.set("scaleX", Math.abs(1 / e)), this.set("width", this.get("width") * e / (void 0 === this.__oldScaleX ? 1 : this.__oldScaleX)), this.__oldScaleX = e) }, get2DCursorLocation: function (t) { void 0 === t && (t = this.selectionStart); for (var e = this._textLines.length, i = 0, r = 0; r < e; r++) { var n = this._textLines[r].length; if (t <= i + n) return { lineIndex: r, charIndex: t - i }; i += n, "\n" !== this.text[i] && " " !== this.text[i] || i++ } return { lineIndex: e - 1, charIndex: this._textLines[e - 1].length } }, _getCursorBoundariesOffsets: function (t, e) { for (var i = 0, r = 0, n = this.get2DCursorLocation(), s = this._textLines[n.lineIndex].split(""), o = this._getLineLeftOffset(this._getLineWidth(this.ctx, n.lineIndex)), a = 0; a < n.charIndex; a++)r += this._getWidthOfChar(this.ctx, s[a], n.lineIndex, a); for (a = 0; a < n.lineIndex; a++)i += this._getHeightOfLine(this.ctx, a); return "cursor" === e && (i += (1 - this._fontSizeFraction) * this._getHeightOfLine(this.ctx, n.lineIndex) / this.lineHeight - this.getCurrentCharFontSize(n.lineIndex, n.charIndex) * (1 - this._fontSizeFraction)), { top: i, left: r, lineLeft: o } }, getMinWidth: function () { return Math.max(this.minWidth, this.dynamicMinWidth) }, toObject: function (t) { return this.callSuper("toObject", ["minWidth"].concat(t)) } }), e.Textbox.fromObject = function (t, i, r) { return e.Object._fromObject("Textbox", t, i, r, "text") }, e.Textbox.getTextboxControlVisibility = function () { return { tl: !1, tr: !1, br: !1, bl: !1, ml: !0, mt: !1, mr: !0, mb: !1, mtr: !0 } } }("undefined" != typeof exports ? exports : this), function () { var t = fabric.Canvas.prototype._setObjectScale; fabric.Canvas.prototype._setObjectScale = function (e, i, r, n, s, o, a) { var h = i.target; if (!(h instanceof fabric.Textbox)) return t.call(fabric.Canvas.prototype, e, i, r, n, s, o, a); var c = h.width * (e.x / i.scaleX / (h.width + h.strokeWidth)); return c >= h.getMinWidth() ? (h.set("width", c), !0) : void 0 }, fabric.Group.prototype._refreshControlsVisibility = function () { if (void 0 !== fabric.Textbox) for (var t = this._objects.length; t--;)if (this._objects[t] instanceof fabric.Textbox) return void this.setControlsVisibility(fabric.Textbox.getTextboxControlVisibility()) }, fabric.util.object.extend(fabric.Textbox.prototype, { _removeExtraneousStyles: function () { for (var t in this._styleMap) this._textLines[t] || delete this.styles[this._styleMap[t].line] }, insertCharStyleObject: function (t, e, i) { var r = this._styleMap[t]; t = r.line, e = r.offset + e, fabric.IText.prototype.insertCharStyleObject.apply(this, [t, e, i]) }, insertNewlineStyleObject: function (t, e, i) { var r = this._styleMap[t]; t = r.line, e = r.offset + e, fabric.IText.prototype.insertNewlineStyleObject.apply(this, [t, e, i]) }, shiftLineStyles: function (t, e) { t = this._styleMap[t].line, fabric.IText.prototype.shiftLineStyles.call(this, t, e) }, _getTextOnPreviousLine: function (t) { for (var e = this._textLines[t - 1]; this._styleMap[t - 2] && this._styleMap[t - 2].line === this._styleMap[t - 1].line;)e = this._textLines[t - 2] + e, t--; return e }, removeStyleObject: function (t, e) { var i = this.get2DCursorLocation(e), r = this._styleMap[i.lineIndex], n = r.line, s = r.offset + i.charIndex; this._removeStyleObject(t, i, n, s) } }) }(), function () { var t = fabric.IText.prototype._getNewSelectionStartFromOffset; fabric.IText.prototype._getNewSelectionStartFromOffset = function (e, i, r, n, s) { n = t.call(this, e, i, r, n, s); for (var o = 0, a = 0, h = 0; h < this._textLines.length && !((o += this._textLines[h].length) + a >= n); h++)"\n" !== this.text[o + a] && " " !== this.text[o + a] || a++; return n - h + a } }(), function () { function request(t, e, i) { var r = URL.parse(t); r.port || (r.port = 0 === r.protocol.indexOf("https:") ? 443 : 80); var n = (0 === r.protocol.indexOf("https:") ? HTTPS : HTTP).request({ hostname: r.hostname, port: r.port, path: r.path, method: "GET" }, function (t) { var r = ""; e && t.setEncoding(e), t.on("end", function () { i(r) }), t.on("data", function (e) { 200 === t.statusCode && (r += e) }) }); n.on("error", function (t) { t.errno === process.ECONNREFUSED ? fabric.log("ECONNREFUSED: connection refused to " + r.hostname + ":" + r.port) : fabric.log(t.message), i(null) }), n.end() } function requestFs(t, e) { require("fs").readFile(t, function (t, i) { if (t) throw fabric.log(t), t; e(i) }) } if ("undefined" == typeof document || "undefined" == typeof window) { var DOMParser = require("xmldom").DOMParser, URL = require("url"), HTTP = require("http"), HTTPS = require("https"), Canvas = require("canvas"), Image = require("canvas").Image; fabric.util.loadImage = function (t, e, i) { function r(r) { r ? (n.src = new Buffer(r, "binary"), n._src = t, e && e.call(i, n)) : (n = null, e && e.call(i, null, !0)) } var n = new Image; t && (t instanceof Buffer || 0 === t.indexOf("data")) ? (n.src = n._src = t, e && e.call(i, n)) : t && 0 !== t.indexOf("http") ? requestFs(t, r) : t ? request(t, "binary", r) : e && e.call(i, t) }, fabric.loadSVGFromURL = function (t, e, i) { 0 !== (t = t.replace(/^\n\s*/, "").replace(/\?.*$/, "").trim()).indexOf("http") ? requestFs(t, function (t) { fabric.loadSVGFromString(t.toString(), e, i) }) : request(t, "", function (t) { fabric.loadSVGFromString(t, e, i) }) }, fabric.loadSVGFromString = function (t, e, i) { var r = (new DOMParser).parseFromString(t); fabric.parseSVGDocument(r.documentElement, function (t, i) { e && e(t, i) }, i) }, fabric.util.getScript = function (url, callback) { request(url, "", function (body) { eval(body), callback && callback() }) }, fabric.createCanvasForNode = function (t, e, i, r) { r = r || i; var n = fabric.document.createElement("canvas"), s = new Canvas(t || 600, e || 600, r), o = new Canvas(t || 600, e || 600, r); n.style = {}, n.width = s.width, n.height = s.height, (i = i || {}).nodeCanvas = s, i.nodeCacheCanvas = o; var a = new (fabric.Canvas || fabric.StaticCanvas)(n, i); return a.nodeCanvas = s, a.nodeCacheCanvas = o, a.contextContainer = s.getContext("2d"), a.contextCache = o.getContext("2d"), a.Font = Canvas.Font, a }; var originaInitStatic = fabric.StaticCanvas.prototype._initStatic; fabric.StaticCanvas.prototype._initStatic = function (t, e) { t = t || fabric.document.createElement("canvas"), this.nodeCanvas = new Canvas(t.width, t.height), this.nodeCacheCanvas = new Canvas(t.width, t.height), originaInitStatic.call(this, t, e), this.contextContainer = this.nodeCanvas.getContext("2d"), this.contextCache = this.nodeCacheCanvas.getContext("2d"), this.Font = Canvas.Font }, fabric.StaticCanvas.prototype.createPNGStream = function () { return this.nodeCanvas.createPNGStream() }, fabric.StaticCanvas.prototype.createJPEGStream = function (t) { return this.nodeCanvas.createJPEGStream(t) }, fabric.StaticCanvas.prototype._initRetinaScaling = function () { if (this._isRetinaScaling()) return this.lowerCanvasEl.setAttribute("width", this.width * fabric.devicePixelRatio), this.lowerCanvasEl.setAttribute("height", this.height * fabric.devicePixelRatio), this.nodeCanvas.width = this.width * fabric.devicePixelRatio, this.nodeCanvas.height = this.height * fabric.devicePixelRatio, this.contextContainer.scale(fabric.devicePixelRatio, fabric.devicePixelRatio), this }, fabric.Canvas && (fabric.Canvas.prototype._initRetinaScaling = fabric.StaticCanvas.prototype._initRetinaScaling); var origSetBackstoreDimension = fabric.StaticCanvas.prototype._setBackstoreDimension; fabric.StaticCanvas.prototype._setBackstoreDimension = function (t, e) { return origSetBackstoreDimension.call(this, t, e), this.nodeCanvas[t] = e, this }, fabric.Canvas && (fabric.Canvas.prototype._setBackstoreDimension = fabric.StaticCanvas.prototype._setBackstoreDimension) } }();
// threejs.org/license
(function (m, ja) { "object" === typeof exports && "undefined" !== typeof module ? ja(exports) : "function" === typeof define && define.amd ? define(["exports"], ja) : ja(m.THREE = m.THREE || {}) })(this, function (m) {
	function ja() { } function C(a, b) { this.x = a || 0; this.y = b || 0 } function K() { this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]; 0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.") } function Z(a, b, c, d) { this._x = a || 0; this._y = b || 0; this._z = c || 0; this._w = void 0 !== d ? d : 1 }
	function p(a, b, c) { this.x = a || 0; this.y = b || 0; this.z = c || 0 } function ra() { this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]; 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.") } function ea(a, b, c, d, e, f, g, h, k, l) {
		Object.defineProperty(this, "id", { value: kf++ }); this.uuid = R.generateUUID(); this.name = ""; this.image = void 0 !== a ? a : ea.DEFAULT_IMAGE; this.mipmaps = []; this.mapping = void 0 !== b ? b : ea.DEFAULT_MAPPING; this.wrapS = void 0 !== c ? c : 1001; this.wrapT = void 0 !== d ? d : 1001; this.magFilter =
			void 0 !== e ? e : 1006; this.minFilter = void 0 !== f ? f : 1008; this.anisotropy = void 0 !== k ? k : 1; this.format = void 0 !== g ? g : 1023; this.type = void 0 !== h ? h : 1009; this.offset = new C(0, 0); this.repeat = new C(1, 1); this.center = new C(0, 0); this.rotation = 0; this.matrixAutoUpdate = !0; this.matrix = new ra; this.generateMipmaps = !0; this.premultiplyAlpha = !1; this.flipY = !0; this.unpackAlignment = 4; this.encoding = void 0 !== l ? l : 3E3; this.version = 0; this.onUpdate = null
	} function da(a, b, c, d) { this.x = a || 0; this.y = b || 0; this.z = c || 0; this.w = void 0 !== d ? d : 1 } function Hb(a,
		b, c) { this.uuid = R.generateUUID(); this.width = a; this.height = b; this.scissor = new da(0, 0, a, b); this.scissorTest = !1; this.viewport = new da(0, 0, a, b); c = c || {}; void 0 === c.minFilter && (c.minFilter = 1006); this.texture = new ea(void 0, void 0, c.wrapS, c.wrapT, c.magFilter, c.minFilter, c.format, c.type, c.anisotropy, c.encoding); this.depthBuffer = void 0 !== c.depthBuffer ? c.depthBuffer : !0; this.stencilBuffer = void 0 !== c.stencilBuffer ? c.stencilBuffer : !0; this.depthTexture = void 0 !== c.depthTexture ? c.depthTexture : null } function Ib(a, b, c) {
			Hb.call(this,
				a, b, c); this.activeMipMapLevel = this.activeCubeFace = 0
		} function fb(a, b, c, d, e, f, g, h, k, l, q, n) { ea.call(this, null, f, g, h, k, l, d, e, q, n); this.image = { data: a, width: b, height: c }; this.magFilter = void 0 !== k ? k : 1003; this.minFilter = void 0 !== l ? l : 1003; this.flipY = this.generateMipmaps = !1; this.unpackAlignment = 1 } function Ua(a, b, c, d, e, f, g, h, k, l) { a = void 0 !== a ? a : []; ea.call(this, a, void 0 !== b ? b : 301, c, d, e, f, g, h, k, l); this.flipY = !1 } function Jb(a, b, c) {
			var d = a[0]; if (0 >= d || 0 < d) return a; var e = b * c, f = we[e]; void 0 === f && (f = new Float32Array(e),
				we[e] = f); if (0 !== b) for (d.toArray(f, 0), d = 1, e = 0; d !== b; ++d)e += c, a[d].toArray(f, e); return f
		} function xe(a, b) { var c = ye[b]; void 0 === c && (c = new Int32Array(b), ye[b] = c); for (var d = 0; d !== b; ++d)c[d] = a.allocTextureUnit(); return c } function lf(a, b) { a.uniform1f(this.addr, b) } function mf(a, b) { a.uniform1i(this.addr, b) } function nf(a, b) { void 0 === b.x ? a.uniform2fv(this.addr, b) : a.uniform2f(this.addr, b.x, b.y) } function of(a, b) {
		void 0 !== b.x ? a.uniform3f(this.addr, b.x, b.y, b.z) : void 0 !== b.r ? a.uniform3f(this.addr, b.r, b.g, b.b) : a.uniform3fv(this.addr,
			b)
		} function pf(a, b) { void 0 === b.x ? a.uniform4fv(this.addr, b) : a.uniform4f(this.addr, b.x, b.y, b.z, b.w) } function qf(a, b) { a.uniformMatrix2fv(this.addr, !1, b.elements || b) } function rf(a, b) { void 0 === b.elements ? a.uniformMatrix3fv(this.addr, !1, b) : (ze.set(b.elements), a.uniformMatrix3fv(this.addr, !1, ze)) } function sf(a, b) { void 0 === b.elements ? a.uniformMatrix4fv(this.addr, !1, b) : (Ae.set(b.elements), a.uniformMatrix4fv(this.addr, !1, Ae)) } function tf(a, b, c) {
			var d = c.allocTextureUnit(); a.uniform1i(this.addr, d); c.setTexture2D(b ||
				Be, d)
		} function uf(a, b, c) { var d = c.allocTextureUnit(); a.uniform1i(this.addr, d); c.setTextureCube(b || Ce, d) } function De(a, b) { a.uniform2iv(this.addr, b) } function Ee(a, b) { a.uniform3iv(this.addr, b) } function Fe(a, b) { a.uniform4iv(this.addr, b) } function vf(a) {
			switch (a) {
				case 5126: return lf; case 35664: return nf; case 35665: return of; case 35666: return pf; case 35674: return qf; case 35675: return rf; case 35676: return sf; case 35678: case 36198: return tf; case 35680: return uf; case 5124: case 35670: return mf; case 35667: case 35671: return De;
				case 35668: case 35672: return Ee; case 35669: case 35673: return Fe
			}
		} function wf(a, b) { a.uniform1fv(this.addr, b) } function xf(a, b) { a.uniform1iv(this.addr, b) } function yf(a, b) { a.uniform2fv(this.addr, Jb(b, this.size, 2)) } function zf(a, b) { a.uniform3fv(this.addr, Jb(b, this.size, 3)) } function Af(a, b) { a.uniform4fv(this.addr, Jb(b, this.size, 4)) } function Bf(a, b) { a.uniformMatrix2fv(this.addr, !1, Jb(b, this.size, 4)) } function Cf(a, b) { a.uniformMatrix3fv(this.addr, !1, Jb(b, this.size, 9)) } function Df(a, b) {
			a.uniformMatrix4fv(this.addr,
				!1, Jb(b, this.size, 16))
		} function Ef(a, b, c) { var d = b.length, e = xe(c, d); a.uniform1iv(this.addr, e); for (a = 0; a !== d; ++a)c.setTexture2D(b[a] || Be, e[a]) } function Ff(a, b, c) { var d = b.length, e = xe(c, d); a.uniform1iv(this.addr, e); for (a = 0; a !== d; ++a)c.setTextureCube(b[a] || Ce, e[a]) } function Gf(a) {
			switch (a) {
				case 5126: return wf; case 35664: return yf; case 35665: return zf; case 35666: return Af; case 35674: return Bf; case 35675: return Cf; case 35676: return Df; case 35678: return Ef; case 35680: return Ff; case 5124: case 35670: return xf;
				case 35667: case 35671: return De; case 35668: case 35672: return Ee; case 35669: case 35673: return Fe
			}
		} function Hf(a, b, c) { this.id = a; this.addr = c; this.setValue = vf(b.type) } function If(a, b, c) { this.id = a; this.addr = c; this.size = b.size; this.setValue = Gf(b.type) } function Ge(a) { this.id = a; this.seq = []; this.map = {} } function gb(a, b, c) {
		this.seq = []; this.map = {}; this.renderer = c; c = a.getProgramParameter(b, a.ACTIVE_UNIFORMS); for (var d = 0; d < c; ++d) {
			var e = a.getActiveUniform(b, d), f = a.getUniformLocation(b, e.name), g = this, h = e.name, k =
				h.length; for (Od.lastIndex = 0; ;) { var l = Od.exec(h), q = Od.lastIndex, n = l[1], t = l[3]; "]" === l[2] && (n |= 0); if (void 0 === t || "[" === t && q + 2 === k) { h = g; e = void 0 === t ? new Hf(n, e, f) : new If(n, e, f); h.seq.push(e); h.map[e.id] = e; break } else t = g.map[n], void 0 === t && (t = new Ge(n), n = g, g = t, n.seq.push(g), n.map[g.id] = g), g = t }
		}
		} function H(a, b, c) { return void 0 === b && void 0 === c ? this.set(a) : this.setRGB(a, b, c) } function kd(a, b) { this.min = void 0 !== a ? a : new C(Infinity, Infinity); this.max = void 0 !== b ? b : new C(-Infinity, -Infinity) } function Jf(a, b, c,
			d, e) {
				var f, g, h, k, l, q, n, t, r, m, v, w, x, z, I, B; this.render = function (a, u, za, la) {
					if (0 !== a.length) {
						u = new p; var J = la.w / la.z, ta = .5 * la.z, Va = .5 * la.w, L = 16 / la.w, Y = new C(L * J, L), ua = new p(1, 1, 0), M = new C(1, 1), V = new kd; V.min.set(la.x, la.y); V.max.set(la.x + (la.z - 16), la.y + (la.w - 16)); if (void 0 === z) {
							var L = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]), y = new Uint16Array([0, 1, 2, 0, 2, 3]); v = b.createBuffer(); w = b.createBuffer(); b.bindBuffer(b.ARRAY_BUFFER, v); b.bufferData(b.ARRAY_BUFFER, L, b.STATIC_DRAW); b.bindBuffer(b.ELEMENT_ARRAY_BUFFER,
								w); b.bufferData(b.ELEMENT_ARRAY_BUFFER, y, b.STATIC_DRAW); I = b.createTexture(); B = b.createTexture(); c.bindTexture(b.TEXTURE_2D, I); b.texImage2D(b.TEXTURE_2D, 0, b.RGB, 16, 16, 0, b.RGB, b.UNSIGNED_BYTE, null); b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE); b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE); b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.NEAREST); b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.NEAREST); c.bindTexture(b.TEXTURE_2D, B); b.texImage2D(b.TEXTURE_2D, 0,
									b.RGBA, 16, 16, 0, b.RGBA, b.UNSIGNED_BYTE, null); b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE); b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE); b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.NEAREST); b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.NEAREST); var L = x = {
										vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\n\tvUV = uv;\n\tvec2 pos = position;\n\tif ( renderType == 2 ) {\n\t\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\n\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\n\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\n\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\n\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\n\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\n\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\n\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\n\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\n\t\tvVisibility =        visibility.r / 9.0;\n\t\tvVisibility *= 1.0 - visibility.g / 9.0;\n\t\tvVisibility *=       visibility.b / 9.0;\n\t\tvVisibility *= 1.0 - visibility.a / 9.0;\n\t\tpos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\n\t\tpos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n\t}\n\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
										fragmentShader: "uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\n\tif ( renderType == 0 ) {\n\t\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n\t} else if ( renderType == 1 ) {\n\t\tgl_FragColor = texture2D( map, vUV );\n\t} else {\n\t\tvec4 texture = texture2D( map, vUV );\n\t\ttexture.a *= opacity * vVisibility;\n\t\tgl_FragColor = texture;\n\t\tgl_FragColor.rgb *= color;\n\t}\n}"
									}, y = b.createProgram(),
										A = b.createShader(b.FRAGMENT_SHADER), aa = b.createShader(b.VERTEX_SHADER), D = "precision " + e.precision + " float;\n"; b.shaderSource(A, D + L.fragmentShader); b.shaderSource(aa, D + L.vertexShader); b.compileShader(A); b.compileShader(aa); b.attachShader(y, A); b.attachShader(y, aa); b.linkProgram(y); z = y; r = b.getAttribLocation(z, "position"); m = b.getAttribLocation(z, "uv"); f = b.getUniformLocation(z, "renderType"); g = b.getUniformLocation(z, "map"); h = b.getUniformLocation(z, "occlusionMap"); k = b.getUniformLocation(z, "opacity"); l = b.getUniformLocation(z,
											"color"); q = b.getUniformLocation(z, "scale"); n = b.getUniformLocation(z, "rotation"); t = b.getUniformLocation(z, "screenPosition")
						} c.useProgram(z); c.initAttributes(); c.enableAttribute(r); c.enableAttribute(m); c.disableUnusedAttributes(); b.uniform1i(h, 0); b.uniform1i(g, 1); b.bindBuffer(b.ARRAY_BUFFER, v); b.vertexAttribPointer(r, 2, b.FLOAT, !1, 16, 0); b.vertexAttribPointer(m, 2, b.FLOAT, !1, 16, 8); b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, w); c.disable(b.CULL_FACE); c.buffers.depth.setMask(!1); y = 0; for (A = a.length; y < A; y++)if (L =
							16 / la.w, Y.set(L * J, L), aa = a[y], u.set(aa.matrixWorld.elements[12], aa.matrixWorld.elements[13], aa.matrixWorld.elements[14]), u.applyMatrix4(za.matrixWorldInverse), u.applyMatrix4(za.projectionMatrix), ua.copy(u), M.x = la.x + ua.x * ta + ta - 8, M.y = la.y + ua.y * Va + Va - 8, !0 === V.containsPoint(M)) {
								c.activeTexture(b.TEXTURE0); c.bindTexture(b.TEXTURE_2D, null); c.activeTexture(b.TEXTURE1); c.bindTexture(b.TEXTURE_2D, I); b.copyTexImage2D(b.TEXTURE_2D, 0, b.RGB, M.x, M.y, 16, 16, 0); b.uniform1i(f, 0); b.uniform2f(q, Y.x, Y.y); b.uniform3f(t,
									ua.x, ua.y, ua.z); c.disable(b.BLEND); c.enable(b.DEPTH_TEST); b.drawElements(b.TRIANGLES, 6, b.UNSIGNED_SHORT, 0); c.activeTexture(b.TEXTURE0); c.bindTexture(b.TEXTURE_2D, B); b.copyTexImage2D(b.TEXTURE_2D, 0, b.RGBA, M.x, M.y, 16, 16, 0); b.uniform1i(f, 1); c.disable(b.DEPTH_TEST); c.activeTexture(b.TEXTURE1); c.bindTexture(b.TEXTURE_2D, I); b.drawElements(b.TRIANGLES, 6, b.UNSIGNED_SHORT, 0); aa.positionScreen.copy(ua); aa.customUpdateCallback ? aa.customUpdateCallback(aa) : aa.updateLensFlares(); b.uniform1i(f, 2); c.enable(b.BLEND);
							for (var D = 0, H = aa.lensFlares.length; D < H; D++) { var E = aa.lensFlares[D]; .001 < E.opacity && .001 < E.scale && (ua.x = E.x, ua.y = E.y, ua.z = E.z, L = E.size * E.scale / la.w, Y.x = L * J, Y.y = L, b.uniform3f(t, ua.x, ua.y, ua.z), b.uniform2f(q, Y.x, Y.y), b.uniform1f(n, E.rotation), b.uniform1f(k, E.opacity), b.uniform3f(l, E.color.r, E.color.g, E.color.b), c.setBlending(E.blending, E.blendEquation, E.blendSrc, E.blendDst), d.setTexture2D(E.texture, 1), b.drawElements(b.TRIANGLES, 6, b.UNSIGNED_SHORT, 0)) }
						} c.enable(b.CULL_FACE); c.enable(b.DEPTH_TEST); c.buffers.depth.setMask(!0);
						c.reset()
					}
				}
	} function tc(a, b, c, d, e, f, g, h, k) { ea.call(this, a, b, c, d, e, f, g, h, k); this.needsUpdate = !0 } function Kf(a, b, c, d, e) {
		var f, g, h, k, l, q, n, t, r, m, v, w, x, z, I, B, J; function ta(a, b) { return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : b.id - a.id } var za, la, ha, He, Va = new p, L = new Z, C = new p; this.render = function (u, p, V) {
			if (0 !== u.length) {
				if (void 0 === ha) {
					var M = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]), y = new Uint16Array([0, 1, 2, 0, 2, 3]); za = b.createBuffer(); la = b.createBuffer();
					b.bindBuffer(b.ARRAY_BUFFER, za); b.bufferData(b.ARRAY_BUFFER, M, b.STATIC_DRAW); b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, la); b.bufferData(b.ELEMENT_ARRAY_BUFFER, y, b.STATIC_DRAW); M = b.createProgram(); y = b.createShader(b.VERTEX_SHADER); var Y = b.createShader(b.FRAGMENT_SHADER); b.shaderSource(y, ["precision " + e.precision + " float;", "#define SHADER_NAME SpriteMaterial\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float fogDepth;\nvoid main() {\n\tvUV = uvOffset + uv * uvScale;\n\tvec2 alignedPosition = position * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tvec4 mvPosition;\n\tmvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\tfogDepth = - mvPosition.z;\n}"].join("\n"));
					b.shaderSource(Y, ["precision " + e.precision + " float;", "#define SHADER_NAME SpriteMaterial\nuniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvarying float fogDepth;\nvoid main() {\n\tvec4 texture = texture2D( map, vUV );\n\tgl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\n\tif ( gl_FragColor.a < alphaTest ) discard;\n\tif ( fogType > 0 ) {\n\t\tfloat fogFactor = 0.0;\n\t\tif ( fogType == 1 ) {\n\t\t\tfogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t\t} else {\n\t\t\tconst float LOG2 = 1.442695;\n\t\t\tfogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );\n\t\t\tfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n\t\t}\n\t\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\t}\n}"].join("\n"));
					b.compileShader(y); b.compileShader(Y); b.attachShader(M, y); b.attachShader(M, Y); b.linkProgram(M); ha = M; B = b.getAttribLocation(ha, "position"); J = b.getAttribLocation(ha, "uv"); f = b.getUniformLocation(ha, "uvOffset"); g = b.getUniformLocation(ha, "uvScale"); h = b.getUniformLocation(ha, "rotation"); k = b.getUniformLocation(ha, "scale"); l = b.getUniformLocation(ha, "color"); q = b.getUniformLocation(ha, "map"); n = b.getUniformLocation(ha, "opacity"); t = b.getUniformLocation(ha, "modelViewMatrix"); r = b.getUniformLocation(ha, "projectionMatrix");
					m = b.getUniformLocation(ha, "fogType"); v = b.getUniformLocation(ha, "fogDensity"); w = b.getUniformLocation(ha, "fogNear"); x = b.getUniformLocation(ha, "fogFar"); z = b.getUniformLocation(ha, "fogColor"); b.getUniformLocation(ha, "fogDepth"); I = b.getUniformLocation(ha, "alphaTest"); M = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"); M.width = 8; M.height = 8; y = M.getContext("2d"); y.fillStyle = "white"; y.fillRect(0, 0, 8, 8); He = new tc(M)
				} c.useProgram(ha); c.initAttributes(); c.enableAttribute(B); c.enableAttribute(J);
				c.disableUnusedAttributes(); c.disable(b.CULL_FACE); c.enable(b.BLEND); b.bindBuffer(b.ARRAY_BUFFER, za); b.vertexAttribPointer(B, 2, b.FLOAT, !1, 16, 0); b.vertexAttribPointer(J, 2, b.FLOAT, !1, 16, 8); b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, la); b.uniformMatrix4fv(r, !1, V.projectionMatrix.elements); c.activeTexture(b.TEXTURE0); b.uniform1i(q, 0); y = M = 0; (Y = p.fog) ? (b.uniform3f(z, Y.color.r, Y.color.g, Y.color.b), Y.isFog ? (b.uniform1f(w, Y.near), b.uniform1f(x, Y.far), b.uniform1i(m, 1), y = M = 1) : Y.isFogExp2 && (b.uniform1f(v, Y.density),
					b.uniform1i(m, 2), y = M = 2)) : (b.uniform1i(m, 0), y = M = 0); for (var A = 0, ua = u.length; A < ua; A++)Y = u[A], Y.modelViewMatrix.multiplyMatrices(V.matrixWorldInverse, Y.matrixWorld), Y.z = -Y.modelViewMatrix.elements[14]; u.sort(ta); for (var E = [], A = 0, ua = u.length; A < ua; A++) {
						Y = u[A]; var G = Y.material; if (!1 !== G.visible) {
							Y.onBeforeRender(a, p, V, void 0, G, void 0); b.uniform1f(I, G.alphaTest); b.uniformMatrix4fv(t, !1, Y.modelViewMatrix.elements); Y.matrixWorld.decompose(Va, L, C); E[0] = C.x; E[1] = C.y; var D = 0; p.fog && G.fog && (D = y); M !== D && (b.uniform1i(m,
								D), M = D); null !== G.map ? (b.uniform2f(f, G.map.offset.x, G.map.offset.y), b.uniform2f(g, G.map.repeat.x, G.map.repeat.y)) : (b.uniform2f(f, 0, 0), b.uniform2f(g, 1, 1)); b.uniform1f(n, G.opacity); b.uniform3f(l, G.color.r, G.color.g, G.color.b); b.uniform1f(h, G.rotation); b.uniform2fv(k, E); c.setBlending(G.blending, G.blendEquation, G.blendSrc, G.blendDst, G.blendEquationAlpha, G.blendSrcAlpha, G.blendDstAlpha, G.premultipliedAlpha); c.buffers.depth.setTest(G.depthTest); c.buffers.depth.setMask(G.depthWrite); c.buffers.color.setMask(G.colorWrite);
							d.setTexture2D(G.map || He, 0); b.drawElements(b.TRIANGLES, 6, b.UNSIGNED_SHORT, 0); Y.onAfterRender(a, p, V, void 0, G, void 0)
						}
					} c.enable(b.CULL_FACE); c.reset()
			}
		}
	} function Q() {
		Object.defineProperty(this, "id", { value: Lf++ }); this.uuid = R.generateUUID(); this.name = ""; this.type = "Material"; this.lights = this.fog = !0; this.blending = 1; this.side = 0; this.flatShading = !1; this.vertexColors = 0; this.opacity = 1; this.transparent = !1; this.blendSrc = 204; this.blendDst = 205; this.blendEquation = 100; this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha =
			null; this.depthFunc = 3; this.depthWrite = this.depthTest = !0; this.clippingPlanes = null; this.clipShadows = this.clipIntersection = !1; this.colorWrite = !0; this.precision = null; this.polygonOffset = !1; this.polygonOffsetUnits = this.polygonOffsetFactor = 0; this.dithering = !1; this.alphaTest = 0; this.premultipliedAlpha = !1; this.overdraw = 0; this.visible = !0; this.userData = {}; this.needsUpdate = !0
	} function Wa(a) {
		Q.call(this); this.type = "MeshDepthMaterial"; this.depthPacking = 3200; this.morphTargets = this.skinning = !1; this.displacementMap =
			this.alphaMap = this.map = null; this.displacementScale = 1; this.displacementBias = 0; this.wireframe = !1; this.wireframeLinewidth = 1; this.lights = this.fog = !1; this.setValues(a)
	} function Xa(a) { Q.call(this); this.type = "MeshDistanceMaterial"; this.referencePosition = new p; this.nearDistance = 1; this.farDistance = 1E3; this.morphTargets = this.skinning = !1; this.displacementMap = this.alphaMap = this.map = null; this.displacementScale = 1; this.displacementBias = 0; this.lights = this.fog = !1; this.setValues(a) } function Oa(a, b) {
	this.min = void 0 !==
		a ? a : new p(Infinity, Infinity, Infinity); this.max = void 0 !== b ? b : new p(-Infinity, -Infinity, -Infinity)
	} function Da(a, b) { this.center = void 0 !== a ? a : new p; this.radius = void 0 !== b ? b : 0 } function Aa(a, b) { this.normal = void 0 !== a ? a : new p(1, 0, 0); this.constant = void 0 !== b ? b : 0 } function ld(a, b, c, d, e, f) { this.planes = [void 0 !== a ? a : new Aa, void 0 !== b ? b : new Aa, void 0 !== c ? c : new Aa, void 0 !== d ? d : new Aa, void 0 !== e ? e : new Aa, void 0 !== f ? f : new Aa] } function Ie(a, b, c) {
		function d(b, c, d, e, f, g) {
			var h = b.geometry; var k = n; var l = b.customDepthMaterial;
			d && (k = t, l = b.customDistanceMaterial); l ? k = l : (l = !1, c.morphTargets && (h && h.isBufferGeometry ? l = h.morphAttributes && h.morphAttributes.position && 0 < h.morphAttributes.position.length : h && h.isGeometry && (l = h.morphTargets && 0 < h.morphTargets.length)), b.isSkinnedMesh && !1 === c.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", b), b = b.isSkinnedMesh && c.skinning, h = 0, l && (h |= 1), b && (h |= 2), k = k[h]); a.localClippingEnabled && !0 === c.clipShadows && 0 !== c.clippingPlanes.length && (h =
				k.uuid, l = c.uuid, b = r[h], void 0 === b && (b = {}, r[h] = b), h = b[l], void 0 === h && (h = k.clone(), b[l] = h), k = h); k.visible = c.visible; k.wireframe = c.wireframe; l = c.side; B.renderSingleSided && 2 == l && (l = 0); B.renderReverseSided && (0 === l ? l = 1 : 1 === l && (l = 0)); k.side = l; k.clipShadows = c.clipShadows; k.clippingPlanes = c.clippingPlanes; k.clipIntersection = c.clipIntersection; k.wireframeLinewidth = c.wireframeLinewidth; k.linewidth = c.linewidth; d && k.isMeshDistanceMaterial && (k.referencePosition.copy(e), k.nearDistance = f, k.farDistance = g); return k
		}
		function e(c, g, h, k) {
			var l; if (!1 !== c.visible) {
				if (c.layers.test(g.layers) && (c.isMesh || c.isLine || c.isPoints) && c.castShadow && (!c.frustumCulled || f.intersectsObject(c))) {
					c.modelViewMatrix.multiplyMatrices(h.matrixWorldInverse, c.matrixWorld); var n = b.update(c), t = c.material; if (Array.isArray(t)) for (var r = n.groups, m = 0, z = r.length; m < z; m++) { var u = r[m]; (l = t[u.materialIndex]) && l.visible && (l = d(c, l, k, q, h.near, h.far), a.renderBufferDirect(h, null, n, l, c, u)) } else t.visible && (l = d(c, t, k, q, h.near, h.far), a.renderBufferDirect(h,
						null, n, l, c, null))
				} c = c.children; n = 0; for (t = c.length; n < t; n++)e(c[n], g, h, k)
			}
		} var f = new ld, g = new K, h = new C, k = new C(c, c), l = new p, q = new p, n = Array(4), t = Array(4), r = {}, m = [new p(1, 0, 0), new p(-1, 0, 0), new p(0, 0, 1), new p(0, 0, -1), new p(0, 1, 0), new p(0, -1, 0)], v = [new p(0, 1, 0), new p(0, 1, 0), new p(0, 1, 0), new p(0, 1, 0), new p(0, 0, 1), new p(0, 0, -1)], w = [new da, new da, new da, new da, new da, new da]; for (c = 0; 4 !== c; ++c) {
			var x = 0 !== (c & 1), z = 0 !== (c & 2), I = new Wa({ depthPacking: 3201, morphTargets: x, skinning: z }); n[c] = I; x = new Xa({
				morphTargets: x,
				skinning: z
			}); t[c] = x
		} var B = this; this.enabled = !1; this.autoUpdate = !0; this.needsUpdate = !1; this.type = 1; this.renderSingleSided = this.renderReverseSided = !0; this.render = function (b, c, d) {
			if (!1 !== B.enabled && (!1 !== B.autoUpdate || !1 !== B.needsUpdate) && 0 !== b.length) {
				var n = a.state; n.disable(a.context.BLEND); n.buffers.color.setClear(1, 1, 1, 1); n.buffers.depth.setTest(!0); n.setScissorTest(!1); for (var t, r = 0, z = b.length; r < z; r++) {
					var u = b[r]; t = u.shadow; var I = u && u.isPointLight; if (void 0 === t) console.warn("THREE.WebGLShadowMap:",
						u, "has no shadow."); else {
							var p = t.camera; h.copy(t.mapSize); h.min(k); if (I) { var x = h.x, J = h.y; w[0].set(2 * x, J, x, J); w[1].set(0, J, x, J); w[2].set(3 * x, J, x, J); w[3].set(x, J, x, J); w[4].set(3 * x, 0, x, J); w[5].set(x, 0, x, J); h.x *= 4; h.y *= 2 } null === t.map && (t.map = new Hb(h.x, h.y, { minFilter: 1003, magFilter: 1003, format: 1023 }), t.map.texture.name = u.name + ".shadowMap", p.updateProjectionMatrix()); t.isSpotLightShadow && t.update(u); x = t.map; J = t.matrix; q.setFromMatrixPosition(u.matrixWorld); p.position.copy(q); I ? (t = 6, J.makeTranslation(-q.x,
								-q.y, -q.z)) : (t = 1, l.setFromMatrixPosition(u.target.matrixWorld), p.lookAt(l), p.updateMatrixWorld(), J.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), J.multiply(p.projectionMatrix), J.multiply(p.matrixWorldInverse)); a.setRenderTarget(x); a.clear(); for (u = 0; u < t; u++)I && (l.copy(p.position), l.add(m[u]), p.up.copy(v[u]), p.lookAt(l), p.updateMatrixWorld(), n.viewport(w[u])), g.multiplyMatrices(p.projectionMatrix, p.matrixWorldInverse), f.setFromMatrix(g), e(c, d, p, I)
					}
				} B.needsUpdate = !1
			}
		}
	} function Mf(a) {
		var b = {}; return {
			get: function (a) {
			a.isInterleavedBufferAttribute &&
				(a = a.data); return b[a.uuid]
			}, remove: function (c) { c.isInterleavedBufferAttribute && (c = c.data); var d = b[c.uuid]; d && (a.deleteBuffer(d.buffer), delete b[c.uuid]) }, update: function (c, d) {
			c.isInterleavedBufferAttribute && (c = c.data); var e = b[c.uuid]; if (void 0 === e) {
				var e = c.uuid, f = c.array, g = c.dynamic ? a.DYNAMIC_DRAW : a.STATIC_DRAW, h = a.createBuffer(); a.bindBuffer(d, h); a.bufferData(d, f, g); c.onUploadCallback(); d = a.FLOAT; f instanceof Float32Array ? d = a.FLOAT : f instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") :
					f instanceof Uint16Array ? d = a.UNSIGNED_SHORT : f instanceof Int16Array ? d = a.SHORT : f instanceof Uint32Array ? d = a.UNSIGNED_INT : f instanceof Int32Array ? d = a.INT : f instanceof Int8Array ? d = a.BYTE : f instanceof Uint8Array && (d = a.UNSIGNED_BYTE); b[e] = { buffer: h, type: d, bytesPerElement: f.BYTES_PER_ELEMENT, version: c.version }
			} else e.version < c.version && (f = c, h = f.array, g = f.updateRange, a.bindBuffer(d, e.buffer), !1 === f.dynamic ? a.bufferData(d, h, a.STATIC_DRAW) : -1 === g.count ? a.bufferSubData(d, 0, h) : 0 === g.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") :
				(a.bufferSubData(d, g.offset * h.BYTES_PER_ELEMENT, h.subarray(g.offset, g.offset + g.count)), g.count = -1), e.version = c.version)
			}
		}
	} function Ya(a, b, c, d) { this._x = a || 0; this._y = b || 0; this._z = c || 0; this._order = d || Ya.DefaultOrder } function Pd() { this.mask = 1 } function A() {
		Object.defineProperty(this, "id", { value: Nf++ }); this.uuid = R.generateUUID(); this.name = ""; this.type = "Object3D"; this.parent = null; this.children = []; this.up = A.DefaultUp.clone(); var a = new p, b = new Ya, c = new Z, d = new p(1, 1, 1); b.onChange(function () {
			c.setFromEuler(b,
				!1)
		}); c.onChange(function () { b.setFromQuaternion(c, void 0, !1) }); Object.defineProperties(this, { position: { enumerable: !0, value: a }, rotation: { enumerable: !0, value: b }, quaternion: { enumerable: !0, value: c }, scale: { enumerable: !0, value: d }, modelViewMatrix: { value: new K }, normalMatrix: { value: new ra } }); this.matrix = new K; this.matrixWorld = new K; this.matrixAutoUpdate = A.DefaultMatrixAutoUpdate; this.matrixWorldNeedsUpdate = !1; this.layers = new Pd; this.visible = !0; this.receiveShadow = this.castShadow = !1; this.frustumCulled = !0; this.renderOrder =
			0; this.userData = {}
	} function La() { A.call(this); this.type = "Camera"; this.matrixWorldInverse = new K; this.projectionMatrix = new K } function Kb(a, b, c, d, e, f) { La.call(this); this.type = "OrthographicCamera"; this.zoom = 1; this.view = null; this.left = a; this.right = b; this.top = c; this.bottom = d; this.near = void 0 !== e ? e : .1; this.far = void 0 !== f ? f : 2E3; this.updateProjectionMatrix() } function Pa(a, b, c, d, e, f) {
	this.a = a; this.b = b; this.c = c; this.normal = d && d.isVector3 ? d : new p; this.vertexNormals = Array.isArray(d) ? d : []; this.color = e && e.isColor ?
		e : new H; this.vertexColors = Array.isArray(e) ? e : []; this.materialIndex = void 0 !== f ? f : 0
	} function N() {
		Object.defineProperty(this, "id", { value: Of += 2 }); this.uuid = R.generateUUID(); this.name = ""; this.type = "Geometry"; this.vertices = []; this.colors = []; this.faces = []; this.faceVertexUvs = [[]]; this.morphTargets = []; this.morphNormals = []; this.skinWeights = []; this.skinIndices = []; this.lineDistances = []; this.boundingSphere = this.boundingBox = null; this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate =
			this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1
	} function P(a, b, c) { if (Array.isArray(a)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.uuid = R.generateUUID(); this.name = ""; this.array = a; this.itemSize = b; this.count = void 0 !== a ? a.length / b : 0; this.normalized = !0 === c; this.dynamic = !1; this.updateRange = { offset: 0, count: -1 }; this.onUploadCallback = function () { }; this.version = 0 } function uc(a, b, c) { P.call(this, new Int8Array(a), b, c) } function vc(a, b, c) {
		P.call(this, new Uint8Array(a),
			b, c)
	} function wc(a, b, c) { P.call(this, new Uint8ClampedArray(a), b, c) } function xc(a, b, c) { P.call(this, new Int16Array(a), b, c) } function hb(a, b, c) { P.call(this, new Uint16Array(a), b, c) } function yc(a, b, c) { P.call(this, new Int32Array(a), b, c) } function ib(a, b, c) { P.call(this, new Uint32Array(a), b, c) } function y(a, b, c) { P.call(this, new Float32Array(a), b, c) } function zc(a, b, c) { P.call(this, new Float64Array(a), b, c) } function Je() {
	this.indices = []; this.vertices = []; this.normals = []; this.colors = []; this.uvs = []; this.uvs2 = []; this.groups =
		[]; this.morphTargets = {}; this.skinWeights = []; this.skinIndices = []; this.boundingSphere = this.boundingBox = null; this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1
	} function Qd(a) { if (0 === a.length) return -Infinity; for (var b = a[0], c = 1, d = a.length; c < d; ++c)a[c] > b && (b = a[c]); return b } function D() {
		Object.defineProperty(this, "id", { value: Pf += 2 }); this.uuid = R.generateUUID(); this.name = ""; this.type = "BufferGeometry"; this.index = null; this.attributes = {}; this.morphAttributes =
			{}; this.groups = []; this.boundingSphere = this.boundingBox = null; this.drawRange = { start: 0, count: Infinity }
	} function Lb(a, b, c, d, e, f) { N.call(this); this.type = "BoxGeometry"; this.parameters = { width: a, height: b, depth: c, widthSegments: d, heightSegments: e, depthSegments: f }; this.fromBufferGeometry(new jb(a, b, c, d, e, f)); this.mergeVertices() } function jb(a, b, c, d, e, f) {
		function g(a, b, c, d, e, f, g, m, ta, za, la) {
			var z = f / ta, u = g / za, v = f / 2, w = g / 2, I = m / 2; g = ta + 1; var B = za + 1, x = f = 0, J, y, C = new p; for (y = 0; y < B; y++) {
				var A = y * u - w; for (J = 0; J < g; J++)C[a] =
					(J * z - v) * d, C[b] = A * e, C[c] = I, l.push(C.x, C.y, C.z), C[a] = 0, C[b] = 0, C[c] = 0 < m ? 1 : -1, q.push(C.x, C.y, C.z), n.push(J / ta), n.push(1 - y / za), f += 1
			} for (y = 0; y < za; y++)for (J = 0; J < ta; J++)a = t + J + g * (y + 1), b = t + (J + 1) + g * (y + 1), c = t + (J + 1) + g * y, k.push(t + J + g * y, a, c), k.push(a, b, c), x += 6; h.addGroup(r, x, la); r += x; t += f
		} D.call(this); this.type = "BoxBufferGeometry"; this.parameters = { width: a, height: b, depth: c, widthSegments: d, heightSegments: e, depthSegments: f }; var h = this; a = a || 1; b = b || 1; c = c || 1; d = Math.floor(d) || 1; e = Math.floor(e) || 1; f = Math.floor(f) || 1; var k =
			[], l = [], q = [], n = [], t = 0, r = 0; g("z", "y", "x", -1, -1, c, b, a, f, e, 0); g("z", "y", "x", 1, -1, c, b, -a, f, e, 1); g("x", "z", "y", 1, 1, a, c, b, d, f, 2); g("x", "z", "y", 1, -1, a, c, -b, d, f, 3); g("x", "y", "z", 1, -1, a, b, c, d, e, 4); g("x", "y", "z", -1, -1, a, b, -c, d, e, 5); this.setIndex(k); this.addAttribute("position", new y(l, 3)); this.addAttribute("normal", new y(q, 3)); this.addAttribute("uv", new y(n, 2))
	} function Ac(a, b, c, d) {
		N.call(this); this.type = "PlaneGeometry"; this.parameters = { width: a, height: b, widthSegments: c, heightSegments: d }; this.fromBufferGeometry(new kb(a,
			b, c, d)); this.mergeVertices()
	} function kb(a, b, c, d) {
		D.call(this); this.type = "PlaneBufferGeometry"; this.parameters = { width: a, height: b, widthSegments: c, heightSegments: d }; a = a || 1; b = b || 1; var e = a / 2, f = b / 2; c = Math.floor(c) || 1; d = Math.floor(d) || 1; var g = c + 1, h = d + 1, k = a / c, l = b / d, q = [], n = [], t = [], r = []; for (a = 0; a < h; a++) { var m = a * l - f; for (b = 0; b < g; b++)n.push(b * k - e, -m, 0), t.push(0, 0, 1), r.push(b / c), r.push(1 - a / d) } for (a = 0; a < d; a++)for (b = 0; b < c; b++)e = b + g * (a + 1), f = b + 1 + g * (a + 1), h = b + 1 + g * a, q.push(b + g * a, e, h), q.push(e, f, h); this.setIndex(q); this.addAttribute("position",
			new y(n, 3)); this.addAttribute("normal", new y(t, 3)); this.addAttribute("uv", new y(r, 2))
	} function va(a) {
		Q.call(this); this.type = "MeshBasicMaterial"; this.color = new H(16777215); this.lightMap = this.map = null; this.lightMapIntensity = 1; this.aoMap = null; this.aoMapIntensity = 1; this.envMap = this.alphaMap = this.specularMap = null; this.combine = 0; this.reflectivity = 1; this.refractionRatio = .98; this.wireframe = !1; this.wireframeLinewidth = 1; this.wireframeLinejoin = this.wireframeLinecap = "round"; this.lights = this.morphTargets = this.skinning =
			!1; this.setValues(a)
	} function oa(a) {
		Q.call(this); this.type = "ShaderMaterial"; this.defines = {}; this.uniforms = {}; this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"; this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"; this.linewidth = 1; this.wireframe = !1; this.wireframeLinewidth = 1; this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1; this.extensions = {
			derivatives: !1, fragDepth: !1,
			drawBuffers: !1, shaderTextureLOD: !1
		}; this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }; this.index0AttributeName = void 0; void 0 !== a && (void 0 !== a.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(a))
	} function lb(a, b) { this.origin = void 0 !== a ? a : new p; this.direction = void 0 !== b ? b : new p } function Mb(a, b) { this.start = void 0 !== a ? a : new p; this.end = void 0 !== b ? b : new p } function Qa(a, b, c) {
	this.a = void 0 !== a ? a : new p; this.b = void 0 !==
		b ? b : new p; this.c = void 0 !== c ? c : new p
	} function pa(a, b) { A.call(this); this.type = "Mesh"; this.geometry = void 0 !== a ? a : new D; this.material = void 0 !== b ? b : new va({ color: 16777215 * Math.random() }); this.drawMode = 0; this.updateMorphTargets() } function Qf(a, b, c, d) {
		function e(a, c) { b.buffers.color.setClear(a.r, a.g, a.b, c, d) } var f = new H(0), g = 0, h, k, l; return {
			getClearColor: function () { return f }, setClearColor: function (a, b) { f.set(a); g = void 0 !== b ? b : 1; e(f, g) }, getClearAlpha: function () { return g }, setClearAlpha: function (a) {
				g = a; e(f,
					g)
			}, render: function (b, d, t, r) {
				d = d.background; null === d ? e(f, g) : d && d.isColor && (e(d, 1), r = !0); (a.autoClear || r) && a.clear(a.autoClearColor, a.autoClearDepth, a.autoClearStencil); d && d.isCubeTexture ? (void 0 === l && (l = new pa(new jb(1, 1, 1), new oa({ uniforms: mb.cube.uniforms, vertexShader: mb.cube.vertexShader, fragmentShader: mb.cube.fragmentShader, side: 1, depthTest: !0, depthWrite: !1, fog: !1 })), l.geometry.removeAttribute("normal"), l.geometry.removeAttribute("uv"), l.onBeforeRender = function (a, b, c) { this.matrixWorld.copyPosition(c.matrixWorld) },
					c.update(l.geometry)), l.material.uniforms.tCube.value = d, b.push(l, l.geometry, l.material, 0, null)) : d && d.isTexture && (void 0 === h && (h = new Kb(-1, 1, 1, -1, 0, 1), k = new pa(new kb(2, 2), new va({ depthTest: !1, depthWrite: !1, fog: !1 })), c.update(k.geometry)), k.material.map = d, a.renderBufferDirect(h, null, k.geometry, k.material, k, null))
			}
		}
	} function Rf(a, b) {
		return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.program && b.program && a.program !== b.program ? a.program.id - b.program.id : a.material.id !== b.material.id ? a.material.id -
			b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id
	} function Sf(a, b) { return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : a.id - b.id } function Tf() {
		var a = [], b = 0, c = [], d = []; return {
			opaque: c, transparent: d, init: function () { b = 0; c.length = 0; d.length = 0 }, push: function (e, f, g, h, k) {
				var l = a[b]; void 0 === l ? (l = { id: e.id, object: e, geometry: f, material: g, program: g.program, renderOrder: e.renderOrder, z: h, group: k }, a[b] = l) : (l.id = e.id, l.object = e, l.geometry = f, l.material = g, l.program = g.program, l.renderOrder = e.renderOrder,
					l.z = h, l.group = k); (!0 === g.transparent ? d : c).push(l); b++
			}, sort: function () { 1 < c.length && c.sort(Rf); 1 < d.length && d.sort(Sf) }
		}
	} function Uf() { var a = {}; return { get: function (b, c) { b = b.id + "," + c.id; c = a[b]; void 0 === c && (c = new Tf, a[b] = c); return c }, dispose: function () { a = {} } } } function Vf(a, b) { return Math.abs(b[1]) - Math.abs(a[1]) } function Wf(a) {
		var b = {}, c = new Float32Array(8); return {
			update: function (d, e, f, g) {
				var h = d.morphTargetInfluences, k = h.length; d = b[e.id]; if (void 0 === d) { d = []; for (var l = 0; l < k; l++)d[l] = [l, 0]; b[e.id] = d } var q =
					f.morphTargets && e.morphAttributes.position; f = f.morphNormals && e.morphAttributes.normal; for (l = 0; l < k; l++) { var n = d[l]; 0 !== n[1] && (q && e.removeAttribute("morphTarget" + l), f && e.removeAttribute("morphNormal" + l)) } for (l = 0; l < k; l++)n = d[l], n[0] = l, n[1] = h[l]; d.sort(Vf); for (l = 0; 8 > l; l++) { if (n = d[l]) if (h = n[0], n = n[1]) { q && e.addAttribute("morphTarget" + l, q[h]); f && e.addAttribute("morphNormal" + l, f[h]); c[l] = n; continue } c[l] = 0 } g.getUniforms().setValue(a, "morphTargetInfluences", c)
			}
		}
	} function Xf(a, b, c) {
		var d, e, f; this.setMode = function (a) {
			d =
			a
		}; this.setIndex = function (a) { e = a.type; f = a.bytesPerElement }; this.render = function (b, h) { a.drawElements(d, h, e, b * f); c.calls++; c.vertices += h; d === a.TRIANGLES ? c.faces += h / 3 : d === a.POINTS && (c.points += h) }; this.renderInstances = function (g, h, k) {
			var l = b.get("ANGLE_instanced_arrays"); null === l ? console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.") : (l.drawElementsInstancedANGLE(d, k, e, h * f, g.maxInstancedCount), c.calls++ , c.vertices +=
				k * g.maxInstancedCount, d === a.TRIANGLES ? c.faces += g.maxInstancedCount * k / 3 : d === a.POINTS && (c.points += g.maxInstancedCount * k))
		}
	} function Yf(a, b, c) {
		var d; this.setMode = function (a) { d = a }; this.render = function (b, f) { a.drawArrays(d, b, f); c.calls++; c.vertices += f; d === a.TRIANGLES ? c.faces += f / 3 : d === a.POINTS && (c.points += f) }; this.renderInstances = function (e, f, g) {
			var h = b.get("ANGLE_instanced_arrays"); if (null === h) console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
			else { var k = e.attributes.position; k.isInterleavedBufferAttribute ? (g = k.data.count, h.drawArraysInstancedANGLE(d, 0, g, e.maxInstancedCount)) : h.drawArraysInstancedANGLE(d, f, g, e.maxInstancedCount); c.calls++; c.vertices += g * e.maxInstancedCount; d === a.TRIANGLES ? c.faces += e.maxInstancedCount * g / 3 : d === a.POINTS && (c.points += e.maxInstancedCount * g) }
		}
	} function Zf(a, b, c) {
		function d(a) {
			a = a.target; var g = e[a.id]; null !== g.index && b.remove(g.index); for (var k in g.attributes) b.remove(g.attributes[k]); a.removeEventListener("dispose",
				d); delete e[a.id]; if (k = f[a.id]) b.remove(k), delete f[a.id]; if (k = f[g.id]) b.remove(k), delete f[g.id]; c.geometries--
		} var e = {}, f = {}; return {
			get: function (a, b) { var f = e[b.id]; if (f) return f; b.addEventListener("dispose", d); b.isBufferGeometry ? f = b : b.isGeometry && (void 0 === b._bufferGeometry && (b._bufferGeometry = (new D).setFromObject(a)), f = b._bufferGeometry); e[b.id] = f; c.geometries++; return f }, update: function (c) {
				var d = c.index, e = c.attributes; null !== d && b.update(d, a.ELEMENT_ARRAY_BUFFER); for (var f in e) b.update(e[f],
					a.ARRAY_BUFFER); c = c.morphAttributes; for (f in c) for (var d = c[f], e = 0, g = d.length; e < g; e++)b.update(d[e], a.ARRAY_BUFFER)
			}, getWireframeAttribute: function (c) {
				var d = f[c.id]; if (d) return d; d = []; var e = c.index; var g = c.attributes; if (null !== e) { var q = e.array; for (var n = 0, t = q.length; n < t; n += 3) { var r = q[n + 0]; g = q[n + 1]; e = q[n + 2]; d.push(r, g, g, e, e, r) } } else for (q = g.position.array, n = 0, t = q.length / 3 - 1; n < t; n += 3)r = n + 0, g = n + 1, e = n + 2, d.push(r, g, g, e, e, r); d = new (65535 < Qd(d) ? ib : hb)(d, 1); b.update(d, a.ELEMENT_ARRAY_BUFFER); return f[c.id] =
					d
			}
		}
	} function $f() {
		var a = {}; return {
			get: function (b) {
				if (void 0 !== a[b.id]) return a[b.id]; switch (b.type) {
					case "DirectionalLight": var c = { direction: new p, color: new H, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new C }; break; case "SpotLight": c = { position: new p, direction: new p, color: new H, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new C }; break; case "PointLight": c = {
						position: new p, color: new H, distance: 0, decay: 0, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new C,
						shadowCameraNear: 1, shadowCameraFar: 1E3
					}; break; case "HemisphereLight": c = { direction: new p, skyColor: new H, groundColor: new H }; break; case "RectAreaLight": c = { color: new H, position: new p, halfWidth: new p, halfHeight: new p }
				}return a[b.id] = c
			}
		}
	} function ag() {
		var a = new $f, b = { hash: "", ambient: [0, 0, 0], directional: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], point: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] }, c = new p, d = new K, e = new K; return {
			setup: function (f,
				g, h) {
					for (var k, l = 0, q = 0, n = 0, t = 0, r = 0, m = 0, v = 0, w = 0, p = h.matrixWorldInverse, z = 0, I = f.length; z < I; z++) {
						var B = f[z]; k = B.color; var J = B.intensity, ta = B.distance, za = B.shadow && B.shadow.map ? B.shadow.map.texture : null; if (B.isAmbientLight) l += k.r * J, q += k.g * J, n += k.b * J; else if (B.isDirectionalLight) {
							h = a.get(B); h.color.copy(B.color).multiplyScalar(B.intensity); h.direction.setFromMatrixPosition(B.matrixWorld); c.setFromMatrixPosition(B.target.matrixWorld); h.direction.sub(c); h.direction.transformDirection(p); if (h.shadow = B.castShadow) k =
								B.shadow, h.shadowBias = k.bias, h.shadowRadius = k.radius, h.shadowMapSize = k.mapSize; b.directionalShadowMap[t] = za; b.directionalShadowMatrix[t] = B.shadow.matrix; b.directional[t] = h; t++
						} else if (B.isSpotLight) {
							h = a.get(B); h.position.setFromMatrixPosition(B.matrixWorld); h.position.applyMatrix4(p); h.color.copy(k).multiplyScalar(J); h.distance = ta; h.direction.setFromMatrixPosition(B.matrixWorld); c.setFromMatrixPosition(B.target.matrixWorld); h.direction.sub(c); h.direction.transformDirection(p); h.coneCos = Math.cos(B.angle);
							h.penumbraCos = Math.cos(B.angle * (1 - B.penumbra)); h.decay = 0 === B.distance ? 0 : B.decay; if (h.shadow = B.castShadow) k = B.shadow, h.shadowBias = k.bias, h.shadowRadius = k.radius, h.shadowMapSize = k.mapSize; b.spotShadowMap[m] = za; b.spotShadowMatrix[m] = B.shadow.matrix; b.spot[m] = h; m++
						} else if (B.isRectAreaLight) h = a.get(B), h.color.copy(k).multiplyScalar(J / (B.width * B.height)), h.position.setFromMatrixPosition(B.matrixWorld), h.position.applyMatrix4(p), e.identity(), d.copy(B.matrixWorld), d.premultiply(p), e.extractRotation(d), h.halfWidth.set(.5 *
							B.width, 0, 0), h.halfHeight.set(0, .5 * B.height, 0), h.halfWidth.applyMatrix4(e), h.halfHeight.applyMatrix4(e), b.rectArea[v] = h, v++; else if (B.isPointLight) {
								h = a.get(B); h.position.setFromMatrixPosition(B.matrixWorld); h.position.applyMatrix4(p); h.color.copy(B.color).multiplyScalar(B.intensity); h.distance = B.distance; h.decay = 0 === B.distance ? 0 : B.decay; if (h.shadow = B.castShadow) k = B.shadow, h.shadowBias = k.bias, h.shadowRadius = k.radius, h.shadowMapSize = k.mapSize, h.shadowCameraNear = k.camera.near, h.shadowCameraFar = k.camera.far;
								b.pointShadowMap[r] = za; b.pointShadowMatrix[r] = B.shadow.matrix; b.point[r] = h; r++
							} else B.isHemisphereLight && (h = a.get(B), h.direction.setFromMatrixPosition(B.matrixWorld), h.direction.transformDirection(p), h.direction.normalize(), h.skyColor.copy(B.color).multiplyScalar(J), h.groundColor.copy(B.groundColor).multiplyScalar(J), b.hemi[w] = h, w++)
					} b.ambient[0] = l; b.ambient[1] = q; b.ambient[2] = n; b.directional.length = t; b.spot.length = m; b.rectArea.length = v; b.point.length = r; b.hemi.length = w; b.hash = t + "," + r + "," + m + "," + v + "," +
						w + "," + g.length
			}, state: b
		}
	} function bg(a, b) { var c = {}; return { update: function (d) { var e = b.frame, f = d.geometry, g = a.get(d, f); c[g.id] !== e && (f.isGeometry && g.updateFromObject(d), a.update(g), c[g.id] = e); return g }, clear: function () { c = {} } } } function cg(a) { a = a.split("\n"); for (var b = 0; b < a.length; b++)a[b] = b + 1 + ": " + a[b]; return a.join("\n") } function Ke(a, b, c) {
		var d = a.createShader(b); a.shaderSource(d, c); a.compileShader(d); !1 === a.getShaderParameter(d, a.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile.");
		"" !== a.getShaderInfoLog(d) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", b === a.VERTEX_SHADER ? "vertex" : "fragment", a.getShaderInfoLog(d), cg(c)); return d
	} function Le(a) {
		switch (a) {
			case 3E3: return ["Linear", "( value )"]; case 3001: return ["sRGB", "( value )"]; case 3002: return ["RGBE", "( value )"]; case 3004: return ["RGBM", "( value, 7.0 )"]; case 3005: return ["RGBM", "( value, 16.0 )"]; case 3006: return ["RGBD", "( value, 256.0 )"]; case 3007: return ["Gamma", "( value, float( GAMMA_FACTOR ) )"]; default: throw Error("unsupported encoding: " +
				a);
		}
	} function Rd(a, b) { b = Le(b); return "vec4 " + a + "( vec4 value ) { return " + b[0] + "ToLinear" + b[1] + "; }" } function dg(a, b) { b = Le(b); return "vec4 " + a + "( vec4 value ) { return LinearTo" + b[0] + b[1] + "; }" } function eg(a, b) { switch (b) { case 1: b = "Linear"; break; case 2: b = "Reinhard"; break; case 3: b = "Uncharted2"; break; case 4: b = "OptimizedCineon"; break; default: throw Error("unsupported toneMapping: " + b); }return "vec3 " + a + "( vec3 color ) { return " + b + "ToneMapping( color ); }" } function fg(a, b, c) {
		a = a || {}; return [a.derivatives ||
			b.envMapCubeUV || b.bumpMap || b.normalMap || b.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (a.fragDepth || b.logarithmicDepthBuffer) && c.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", a.drawBuffers && c.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (a.shaderTextureLOD || b.envMap) && c.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Bc).join("\n")
	} function gg(a) {
		var b = [], c; for (c in a) {
			var d = a[c]; !1 !== d && b.push("#define " +
				c + " " + d)
		} return b.join("\n")
	} function Bc(a) { return "" !== a } function Me(a, b) { return a.replace(/NUM_DIR_LIGHTS/g, b.numDirLights).replace(/NUM_SPOT_LIGHTS/g, b.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, b.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, b.numPointLights).replace(/NUM_HEMI_LIGHTS/g, b.numHemiLights) } function Sd(a) { return a.replace(/^[ \t]*#include +<([\w\d.]+)>/gm, function (a, c) { a = W[c]; if (void 0 === a) throw Error("Can not resolve #include <" + c + ">"); return Sd(a) }) } function Ne(a) {
		return a.replace(/for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
			function (a, c, d, e) { a = ""; for (c = parseInt(c); c < parseInt(d); c++)a += e.replace(/\[ i \]/g, "[ " + c + " ]"); return a })
	} function hg(a, b, c, d, e, f) {
		var g = a.context, h = d.defines, k = e.vertexShader, l = e.fragmentShader, q = "SHADOWMAP_TYPE_BASIC"; 1 === f.shadowMapType ? q = "SHADOWMAP_TYPE_PCF" : 2 === f.shadowMapType && (q = "SHADOWMAP_TYPE_PCF_SOFT"); var n = "ENVMAP_TYPE_CUBE", t = "ENVMAP_MODE_REFLECTION", r = "ENVMAP_BLENDING_MULTIPLY"; if (f.envMap) {
			switch (d.envMap.mapping) {
				case 301: case 302: n = "ENVMAP_TYPE_CUBE"; break; case 306: case 307: n = "ENVMAP_TYPE_CUBE_UV";
					break; case 303: case 304: n = "ENVMAP_TYPE_EQUIREC"; break; case 305: n = "ENVMAP_TYPE_SPHERE"
			}switch (d.envMap.mapping) { case 302: case 304: t = "ENVMAP_MODE_REFRACTION" }switch (d.combine) { case 0: r = "ENVMAP_BLENDING_MULTIPLY"; break; case 1: r = "ENVMAP_BLENDING_MIX"; break; case 2: r = "ENVMAP_BLENDING_ADD" }
		} var m = 0 < a.gammaFactor ? a.gammaFactor : 1, v = fg(d.extensions, f, b), w = gg(h), p = g.createProgram(); d.isRawShaderMaterial ? (h = [w].filter(Bc).join("\n"), 0 < h.length && (h += "\n"), b = [v, w].filter(Bc).join("\n"), 0 < b.length && (b += "\n")) : (h =
			["precision " + f.precision + " float;", "precision " + f.precision + " int;", "#define SHADER_NAME " + e.name, w, f.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + m, "#define MAX_BONES " + f.maxBones, f.useFog && f.fog ? "#define USE_FOG" : "", f.useFog && f.fogExp ? "#define FOG_EXP2" : "", f.map ? "#define USE_MAP" : "", f.envMap ? "#define USE_ENVMAP" : "", f.envMap ? "#define " + t : "", f.lightMap ? "#define USE_LIGHTMAP" : "", f.aoMap ? "#define USE_AOMAP" : "", f.emissiveMap ? "#define USE_EMISSIVEMAP" : "", f.bumpMap ? "#define USE_BUMPMAP" :
				"", f.normalMap ? "#define USE_NORMALMAP" : "", f.displacementMap && f.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", f.specularMap ? "#define USE_SPECULARMAP" : "", f.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", f.metalnessMap ? "#define USE_METALNESSMAP" : "", f.alphaMap ? "#define USE_ALPHAMAP" : "", f.vertexColors ? "#define USE_COLOR" : "", f.flatShading ? "#define FLAT_SHADED" : "", f.skinning ? "#define USE_SKINNING" : "", f.useVertexTexture ? "#define BONE_TEXTURE" : "", f.morphTargets ? "#define USE_MORPHTARGETS" : "", f.morphNormals &&
					!1 === f.flatShading ? "#define USE_MORPHNORMALS" : "", f.doubleSided ? "#define DOUBLE_SIDED" : "", f.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + f.numClippingPlanes, f.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", f.shadowMapEnabled ? "#define " + q : "", f.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", f.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", f.logarithmicDepthBuffer && b.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;",
				"uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;",
				"\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Bc).join("\n"), b = [v, "precision " + f.precision + " float;", "precision " + f.precision + " int;", "#define SHADER_NAME " + e.name, w, f.alphaTest ? "#define ALPHATEST " + f.alphaTest :
					"", "#define GAMMA_FACTOR " + m, f.useFog && f.fog ? "#define USE_FOG" : "", f.useFog && f.fogExp ? "#define FOG_EXP2" : "", f.map ? "#define USE_MAP" : "", f.envMap ? "#define USE_ENVMAP" : "", f.envMap ? "#define " + n : "", f.envMap ? "#define " + t : "", f.envMap ? "#define " + r : "", f.lightMap ? "#define USE_LIGHTMAP" : "", f.aoMap ? "#define USE_AOMAP" : "", f.emissiveMap ? "#define USE_EMISSIVEMAP" : "", f.bumpMap ? "#define USE_BUMPMAP" : "", f.normalMap ? "#define USE_NORMALMAP" : "", f.specularMap ? "#define USE_SPECULARMAP" : "", f.roughnessMap ? "#define USE_ROUGHNESSMAP" :
						"", f.metalnessMap ? "#define USE_METALNESSMAP" : "", f.alphaMap ? "#define USE_ALPHAMAP" : "", f.vertexColors ? "#define USE_COLOR" : "", f.gradientMap ? "#define USE_GRADIENTMAP" : "", f.flatShading ? "#define FLAT_SHADED" : "", f.doubleSided ? "#define DOUBLE_SIDED" : "", f.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + f.numClippingPlanes, "#define UNION_CLIPPING_PLANES " + (f.numClippingPlanes - f.numClipIntersection), f.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", f.shadowMapEnabled ? "#define " + q : "", f.premultipliedAlpha ?
						"#define PREMULTIPLIED_ALPHA" : "", f.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", f.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", f.logarithmicDepthBuffer && b.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", f.envMap && b.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", 0 !== f.toneMapping ? "#define TONE_MAPPING" : "", 0 !== f.toneMapping ? W.tonemapping_pars_fragment : "", 0 !== f.toneMapping ? eg("toneMapping", f.toneMapping) :
						"", f.dithering ? "#define DITHERING" : "", f.outputEncoding || f.mapEncoding || f.envMapEncoding || f.emissiveMapEncoding ? W.encodings_pars_fragment : "", f.mapEncoding ? Rd("mapTexelToLinear", f.mapEncoding) : "", f.envMapEncoding ? Rd("envMapTexelToLinear", f.envMapEncoding) : "", f.emissiveMapEncoding ? Rd("emissiveMapTexelToLinear", f.emissiveMapEncoding) : "", f.outputEncoding ? dg("linearToOutputTexel", f.outputEncoding) : "", f.depthPacking ? "#define DEPTH_PACKING " + d.depthPacking : "", "\n"].filter(Bc).join("\n")); k = Sd(k); k = Me(k, f);
		l = Sd(l); l = Me(l, f); d.isShaderMaterial || (k = Ne(k), l = Ne(l)); l = b + l; k = Ke(g, g.VERTEX_SHADER, h + k); l = Ke(g, g.FRAGMENT_SHADER, l); g.attachShader(p, k); g.attachShader(p, l); void 0 !== d.index0AttributeName ? g.bindAttribLocation(p, 0, d.index0AttributeName) : !0 === f.morphTargets && g.bindAttribLocation(p, 0, "position"); g.linkProgram(p); f = g.getProgramInfoLog(p); e = g.getShaderInfoLog(k); q = g.getShaderInfoLog(l); t = n = !0; if (!1 === g.getProgramParameter(p, g.LINK_STATUS)) n = !1, console.error("THREE.WebGLProgram: shader error: ", g.getError(),
			"gl.VALIDATE_STATUS", g.getProgramParameter(p, g.VALIDATE_STATUS), "gl.getProgramInfoLog", f, e, q); else if ("" !== f) console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", f); else if ("" === e || "" === q) t = !1; t && (this.diagnostics = { runnable: n, material: d, programLog: f, vertexShader: { log: e, prefix: h }, fragmentShader: { log: q, prefix: b } }); g.deleteShader(k); g.deleteShader(l); var z; this.getUniforms = function () { void 0 === z && (z = new gb(g, p, a)); return z }; var I; this.getAttributes = function () {
				if (void 0 === I) {
					for (var a = {}, b = g.getProgramParameter(p,
						g.ACTIVE_ATTRIBUTES), c = 0; c < b; c++) { var d = g.getActiveAttrib(p, c).name; a[d] = g.getAttribLocation(p, d) } I = a
				} return I
			}; this.destroy = function () { g.deleteProgram(p); this.program = void 0 }; Object.defineProperties(this, { uniforms: { get: function () { console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."); return this.getUniforms() } }, attributes: { get: function () { console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."); return this.getAttributes() } } }); this.id = ig++; this.code = c; this.usedTimes = 1;
		this.program = p; this.vertexShader = k; this.fragmentShader = l; return this
	} function jg(a, b, c) {
		function d(a, b) { if (a) a.isTexture ? c = a.encoding : a.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), c = a.texture.encoding); else var c = 3E3; 3E3 === c && b && (c = 3007); return c } var e = [], f = {
			MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert",
			MeshPhongMaterial: "phong", MeshToonMaterial: "phong", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow"
		}, g = "precision supportsVertexTextures map mapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering".split(" ");
		this.getParameters = function (b, e, g, q, n, t, r) {
			var h = f[b.type]; if (r.isSkinnedMesh) { var l = r.skeleton.bones; if (c.floatVertexTextures) l = 1024; else { var k = Math.min(Math.floor((c.maxVertexUniforms - 20) / 4), l.length); k < l.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + l.length + " bones. This GPU supports " + k + "."), l = 0) : l = k } } else l = 0; k = c.precision; null !== b.precision && (k = c.getMaxPrecision(b.precision), k !== b.precision && console.warn("THREE.WebGLProgram.getParameters:", b.precision, "not supported, using", k, "instead."));
			var m = a.getRenderTarget(); return {
				shaderID: h, precision: k, supportsVertexTextures: c.vertexTextures, outputEncoding: d(m ? m.texture : null, a.gammaOutput), map: !!b.map, mapEncoding: d(b.map, a.gammaInput), envMap: !!b.envMap, envMapMode: b.envMap && b.envMap.mapping, envMapEncoding: d(b.envMap, a.gammaInput), envMapCubeUV: !!b.envMap && (306 === b.envMap.mapping || 307 === b.envMap.mapping), lightMap: !!b.lightMap, aoMap: !!b.aoMap, emissiveMap: !!b.emissiveMap, emissiveMapEncoding: d(b.emissiveMap, a.gammaInput), bumpMap: !!b.bumpMap, normalMap: !!b.normalMap,
				displacementMap: !!b.displacementMap, roughnessMap: !!b.roughnessMap, metalnessMap: !!b.metalnessMap, specularMap: !!b.specularMap, alphaMap: !!b.alphaMap, gradientMap: !!b.gradientMap, combine: b.combine, vertexColors: b.vertexColors, fog: !!q, useFog: b.fog, fogExp: q && q.isFogExp2, flatShading: b.flatShading, sizeAttenuation: b.sizeAttenuation, logarithmicDepthBuffer: c.logarithmicDepthBuffer, skinning: b.skinning && 0 < l, maxBones: l, useVertexTexture: c.floatVertexTextures, morphTargets: b.morphTargets, morphNormals: b.morphNormals,
				maxMorphTargets: a.maxMorphTargets, maxMorphNormals: a.maxMorphNormals, numDirLights: e.directional.length, numPointLights: e.point.length, numSpotLights: e.spot.length, numRectAreaLights: e.rectArea.length, numHemiLights: e.hemi.length, numClippingPlanes: n, numClipIntersection: t, dithering: b.dithering, shadowMapEnabled: a.shadowMap.enabled && r.receiveShadow && 0 < g.length, shadowMapType: a.shadowMap.type, toneMapping: a.toneMapping, physicallyCorrectLights: a.physicallyCorrectLights, premultipliedAlpha: b.premultipliedAlpha,
				alphaTest: b.alphaTest, doubleSided: 2 === b.side, flipSided: 1 === b.side, depthPacking: void 0 !== b.depthPacking ? b.depthPacking : !1
			}
		}; this.getProgramCode = function (b, c) { var d = []; c.shaderID ? d.push(c.shaderID) : (d.push(b.fragmentShader), d.push(b.vertexShader)); if (void 0 !== b.defines) for (var e in b.defines) d.push(e), d.push(b.defines[e]); for (e = 0; e < g.length; e++)d.push(c[g[e]]); d.push(b.onBeforeCompile.toString()); d.push(a.gammaOutput); return d.join() }; this.acquireProgram = function (c, d, f, g) {
			for (var h, l = 0, k = e.length; l <
				k; l++) { var q = e[l]; if (q.code === g) { h = q; ++h.usedTimes; break } } void 0 === h && (h = new hg(a, b, g, c, d, f), e.push(h)); return h
		}; this.releaseProgram = function (a) { if (0 === --a.usedTimes) { var b = e.indexOf(a); e[b] = e[e.length - 1]; e.pop(); a.destroy() } }; this.programs = e
	} function kg(a, b, c, d, e, f, g) {
		function h(a, b) {
			if (a.width > b || a.height > b) {
				b /= Math.max(a.width, a.height); var c = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"); c.width = Math.floor(a.width * b); c.height = Math.floor(a.height * b); c.getContext("2d").drawImage(a,
					0, 0, a.width, a.height, 0, 0, c.width, c.height); console.warn("THREE.WebGLRenderer: image is too big (" + a.width + "x" + a.height + "). Resized to " + c.width + "x" + c.height, a); return c
			} return a
		} function k(a) { return R.isPowerOfTwo(a.width) && R.isPowerOfTwo(a.height) } function l(a, b) { return a.generateMipmaps && b && 1003 !== a.minFilter && 1006 !== a.minFilter } function q(b) { return 1003 === b || 1004 === b || 1005 === b ? a.NEAREST : a.LINEAR } function n(b) {
			b = b.target; b.removeEventListener("dispose", n); a: {
				var c = d.get(b); if (b.image && c.__image__webglTextureCube) a.deleteTexture(c.__image__webglTextureCube);
				else { if (void 0 === c.__webglInit) break a; a.deleteTexture(c.__webglTexture) } d.remove(b)
			} g.textures--
		} function t(b) {
			b = b.target; b.removeEventListener("dispose", t); var c = d.get(b), e = d.get(b.texture); if (b) {
			void 0 !== e.__webglTexture && a.deleteTexture(e.__webglTexture); b.depthTexture && b.depthTexture.dispose(); if (b.isWebGLRenderTargetCube) for (e = 0; 6 > e; e++)a.deleteFramebuffer(c.__webglFramebuffer[e]), c.__webglDepthbuffer && a.deleteRenderbuffer(c.__webglDepthbuffer[e]); else a.deleteFramebuffer(c.__webglFramebuffer),
				c.__webglDepthbuffer && a.deleteRenderbuffer(c.__webglDepthbuffer); d.remove(b.texture); d.remove(b)
			} g.textures--
		} function r(b, q) {
			var t = d.get(b); if (0 < b.version && t.__version !== b.version) {
				var r = b.image; if (void 0 === r) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", b); else if (!1 === r.complete) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", b); else {
				void 0 === t.__webglInit && (t.__webglInit = !0, b.addEventListener("dispose", n), t.__webglTexture =
					a.createTexture(), g.textures++); c.activeTexture(a.TEXTURE0 + q); c.bindTexture(a.TEXTURE_2D, t.__webglTexture); a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, b.flipY); a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, b.premultiplyAlpha); a.pixelStorei(a.UNPACK_ALIGNMENT, b.unpackAlignment); var u = h(b.image, e.maxTextureSize); (1001 !== b.wrapS || 1001 !== b.wrapT || 1003 !== b.minFilter && 1006 !== b.minFilter) && !1 === k(u) && (q = u, q instanceof HTMLImageElement || q instanceof HTMLCanvasElement || q instanceof ImageBitmap ? (r = document.createElementNS("http://www.w3.org/1999/xhtml",
						"canvas"), r.width = R.floorPowerOfTwo(q.width), r.height = R.floorPowerOfTwo(q.height), r.getContext("2d").drawImage(q, 0, 0, r.width, r.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + q.width + "x" + q.height + "). Resized to " + r.width + "x" + r.height, q), u = r) : u = q); q = k(u); var r = f.convert(b.format), z = f.convert(b.type); m(a.TEXTURE_2D, b, q); var p = b.mipmaps; if (b.isDepthTexture) {
							p = a.DEPTH_COMPONENT; if (1015 === b.type) { if (!x) throw Error("Float Depth Texture only supported in WebGL2.0"); p = a.DEPTH_COMPONENT32F } else x &&
								(p = a.DEPTH_COMPONENT16); 1026 === b.format && p === a.DEPTH_COMPONENT && 1012 !== b.type && 1014 !== b.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), b.type = 1012, z = f.convert(b.type)); 1027 === b.format && (p = a.DEPTH_STENCIL, 1020 !== b.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), b.type = 1020, z = f.convert(b.type))); c.texImage2D(a.TEXTURE_2D, 0, p, u.width, u.height, 0, r, z, null)
						} else if (b.isDataTexture) if (0 <
							p.length && q) { for (var v = 0, w = p.length; v < w; v++)u = p[v], c.texImage2D(a.TEXTURE_2D, v, r, u.width, u.height, 0, r, z, u.data); b.generateMipmaps = !1 } else c.texImage2D(a.TEXTURE_2D, 0, r, u.width, u.height, 0, r, z, u.data); else if (b.isCompressedTexture) for (v = 0, w = p.length; v < w; v++)u = p[v], 1023 !== b.format && 1022 !== b.format ? -1 < c.getCompressedTextureFormats().indexOf(r) ? c.compressedTexImage2D(a.TEXTURE_2D, v, r, u.width, u.height, 0, u.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") :
								c.texImage2D(a.TEXTURE_2D, v, r, u.width, u.height, 0, r, z, u.data); else if (0 < p.length && q) { v = 0; for (w = p.length; v < w; v++)u = p[v], c.texImage2D(a.TEXTURE_2D, v, r, r, z, u); b.generateMipmaps = !1 } else c.texImage2D(a.TEXTURE_2D, 0, r, r, z, u); l(b, q) && a.generateMipmap(a.TEXTURE_2D); t.__version = b.version; if (b.onUpdate) b.onUpdate(b); return
				}
			} c.activeTexture(a.TEXTURE0 + q); c.bindTexture(a.TEXTURE_2D, t.__webglTexture)
		} function m(c, g, h) {
			h ? (a.texParameteri(c, a.TEXTURE_WRAP_S, f.convert(g.wrapS)), a.texParameteri(c, a.TEXTURE_WRAP_T,
				f.convert(g.wrapT)), a.texParameteri(c, a.TEXTURE_MAG_FILTER, f.convert(g.magFilter)), a.texParameteri(c, a.TEXTURE_MIN_FILTER, f.convert(g.minFilter))) : (a.texParameteri(c, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE), a.texParameteri(c, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE), 1001 === g.wrapS && 1001 === g.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", g), a.texParameteri(c, a.TEXTURE_MAG_FILTER, q(g.magFilter)), a.texParameteri(c,
					a.TEXTURE_MIN_FILTER, q(g.minFilter)), 1003 !== g.minFilter && 1006 !== g.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", g)); !(h = b.get("EXT_texture_filter_anisotropic")) || 1015 === g.type && null === b.get("OES_texture_float_linear") || 1016 === g.type && null === b.get("OES_texture_half_float_linear") || !(1 < g.anisotropy || d.get(g).__currentAnisotropy) || (a.texParameterf(c, h.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(g.anisotropy,
						e.getMaxAnisotropy())), d.get(g).__currentAnisotropy = g.anisotropy)
		} function p(b, e, g, h) { var l = f.convert(e.texture.format), k = f.convert(e.texture.type); c.texImage2D(h, 0, l, e.width, e.height, 0, l, k, null); a.bindFramebuffer(a.FRAMEBUFFER, b); a.framebufferTexture2D(a.FRAMEBUFFER, g, h, d.get(e.texture).__webglTexture, 0); a.bindFramebuffer(a.FRAMEBUFFER, null) } function w(b, c) {
			a.bindRenderbuffer(a.RENDERBUFFER, b); c.depthBuffer && !c.stencilBuffer ? (a.renderbufferStorage(a.RENDERBUFFER, a.DEPTH_COMPONENT16, c.width, c.height),
				a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.RENDERBUFFER, b)) : c.depthBuffer && c.stencilBuffer ? (a.renderbufferStorage(a.RENDERBUFFER, a.DEPTH_STENCIL, c.width, c.height), a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, b)) : a.renderbufferStorage(a.RENDERBUFFER, a.RGBA4, c.width, c.height); a.bindRenderbuffer(a.RENDERBUFFER, null)
		} var x = "undefined" !== typeof WebGL2RenderingContext && a instanceof window.WebGL2RenderingContext; this.setTexture2D = r; this.setTextureCube =
			function (b, q) {
				var t = d.get(b); if (6 === b.image.length) if (0 < b.version && t.__version !== b.version) {
				t.__image__webglTextureCube || (b.addEventListener("dispose", n), t.__image__webglTextureCube = a.createTexture(), g.textures++); c.activeTexture(a.TEXTURE0 + q); c.bindTexture(a.TEXTURE_CUBE_MAP, t.__image__webglTextureCube); a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, b.flipY); q = b && b.isCompressedTexture; for (var r = b.image[0] && b.image[0].isDataTexture, u = [], p = 0; 6 > p; p++)u[p] = q || r ? r ? b.image[p].image : b.image[p] : h(b.image[p], e.maxCubemapSize);
					var v = k(u[0]), w = f.convert(b.format), z = f.convert(b.type); m(a.TEXTURE_CUBE_MAP, b, v); for (p = 0; 6 > p; p++)if (q) for (var x, I = u[p].mipmaps, y = 0, C = I.length; y < C; y++)x = I[y], 1023 !== b.format && 1022 !== b.format ? -1 < c.getCompressedTextureFormats().indexOf(w) ? c.compressedTexImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + p, y, w, x.width, x.height, 0, x.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + p, y, w, x.width, x.height,
						0, w, z, x.data); else r ? c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + p, 0, w, u[p].width, u[p].height, 0, w, z, u[p].data) : c.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + p, 0, w, w, z, u[p]); l(b, v) && a.generateMipmap(a.TEXTURE_CUBE_MAP); t.__version = b.version; if (b.onUpdate) b.onUpdate(b)
				} else c.activeTexture(a.TEXTURE0 + q), c.bindTexture(a.TEXTURE_CUBE_MAP, t.__image__webglTextureCube)
			}; this.setTextureCubeDynamic = function (b, e) { c.activeTexture(a.TEXTURE0 + e); c.bindTexture(a.TEXTURE_CUBE_MAP, d.get(b).__webglTexture) }; this.setupRenderTarget =
				function (b) {
					var e = d.get(b), f = d.get(b.texture); b.addEventListener("dispose", t); f.__webglTexture = a.createTexture(); g.textures++; var h = !0 === b.isWebGLRenderTargetCube, n = k(b); if (h) { e.__webglFramebuffer = []; for (var q = 0; 6 > q; q++)e.__webglFramebuffer[q] = a.createFramebuffer() } else e.__webglFramebuffer = a.createFramebuffer(); if (h) {
						c.bindTexture(a.TEXTURE_CUBE_MAP, f.__webglTexture); m(a.TEXTURE_CUBE_MAP, b.texture, n); for (q = 0; 6 > q; q++)p(e.__webglFramebuffer[q], b, a.COLOR_ATTACHMENT0, a.TEXTURE_CUBE_MAP_POSITIVE_X + q);
						l(b.texture, n) && a.generateMipmap(a.TEXTURE_CUBE_MAP); c.bindTexture(a.TEXTURE_CUBE_MAP, null)
					} else c.bindTexture(a.TEXTURE_2D, f.__webglTexture), m(a.TEXTURE_2D, b.texture, n), p(e.__webglFramebuffer, b, a.COLOR_ATTACHMENT0, a.TEXTURE_2D), l(b.texture, n) && a.generateMipmap(a.TEXTURE_2D), c.bindTexture(a.TEXTURE_2D, null); if (b.depthBuffer) {
						e = d.get(b); f = !0 === b.isWebGLRenderTargetCube; if (b.depthTexture) {
							if (f) throw Error("target.depthTexture not supported in Cube render targets"); if (b && b.isWebGLRenderTargetCube) throw Error("Depth Texture with cube render targets is not supported");
							a.bindFramebuffer(a.FRAMEBUFFER, e.__webglFramebuffer); if (!b.depthTexture || !b.depthTexture.isDepthTexture) throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); d.get(b.depthTexture).__webglTexture && b.depthTexture.image.width === b.width && b.depthTexture.image.height === b.height || (b.depthTexture.image.width = b.width, b.depthTexture.image.height = b.height, b.depthTexture.needsUpdate = !0); r(b.depthTexture, 0); e = d.get(b.depthTexture).__webglTexture; if (1026 === b.depthTexture.format) a.framebufferTexture2D(a.FRAMEBUFFER,
								a.DEPTH_ATTACHMENT, a.TEXTURE_2D, e, 0); else if (1027 === b.depthTexture.format) a.framebufferTexture2D(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.TEXTURE_2D, e, 0); else throw Error("Unknown depthTexture format");
						} else if (f) for (e.__webglDepthbuffer = [], f = 0; 6 > f; f++)a.bindFramebuffer(a.FRAMEBUFFER, e.__webglFramebuffer[f]), e.__webglDepthbuffer[f] = a.createRenderbuffer(), w(e.__webglDepthbuffer[f], b); else a.bindFramebuffer(a.FRAMEBUFFER, e.__webglFramebuffer), e.__webglDepthbuffer = a.createRenderbuffer(), w(e.__webglDepthbuffer,
							b); a.bindFramebuffer(a.FRAMEBUFFER, null)
					}
				}; this.updateRenderTargetMipmap = function (b) { var e = b.texture, f = k(b); l(e, f) && (b = b.isWebGLRenderTargetCube ? a.TEXTURE_CUBE_MAP : a.TEXTURE_2D, e = d.get(e).__webglTexture, c.bindTexture(b, e), a.generateMipmap(b), c.bindTexture(b, null)) }
	} function lg() { var a = {}; return { get: function (b) { b = b.uuid; var c = a[b]; void 0 === c && (c = {}, a[b] = c); return c }, remove: function (b) { delete a[b.uuid] }, clear: function () { a = {} } } } function mg(a, b, c) {
		function d(b, c, d) {
			var e = new Uint8Array(4), f = a.createTexture();
			a.bindTexture(b, f); a.texParameteri(b, a.TEXTURE_MIN_FILTER, a.NEAREST); a.texParameteri(b, a.TEXTURE_MAG_FILTER, a.NEAREST); for (b = 0; b < d; b++)a.texImage2D(c + b, 0, a.RGBA, 1, 1, 0, a.RGBA, a.UNSIGNED_BYTE, e); return f
		} function e(b) { !0 !== z[b] && (a.enable(b), z[b] = !0) } function f(b) { !1 !== z[b] && (a.disable(b), z[b] = !1) } function g(b, d, g, h, l, k, n, q) {
			0 !== b ? e(a.BLEND) : f(a.BLEND); if (5 !== b) {
				if (b !== J || q !== L) switch (b) {
					case 2: q ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ONE, a.ONE, a.ONE, a.ONE)) : (a.blendEquation(a.FUNC_ADD),
						a.blendFunc(a.SRC_ALPHA, a.ONE)); break; case 3: q ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ZERO, a.ZERO, a.ONE_MINUS_SRC_COLOR, a.ONE_MINUS_SRC_ALPHA)) : (a.blendEquation(a.FUNC_ADD), a.blendFunc(a.ZERO, a.ONE_MINUS_SRC_COLOR)); break; case 4: q ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ZERO, a.SRC_COLOR, a.ZERO, a.SRC_ALPHA)) : (a.blendEquation(a.FUNC_ADD), a.blendFunc(a.ZERO, a.SRC_COLOR)); break; default: q ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ONE,
							a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA)) : (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.SRC_ALPHA, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA))
				}E = A = ha = C = y = ta = null
			} else { l = l || d; k = k || g; n = n || h; if (d !== ta || l !== ha) a.blendEquationSeparate(c.convert(d), c.convert(l)), ta = d, ha = l; if (g !== y || h !== C || k !== A || n !== E) a.blendFuncSeparate(c.convert(g), c.convert(h), c.convert(k), c.convert(n)), y = g, C = h, A = k, E = n } J = b; L = q
		} function h(b) { D !== b && (b ? a.frontFace(a.CW) : a.frontFace(a.CCW), D = b) }
		function k(b) { 0 !== b ? (e(a.CULL_FACE), b !== H && (1 === b ? a.cullFace(a.BACK) : 2 === b ? a.cullFace(a.FRONT) : a.cullFace(a.FRONT_AND_BACK))) : f(a.CULL_FACE); H = b } function l(b, c, d) { if (b) { if (e(a.POLYGON_OFFSET_FILL), V !== c || K !== d) a.polygonOffset(c, d), V = c, K = d } else f(a.POLYGON_OFFSET_FILL) } function q(b) { void 0 === b && (b = a.TEXTURE0 + N - 1); R !== b && (a.activeTexture(b), R = b) } var n = new function () {
			var b = !1, c = new da, d = null, e = new da(0, 0, 0, 0); return {
				setMask: function (c) { d === c || b || (a.colorMask(c, c, c, c), d = c) }, setLocked: function (a) { b = a },
				setClear: function (b, d, f, g, h) { !0 === h && (b *= g, d *= g, f *= g); c.set(b, d, f, g); !1 === e.equals(c) && (a.clearColor(b, d, f, g), e.copy(c)) }, reset: function () { b = !1; d = null; e.set(-1, 0, 0, 0) }
			}
		}, t = new function () {
			var b = !1, c = null, d = null, g = null; return {
				setTest: function (b) { b ? e(a.DEPTH_TEST) : f(a.DEPTH_TEST) }, setMask: function (d) { c === d || b || (a.depthMask(d), c = d) }, setFunc: function (b) {
					if (d !== b) {
						if (b) switch (b) {
							case 0: a.depthFunc(a.NEVER); break; case 1: a.depthFunc(a.ALWAYS); break; case 2: a.depthFunc(a.LESS); break; case 3: a.depthFunc(a.LEQUAL);
								break; case 4: a.depthFunc(a.EQUAL); break; case 5: a.depthFunc(a.GEQUAL); break; case 6: a.depthFunc(a.GREATER); break; case 7: a.depthFunc(a.NOTEQUAL); break; default: a.depthFunc(a.LEQUAL)
						} else a.depthFunc(a.LEQUAL); d = b
					}
				}, setLocked: function (a) { b = a }, setClear: function (b) { g !== b && (a.clearDepth(b), g = b) }, reset: function () { b = !1; g = d = c = null }
			}
		}, r = new function () {
			var b = !1, c = null, d = null, g = null, h = null, l = null, k = null, n = null, q = null; return {
				setTest: function (b) { b ? e(a.STENCIL_TEST) : f(a.STENCIL_TEST) }, setMask: function (d) {
				c === d || b ||
					(a.stencilMask(d), c = d)
				}, setFunc: function (b, c, e) { if (d !== b || g !== c || h !== e) a.stencilFunc(b, c, e), d = b, g = c, h = e }, setOp: function (b, c, d) { if (l !== b || k !== c || n !== d) a.stencilOp(b, c, d), l = b, k = c, n = d }, setLocked: function (a) { b = a }, setClear: function (b) { q !== b && (a.clearStencil(b), q = b) }, reset: function () { b = !1; q = n = k = l = h = g = d = c = null }
			}
		}, m = a.getParameter(a.MAX_VERTEX_ATTRIBS), p = new Uint8Array(m), w = new Uint8Array(m), x = new Uint8Array(m), z = {}, I = null, B = null, J = null, ta = null, y = null, C = null, ha = null, A = null, E = null, L = !1, D = null, H = null, M = null,
			V = null, K = null, N = a.getParameter(a.MAX_COMBINED_TEXTURE_IMAGE_UNITS), m = parseFloat(/^WebGL\ ([0-9])/.exec(a.getParameter(a.VERSION))[1]), aa = 1 <= parseFloat(m), R = null, P = {}, Q = new da, G = new da, X = {}; X[a.TEXTURE_2D] = d(a.TEXTURE_2D, a.TEXTURE_2D, 1); X[a.TEXTURE_CUBE_MAP] = d(a.TEXTURE_CUBE_MAP, a.TEXTURE_CUBE_MAP_POSITIVE_X, 6); n.setClear(0, 0, 0, 1); t.setClear(1); r.setClear(0); e(a.DEPTH_TEST); t.setFunc(3); h(!1); k(1); e(a.CULL_FACE); e(a.BLEND); g(1); return {
				buffers: { color: n, depth: t, stencil: r }, initAttributes: function () {
					for (var a =
						0, b = p.length; a < b; a++)p[a] = 0
				}, enableAttribute: function (c) { p[c] = 1; 0 === w[c] && (a.enableVertexAttribArray(c), w[c] = 1); 0 !== x[c] && (b.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(c, 0), x[c] = 0) }, enableAttributeAndDivisor: function (c, d) { p[c] = 1; 0 === w[c] && (a.enableVertexAttribArray(c), w[c] = 1); x[c] !== d && (b.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(c, d), x[c] = d) }, disableUnusedAttributes: function () { for (var b = 0, c = w.length; b !== c; ++b)w[b] !== p[b] && (a.disableVertexAttribArray(b), w[b] = 0) }, enable: e,
				disable: f, getCompressedTextureFormats: function () { if (null === I && (I = [], b.get("WEBGL_compressed_texture_pvrtc") || b.get("WEBGL_compressed_texture_s3tc") || b.get("WEBGL_compressed_texture_etc1"))) for (var c = a.getParameter(a.COMPRESSED_TEXTURE_FORMATS), d = 0; d < c.length; d++)I.push(c[d]); return I }, useProgram: function (b) { return B !== b ? (a.useProgram(b), B = b, !0) : !1 }, setBlending: g, setMaterial: function (b) {
					2 === b.side ? f(a.CULL_FACE) : e(a.CULL_FACE); h(1 === b.side); !0 === b.transparent ? g(b.blending, b.blendEquation, b.blendSrc,
						b.blendDst, b.blendEquationAlpha, b.blendSrcAlpha, b.blendDstAlpha, b.premultipliedAlpha) : g(0); t.setFunc(b.depthFunc); t.setTest(b.depthTest); t.setMask(b.depthWrite); n.setMask(b.colorWrite); l(b.polygonOffset, b.polygonOffsetFactor, b.polygonOffsetUnits)
				}, setFlipSided: h, setCullFace: k, setLineWidth: function (b) { b !== M && (aa && a.lineWidth(b), M = b) }, setPolygonOffset: l, setScissorTest: function (b) { b ? e(a.SCISSOR_TEST) : f(a.SCISSOR_TEST) }, activeTexture: q, bindTexture: function (b, c) {
				null === R && q(); var d = P[R]; void 0 === d && (d =
					{ type: void 0, texture: void 0 }, P[R] = d); if (d.type !== b || d.texture !== c) a.bindTexture(b, c || X[b]), d.type = b, d.texture = c
				}, compressedTexImage2D: function () { try { a.compressedTexImage2D.apply(a, arguments) } catch (fa) { console.error("THREE.WebGLState:", fa) } }, texImage2D: function () { try { a.texImage2D.apply(a, arguments) } catch (fa) { console.error("THREE.WebGLState:", fa) } }, scissor: function (b) { !1 === Q.equals(b) && (a.scissor(b.x, b.y, b.z, b.w), Q.copy(b)) }, viewport: function (b) { !1 === G.equals(b) && (a.viewport(b.x, b.y, b.z, b.w), G.copy(b)) },
				reset: function () { for (var b = 0; b < w.length; b++)1 === w[b] && (a.disableVertexAttribArray(b), w[b] = 0); z = {}; R = I = null; P = {}; H = D = J = B = null; n.reset(); t.reset(); r.reset() }
			}
	} function ng(a, b, c) {
		function d(b) {
			if ("highp" === b) { if (0 < a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.HIGH_FLOAT).precision && 0 < a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.HIGH_FLOAT).precision) return "highp"; b = "mediump" } return "mediump" === b && 0 < a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.MEDIUM_FLOAT).precision && 0 < a.getShaderPrecisionFormat(a.FRAGMENT_SHADER,
				a.MEDIUM_FLOAT).precision ? "mediump" : "lowp"
		} var e, f = void 0 !== c.precision ? c.precision : "highp", g = d(f); g !== f && (console.warn("THREE.WebGLRenderer:", f, "not supported, using", g, "instead."), f = g); c = !0 === c.logarithmicDepthBuffer; var g = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS), h = a.getParameter(a.MAX_VERTEX_TEXTURE_IMAGE_UNITS), k = a.getParameter(a.MAX_TEXTURE_SIZE), l = a.getParameter(a.MAX_CUBE_MAP_TEXTURE_SIZE), q = a.getParameter(a.MAX_VERTEX_ATTRIBS), n = a.getParameter(a.MAX_VERTEX_UNIFORM_VECTORS), t = a.getParameter(a.MAX_VARYING_VECTORS),
			r = a.getParameter(a.MAX_FRAGMENT_UNIFORM_VECTORS), m = 0 < h, p = !!b.get("OES_texture_float"); return {
				getMaxAnisotropy: function () { if (void 0 !== e) return e; var c = b.get("EXT_texture_filter_anisotropic"); return e = null !== c ? a.getParameter(c.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0 }, getMaxPrecision: d, precision: f, logarithmicDepthBuffer: c, maxTextures: g, maxVertexTextures: h, maxTextureSize: k, maxCubemapSize: l, maxAttributes: q, maxVertexUniforms: n, maxVaryings: t, maxFragmentUniforms: r, vertexTextures: m, floatFragmentTextures: p, floatVertexTextures: m &&
					p
			}
	} function U(a, b, c, d) { La.call(this); this.type = "PerspectiveCamera"; this.fov = void 0 !== a ? a : 50; this.zoom = 1; this.near = void 0 !== c ? c : .1; this.far = void 0 !== d ? d : 2E3; this.focus = 10; this.aspect = void 0 !== b ? b : 1; this.view = null; this.filmGauge = 35; this.filmOffset = 0; this.updateProjectionMatrix() } function nd(a) { U.call(this); this.cameras = a || [] } function og(a) {
		function b() {
			if (null !== d && d.isPresenting) {
				var b = d.getEyeParameters("left"), e = b.renderWidth, b = b.renderHeight; t = a.getPixelRatio(); n = a.getSize(); a.setDrawingBufferSize(2 *
					e, b, 1)
			} else c.enabled && a.setDrawingBufferSize(n.width, n.height, t)
		} var c = this, d = null, e = null; "undefined" !== typeof window && "VRFrameData" in window && (e = new window.VRFrameData); var f = new K, g = new K, h = new K, k = new U; k.bounds = new da(0, 0, .5, 1); k.layers.enable(1); var l = new U; l.bounds = new da(.5, 0, .5, 1); l.layers.enable(2); var q = new nd([k, l]); q.layers.enable(1); q.layers.enable(2); var n, t; "undefined" !== typeof window && window.addEventListener("vrdisplaypresentchange", b, !1); this.standing = this.enabled = !1; this.getDevice =
			function () { return d }; this.setDevice = function (a) { void 0 !== a && (d = a) }; this.getCamera = function (a) {
				if (null === d) return a; d.depthNear = a.near; d.depthFar = a.far; d.getFrameData(e); var b = e.pose; null !== b.position ? a.position.fromArray(b.position) : a.position.set(0, 0, 0); null !== b.orientation && a.quaternion.fromArray(b.orientation); a.updateMatrixWorld(); b = d.stageParameters; this.standing && b && (g.fromArray(b.sittingToStandingTransform), h.getInverse(g), a.matrixWorld.multiply(g), a.matrixWorldInverse.multiply(h)); if (!1 ===
					d.isPresenting) return a; k.near = a.near; l.near = a.near; k.far = a.far; l.far = a.far; q.matrixWorld.copy(a.matrixWorld); q.matrixWorldInverse.copy(a.matrixWorldInverse); k.matrixWorldInverse.fromArray(e.leftViewMatrix); l.matrixWorldInverse.fromArray(e.rightViewMatrix); this.standing && b && (k.matrixWorldInverse.multiply(h), l.matrixWorldInverse.multiply(h)); a = a.parent; null !== a && (f.getInverse(a.matrixWorld), k.matrixWorldInverse.multiply(f), l.matrixWorldInverse.multiply(f)); k.matrixWorld.getInverse(k.matrixWorldInverse);
				l.matrixWorld.getInverse(l.matrixWorldInverse); k.projectionMatrix.fromArray(e.leftProjectionMatrix); l.projectionMatrix.fromArray(e.rightProjectionMatrix); q.projectionMatrix.copy(k.projectionMatrix); a = d.getLayers(); a.length && (a = a[0], null !== a.leftBounds && 4 === a.leftBounds.length && k.bounds.fromArray(a.leftBounds), null !== a.rightBounds && 4 === a.rightBounds.length && l.bounds.fromArray(a.rightBounds)); return q
			}; this.getStandingMatrix = function () { return g }; this.submitFrame = function () { d && d.isPresenting && d.submitFrame() };
		this.dispose = function () { "undefined" !== typeof window && window.removeEventListener("vrdisplaypresentchange", b) }
	} function pg(a) {
		var b = {}; return {
			get: function (c) {
				if (void 0 !== b[c]) return b[c]; switch (c) {
					case "WEBGL_depth_texture": var d = a.getExtension("WEBGL_depth_texture") || a.getExtension("MOZ_WEBGL_depth_texture") || a.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": d = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
						a.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": d = a.getExtension("WEBGL_compressed_texture_s3tc") || a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": d = a.getExtension("WEBGL_compressed_texture_pvrtc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; case "WEBGL_compressed_texture_etc1": d = a.getExtension("WEBGL_compressed_texture_etc1");
						break; default: d = a.getExtension(c)
				}null === d && console.warn("THREE.WebGLRenderer: " + c + " extension not supported."); return b[c] = d
			}
		}
	} function qg() {
		function a() { l.value !== d && (l.value = d, l.needsUpdate = 0 < e); c.numPlanes = e; c.numIntersection = 0 } function b(a, b, d, e) {
			var f = null !== a ? a.length : 0, g = null; if (0 !== f) {
				g = l.value; if (!0 !== e || null === g) {
					e = d + 4 * f; b = b.matrixWorldInverse; k.getNormalMatrix(b); if (null === g || g.length < e) g = new Float32Array(e); for (e = 0; e !== f; ++e, d += 4)h.copy(a[e]).applyMatrix4(b, k), h.normal.toArray(g, d), g[d +
						3] = h.constant
				} l.value = g; l.needsUpdate = !0
			} c.numPlanes = f; return g
		} var c = this, d = null, e = 0, f = !1, g = !1, h = new Aa, k = new ra, l = { value: null, needsUpdate: !1 }; this.uniform = l; this.numIntersection = this.numPlanes = 0; this.init = function (a, c, g) { var h = 0 !== a.length || c || 0 !== e || f; f = c; d = b(a, g, 0); e = a.length; return h }; this.beginShadows = function () { g = !0; b(null) }; this.endShadows = function () { g = !1; a() }; this.setState = function (c, h, k, r, m, p) {
			if (!f || null === c || 0 === c.length || g && !k) g ? b(null) : a(); else {
				k = g ? 0 : e; var n = 4 * k, q = m.clippingState || null;
				l.value = q; q = b(c, r, n, p); for (c = 0; c !== n; ++c)q[c] = d[c]; m.clippingState = q; this.numIntersection = h ? this.numPlanes : 0; this.numPlanes += k
			}
		}
	} function Pe(a, b) {
		return {
			convert: function (c) {
				if (1E3 === c) return a.REPEAT; if (1001 === c) return a.CLAMP_TO_EDGE; if (1002 === c) return a.MIRRORED_REPEAT; if (1003 === c) return a.NEAREST; if (1004 === c) return a.NEAREST_MIPMAP_NEAREST; if (1005 === c) return a.NEAREST_MIPMAP_LINEAR; if (1006 === c) return a.LINEAR; if (1007 === c) return a.LINEAR_MIPMAP_NEAREST; if (1008 === c) return a.LINEAR_MIPMAP_LINEAR;
				if (1009 === c) return a.UNSIGNED_BYTE; if (1017 === c) return a.UNSIGNED_SHORT_4_4_4_4; if (1018 === c) return a.UNSIGNED_SHORT_5_5_5_1; if (1019 === c) return a.UNSIGNED_SHORT_5_6_5; if (1010 === c) return a.BYTE; if (1011 === c) return a.SHORT; if (1012 === c) return a.UNSIGNED_SHORT; if (1013 === c) return a.INT; if (1014 === c) return a.UNSIGNED_INT; if (1015 === c) return a.FLOAT; if (1016 === c) { var d = b.get("OES_texture_half_float"); if (null !== d) return d.HALF_FLOAT_OES } if (1021 === c) return a.ALPHA; if (1022 === c) return a.RGB; if (1023 === c) return a.RGBA;
				if (1024 === c) return a.LUMINANCE; if (1025 === c) return a.LUMINANCE_ALPHA; if (1026 === c) return a.DEPTH_COMPONENT; if (1027 === c) return a.DEPTH_STENCIL; if (100 === c) return a.FUNC_ADD; if (101 === c) return a.FUNC_SUBTRACT; if (102 === c) return a.FUNC_REVERSE_SUBTRACT; if (200 === c) return a.ZERO; if (201 === c) return a.ONE; if (202 === c) return a.SRC_COLOR; if (203 === c) return a.ONE_MINUS_SRC_COLOR; if (204 === c) return a.SRC_ALPHA; if (205 === c) return a.ONE_MINUS_SRC_ALPHA; if (206 === c) return a.DST_ALPHA; if (207 === c) return a.ONE_MINUS_DST_ALPHA;
				if (208 === c) return a.DST_COLOR; if (209 === c) return a.ONE_MINUS_DST_COLOR; if (210 === c) return a.SRC_ALPHA_SATURATE; if (2001 === c || 2002 === c || 2003 === c || 2004 === c) if (d = b.get("WEBGL_compressed_texture_s3tc"), null !== d) { if (2001 === c) return d.COMPRESSED_RGB_S3TC_DXT1_EXT; if (2002 === c) return d.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (2003 === c) return d.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (2004 === c) return d.COMPRESSED_RGBA_S3TC_DXT5_EXT } if (2100 === c || 2101 === c || 2102 === c || 2103 === c) if (d = b.get("WEBGL_compressed_texture_pvrtc"), null !==
					d) { if (2100 === c) return d.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (2101 === c) return d.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (2102 === c) return d.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (2103 === c) return d.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (2151 === c && (d = b.get("WEBGL_compressed_texture_etc1"), null !== d)) return d.COMPRESSED_RGB_ETC1_WEBGL; if (103 === c || 104 === c) if (d = b.get("EXT_blend_minmax"), null !== d) { if (103 === c) return d.MIN_EXT; if (104 === c) return d.MAX_EXT } return 1020 === c && (d = b.get("WEBGL_depth_texture"), null !== d) ? d.UNSIGNED_INT_24_8_WEBGL :
						0
			}
		}
	} function Wd(a) {
		function b() {
			ia = new pg(F); ia.get("WEBGL_depth_texture"); ia.get("OES_texture_float"); ia.get("OES_texture_float_linear"); ia.get("OES_texture_half_float"); ia.get("OES_texture_half_float_linear"); ia.get("OES_standard_derivatives"); ia.get("OES_element_index_uint"); ia.get("ANGLE_instanced_arrays"); oa = new Pe(F, ia); Z = new ng(F, ia, a); ba = new mg(F, ia, oa); ba.scissor(S.copy(ea).multiplyScalar(O)); ba.viewport(Q.copy(ca).multiplyScalar(O)); U = new lg; T = new kg(F, ia, ba, U, Z, oa, Vd); na = new Mf(F); pa = new Zf(F,
				na, Vd); ra = new bg(pa, Ra); va = new Wf(F); ma = new jg(L, ia, Z); sa = new ag; qa = new Uf; ja = new Qf(L, ba, pa, J); wa = new Yf(F, ia, Ra); xa = new Xf(F, ia, Ra); ya = new Jf(L, F, ba, T, Z); Aa = new Kf(L, F, ba, T, Z); L.info.programs = ma.programs; L.context = F; L.capabilities = Z; L.extensions = ia; L.properties = U; L.renderLists = qa; L.state = ba
		} function c(a) { a.preventDefault(); console.log("THREE.WebGLRenderer: Context Lost."); Y = !0 } function d() { console.log("THREE.WebGLRenderer: Context Restored."); Y = !1; b() } function e(a) {
			a = a.target; a.removeEventListener("dispose",
				e); f(a); U.remove(a)
		} function f(a) { var b = U.get(a).program; a.program = void 0; void 0 !== b && ma.releaseProgram(b) } function g(a, b, c) { a.render(function (a) { L.renderBufferImmediate(a, b, c) }) } function h(a) { null !== Ba && Ba(a); (a = ka.getDevice()) && a.isPresenting ? a.requestAnimationFrame(h) : window.requestAnimationFrame(h) } function k(a, b, c) {
			if (!1 !== a.visible) {
				if (a.layers.test(b.layers)) if (a.isLight) y.push(a), a.castShadow && C.push(a); else if (a.isSprite) a.frustumCulled && !Td.intersectsSprite(a) || D.push(a); else if (a.isLensFlare) Va.push(a);
				else if (a.isImmediateRenderObject) c && Nb.setFromMatrixPosition(a.matrixWorld).applyMatrix4(md), A.push(a, null, a.material, Nb.z, null); else if (a.isMesh || a.isLine || a.isPoints) if (a.isSkinnedMesh && a.skeleton.update(), !a.frustumCulled || Td.intersectsObject(a)) {
					c && Nb.setFromMatrixPosition(a.matrixWorld).applyMatrix4(md); var d = ra.update(a), e = a.material; if (Array.isArray(e)) for (var f = d.groups, g = 0, h = f.length; g < h; g++) { var l = f[g], n = e[l.materialIndex]; n && n.visible && A.push(a, d, n, Nb.z, l) } else e.visible && A.push(a, d, e,
						Nb.z, null)
				} a = a.children; g = 0; for (h = a.length; g < h; g++)k(a[g], b, c)
			}
		} function l(a, b, c, d) { for (var e = 0, f = a.length; e < f; e++) { var g = a[e], h = g.object, l = g.geometry, k = void 0 === d ? g.material : d, g = g.group; if (c.isArrayCamera) { aa = c; for (var n = c.cameras, t = 0, r = n.length; t < r; t++) { var m = n[t]; if (h.layers.test(m.layers)) { var u = m.bounds; ba.viewport(Q.set(u.x * X, u.y * fa, u.z * X, u.w * fa).multiplyScalar(O)); q(h, b, m, l, k, g) } } } else aa = null, q(h, b, c, l, k, g) } } function q(a, b, c, d, e, f) {
			a.onBeforeRender(L, b, c, d, e, f); a.modelViewMatrix.multiplyMatrices(c.matrixWorldInverse,
				a.matrixWorld); a.normalMatrix.getNormalMatrix(a.modelViewMatrix); if (a.isImmediateRenderObject) { ba.setMaterial(e); var h = t(c, b.fog, e, a); N = ""; g(a, h, e) } else L.renderBufferDirect(c, b.fog, d, e, a, f); a.onAfterRender(L, b, c, d, e, f)
		} function n(a, b, c) {
			var d = U.get(a); c = ma.getParameters(a, sa.state, C, b, Fa.numPlanes, Fa.numIntersection, c); var g = ma.getProgramCode(a, c), h = d.program, l = !0; if (void 0 === h) a.addEventListener("dispose", e); else if (h.code !== g) f(a); else { if (void 0 !== c.shaderID) return; l = !1 } l && (c.shaderID ? (h = mb[c.shaderID],
				d.shader = { name: a.type, uniforms: Ea.clone(h.uniforms), vertexShader: h.vertexShader, fragmentShader: h.fragmentShader }) : d.shader = { name: a.type, uniforms: a.uniforms, vertexShader: a.vertexShader, fragmentShader: a.fragmentShader }, a.onBeforeCompile(d.shader), h = ma.acquireProgram(a, d.shader, c, g), d.program = h, a.program = h); c = h.getAttributes(); if (a.morphTargets) for (g = a.numSupportedMorphTargets = 0; g < L.maxMorphTargets; g++)0 <= c["morphTarget" + g] && a.numSupportedMorphTargets++; if (a.morphNormals) for (g = a.numSupportedMorphNormals =
					0; g < L.maxMorphNormals; g++)0 <= c["morphNormal" + g] && a.numSupportedMorphNormals++; c = d.shader.uniforms; if (!a.isShaderMaterial && !a.isRawShaderMaterial || !0 === a.clipping) d.numClippingPlanes = Fa.numPlanes, d.numIntersection = Fa.numIntersection, c.clippingPlanes = Fa.uniform; d.fog = b; d.lightsHash = sa.state.hash; a.lights && (c.ambientLightColor.value = sa.state.ambient, c.directionalLights.value = sa.state.directional, c.spotLights.value = sa.state.spot, c.rectAreaLights.value = sa.state.rectArea, c.pointLights.value = sa.state.point,
						c.hemisphereLights.value = sa.state.hemi, c.directionalShadowMap.value = sa.state.directionalShadowMap, c.directionalShadowMatrix.value = sa.state.directionalShadowMatrix, c.spotShadowMap.value = sa.state.spotShadowMap, c.spotShadowMatrix.value = sa.state.spotShadowMatrix, c.pointShadowMap.value = sa.state.pointShadowMap, c.pointShadowMatrix.value = sa.state.pointShadowMatrix); a = d.program.getUniforms(); a = gb.seqWithValue(a.seq, c); d.uniformsList = a
		} function t(a, b, c, d) {
			G = 0; var e = U.get(c); ga && (Ud || a !== P) && Fa.setState(c.clippingPlanes,
				c.clipIntersection, c.clipShadows, a, e, a === P && c.id === V); !1 === c.needsUpdate && (void 0 === e.program ? c.needsUpdate = !0 : c.fog && e.fog !== b ? c.needsUpdate = !0 : c.lights && e.lightsHash !== sa.state.hash ? c.needsUpdate = !0 : void 0 === e.numClippingPlanes || e.numClippingPlanes === Fa.numPlanes && e.numIntersection === Fa.numIntersection || (c.needsUpdate = !0)); c.needsUpdate && (n(c, b, d), c.needsUpdate = !1); var f = !1, g = !1, h = !1, l = e.program, k = l.getUniforms(), q = e.shader.uniforms; ba.useProgram(l.program) && (h = g = f = !0); c.id !== V && (V = c.id, g = !0); if (f ||
					a !== P) {
						k.setValue(F, "projectionMatrix", a.projectionMatrix); Z.logarithmicDepthBuffer && k.setValue(F, "logDepthBufFC", 2 / (Math.log(a.far + 1) / Math.LN2)); P !== (aa || a) && (P = aa || a, h = g = !0); if (c.isShaderMaterial || c.isMeshPhongMaterial || c.isMeshStandardMaterial || c.envMap) f = k.map.cameraPosition, void 0 !== f && f.setValue(F, Nb.setFromMatrixPosition(a.matrixWorld)); (c.isMeshPhongMaterial || c.isMeshLambertMaterial || c.isMeshBasicMaterial || c.isMeshStandardMaterial || c.isShaderMaterial || c.skinning) && k.setValue(F, "viewMatrix",
							a.matrixWorldInverse)
			} if (c.skinning && (k.setOptional(F, d, "bindMatrix"), k.setOptional(F, d, "bindMatrixInverse"), a = d.skeleton)) if (f = a.bones, Z.floatVertexTextures) { if (void 0 === a.boneTexture) { var f = Math.sqrt(4 * f.length), f = R.ceilPowerOfTwo(f), f = Math.max(f, 4), t = new Float32Array(f * f * 4); t.set(a.boneMatrices); var u = new fb(t, f, f, 1023, 1015); a.boneMatrices = t; a.boneTexture = u; a.boneTextureSize = f } k.setValue(F, "boneTexture", a.boneTexture); k.setValue(F, "boneTextureSize", a.boneTextureSize) } else k.setOptional(F, a, "boneMatrices");
			g && (k.setValue(F, "toneMappingExposure", L.toneMappingExposure), k.setValue(F, "toneMappingWhitePoint", L.toneMappingWhitePoint), c.lights && (g = h, q.ambientLightColor.needsUpdate = g, q.directionalLights.needsUpdate = g, q.pointLights.needsUpdate = g, q.spotLights.needsUpdate = g, q.rectAreaLights.needsUpdate = g, q.hemisphereLights.needsUpdate = g), b && c.fog && (q.fogColor.value = b.color, b.isFog ? (q.fogNear.value = b.near, q.fogFar.value = b.far) : b.isFogExp2 && (q.fogDensity.value = b.density)), c.isMeshBasicMaterial ? r(q, c) : c.isMeshLambertMaterial ?
				(r(q, c), c.emissiveMap && (q.emissiveMap.value = c.emissiveMap)) : c.isMeshPhongMaterial ? (r(q, c), c.isMeshToonMaterial ? (m(q, c), c.gradientMap && (q.gradientMap.value = c.gradientMap)) : m(q, c)) : c.isMeshStandardMaterial ? (r(q, c), c.isMeshPhysicalMaterial && (q.clearCoat.value = c.clearCoat, q.clearCoatRoughness.value = c.clearCoatRoughness), q.roughness.value = c.roughness, q.metalness.value = c.metalness, c.roughnessMap && (q.roughnessMap.value = c.roughnessMap), c.metalnessMap && (q.metalnessMap.value = c.metalnessMap), c.emissiveMap &&
					(q.emissiveMap.value = c.emissiveMap), c.bumpMap && (q.bumpMap.value = c.bumpMap, q.bumpScale.value = c.bumpScale), c.normalMap && (q.normalMap.value = c.normalMap, q.normalScale.value.copy(c.normalScale)), c.displacementMap && (q.displacementMap.value = c.displacementMap, q.displacementScale.value = c.displacementScale, q.displacementBias.value = c.displacementBias), c.envMap && (q.envMapIntensity.value = c.envMapIntensity)) : c.isMeshDepthMaterial ? (r(q, c), c.displacementMap && (q.displacementMap.value = c.displacementMap, q.displacementScale.value =
						c.displacementScale, q.displacementBias.value = c.displacementBias)) : c.isMeshDistanceMaterial ? (r(q, c), c.displacementMap && (q.displacementMap.value = c.displacementMap, q.displacementScale.value = c.displacementScale, q.displacementBias.value = c.displacementBias), q.referencePosition.value.copy(c.referencePosition), q.nearDistance.value = c.nearDistance, q.farDistance.value = c.farDistance) : c.isMeshNormalMaterial ? (r(q, c), c.bumpMap && (q.bumpMap.value = c.bumpMap, q.bumpScale.value = c.bumpScale), c.normalMap && (q.normalMap.value =
							c.normalMap, q.normalScale.value.copy(c.normalScale)), c.displacementMap && (q.displacementMap.value = c.displacementMap, q.displacementScale.value = c.displacementScale, q.displacementBias.value = c.displacementBias)) : c.isLineBasicMaterial ? (q.diffuse.value = c.color, q.opacity.value = c.opacity, c.isLineDashedMaterial && (q.dashSize.value = c.dashSize, q.totalSize.value = c.dashSize + c.gapSize, q.scale.value = c.scale)) : c.isPointsMaterial ? (q.diffuse.value = c.color, q.opacity.value = c.opacity, q.size.value = c.size * O, q.scale.value =
								.5 * fa, q.map.value = c.map, null !== c.map && (!0 === c.map.matrixAutoUpdate && (b = c.map.offset, g = c.map.repeat, h = c.map.center, c.map.matrix.setUvTransform(b.x, b.y, g.x, g.y, c.map.rotation, h.x, h.y)), q.uvTransform.value.copy(c.map.matrix))) : c.isShadowMaterial && (q.color.value = c.color, q.opacity.value = c.opacity), void 0 !== q.ltcMat && (q.ltcMat.value = E.LTC_MAT_TEXTURE), void 0 !== q.ltcMag && (q.ltcMag.value = E.LTC_MAG_TEXTURE), gb.upload(F, e.uniformsList, q, L)); k.setValue(F, "modelViewMatrix", d.modelViewMatrix); k.setValue(F, "normalMatrix",
									d.normalMatrix); k.setValue(F, "modelMatrix", d.matrixWorld); return l
		} function r(a, b) {
			a.opacity.value = b.opacity; b.color && (a.diffuse.value = b.color); b.emissive && a.emissive.value.copy(b.emissive).multiplyScalar(b.emissiveIntensity); b.map && (a.map.value = b.map); b.alphaMap && (a.alphaMap.value = b.alphaMap); b.specularMap && (a.specularMap.value = b.specularMap); b.envMap && (a.envMap.value = b.envMap, a.flipEnvMap.value = b.envMap && b.envMap.isCubeTexture ? -1 : 1, a.reflectivity.value = b.reflectivity, a.refractionRatio.value = b.refractionRatio);
			b.lightMap && (a.lightMap.value = b.lightMap, a.lightMapIntensity.value = b.lightMapIntensity); b.aoMap && (a.aoMap.value = b.aoMap, a.aoMapIntensity.value = b.aoMapIntensity); if (b.map) var c = b.map; else b.specularMap ? c = b.specularMap : b.displacementMap ? c = b.displacementMap : b.normalMap ? c = b.normalMap : b.bumpMap ? c = b.bumpMap : b.roughnessMap ? c = b.roughnessMap : b.metalnessMap ? c = b.metalnessMap : b.alphaMap ? c = b.alphaMap : b.emissiveMap && (c = b.emissiveMap); if (void 0 !== c) {
			c.isWebGLRenderTarget && (c = c.texture); if (!0 === c.matrixAutoUpdate) {
				b =
				c.offset; var d = c.repeat, e = c.center; c.matrix.setUvTransform(b.x, b.y, d.x, d.y, c.rotation, e.x, e.y)
			} a.uvTransform.value.copy(c.matrix)
			}
		} function m(a, b) {
			a.specular.value = b.specular; a.shininess.value = Math.max(b.shininess, 1E-4); b.emissiveMap && (a.emissiveMap.value = b.emissiveMap); b.bumpMap && (a.bumpMap.value = b.bumpMap, a.bumpScale.value = b.bumpScale); b.normalMap && (a.normalMap.value = b.normalMap, a.normalScale.value.copy(b.normalScale)); b.displacementMap && (a.displacementMap.value = b.displacementMap, a.displacementScale.value =
				b.displacementScale, a.displacementBias.value = b.displacementBias)
		} console.log("THREE.WebGLRenderer", "88"); a = a || {}; var v = void 0 !== a.canvas ? a.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), w = void 0 !== a.context ? a.context : null, x = void 0 !== a.alpha ? a.alpha : !1, z = void 0 !== a.depth ? a.depth : !0, I = void 0 !== a.stencil ? a.stencil : !0, B = void 0 !== a.antialias ? a.antialias : !1, J = void 0 !== a.premultipliedAlpha ? a.premultipliedAlpha : !0, ta = void 0 !== a.preserveDrawingBuffer ? a.preserveDrawingBuffer : !1, y =
			[], C = [], A = null, D = [], Va = []; this.domElement = v; this.context = null; this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0; this.clippingPlanes = []; this.localClippingEnabled = !1; this.gammaFactor = 2; this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1; this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1; this.maxMorphTargets = 8; this.maxMorphNormals = 4; var L = this, Y = !1, H = null, M = null, V = -1, N = "", P = null, aa = null, Q = new da, S = new da, W = null, G = 0, X = v.width,
				fa = v.height, O = 1, ca = new da(0, 0, X, fa), ea = new da(0, 0, X, fa), Oe = !1, Td = new ld, Fa = new qg, ga = !1, Ud = !1, md = new K, Nb = new p, Vd = { geometries: 0, textures: 0 }, Ra = { frame: 0, calls: 0, vertices: 0, faces: 0, points: 0 }; this.info = { render: Ra, memory: Vd, programs: null }; try {
					x = { alpha: x, depth: z, stencil: I, antialias: B, premultipliedAlpha: J, preserveDrawingBuffer: ta }; var F = w || v.getContext("webgl", x) || v.getContext("experimental-webgl", x); if (null === F) {
						if (null !== v.getContext("webgl")) throw "Error creating WebGL context with your selected attributes.";
						throw "Error creating WebGL context.";
					} void 0 === F.getShaderPrecisionFormat && (F.getShaderPrecisionFormat = function () { return { rangeMin: 1, rangeMax: 1, precision: 1 } }); v.addEventListener("webglcontextlost", c, !1); v.addEventListener("webglcontextrestored", d, !1)
				} catch (rg) { console.error("THREE.WebGLRenderer: " + rg) } var ia, Z, ba, U, T, na, pa, ra, sa, ma, qa, ja, va, wa, xa, ya, Aa, oa; b(); var ka = new og(L); this.vr = ka; var Ca = new Ie(L, ra, Z.maxTextureSize); this.shadowMap = Ca; this.getContext = function () { return F }; this.getContextAttributes =
					function () { return F.getContextAttributes() }; this.forceContextLoss = function () { var a = ia.get("WEBGL_lose_context"); a && a.loseContext() }; this.forceContextRestore = function () { var a = ia.get("WEBGL_lose_context"); a && a.restoreContext() }; this.getPixelRatio = function () { return O }; this.setPixelRatio = function (a) { void 0 !== a && (O = a, this.setSize(X, fa, !1)) }; this.getSize = function () { return { width: X, height: fa } }; this.setSize = function (a, b, c) {
						var d = ka.getDevice(); d && d.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") :
							(X = a, fa = b, v.width = a * O, v.height = b * O, !1 !== c && (v.style.width = a + "px", v.style.height = b + "px"), this.setViewport(0, 0, a, b))
					}; this.getDrawingBufferSize = function () { return { width: X * O, height: fa * O } }; this.setDrawingBufferSize = function (a, b, c) { X = a; fa = b; O = c; v.width = a * c; v.height = b * c; this.setViewport(0, 0, a, b) }; this.setViewport = function (a, b, c, d) { ca.set(a, fa - b - d, c, d); ba.viewport(Q.copy(ca).multiplyScalar(O)) }; this.setScissor = function (a, b, c, d) { ea.set(a, fa - b - d, c, d); ba.scissor(S.copy(ea).multiplyScalar(O)) }; this.setScissorTest =
						function (a) { ba.setScissorTest(Oe = a) }; this.getClearColor = function () { return ja.getClearColor() }; this.setClearColor = function () { ja.setClearColor.apply(ja, arguments) }; this.getClearAlpha = function () { return ja.getClearAlpha() }; this.setClearAlpha = function () { ja.setClearAlpha.apply(ja, arguments) }; this.clear = function (a, b, c) { var d = 0; if (void 0 === a || a) d |= F.COLOR_BUFFER_BIT; if (void 0 === b || b) d |= F.DEPTH_BUFFER_BIT; if (void 0 === c || c) d |= F.STENCIL_BUFFER_BIT; F.clear(d) }; this.clearColor = function () { this.clear(!0, !1, !1) };
		this.clearDepth = function () { this.clear(!1, !0, !1) }; this.clearStencil = function () { this.clear(!1, !1, !0) }; this.clearTarget = function (a, b, c, d) { this.setRenderTarget(a); this.clear(b, c, d) }; this.dispose = function () { v.removeEventListener("webglcontextlost", c, !1); v.removeEventListener("webglcontextrestored", d, !1); qa.dispose(); ka.dispose() }; this.renderBufferImmediate = function (a, b, c) {
			ba.initAttributes(); var d = U.get(a); a.hasPositions && !d.position && (d.position = F.createBuffer()); a.hasNormals && !d.normal && (d.normal = F.createBuffer());
			a.hasUvs && !d.uv && (d.uv = F.createBuffer()); a.hasColors && !d.color && (d.color = F.createBuffer()); b = b.getAttributes(); a.hasPositions && (F.bindBuffer(F.ARRAY_BUFFER, d.position), F.bufferData(F.ARRAY_BUFFER, a.positionArray, F.DYNAMIC_DRAW), ba.enableAttribute(b.position), F.vertexAttribPointer(b.position, 3, F.FLOAT, !1, 0, 0)); if (a.hasNormals) {
				F.bindBuffer(F.ARRAY_BUFFER, d.normal); if (!c.isMeshPhongMaterial && !c.isMeshStandardMaterial && !c.isMeshNormalMaterial && !0 === c.flatShading) for (var e = 0, f = 3 * a.count; e < f; e += 9) {
					var g =
						a.normalArray, h = (g[e + 0] + g[e + 3] + g[e + 6]) / 3, l = (g[e + 1] + g[e + 4] + g[e + 7]) / 3, k = (g[e + 2] + g[e + 5] + g[e + 8]) / 3; g[e + 0] = h; g[e + 1] = l; g[e + 2] = k; g[e + 3] = h; g[e + 4] = l; g[e + 5] = k; g[e + 6] = h; g[e + 7] = l; g[e + 8] = k
				} F.bufferData(F.ARRAY_BUFFER, a.normalArray, F.DYNAMIC_DRAW); ba.enableAttribute(b.normal); F.vertexAttribPointer(b.normal, 3, F.FLOAT, !1, 0, 0)
			} a.hasUvs && c.map && (F.bindBuffer(F.ARRAY_BUFFER, d.uv), F.bufferData(F.ARRAY_BUFFER, a.uvArray, F.DYNAMIC_DRAW), ba.enableAttribute(b.uv), F.vertexAttribPointer(b.uv, 2, F.FLOAT, !1, 0, 0)); a.hasColors &&
				0 !== c.vertexColors && (F.bindBuffer(F.ARRAY_BUFFER, d.color), F.bufferData(F.ARRAY_BUFFER, a.colorArray, F.DYNAMIC_DRAW), ba.enableAttribute(b.color), F.vertexAttribPointer(b.color, 3, F.FLOAT, !1, 0, 0)); ba.disableUnusedAttributes(); F.drawArrays(F.TRIANGLES, 0, a.count); a.count = 0
		}; this.renderBufferDirect = function (a, b, c, d, e, f) {
			ba.setMaterial(d); var g = t(a, b, d, e); a = c.id + "_" + g.id + "_" + (!0 === d.wireframe); var h = !1; a !== N && (N = a, h = !0); e.morphTargetInfluences && (va.update(e, c, d, g), h = !0); var l = c.index, k = c.attributes.position;
			b = 1; !0 === d.wireframe && (l = pa.getWireframeAttribute(c), b = 2); a = wa; if (null !== l) { var n = na.get(l); a = xa; a.setIndex(n) } if (h) {
				h = void 0; if (c && c.isInstancedBufferGeometry && null === ia.get("ANGLE_instanced_arrays")) console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); else {
				void 0 === h && (h = 0); ba.initAttributes(); var q = c.attributes, g = g.getAttributes(), r = d.defaultAttributeValues; for (J in g) {
					var m = g[J]; if (0 <= m) {
						var u =
							q[J]; if (void 0 !== u) {
								var p = u.normalized, v = u.itemSize, w = na.get(u); if (void 0 !== w) {
									var z = w.buffer, x = w.type, w = w.bytesPerElement; if (u.isInterleavedBufferAttribute) { var B = u.data, I = B.stride, u = u.offset; B && B.isInstancedInterleavedBuffer ? (ba.enableAttributeAndDivisor(m, B.meshPerAttribute), void 0 === c.maxInstancedCount && (c.maxInstancedCount = B.meshPerAttribute * B.count)) : ba.enableAttribute(m); F.bindBuffer(F.ARRAY_BUFFER, z); F.vertexAttribPointer(m, v, x, p, I * w, (h * I + u) * w) } else u.isInstancedBufferAttribute ? (ba.enableAttributeAndDivisor(m,
										u.meshPerAttribute), void 0 === c.maxInstancedCount && (c.maxInstancedCount = u.meshPerAttribute * u.count)) : ba.enableAttribute(m), F.bindBuffer(F.ARRAY_BUFFER, z), F.vertexAttribPointer(m, v, x, p, 0, h * v * w)
								}
							} else if (void 0 !== r && (p = r[J], void 0 !== p)) switch (p.length) { case 2: F.vertexAttrib2fv(m, p); break; case 3: F.vertexAttrib3fv(m, p); break; case 4: F.vertexAttrib4fv(m, p); break; default: F.vertexAttrib1fv(m, p) }
					}
				} ba.disableUnusedAttributes()
				} null !== l && F.bindBuffer(F.ELEMENT_ARRAY_BUFFER, n.buffer)
			} n = 0; null !== l ? n = l.count : void 0 !==
				k && (n = k.count); l = c.drawRange.start * b; k = null !== f ? f.start * b : 0; var J = Math.max(l, k); f = Math.max(0, Math.min(n, l + c.drawRange.count * b, k + (null !== f ? f.count * b : Infinity)) - 1 - J + 1); if (0 !== f) {
					if (e.isMesh) if (!0 === d.wireframe) ba.setLineWidth(d.wireframeLinewidth * (null === H ? O : 1)), a.setMode(F.LINES); else switch (e.drawMode) { case 0: a.setMode(F.TRIANGLES); break; case 1: a.setMode(F.TRIANGLE_STRIP); break; case 2: a.setMode(F.TRIANGLE_FAN) } else e.isLine ? (d = d.linewidth, void 0 === d && (d = 1), ba.setLineWidth(d * (null === H ? O : 1)), e.isLineSegments ?
						a.setMode(F.LINES) : e.isLineLoop ? a.setMode(F.LINE_LOOP) : a.setMode(F.LINE_STRIP)) : e.isPoints && a.setMode(F.POINTS); c && c.isInstancedBufferGeometry ? 0 < c.maxInstancedCount && a.renderInstances(c, J, f) : a.render(J, f)
				}
		}; this.compile = function (a, b) { y.length = 0; C.length = 0; a.traverse(function (a) { a.isLight && (y.push(a), a.castShadow && C.push(a)) }); sa.setup(y, C, b); a.traverse(function (b) { if (b.material) if (Array.isArray(b.material)) for (var c = 0; c < b.material.length; c++)n(b.material[c], a.fog, b); else n(b.material, a.fog, b) }) };
		var Da = !1, Ba = null; this.animate = function (a) { Ba = a; Da || ((a = ka.getDevice()) && a.isPresenting ? a.requestAnimationFrame(h) : window.requestAnimationFrame(h), Da = !0) }; this.render = function (a, b, c, d) {
			if (!b || !b.isCamera) console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); else if (!Y) {
				N = ""; V = -1; P = null; !0 === a.autoUpdate && a.updateMatrixWorld(); null === b.parent && b.updateMatrixWorld(); ka.enabled && (b = ka.getCamera(b)); md.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse); Td.setFromMatrix(md);
				y.length = 0; C.length = 0; D.length = 0; Va.length = 0; Ud = this.localClippingEnabled; ga = Fa.init(this.clippingPlanes, Ud, b); A = qa.get(a, b); A.init(); k(a, b, L.sortObjects); !0 === L.sortObjects && A.sort(); ga && Fa.beginShadows(); Ca.render(C, a, b); sa.setup(y, C, b); ga && Fa.endShadows(); Ra.frame++; Ra.calls = 0; Ra.vertices = 0; Ra.faces = 0; Ra.points = 0; void 0 === c && (c = null); this.setRenderTarget(c); ja.render(A, a, b, d); d = A.opaque; var e = A.transparent; if (a.overrideMaterial) { var f = a.overrideMaterial; d.length && l(d, a, b, f); e.length && l(e, a, b, f) } else d.length &&
					l(d, a, b), e.length && l(e, a, b); Aa.render(D, a, b); ya.render(Va, a, b, Q); c && T.updateRenderTargetMipmap(c); ba.buffers.depth.setTest(!0); ba.buffers.depth.setMask(!0); ba.buffers.color.setMask(!0); ba.setPolygonOffset(!1); ka.enabled && ka.submitFrame()
			}
		}; this.setFaceCulling = function (a, b) { ba.setCullFace(a); ba.setFlipSided(0 === b) }; this.allocTextureUnit = function () { var a = G; a >= Z.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + a + " texture units while this GPU supports only " + Z.maxTextures); G += 1; return a };
		this.setTexture2D = function () { var a = !1; return function (b, c) { b && b.isWebGLRenderTarget && (a || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), a = !0), b = b.texture); T.setTexture2D(b, c) } }(); this.setTexture = function () { var a = !1; return function (b, c) { a || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), a = !0); T.setTexture2D(b, c) } }(); this.setTextureCube = function () {
			var a = !1; return function (b, c) {
			b &&
				b.isWebGLRenderTargetCube && (a || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), a = !0), b = b.texture); b && b.isCubeTexture || Array.isArray(b.image) && 6 === b.image.length ? T.setTextureCube(b, c) : T.setTextureCubeDynamic(b, c)
			}
		}(); this.getRenderTarget = function () { return H }; this.setRenderTarget = function (a) {
		(H = a) && void 0 === U.get(a).__webglFramebuffer && T.setupRenderTarget(a); var b = null, c = !1; a ? (b = U.get(a).__webglFramebuffer, a.isWebGLRenderTargetCube &&
			(b = b[a.activeCubeFace], c = !0), Q.copy(a.viewport), S.copy(a.scissor), W = a.scissorTest) : (Q.copy(ca).multiplyScalar(O), S.copy(ea).multiplyScalar(O), W = Oe); M !== b && (F.bindFramebuffer(F.FRAMEBUFFER, b), M = b); ba.viewport(Q); ba.scissor(S); ba.setScissorTest(W); c && (c = U.get(a.texture), F.framebufferTexture2D(F.FRAMEBUFFER, F.COLOR_ATTACHMENT0, F.TEXTURE_CUBE_MAP_POSITIVE_X + a.activeCubeFace, c.__webglTexture, a.activeMipMapLevel))
		}; this.readRenderTargetPixels = function (a, b, c, d, e, f) {
			if (a && a.isWebGLRenderTarget) {
				var g = U.get(a).__webglFramebuffer;
				if (g) {
					var h = !1; g !== M && (F.bindFramebuffer(F.FRAMEBUFFER, g), h = !0); try {
						var l = a.texture, k = l.format, n = l.type; 1023 !== k && oa.convert(k) !== F.getParameter(F.IMPLEMENTATION_COLOR_READ_FORMAT) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : 1009 === n || oa.convert(n) === F.getParameter(F.IMPLEMENTATION_COLOR_READ_TYPE) || 1015 === n && (ia.get("OES_texture_float") || ia.get("WEBGL_color_buffer_float")) || 1016 === n && ia.get("EXT_color_buffer_half_float") ?
							F.checkFramebufferStatus(F.FRAMEBUFFER) === F.FRAMEBUFFER_COMPLETE ? 0 <= b && b <= a.width - d && 0 <= c && c <= a.height - e && F.readPixels(b, c, d, e, oa.convert(k), oa.convert(n), f) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.")
					} finally { h && F.bindFramebuffer(F.FRAMEBUFFER, M) }
				}
			} else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
		}
	}
	function Ob(a, b) { this.name = ""; this.color = new H(a); this.density = void 0 !== b ? b : 2.5E-4 } function Pb(a, b, c) { this.name = ""; this.color = new H(a); this.near = void 0 !== b ? b : 1; this.far = void 0 !== c ? c : 1E3 } function od() { A.call(this); this.type = "Scene"; this.overrideMaterial = this.fog = this.background = null; this.autoUpdate = !0 } function Xd(a, b, c, d, e) { A.call(this); this.lensFlares = []; this.positionScreen = new p; this.customUpdateCallback = void 0; void 0 !== a && this.add(a, b, c, d, e) } function Za(a) {
		Q.call(this); this.type = "SpriteMaterial";
		this.color = new H(16777215); this.map = null; this.rotation = 0; this.lights = this.fog = !1; this.setValues(a)
	} function Cc(a) { A.call(this); this.type = "Sprite"; this.material = void 0 !== a ? a : new Za } function Dc() { A.call(this); this.type = "LOD"; Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }) } function Ec(a, b) {
		a = a || []; this.bones = a.slice(0); this.boneMatrices = new Float32Array(16 * this.bones.length); if (void 0 === b) this.calculateInverses(); else if (this.bones.length === b.length) this.boneInverses = b.slice(0); else for (console.warn("THREE.Skeleton boneInverses is the wrong length."),
			this.boneInverses = [], a = 0, b = this.bones.length; a < b; a++)this.boneInverses.push(new K)
	} function pd() { A.call(this); this.type = "Bone" } function qd(a, b) { pa.call(this, a, b); this.type = "SkinnedMesh"; this.bindMode = "attached"; this.bindMatrix = new K; this.bindMatrixInverse = new K; a = this.initBones(); a = new Ec(a); this.bind(a, this.matrixWorld); this.normalizeSkinWeights() } function O(a) {
		Q.call(this); this.type = "LineBasicMaterial"; this.color = new H(16777215); this.linewidth = 1; this.linejoin = this.linecap = "round"; this.lights = !1;
		this.setValues(a)
	} function ma(a, b, c) { if (1 === c) return console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."), new ca(a, b); A.call(this); this.type = "Line"; this.geometry = void 0 !== a ? a : new D; this.material = void 0 !== b ? b : new O({ color: 16777215 * Math.random() }) } function ca(a, b) { ma.call(this, a, b); this.type = "LineSegments" } function rd(a, b) { ma.call(this, a, b); this.type = "LineLoop" } function Ba(a) {
		Q.call(this); this.type = "PointsMaterial"; this.color = new H(16777215);
		this.map = null; this.size = 1; this.sizeAttenuation = !0; this.lights = !1; this.setValues(a)
	} function Qb(a, b) { A.call(this); this.type = "Points"; this.geometry = void 0 !== a ? a : new D; this.material = void 0 !== b ? b : new Ba({ color: 16777215 * Math.random() }) } function Fc() { A.call(this); this.type = "Group" } function sd(a, b, c, d, e, f, g, h, k) { function l() { var a = q.image; a.readyState >= a.HAVE_CURRENT_DATA && (q.needsUpdate = !0); requestAnimationFrame(l) } ea.call(this, a, b, c, d, e, f, g, h, k); this.generateMipmaps = !1; var q = this; requestAnimationFrame(l) }
	function Rb(a, b, c, d, e, f, g, h, k, l, q, n) { ea.call(this, null, f, g, h, k, l, d, e, q, n); this.image = { width: b, height: c }; this.mipmaps = a; this.generateMipmaps = this.flipY = !1 } function Gc(a, b, c, d, e, f, g, h, k, l) {
		l = void 0 !== l ? l : 1026; if (1026 !== l && 1027 !== l) throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); void 0 === c && 1026 === l && (c = 1012); void 0 === c && 1027 === l && (c = 1020); ea.call(this, null, d, e, f, g, h, l, c, k); this.image = { width: a, height: b }; this.magFilter = void 0 !== g ? g : 1003; this.minFilter = void 0 !==
			h ? h : 1003; this.generateMipmaps = this.flipY = !1
	} function Sb(a) {
		D.call(this); this.type = "WireframeGeometry"; var b = [], c, d, e, f = [0, 0], g = {}, h = ["a", "b", "c"]; if (a && a.isGeometry) { var k = a.faces; var l = 0; for (d = k.length; l < d; l++) { var q = k[l]; for (c = 0; 3 > c; c++) { var n = q[h[c]]; var t = q[h[(c + 1) % 3]]; f[0] = Math.min(n, t); f[1] = Math.max(n, t); n = f[0] + "," + f[1]; void 0 === g[n] && (g[n] = { index1: f[0], index2: f[1] }) } } for (n in g) l = g[n], h = a.vertices[l.index1], b.push(h.x, h.y, h.z), h = a.vertices[l.index2], b.push(h.x, h.y, h.z) } else if (a && a.isBufferGeometry) {
			var h =
				new p; if (null !== a.index) { k = a.attributes.position; q = a.index; var r = a.groups; 0 === r.length && (r = [{ start: 0, count: q.count, materialIndex: 0 }]); a = 0; for (e = r.length; a < e; ++a)for (l = r[a], c = l.start, d = l.count, l = c, d = c + d; l < d; l += 3)for (c = 0; 3 > c; c++)n = q.getX(l + c), t = q.getX(l + (c + 1) % 3), f[0] = Math.min(n, t), f[1] = Math.max(n, t), n = f[0] + "," + f[1], void 0 === g[n] && (g[n] = { index1: f[0], index2: f[1] }); for (n in g) l = g[n], h.fromBufferAttribute(k, l.index1), b.push(h.x, h.y, h.z), h.fromBufferAttribute(k, l.index2), b.push(h.x, h.y, h.z) } else for (k = a.attributes.position,
					l = 0, d = k.count / 3; l < d; l++)for (c = 0; 3 > c; c++)g = 3 * l + c, h.fromBufferAttribute(k, g), b.push(h.x, h.y, h.z), g = 3 * l + (c + 1) % 3, h.fromBufferAttribute(k, g), b.push(h.x, h.y, h.z)
		} this.addAttribute("position", new y(b, 3))
	} function Hc(a, b, c) { N.call(this); this.type = "ParametricGeometry"; this.parameters = { func: a, slices: b, stacks: c }; this.fromBufferGeometry(new Tb(a, b, c)); this.mergeVertices() } function Tb(a, b, c) {
		D.call(this); this.type = "ParametricBufferGeometry"; this.parameters = { func: a, slices: b, stacks: c }; var d = [], e = [], f = [], g = [], h =
			new p, k = new p, l = new p, q = new p, n = new p, t, r, m = b + 1; for (t = 0; t <= c; t++) { var v = t / c; for (r = 0; r <= b; r++) { var w = r / b, k = a(w, v, k); e.push(k.x, k.y, k.z); 0 <= w - 1E-5 ? (l = a(w - 1E-5, v, l), q.subVectors(k, l)) : (l = a(w + 1E-5, v, l), q.subVectors(l, k)); 0 <= v - 1E-5 ? (l = a(w, v - 1E-5, l), n.subVectors(k, l)) : (l = a(w, v + 1E-5, l), n.subVectors(l, k)); h.crossVectors(q, n).normalize(); f.push(h.x, h.y, h.z); g.push(w, v) } } for (t = 0; t < c; t++)for (r = 0; r < b; r++)a = t * m + r + 1, h = (t + 1) * m + r + 1, k = (t + 1) * m + r, d.push(t * m + r, a, k), d.push(a, h, k); this.setIndex(d); this.addAttribute("position",
				new y(e, 3)); this.addAttribute("normal", new y(f, 3)); this.addAttribute("uv", new y(g, 2))
	} function Ic(a, b, c, d) { N.call(this); this.type = "PolyhedronGeometry"; this.parameters = { vertices: a, indices: b, radius: c, detail: d }; this.fromBufferGeometry(new qa(a, b, c, d)); this.mergeVertices() } function qa(a, b, c, d) {
		function e(a) { h.push(a.x, a.y, a.z) } function f(b, c) { b *= 3; c.x = a[b + 0]; c.y = a[b + 1]; c.z = a[b + 2] } function g(a, b, c, d) { 0 > d && 1 === a.x && (k[b] = a.x - 1); 0 === c.x && 0 === c.z && (k[b] = d / 2 / Math.PI + .5) } D.call(this); this.type = "PolyhedronBufferGeometry";
		this.parameters = { vertices: a, indices: b, radius: c, detail: d }; c = c || 1; d = d || 0; var h = [], k = []; (function (a) {
			for (var c = new p, d = new p, g = new p, h = 0; h < b.length; h += 3) {
				f(b[h + 0], c); f(b[h + 1], d); f(b[h + 2], g); var k, l, m = c, x = d, z = g, I = Math.pow(2, a), B = []; for (l = 0; l <= I; l++) { B[l] = []; var J = m.clone().lerp(z, l / I), y = x.clone().lerp(z, l / I), C = I - l; for (k = 0; k <= C; k++)B[l][k] = 0 === k && l === I ? J : J.clone().lerp(y, k / C) } for (l = 0; l < I; l++)for (k = 0; k < 2 * (I - l) - 1; k++)m = Math.floor(k / 2), 0 === k % 2 ? (e(B[l][m + 1]), e(B[l + 1][m]), e(B[l][m])) : (e(B[l][m + 1]), e(B[l + 1][m +
					1]), e(B[l + 1][m]))
			}
		})(d); (function (a) { for (var b = new p, c = 0; c < h.length; c += 3)b.x = h[c + 0], b.y = h[c + 1], b.z = h[c + 2], b.normalize().multiplyScalar(a), h[c + 0] = b.x, h[c + 1] = b.y, h[c + 2] = b.z })(c); (function () {
			for (var a = new p, b = 0; b < h.length; b += 3)a.x = h[b + 0], a.y = h[b + 1], a.z = h[b + 2], k.push(Math.atan2(a.z, -a.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + .5)); for (var a = new p, b = new p, c = new p, d = new p, e = new C, f = new C, m = new C, w = 0, x = 0; w < h.length; w += 9, x += 6) {
				a.set(h[w + 0], h[w + 1], h[w + 2]); b.set(h[w + 3], h[w + 4], h[w +
					5]); c.set(h[w + 6], h[w + 7], h[w + 8]); e.set(k[x + 0], k[x + 1]); f.set(k[x + 2], k[x + 3]); m.set(k[x + 4], k[x + 5]); d.copy(a).add(b).add(c).divideScalar(3); var z = Math.atan2(d.z, -d.x); g(e, x + 0, a, z); g(f, x + 2, b, z); g(m, x + 4, c, z)
			} for (a = 0; a < k.length; a += 6)b = k[a + 0], c = k[a + 2], d = k[a + 4], e = Math.min(b, c, d), .9 < Math.max(b, c, d) && .1 > e && (.2 > b && (k[a + 0] += 1), .2 > c && (k[a + 2] += 1), .2 > d && (k[a + 4] += 1))
		})(); this.addAttribute("position", new y(h, 3)); this.addAttribute("normal", new y(h.slice(), 3)); this.addAttribute("uv", new y(k, 2)); 0 === d ? this.computeVertexNormals() :
			this.normalizeNormals()
	} function Jc(a, b) { N.call(this); this.type = "TetrahedronGeometry"; this.parameters = { radius: a, detail: b }; this.fromBufferGeometry(new Ub(a, b)); this.mergeVertices() } function Ub(a, b) { qa.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], a, b); this.type = "TetrahedronBufferGeometry"; this.parameters = { radius: a, detail: b } } function Kc(a, b) { N.call(this); this.type = "OctahedronGeometry"; this.parameters = { radius: a, detail: b }; this.fromBufferGeometry(new nb(a, b)); this.mergeVertices() }
	function nb(a, b) { qa.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], a, b); this.type = "OctahedronBufferGeometry"; this.parameters = { radius: a, detail: b } } function Lc(a, b) { N.call(this); this.type = "IcosahedronGeometry"; this.parameters = { radius: a, detail: b }; this.fromBufferGeometry(new Vb(a, b)); this.mergeVertices() } function Vb(a, b) {
		var c = (1 + Math.sqrt(5)) / 2; qa.call(this, [-1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, 0, 0, -1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, c, 0, -1, c, 0, 1, -c, 0, -1, -c, 0, 1], [0, 11,
			5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], a, b); this.type = "IcosahedronBufferGeometry"; this.parameters = { radius: a, detail: b }
	} function Mc(a, b) { N.call(this); this.type = "DodecahedronGeometry"; this.parameters = { radius: a, detail: b }; this.fromBufferGeometry(new Wb(a, b)); this.mergeVertices() } function Wb(a, b) {
		var c = (1 + Math.sqrt(5)) / 2, d = 1 / c; qa.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -d, -c, 0, -d, c, 0,
			d, -c, 0, d, c, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, 0, -c, 0, -d, c, 0, -d, -c, 0, d, c, 0, d], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], a, b); this.type = "DodecahedronBufferGeometry"; this.parameters = { radius: a, detail: b }
	} function Nc(a, b, c, d, e, f) {
		N.call(this); this.type = "TubeGeometry"; this.parameters = {
			path: a,
			tubularSegments: b, radius: c, radialSegments: d, closed: e
		}; void 0 !== f && console.warn("THREE.TubeGeometry: taper has been removed."); a = new Xb(a, b, c, d, e); this.tangents = a.tangents; this.normals = a.normals; this.binormals = a.binormals; this.fromBufferGeometry(a); this.mergeVertices()
	} function Xb(a, b, c, d, e) {
		function f(e) {
			q = a.getPointAt(e / b, q); var f = g.normals[e]; e = g.binormals[e]; for (t = 0; t <= d; t++) {
				var l = t / d * Math.PI * 2, n = Math.sin(l), l = -Math.cos(l); k.x = l * f.x + n * e.x; k.y = l * f.y + n * e.y; k.z = l * f.z + n * e.z; k.normalize(); u.push(k.x,
					k.y, k.z); h.x = q.x + c * k.x; h.y = q.y + c * k.y; h.z = q.z + c * k.z; m.push(h.x, h.y, h.z)
			}
		} D.call(this); this.type = "TubeBufferGeometry"; this.parameters = { path: a, tubularSegments: b, radius: c, radialSegments: d, closed: e }; b = b || 64; c = c || 1; d = d || 8; e = e || !1; var g = a.computeFrenetFrames(b, e); this.tangents = g.tangents; this.normals = g.normals; this.binormals = g.binormals; var h = new p, k = new p, l = new C, q = new p, n, t, m = [], u = [], v = [], w = []; for (n = 0; n < b; n++)f(n); f(!1 === e ? b : 0); for (n = 0; n <= b; n++)for (t = 0; t <= d; t++)l.x = n / b, l.y = t / d, v.push(l.x, l.y); (function () {
			for (t =
				1; t <= b; t++)for (n = 1; n <= d; n++) { var a = (d + 1) * t + (n - 1), c = (d + 1) * t + n, e = (d + 1) * (t - 1) + n; w.push((d + 1) * (t - 1) + (n - 1), a, e); w.push(a, c, e) }
		})(); this.setIndex(w); this.addAttribute("position", new y(m, 3)); this.addAttribute("normal", new y(u, 3)); this.addAttribute("uv", new y(v, 2))
	} function Oc(a, b, c, d, e, f, g) {
		N.call(this); this.type = "TorusKnotGeometry"; this.parameters = { radius: a, tube: b, tubularSegments: c, radialSegments: d, p: e, q: f }; void 0 !== g && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.");
		this.fromBufferGeometry(new Yb(a, b, c, d, e, f)); this.mergeVertices()
	} function Yb(a, b, c, d, e, f) {
		function g(a, b, c, d, e) { var f = Math.sin(a); b = c / b * a; c = Math.cos(b); e.x = d * (2 + c) * .5 * Math.cos(a); e.y = d * (2 + c) * f * .5; e.z = d * Math.sin(b) * .5 } D.call(this); this.type = "TorusKnotBufferGeometry"; this.parameters = { radius: a, tube: b, tubularSegments: c, radialSegments: d, p: e, q: f }; a = a || 1; b = b || .4; c = Math.floor(c) || 64; d = Math.floor(d) || 8; e = e || 2; f = f || 3; var h = [], k = [], l = [], q = [], n, t = new p, m = new p, u = new p, v = new p, w = new p, x = new p, z = new p; for (n = 0; n <=
			c; ++n) { var I = n / c * e * Math.PI * 2; g(I, e, f, a, u); g(I + .01, e, f, a, v); x.subVectors(v, u); z.addVectors(v, u); w.crossVectors(x, z); z.crossVectors(w, x); w.normalize(); z.normalize(); for (I = 0; I <= d; ++I) { var B = I / d * Math.PI * 2, J = -b * Math.cos(B), B = b * Math.sin(B); t.x = u.x + (J * z.x + B * w.x); t.y = u.y + (J * z.y + B * w.y); t.z = u.z + (J * z.z + B * w.z); k.push(t.x, t.y, t.z); m.subVectors(t, u).normalize(); l.push(m.x, m.y, m.z); q.push(n / c); q.push(I / d) } } for (I = 1; I <= c; I++)for (n = 1; n <= d; n++)a = (d + 1) * I + (n - 1), b = (d + 1) * I + n, e = (d + 1) * (I - 1) + n, h.push((d + 1) * (I - 1) + (n - 1), a, e),
				h.push(a, b, e); this.setIndex(h); this.addAttribute("position", new y(k, 3)); this.addAttribute("normal", new y(l, 3)); this.addAttribute("uv", new y(q, 2))
	} function Pc(a, b, c, d, e) { N.call(this); this.type = "TorusGeometry"; this.parameters = { radius: a, tube: b, radialSegments: c, tubularSegments: d, arc: e }; this.fromBufferGeometry(new Zb(a, b, c, d, e)); this.mergeVertices() } function Zb(a, b, c, d, e) {
		D.call(this); this.type = "TorusBufferGeometry"; this.parameters = { radius: a, tube: b, radialSegments: c, tubularSegments: d, arc: e }; a = a || 1; b = b ||
			.4; c = Math.floor(c) || 8; d = Math.floor(d) || 6; e = e || 2 * Math.PI; var f = [], g = [], h = [], k = [], l = new p, q = new p, n = new p, t, m; for (t = 0; t <= c; t++)for (m = 0; m <= d; m++) { var u = m / d * e, v = t / c * Math.PI * 2; q.x = (a + b * Math.cos(v)) * Math.cos(u); q.y = (a + b * Math.cos(v)) * Math.sin(u); q.z = b * Math.sin(v); g.push(q.x, q.y, q.z); l.x = a * Math.cos(u); l.y = a * Math.sin(u); n.subVectors(q, l).normalize(); h.push(n.x, n.y, n.z); k.push(m / d); k.push(t / c) } for (t = 1; t <= c; t++)for (m = 1; m <= d; m++)a = (d + 1) * (t - 1) + m - 1, b = (d + 1) * (t - 1) + m, e = (d + 1) * t + m, f.push((d + 1) * t + m - 1, a, e), f.push(a, b,
				e); this.setIndex(f); this.addAttribute("position", new y(g, 3)); this.addAttribute("normal", new y(h, 3)); this.addAttribute("uv", new y(k, 2))
	} function $a(a, b) { N.call(this); this.type = "ExtrudeGeometry"; this.parameters = { shapes: a, options: b }; this.fromBufferGeometry(new Ga(a, b)); this.mergeVertices() } function Ga(a, b) { "undefined" !== typeof a && (D.call(this), this.type = "ExtrudeBufferGeometry", a = Array.isArray(a) ? a : [a], this.addShapeList(a, b), this.computeVertexNormals()) } function Qc(a, b) {
		N.call(this); this.type = "TextGeometry";
		this.parameters = { text: a, parameters: b }; this.fromBufferGeometry(new $b(a, b)); this.mergeVertices()
	} function $b(a, b) { b = b || {}; var c = b.font; if (!c || !c.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new N; a = c.generateShapes(a, b.size, b.curveSegments); b.amount = void 0 !== b.height ? b.height : 50; void 0 === b.bevelThickness && (b.bevelThickness = 10); void 0 === b.bevelSize && (b.bevelSize = 8); void 0 === b.bevelEnabled && (b.bevelEnabled = !1); Ga.call(this, a, b); this.type = "TextBufferGeometry" }
	function Rc(a, b, c, d, e, f, g) { N.call(this); this.type = "SphereGeometry"; this.parameters = { radius: a, widthSegments: b, heightSegments: c, phiStart: d, phiLength: e, thetaStart: f, thetaLength: g }; this.fromBufferGeometry(new ob(a, b, c, d, e, f, g)); this.mergeVertices() } function ob(a, b, c, d, e, f, g) {
		D.call(this); this.type = "SphereBufferGeometry"; this.parameters = { radius: a, widthSegments: b, heightSegments: c, phiStart: d, phiLength: e, thetaStart: f, thetaLength: g }; a = a || 1; b = Math.max(3, Math.floor(b) || 8); c = Math.max(2, Math.floor(c) || 6); d = void 0 !==
			d ? d : 0; e = void 0 !== e ? e : 2 * Math.PI; f = void 0 !== f ? f : 0; g = void 0 !== g ? g : Math.PI; var h = f + g, k, l, q = 0, n = [], t = new p, m = new p, u = [], v = [], w = [], x = []; for (l = 0; l <= c; l++) { var z = [], I = l / c; for (k = 0; k <= b; k++) { var B = k / b; t.x = -a * Math.cos(d + B * e) * Math.sin(f + I * g); t.y = a * Math.cos(f + I * g); t.z = a * Math.sin(d + B * e) * Math.sin(f + I * g); v.push(t.x, t.y, t.z); m.set(t.x, t.y, t.z).normalize(); w.push(m.x, m.y, m.z); x.push(B, 1 - I); z.push(q++) } n.push(z) } for (l = 0; l < c; l++)for (k = 0; k < b; k++)a = n[l][k + 1], d = n[l][k], e = n[l + 1][k], g = n[l + 1][k + 1], (0 !== l || 0 < f) && u.push(a, d,
				g), (l !== c - 1 || h < Math.PI) && u.push(d, e, g); this.setIndex(u); this.addAttribute("position", new y(v, 3)); this.addAttribute("normal", new y(w, 3)); this.addAttribute("uv", new y(x, 2))
	} function Sc(a, b, c, d, e, f) { N.call(this); this.type = "RingGeometry"; this.parameters = { innerRadius: a, outerRadius: b, thetaSegments: c, phiSegments: d, thetaStart: e, thetaLength: f }; this.fromBufferGeometry(new ac(a, b, c, d, e, f)); this.mergeVertices() } function ac(a, b, c, d, e, f) {
		D.call(this); this.type = "RingBufferGeometry"; this.parameters = {
			innerRadius: a,
			outerRadius: b, thetaSegments: c, phiSegments: d, thetaStart: e, thetaLength: f
		}; a = a || .5; b = b || 1; e = void 0 !== e ? e : 0; f = void 0 !== f ? f : 2 * Math.PI; c = void 0 !== c ? Math.max(3, c) : 8; d = void 0 !== d ? Math.max(1, d) : 1; var g = [], h = [], k = [], l = [], q = a, n = (b - a) / d, t = new p, m = new C, u, v; for (u = 0; u <= d; u++) { for (v = 0; v <= c; v++)a = e + v / c * f, t.x = q * Math.cos(a), t.y = q * Math.sin(a), h.push(t.x, t.y, t.z), k.push(0, 0, 1), m.x = (t.x / b + 1) / 2, m.y = (t.y / b + 1) / 2, l.push(m.x, m.y); q += n } for (u = 0; u < d; u++)for (b = u * (c + 1), v = 0; v < c; v++)a = v + b, e = a + c + 1, f = a + c + 2, q = a + 1, g.push(a, e, q), g.push(e,
			f, q); this.setIndex(g); this.addAttribute("position", new y(h, 3)); this.addAttribute("normal", new y(k, 3)); this.addAttribute("uv", new y(l, 2))
	} function Tc(a, b, c, d) { N.call(this); this.type = "LatheGeometry"; this.parameters = { points: a, segments: b, phiStart: c, phiLength: d }; this.fromBufferGeometry(new bc(a, b, c, d)); this.mergeVertices() } function bc(a, b, c, d) {
		D.call(this); this.type = "LatheBufferGeometry"; this.parameters = { points: a, segments: b, phiStart: c, phiLength: d }; b = Math.floor(b) || 12; c = c || 0; d = d || 2 * Math.PI; d = R.clamp(d,
			0, 2 * Math.PI); var e = [], f = [], g = [], h = 1 / b, k = new p, l = new C, q; for (q = 0; q <= b; q++) { var n = c + q * h * d; var t = Math.sin(n), m = Math.cos(n); for (n = 0; n <= a.length - 1; n++)k.x = a[n].x * t, k.y = a[n].y, k.z = a[n].x * m, f.push(k.x, k.y, k.z), l.x = q / b, l.y = n / (a.length - 1), g.push(l.x, l.y) } for (q = 0; q < b; q++)for (n = 0; n < a.length - 1; n++)c = n + q * a.length, h = c + a.length, k = c + a.length + 1, l = c + 1, e.push(c, h, l), e.push(h, k, l); this.setIndex(e); this.addAttribute("position", new y(f, 3)); this.addAttribute("uv", new y(g, 2)); this.computeVertexNormals(); if (d === 2 * Math.PI) for (d =
				this.attributes.normal.array, e = new p, f = new p, g = new p, c = b * a.length * 3, n = q = 0; q < a.length; q++ , n += 3)e.x = d[n + 0], e.y = d[n + 1], e.z = d[n + 2], f.x = d[c + n + 0], f.y = d[c + n + 1], f.z = d[c + n + 2], g.addVectors(e, f).normalize(), d[n + 0] = d[c + n + 0] = g.x, d[n + 1] = d[c + n + 1] = g.y, d[n + 2] = d[c + n + 2] = g.z
	} function cc(a, b) {
		N.call(this); this.type = "ShapeGeometry"; "object" === typeof b && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), b = b.curveSegments); this.parameters = { shapes: a, curveSegments: b }; this.fromBufferGeometry(new dc(a,
			b)); this.mergeVertices()
	} function dc(a, b) {
		function c(a) { var c, h = e.length / 3; a = a.extractPoints(b); var l = a.shape, q = a.holes; if (!1 === Ha.isClockWise(l)) for (l = l.reverse(), a = 0, c = q.length; a < c; a++) { var m = q[a]; !0 === Ha.isClockWise(m) && (q[a] = m.reverse()) } var p = Ha.triangulateShape(l, q); a = 0; for (c = q.length; a < c; a++)m = q[a], l = l.concat(m); a = 0; for (c = l.length; a < c; a++)m = l[a], e.push(m.x, m.y, 0), f.push(0, 0, 1), g.push(m.x, m.y); a = 0; for (c = p.length; a < c; a++)l = p[a], d.push(l[0] + h, l[1] + h, l[2] + h), k += 3 } D.call(this); this.type = "ShapeBufferGeometry";
		this.parameters = { shapes: a, curveSegments: b }; b = b || 12; var d = [], e = [], f = [], g = [], h = 0, k = 0; if (!1 === Array.isArray(a)) c(a); else for (var l = 0; l < a.length; l++)c(a[l]), this.addGroup(h, k, l), h += k, k = 0; this.setIndex(d); this.addAttribute("position", new y(e, 3)); this.addAttribute("normal", new y(f, 3)); this.addAttribute("uv", new y(g, 2))
	} function ec(a, b) {
		D.call(this); this.type = "EdgesGeometry"; this.parameters = { thresholdAngle: b }; var c = []; b = Math.cos(R.DEG2RAD * (void 0 !== b ? b : 1)); var d = [0, 0], e = {}, f = ["a", "b", "c"]; if (a.isBufferGeometry) {
			var g =
				new N; g.fromBufferGeometry(a)
		} else g = a.clone(); g.mergeVertices(); g.computeFaceNormals(); a = g.vertices; g = g.faces; for (var h = 0, k = g.length; h < k; h++)for (var l = g[h], q = 0; 3 > q; q++) { var n = l[f[q]]; var t = l[f[(q + 1) % 3]]; d[0] = Math.min(n, t); d[1] = Math.max(n, t); n = d[0] + "," + d[1]; void 0 === e[n] ? e[n] = { index1: d[0], index2: d[1], face1: h, face2: void 0 } : e[n].face2 = h } for (n in e) if (d = e[n], void 0 === d.face2 || g[d.face1].normal.dot(g[d.face2].normal) <= b) f = a[d.index1], c.push(f.x, f.y, f.z), f = a[d.index2], c.push(f.x, f.y, f.z); this.addAttribute("position",
			new y(c, 3))
	} function pb(a, b, c, d, e, f, g, h) { N.call(this); this.type = "CylinderGeometry"; this.parameters = { radiusTop: a, radiusBottom: b, height: c, radialSegments: d, heightSegments: e, openEnded: f, thetaStart: g, thetaLength: h }; this.fromBufferGeometry(new Sa(a, b, c, d, e, f, g, h)); this.mergeVertices() } function Sa(a, b, c, d, e, f, g, h) {
		function k(c) {
			var e, f = new C, k = new p, r = 0, v = !0 === c ? a : b, z = !0 === c ? 1 : -1; var y = u; for (e = 1; e <= d; e++)n.push(0, w * z, 0), t.push(0, z, 0), m.push(.5, .5), u++; var A = u; for (e = 0; e <= d; e++) {
				var D = e / d * h + g, L = Math.cos(D),
				D = Math.sin(D); k.x = v * D; k.y = w * z; k.z = v * L; n.push(k.x, k.y, k.z); t.push(0, z, 0); f.x = .5 * L + .5; f.y = .5 * D * z + .5; m.push(f.x, f.y); u++
			} for (e = 0; e < d; e++)f = y + e, k = A + e, !0 === c ? q.push(k, k + 1, f) : q.push(k + 1, k, f), r += 3; l.addGroup(x, r, !0 === c ? 1 : 2); x += r
		} D.call(this); this.type = "CylinderBufferGeometry"; this.parameters = { radiusTop: a, radiusBottom: b, height: c, radialSegments: d, heightSegments: e, openEnded: f, thetaStart: g, thetaLength: h }; var l = this; a = void 0 !== a ? a : 1; b = void 0 !== b ? b : 1; c = c || 1; d = Math.floor(d) || 8; e = Math.floor(e) || 1; f = void 0 !== f ? f :
			!1; g = void 0 !== g ? g : 0; h = void 0 !== h ? h : 2 * Math.PI; var q = [], n = [], t = [], m = [], u = 0, v = [], w = c / 2, x = 0; (function () {
				var f, k, r = new p, J = new p, y = 0, C = (b - a) / c; for (k = 0; k <= e; k++) { var A = [], D = k / e, E = D * (b - a) + a; for (f = 0; f <= d; f++) { var H = f / d, L = H * h + g, Y = Math.sin(L), L = Math.cos(L); J.x = E * Y; J.y = -D * c + w; J.z = E * L; n.push(J.x, J.y, J.z); r.set(Y, C, L).normalize(); t.push(r.x, r.y, r.z); m.push(H, 1 - D); A.push(u++) } v.push(A) } for (f = 0; f < d; f++)for (k = 0; k < e; k++)r = v[k + 1][f], J = v[k + 1][f + 1], C = v[k][f + 1], q.push(v[k][f], r, C), q.push(r, J, C), y += 6; l.addGroup(x, y, 0);
				x += y
			})(); !1 === f && (0 < a && k(!0), 0 < b && k(!1)); this.setIndex(q); this.addAttribute("position", new y(n, 3)); this.addAttribute("normal", new y(t, 3)); this.addAttribute("uv", new y(m, 2))
	} function Uc(a, b, c, d, e, f, g) { pb.call(this, 0, a, b, c, d, e, f, g); this.type = "ConeGeometry"; this.parameters = { radius: a, height: b, radialSegments: c, heightSegments: d, openEnded: e, thetaStart: f, thetaLength: g } } function Vc(a, b, c, d, e, f, g) {
		Sa.call(this, 0, a, b, c, d, e, f, g); this.type = "ConeBufferGeometry"; this.parameters = {
			radius: a, height: b, radialSegments: c,
			heightSegments: d, openEnded: e, thetaStart: f, thetaLength: g
		}
	} function Wc(a, b, c, d) { N.call(this); this.type = "CircleGeometry"; this.parameters = { radius: a, segments: b, thetaStart: c, thetaLength: d }; this.fromBufferGeometry(new fc(a, b, c, d)); this.mergeVertices() } function fc(a, b, c, d) {
		D.call(this); this.type = "CircleBufferGeometry"; this.parameters = { radius: a, segments: b, thetaStart: c, thetaLength: d }; a = a || 1; b = void 0 !== b ? Math.max(3, b) : 8; c = void 0 !== c ? c : 0; d = void 0 !== d ? d : 2 * Math.PI; var e = [], f = [], g = [], h = [], k, l = new p, q = new C; f.push(0,
			0, 0); g.push(0, 0, 1); h.push(.5, .5); var n = 0; for (k = 3; n <= b; n++ , k += 3) { var t = c + n / b * d; l.x = a * Math.cos(t); l.y = a * Math.sin(t); f.push(l.x, l.y, l.z); g.push(0, 0, 1); q.x = (f[k] / a + 1) / 2; q.y = (f[k + 1] / a + 1) / 2; h.push(q.x, q.y) } for (k = 1; k <= b; k++)e.push(k, k + 1, 0); this.setIndex(e); this.addAttribute("position", new y(f, 3)); this.addAttribute("normal", new y(g, 3)); this.addAttribute("uv", new y(h, 2))
	} function gc(a) { Q.call(this); this.type = "ShadowMaterial"; this.color = new H(0); this.opacity = 1; this.transparent = this.lights = !0; this.setValues(a) }
	function hc(a) { oa.call(this, a); this.type = "RawShaderMaterial" } function Ma(a) {
		Q.call(this); this.defines = { STANDARD: "" }; this.type = "MeshStandardMaterial"; this.color = new H(16777215); this.metalness = this.roughness = .5; this.lightMap = this.map = null; this.lightMapIntensity = 1; this.aoMap = null; this.aoMapIntensity = 1; this.emissive = new H(0); this.emissiveIntensity = 1; this.bumpMap = this.emissiveMap = null; this.bumpScale = 1; this.normalMap = null; this.normalScale = new C(1, 1); this.displacementMap = null; this.displacementScale = 1; this.displacementBias =
			0; this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null; this.envMapIntensity = 1; this.refractionRatio = .98; this.wireframe = !1; this.wireframeLinewidth = 1; this.wireframeLinejoin = this.wireframeLinecap = "round"; this.morphNormals = this.morphTargets = this.skinning = !1; this.setValues(a)
	} function qb(a) { Ma.call(this); this.defines = { PHYSICAL: "" }; this.type = "MeshPhysicalMaterial"; this.reflectivity = .5; this.clearCoatRoughness = this.clearCoat = 0; this.setValues(a) } function Ia(a) {
		Q.call(this); this.type = "MeshPhongMaterial";
		this.color = new H(16777215); this.specular = new H(1118481); this.shininess = 30; this.lightMap = this.map = null; this.lightMapIntensity = 1; this.aoMap = null; this.aoMapIntensity = 1; this.emissive = new H(0); this.emissiveIntensity = 1; this.bumpMap = this.emissiveMap = null; this.bumpScale = 1; this.normalMap = null; this.normalScale = new C(1, 1); this.displacementMap = null; this.displacementScale = 1; this.displacementBias = 0; this.envMap = this.alphaMap = this.specularMap = null; this.combine = 0; this.reflectivity = 1; this.refractionRatio = .98; this.wireframe =
			!1; this.wireframeLinewidth = 1; this.wireframeLinejoin = this.wireframeLinecap = "round"; this.morphNormals = this.morphTargets = this.skinning = !1; this.setValues(a)
	} function rb(a) { Ia.call(this); this.defines = { TOON: "" }; this.type = "MeshToonMaterial"; this.gradientMap = null; this.setValues(a) } function sb(a) {
		Q.call(this); this.type = "MeshNormalMaterial"; this.bumpMap = null; this.bumpScale = 1; this.normalMap = null; this.normalScale = new C(1, 1); this.displacementMap = null; this.displacementScale = 1; this.displacementBias = 0; this.wireframe =
			!1; this.wireframeLinewidth = 1; this.morphNormals = this.morphTargets = this.skinning = this.lights = this.fog = !1; this.setValues(a)
	} function tb(a) {
		Q.call(this); this.type = "MeshLambertMaterial"; this.color = new H(16777215); this.lightMap = this.map = null; this.lightMapIntensity = 1; this.aoMap = null; this.aoMapIntensity = 1; this.emissive = new H(0); this.emissiveIntensity = 1; this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null; this.combine = 0; this.reflectivity = 1; this.refractionRatio = .98; this.wireframe = !1; this.wireframeLinewidth =
			1; this.wireframeLinejoin = this.wireframeLinecap = "round"; this.morphNormals = this.morphTargets = this.skinning = !1; this.setValues(a)
	} function ub(a) { O.call(this); this.type = "LineDashedMaterial"; this.scale = 1; this.dashSize = 3; this.gapSize = 1; this.setValues(a) } function Yd(a, b, c) {
		var d = this, e = !1, f = 0, g = 0, h = void 0; this.onStart = void 0; this.onLoad = a; this.onProgress = b; this.onError = c; this.itemStart = function (a) { g++; if (!1 === e && void 0 !== d.onStart) d.onStart(a, f, g); e = !0 }; this.itemEnd = function (a) {
			f++; if (void 0 !== d.onProgress) d.onProgress(a,
				f, g); if (f === g && (e = !1, void 0 !== d.onLoad)) d.onLoad()
		}; this.itemError = function (a) { if (void 0 !== d.onError) d.onError(a) }; this.resolveURL = function (a) { return h ? h(a) : a }; this.setURLModifier = function (a) { h = a }
	} function Ja(a) { this.manager = void 0 !== a ? a : wa } function Qe(a) { this.manager = void 0 !== a ? a : wa; this._parser = null } function Zd(a) { this.manager = void 0 !== a ? a : wa; this._parser = null } function Xc(a) { this.manager = void 0 !== a ? a : wa } function $d(a) { this.manager = void 0 !== a ? a : wa } function td(a) { this.manager = void 0 !== a ? a : wa } function ga(a,
		b) { A.call(this); this.type = "Light"; this.color = new H(a); this.intensity = void 0 !== b ? b : 1; this.receiveShadow = void 0 } function ud(a, b, c) { ga.call(this, a, c); this.type = "HemisphereLight"; this.castShadow = void 0; this.position.copy(A.DefaultUp); this.updateMatrix(); this.groundColor = new H(b) } function vb(a) { this.camera = a; this.bias = 0; this.radius = 1; this.mapSize = new C(512, 512); this.map = null; this.matrix = new K } function vd() { vb.call(this, new U(50, 1, .5, 500)) } function wd(a, b, c, d, e, f) {
			ga.call(this, a, b); this.type = "SpotLight";
			this.position.copy(A.DefaultUp); this.updateMatrix(); this.target = new A; Object.defineProperty(this, "power", { get: function () { return this.intensity * Math.PI }, set: function (a) { this.intensity = a / Math.PI } }); this.distance = void 0 !== c ? c : 0; this.angle = void 0 !== d ? d : Math.PI / 3; this.penumbra = void 0 !== e ? e : 0; this.decay = void 0 !== f ? f : 1; this.shadow = new vd
		} function xd(a, b, c, d) {
			ga.call(this, a, b); this.type = "PointLight"; Object.defineProperty(this, "power", {
				get: function () { return 4 * this.intensity * Math.PI }, set: function (a) {
				this.intensity =
					a / (4 * Math.PI)
				}
			}); this.distance = void 0 !== c ? c : 0; this.decay = void 0 !== d ? d : 1; this.shadow = new vb(new U(90, 1, .5, 500))
		} function yd() { vb.call(this, new Kb(-5, 5, 5, -5, .5, 500)) } function zd(a, b) { ga.call(this, a, b); this.type = "DirectionalLight"; this.position.copy(A.DefaultUp); this.updateMatrix(); this.target = new A; this.shadow = new yd } function Ad(a, b) { ga.call(this, a, b); this.type = "AmbientLight"; this.castShadow = void 0 } function Bd(a, b, c, d) {
			ga.call(this, a, b); this.type = "RectAreaLight"; this.position.set(0, 1, 0); this.updateMatrix();
			this.width = void 0 !== c ? c : 10; this.height = void 0 !== d ? d : 10
		} function xa(a, b, c, d) { this.parameterPositions = a; this._cachedIndex = 0; this.resultBuffer = void 0 !== d ? d : new b.constructor(c); this.sampleValues = b; this.valueSize = c } function Cd(a, b, c, d) { xa.call(this, a, b, c, d); this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0 } function Yc(a, b, c, d) { xa.call(this, a, b, c, d) } function Dd(a, b, c, d) { xa.call(this, a, b, c, d) } function wb(a, b, c, d) {
			if (void 0 === a) throw Error("track name is undefined"); if (void 0 === b || 0 ===
				b.length) throw Error("no keyframes in track named " + a); this.name = a; this.times = T.convertArray(b, this.TimeBufferType); this.values = T.convertArray(c, this.ValueBufferType); this.setInterpolation(d || this.DefaultInterpolation); this.validate(); this.optimize()
		} function ic(a, b, c, d) { wb.call(this, a, b, c, d) } function Ed(a, b, c, d) { xa.call(this, a, b, c, d) } function Zc(a, b, c, d) { wb.call(this, a, b, c, d) } function jc(a, b, c, d) { wb.call(this, a, b, c, d) } function Fd(a, b, c, d) { wb.call(this, a, b, c, d) } function Gd(a, b, c) {
			wb.call(this, a, b,
				c)
		} function Hd(a, b, c, d) { wb.call(this, a, b, c, d) } function xb(a, b, c, d) { wb.apply(this, a, b, c, d) } function ka(a, b, c) { this.name = a; this.tracks = c; this.duration = void 0 !== b ? b : -1; this.uuid = R.generateUUID(); 0 > this.duration && this.resetDuration(); this.optimize() } function Id(a) { this.manager = void 0 !== a ? a : wa; this.textures = {} } function ae(a) { this.manager = void 0 !== a ? a : wa } function kc() { this.onLoadStart = function () { }; this.onLoadProgress = function () { }; this.onLoadComplete = function () { } } function be(a) {
		"boolean" === typeof a && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."),
			a = void 0); this.manager = void 0 !== a ? a : wa; this.withCredentials = !1
		} function Re(a) { this.manager = void 0 !== a ? a : wa; this.texturePath = "" } function Se(a, b, c, d, e) { b = .5 * (d - b); e = .5 * (e - c); var f = a * a; return (2 * c - 2 * d + b + e) * a * f + (-3 * c + 3 * d - 2 * b - e) * f + b * a + c } function yb(a, b, c, d) { var e = 1 - a; return e * e * b + 2 * (1 - a) * a * c + a * a * d } function zb(a, b, c, d, e) { var f = 1 - a, g = 1 - a; return f * f * f * b + 3 * g * g * a * c + 3 * (1 - a) * a * a * d + a * a * a * e } function S() { this.type = "Curve"; this.arcLengthDivisions = 200 } function Ka(a, b) {
			S.call(this); this.type = "LineCurve"; this.v1 = a ||
				new C; this.v2 = b || new C
		} function Ab() { S.call(this); this.type = "CurvePath"; this.curves = []; this.autoClose = !1 } function Na(a, b, c, d, e, f, g, h) { S.call(this); this.type = "EllipseCurve"; this.aX = a || 0; this.aY = b || 0; this.xRadius = c || 1; this.yRadius = d || 1; this.aStartAngle = e || 0; this.aEndAngle = f || 2 * Math.PI; this.aClockwise = g || !1; this.aRotation = h || 0 } function ab(a) { S.call(this); this.type = "SplineCurve"; this.points = a || [] } function bb(a, b, c, d) {
			S.call(this); this.type = "CubicBezierCurve"; this.v0 = a || new C; this.v1 = b || new C; this.v2 =
				c || new C; this.v3 = d || new C
		} function cb(a, b, c) { S.call(this); this.type = "QuadraticBezierCurve"; this.v0 = a || new C; this.v1 = b || new C; this.v2 = c || new C } function Bb(a) { Ab.call(this); this.type = "Path"; this.currentPoint = new C; a && this.setFromPoints(a) } function Cb(a) { Bb.call(this, a); this.type = "Shape"; this.holes = [] } function ce() { this.type = "ShapePath"; this.subPaths = []; this.currentPath = null } function de(a) { this.type = "Font"; this.data = a } function Te(a) { this.manager = void 0 !== a ? a : wa } function ee(a) {
		this.manager = void 0 !== a ?
			a : wa
		} function Ue() { this.type = "StereoCamera"; this.aspect = 1; this.eyeSep = .064; this.cameraL = new U; this.cameraL.layers.enable(1); this.cameraL.matrixAutoUpdate = !1; this.cameraR = new U; this.cameraR.layers.enable(2); this.cameraR.matrixAutoUpdate = !1 } function $c(a, b, c) {
			A.call(this); this.type = "CubeCamera"; var d = new U(90, 1, a, b); d.up.set(0, -1, 0); d.lookAt(new p(1, 0, 0)); this.add(d); var e = new U(90, 1, a, b); e.up.set(0, -1, 0); e.lookAt(new p(-1, 0, 0)); this.add(e); var f = new U(90, 1, a, b); f.up.set(0, 0, 1); f.lookAt(new p(0, 1, 0));
			this.add(f); var g = new U(90, 1, a, b); g.up.set(0, 0, -1); g.lookAt(new p(0, -1, 0)); this.add(g); var h = new U(90, 1, a, b); h.up.set(0, -1, 0); h.lookAt(new p(0, 0, 1)); this.add(h); var k = new U(90, 1, a, b); k.up.set(0, -1, 0); k.lookAt(new p(0, 0, -1)); this.add(k); this.renderTarget = new Ib(c, c, { format: 1022, magFilter: 1006, minFilter: 1006 }); this.renderTarget.texture.name = "CubeCamera"; this.update = function (a, b) {
			null === this.parent && this.updateMatrixWorld(); var c = this.renderTarget, l = c.texture.generateMipmaps; c.texture.generateMipmaps =
				!1; c.activeCubeFace = 0; a.render(b, d, c); c.activeCubeFace = 1; a.render(b, e, c); c.activeCubeFace = 2; a.render(b, f, c); c.activeCubeFace = 3; a.render(b, g, c); c.activeCubeFace = 4; a.render(b, h, c); c.texture.generateMipmaps = l; c.activeCubeFace = 5; a.render(b, k, c); a.setRenderTarget(null)
			}; this.clear = function (a, b, c, d) { for (var e = this.renderTarget, f = 0; 6 > f; f++)e.activeCubeFace = f, a.setRenderTarget(e), a.clear(b, c, d); a.setRenderTarget(null) }
		} function fe() {
			A.call(this); this.type = "AudioListener"; this.context = ge.getContext(); this.gain =
				this.context.createGain(); this.gain.connect(this.context.destination); this.filter = null
		} function lc(a) { A.call(this); this.type = "Audio"; this.context = a.context; this.gain = this.context.createGain(); this.gain.connect(a.getInput()); this.autoplay = !1; this.buffer = null; this.loop = !1; this.offset = this.startTime = 0; this.playbackRate = 1; this.isPlaying = !1; this.hasPlaybackControl = !0; this.sourceType = "empty"; this.filters = [] } function he(a) { lc.call(this, a); this.panner = this.context.createPanner(); this.panner.connect(this.gain) }
	function ie(a, b) { this.analyser = a.context.createAnalyser(); this.analyser.fftSize = void 0 !== b ? b : 2048; this.data = new Uint8Array(this.analyser.frequencyBinCount); a.getOutput().connect(this.analyser) } function je(a, b, c) { this.binding = a; this.valueSize = c; a = Float64Array; switch (b) { case "quaternion": b = this._slerp; break; case "string": case "bool": a = Array; b = this._select; break; default: b = this._lerp }this.buffer = new a(4 * c); this._mixBufferRegion = b; this.referenceCount = this.useCount = this.cumulativeWeight = 0 } function Ve(a,
		b, c) { c = c || na.parseTrackName(b); this._targetGroup = a; this._bindings = a.subscribe_(b, c) } function na(a, b, c) { this.path = b; this.parsedPath = c || na.parseTrackName(b); this.node = na.findNode(a, this.parsedPath.nodeName) || a; this.rootNode = a } function We() {
		this.uuid = R.generateUUID(); this._objects = Array.prototype.slice.call(arguments); this.nCachedObjects_ = 0; var a = {}; this._indicesByUUID = a; for (var b = 0, c = arguments.length; b !== c; ++b)a[arguments[b].uuid] = b; this._paths = []; this._parsedPaths = []; this._bindings = []; this._bindingsIndicesByPath =
			{}; var d = this; this.stats = { objects: { get total() { return d._objects.length }, get inUse() { return this.total - d.nCachedObjects_ } }, get bindingsPerObject() { return d._bindings.length } }
		} function Xe(a, b, c) {
		this._mixer = a; this._clip = b; this._localRoot = c || null; a = b.tracks; b = a.length; c = Array(b); for (var d = { endingStart: 2400, endingEnd: 2400 }, e = 0; e !== b; ++e) { var f = a[e].createInterpolant(null); c[e] = f; f.settings = d } this._interpolantSettings = d; this._interpolants = c; this._propertyBindings = Array(b); this._weightInterpolant = this._timeScaleInterpolant =
			this._byClipCacheIndex = this._cacheIndex = null; this.loop = 2201; this._loopCount = -1; this._startTime = null; this.time = 0; this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1; this.repetitions = Infinity; this.paused = !1; this.enabled = !0; this.clampWhenFinished = !1; this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0
		} function Ye(a) { this._root = a; this._initMemoryManager(); this.time = this._accuIndex = 0; this.timeScale = 1 } function Jd(a, b) {
		"string" === typeof a && (console.warn("THREE.Uniform: Type parameter is no longer needed."),
			a = b); this.value = a
		} function ke() { D.call(this); this.type = "InstancedBufferGeometry"; this.maxInstancedCount = void 0 } function le(a, b, c, d) { this.uuid = R.generateUUID(); this.data = a; this.itemSize = b; this.offset = c; this.normalized = !0 === d } function mc(a, b) { this.uuid = R.generateUUID(); this.array = a; this.stride = b; this.count = void 0 !== a ? a.length / b : 0; this.dynamic = !1; this.updateRange = { offset: 0, count: -1 }; this.onUploadCallback = function () { }; this.version = 0 } function me(a, b, c) { mc.call(this, a, b); this.meshPerAttribute = c || 1 } function ne(a,
			b, c) { P.call(this, a, b); this.meshPerAttribute = c || 1 } function Ze(a, b, c, d) { this.ray = new lb(a, b); this.near = c || 0; this.far = d || Infinity; this.params = { Mesh: {}, Line: {}, LOD: {}, Points: { threshold: 1 }, Sprite: {} }; Object.defineProperties(this.params, { PointCloud: { get: function () { console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."); return this.Points } } }) } function $e(a, b) { return a.distance - b.distance } function oe(a, b, c, d) {
				if (!1 !== a.visible && (a.raycast(b, c), !0 === d)) {
					a = a.children; d = 0; for (var e =
						a.length; d < e; d++)oe(a[d], b, c, !0)
				}
			} function af(a) { this.autoStart = void 0 !== a ? a : !0; this.elapsedTime = this.oldTime = this.startTime = 0; this.running = !1 } function bf(a, b, c) { this.radius = void 0 !== a ? a : 1; this.phi = void 0 !== b ? b : 0; this.theta = void 0 !== c ? c : 0; return this } function cf(a, b, c) { this.radius = void 0 !== a ? a : 1; this.theta = void 0 !== b ? b : 0; this.y = void 0 !== c ? c : 0; return this } function ad(a) { A.call(this); this.material = a; this.render = function () { } } function bd(a, b, c, d) {
			this.object = a; this.size = void 0 !== b ? b : 1; a = void 0 !== c ? c :
				16711680; d = void 0 !== d ? d : 1; b = 0; (c = this.object.geometry) && c.isGeometry ? b = 3 * c.faces.length : c && c.isBufferGeometry && (b = c.attributes.normal.count); c = new D; b = new y(6 * b, 3); c.addAttribute("position", b); ca.call(this, c, new O({ color: a, linewidth: d })); this.matrixAutoUpdate = !1; this.update()
			} function nc(a, b) {
				A.call(this); this.light = a; this.light.updateMatrixWorld(); this.matrix = a.matrixWorld; this.matrixAutoUpdate = !1; this.color = b; a = new D; b = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1]; for (var c = 0,
					d = 1; 32 > c; c++ , d++) { var e = c / 32 * Math.PI * 2, f = d / 32 * Math.PI * 2; b.push(Math.cos(e), Math.sin(e), 1, Math.cos(f), Math.sin(f), 1) } a.addAttribute("position", new y(b, 3)); b = new O({ fog: !1 }); this.cone = new ca(a, b); this.add(this.cone); this.update()
			} function df(a) { var b = []; a && a.isBone && b.push(a); for (var c = 0; c < a.children.length; c++)b.push.apply(b, df(a.children[c])); return b } function oc(a) {
				for (var b = df(a), c = new D, d = [], e = [], f = new H(0, 0, 1), g = new H(0, 1, 0), h = 0; h < b.length; h++) {
					var k = b[h]; k.parent && k.parent.isBone && (d.push(0,
						0, 0), d.push(0, 0, 0), e.push(f.r, f.g, f.b), e.push(g.r, g.g, g.b))
				} c.addAttribute("position", new y(d, 3)); c.addAttribute("color", new y(e, 3)); d = new O({ vertexColors: 2, depthTest: !1, depthWrite: !1, transparent: !0 }); ca.call(this, c, d); this.root = a; this.bones = b; this.matrix = a.matrixWorld; this.matrixAutoUpdate = !1
			} function pc(a, b, c) { this.light = a; this.light.updateMatrixWorld(); this.color = c; a = new ob(b, 4, 2); b = new va({ wireframe: !0, fog: !1 }); pa.call(this, a, b); this.matrix = this.light.matrixWorld; this.matrixAutoUpdate = !1; this.update() }
	function qc(a, b) { A.call(this); this.light = a; this.light.updateMatrixWorld(); this.matrix = a.matrixWorld; this.matrixAutoUpdate = !1; this.color = b; a = new O({ fog: !1 }); b = new D; b.addAttribute("position", new P(new Float32Array(15), 3)); this.line = new ma(b, a); this.add(this.line); this.update() } function rc(a, b, c) {
		A.call(this); this.light = a; this.light.updateMatrixWorld(); this.matrix = a.matrixWorld; this.matrixAutoUpdate = !1; this.color = c; a = new nb(b); a.rotateY(.5 * Math.PI); this.material = new va({ wireframe: !0, fog: !1 }); void 0 ===
			this.color && (this.material.vertexColors = 2); b = a.getAttribute("position"); b = new Float32Array(3 * b.count); a.addAttribute("color", new P(b, 3)); this.add(new pa(a, this.material)); this.update()
	} function cd(a, b, c, d) {
		a = a || 10; b = b || 10; c = new H(void 0 !== c ? c : 4473924); d = new H(void 0 !== d ? d : 8947848); var e = b / 2, f = a / b, g = a / 2; a = []; for (var h = [], k = 0, l = 0, q = -g; k <= b; k++ , q += f) { a.push(-g, 0, q, g, 0, q); a.push(q, 0, -g, q, 0, g); var n = k === e ? c : d; n.toArray(h, l); l += 3; n.toArray(h, l); l += 3; n.toArray(h, l); l += 3; n.toArray(h, l); l += 3 } b = new D; b.addAttribute("position",
			new y(a, 3)); b.addAttribute("color", new y(h, 3)); c = new O({ vertexColors: 2 }); ca.call(this, b, c)
	} function Kd(a, b, c, d, e, f) {
		a = a || 10; b = b || 16; c = c || 8; d = d || 64; e = new H(void 0 !== e ? e : 4473924); f = new H(void 0 !== f ? f : 8947848); var g = [], h = [], k; for (k = 0; k <= b; k++) { var l = k / b * 2 * Math.PI; var q = Math.sin(l) * a; l = Math.cos(l) * a; g.push(0, 0, 0); g.push(q, 0, l); var n = k & 1 ? e : f; h.push(n.r, n.g, n.b); h.push(n.r, n.g, n.b) } for (k = 0; k <= c; k++) {
			n = k & 1 ? e : f; var t = a - a / c * k; for (b = 0; b < d; b++)l = b / d * 2 * Math.PI, q = Math.sin(l) * t, l = Math.cos(l) * t, g.push(q, 0, l), h.push(n.r,
				n.g, n.b), l = (b + 1) / d * 2 * Math.PI, q = Math.sin(l) * t, l = Math.cos(l) * t, g.push(q, 0, l), h.push(n.r, n.g, n.b)
		} a = new D; a.addAttribute("position", new y(g, 3)); a.addAttribute("color", new y(h, 3)); g = new O({ vertexColors: 2 }); ca.call(this, a, g)
	} function dd(a, b, c, d) {
	this.object = a; this.size = void 0 !== b ? b : 1; a = void 0 !== c ? c : 16776960; d = void 0 !== d ? d : 1; b = 0; (c = this.object.geometry) && c.isGeometry ? b = c.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."); c = new D;
		b = new y(6 * b, 3); c.addAttribute("position", b); ca.call(this, c, new O({ color: a, linewidth: d })); this.matrixAutoUpdate = !1; this.update()
	} function sc(a, b, c) {
		A.call(this); this.light = a; this.light.updateMatrixWorld(); this.matrix = a.matrixWorld; this.matrixAutoUpdate = !1; this.color = c; void 0 === b && (b = 1); a = new D; a.addAttribute("position", new y([-b, b, 0, b, b, 0, b, -b, 0, -b, -b, 0, -b, b, 0], 3)); b = new O({ fog: !1 }); this.lightPlane = new ma(a, b); this.add(this.lightPlane); a = new D; a.addAttribute("position", new y([0, 0, 0, 0, 0, 1], 3)); this.targetLine =
			new ma(a, b); this.add(this.targetLine); this.update()
	} function ed(a) {
		function b(a, b, d) { c(a, d); c(b, d) } function c(a, b) { f.push(0, 0, 0); g.push(b.r, b.g, b.b); void 0 === h[a] && (h[a] = []); h[a].push(f.length / 3 - 1) } var d = new D, e = new O({ color: 16777215, vertexColors: 1 }), f = [], g = [], h = {}, k = new H(16755200), l = new H(16711680), q = new H(43775), n = new H(16777215), t = new H(3355443); b("n1", "n2", k); b("n2", "n4", k); b("n4", "n3", k); b("n3", "n1", k); b("f1", "f2", k); b("f2", "f4", k); b("f4", "f3", k); b("f3", "f1", k); b("n1", "f1", k); b("n2", "f2", k);
		b("n3", "f3", k); b("n4", "f4", k); b("p", "n1", l); b("p", "n2", l); b("p", "n3", l); b("p", "n4", l); b("u1", "u2", q); b("u2", "u3", q); b("u3", "u1", q); b("c", "t", n); b("p", "c", t); b("cn1", "cn2", t); b("cn3", "cn4", t); b("cf1", "cf2", t); b("cf3", "cf4", t); d.addAttribute("position", new y(f, 3)); d.addAttribute("color", new y(g, 3)); ca.call(this, d, e); this.camera = a; this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(); this.matrix = a.matrixWorld; this.matrixAutoUpdate = !1; this.pointMap = h; this.update()
	} function Db(a, b) {
	this.object =
		a; void 0 === b && (b = 16776960); a = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]); var c = new Float32Array(24), d = new D; d.setIndex(new P(a, 1)); d.addAttribute("position", new P(c, 3)); ca.call(this, d, new O({ color: b })); this.matrixAutoUpdate = !1; this.update()
	} function fd(a, b) {
	this.type = "Box3Helper"; this.box = a; a = void 0 !== b ? b : 16776960; b = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]); var c = new D; c.setIndex(new P(b, 1)); c.addAttribute("position", new y([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1,
		1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)); ca.call(this, c, new O({ color: a })); this.geometry.computeBoundingSphere()
	} function gd(a, b, c) {
	this.type = "PlaneHelper"; this.plane = a; this.size = void 0 === b ? 1 : b; a = void 0 !== c ? c : 16776960; b = new D; b.addAttribute("position", new y([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)); b.computeBoundingSphere(); ma.call(this, b, new O({ color: a })); b = new D; b.addAttribute("position", new y([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)); b.computeBoundingSphere();
		this.add(new pa(b, new va({ color: a, opacity: .2, transparent: !0, depthWrite: !1 })))
	} function Eb(a, b, c, d, e, f) {
		A.call(this); void 0 === d && (d = 16776960); void 0 === c && (c = 1); void 0 === e && (e = .2 * c); void 0 === f && (f = .2 * e); void 0 === Ld && (Ld = new D, Ld.addAttribute("position", new y([0, 0, 0, 0, 1, 0], 3)), pe = new Sa(0, .5, 1, 5, 1), pe.translate(0, -.5, 0)); this.position.copy(b); this.line = new ma(Ld, new O({ color: d })); this.line.matrixAutoUpdate = !1; this.add(this.line); this.cone = new pa(pe, new va({ color: d })); this.cone.matrixAutoUpdate = !1; this.add(this.cone);
		this.setDirection(a); this.setLength(c, e, f)
	} function hd(a) { a = a || 1; var b = [0, 0, 0, a, 0, 0, 0, 0, 0, 0, a, 0, 0, 0, 0, 0, 0, a]; a = new D; a.addAttribute("position", new y(b, 3)); a.addAttribute("color", new y([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)); b = new O({ vertexColors: 2 }); ca.call(this, a, b) } function qe() {
		var a = 0, b = 0, c = 0, d = 0; return {
			initCatmullRom: function (e, f, g, h, k) { e = k * (g - e); h = k * (h - f); a = f; b = e; c = -3 * f + 3 * g - 2 * e - h; d = 2 * f - 2 * g + e + h }, initNonuniformCatmullRom: function (e, f, g, h, k, l, q) {
				e = ((f - e) / k - (g - e) / (k + l) + (g - f) / l) * l; h = ((g - f) /
					l - (h - f) / (l + q) + (h - g) / q) * l; a = f; b = e; c = -3 * f + 3 * g - 2 * e - h; d = 2 * f - 2 * g + e + h
			}, calc: function (e) { var f = e * e; return a + b * e + c * f + d * f * e }
		}
	} function ya(a, b, c, d) { S.call(this); this.type = "CatmullRomCurve3"; this.points = a || []; this.closed = b || !1; this.curveType = c || "centripetal"; this.tension = d || .5 } function Fb(a, b, c, d) { S.call(this); this.type = "CubicBezierCurve3"; this.v0 = a || new p; this.v1 = b || new p; this.v2 = c || new p; this.v3 = d || new p } function Gb(a, b, c) {
		S.call(this); this.type = "QuadraticBezierCurve3"; this.v0 = a || new p; this.v1 = b || new p; this.v2 =
			c || new p
	} function db(a, b) { S.call(this); this.type = "LineCurve3"; this.v1 = a || new p; this.v2 = b || new p } function id(a, b, c, d, e, f) { Na.call(this, a, b, c, c, d, e, f); this.type = "ArcCurve" } function ef(a) { console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."); ya.call(this, a); this.type = "catmullrom"; this.closed = !0 } function ff(a) { console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."); ya.call(this, a); this.type = "catmullrom" } function re(a) {
		console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.");
		ya.call(this, a); this.type = "catmullrom"
	} void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)); void 0 === Number.isInteger && (Number.isInteger = function (a) { return "number" === typeof a && isFinite(a) && Math.floor(a) === a }); void 0 === Math.sign && (Math.sign = function (a) { return 0 > a ? -1 : 0 < a ? 1 : +a }); !1 === "name" in Function.prototype && Object.defineProperty(Function.prototype, "name", { get: function () { return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1] } }); void 0 === Object.assign && function () {
	Object.assign = function (a) {
		if (void 0 ===
			a || null === a) throw new TypeError("Cannot convert undefined or null to object"); for (var b = Object(a), c = 1; c < arguments.length; c++) { var d = arguments[c]; if (void 0 !== d && null !== d) for (var e in d) Object.prototype.hasOwnProperty.call(d, e) && (b[e] = d[e]) } return b
	}
	}(); Object.assign(ja.prototype, {
		addEventListener: function (a, b) { void 0 === this._listeners && (this._listeners = {}); var c = this._listeners; void 0 === c[a] && (c[a] = []); -1 === c[a].indexOf(b) && c[a].push(b) }, hasEventListener: function (a, b) {
			if (void 0 === this._listeners) return !1;
			var c = this._listeners; return void 0 !== c[a] && -1 !== c[a].indexOf(b)
		}, removeEventListener: function (a, b) { void 0 !== this._listeners && (a = this._listeners[a], void 0 !== a && (b = a.indexOf(b), -1 !== b && a.splice(b, 1))) }, dispatchEvent: function (a) { if (void 0 !== this._listeners) { var b = this._listeners[a.type]; if (void 0 !== b) { a.target = this; for (var b = b.slice(0), c = 0, d = b.length; c < d; c++)b[c].call(this, a) } } }
	}); var R = {
		DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: function () {
			var a = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
			b = 0, c; return function () { for (var d = "", e = 0; 36 > e; e++)8 === e || 13 === e || 18 === e || 23 === e ? d += "-" : 14 === e ? d += "4" : (2 >= b && (b = 33554432 + 16777216 * Math.random() | 0), c = b & 15, b >>= 4, d += a[19 === e ? c & 3 | 8 : c]); return d }
		}(), clamp: function (a, b, c) { return Math.max(b, Math.min(c, a)) }, euclideanModulo: function (a, b) { return (a % b + b) % b }, mapLinear: function (a, b, c, d, e) { return d + (a - b) * (e - d) / (c - b) }, lerp: function (a, b, c) { return (1 - c) * a + c * b }, smoothstep: function (a, b, c) { if (a <= b) return 0; if (a >= c) return 1; a = (a - b) / (c - b); return a * a * (3 - 2 * a) }, smootherstep: function (a,
			b, c) { if (a <= b) return 0; if (a >= c) return 1; a = (a - b) / (c - b); return a * a * a * (a * (6 * a - 15) + 10) }, randInt: function (a, b) { return a + Math.floor(Math.random() * (b - a + 1)) }, randFloat: function (a, b) { return a + Math.random() * (b - a) }, randFloatSpread: function (a) { return a * (.5 - Math.random()) }, degToRad: function (a) { return a * R.DEG2RAD }, radToDeg: function (a) { return a * R.RAD2DEG }, isPowerOfTwo: function (a) { return 0 === (a & a - 1) && 0 !== a }, ceilPowerOfTwo: function (a) { return Math.pow(2, Math.ceil(Math.log(a) / Math.LN2)) }, floorPowerOfTwo: function (a) {
				return Math.pow(2,
					Math.floor(Math.log(a) / Math.LN2))
			}
	}; Object.defineProperties(C.prototype, { width: { get: function () { return this.x }, set: function (a) { this.x = a } }, height: { get: function () { return this.y }, set: function (a) { this.y = a } } }); Object.assign(C.prototype, {
		isVector2: !0, set: function (a, b) { this.x = a; this.y = b; return this }, setScalar: function (a) { this.y = this.x = a; return this }, setX: function (a) { this.x = a; return this }, setY: function (a) { this.y = a; return this }, setComponent: function (a, b) {
			switch (a) {
				case 0: this.x = b; break; case 1: this.y = b; break;
				default: throw Error("index is out of range: " + a);
			}return this
		}, getComponent: function (a) { switch (a) { case 0: return this.x; case 1: return this.y; default: throw Error("index is out of range: " + a); } }, clone: function () { return new this.constructor(this.x, this.y) }, copy: function (a) { this.x = a.x; this.y = a.y; return this }, add: function (a, b) { if (void 0 !== b) return console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b); this.x += a.x; this.y += a.y; return this },
		addScalar: function (a) { this.x += a; this.y += a; return this }, addVectors: function (a, b) { this.x = a.x + b.x; this.y = a.y + b.y; return this }, addScaledVector: function (a, b) { this.x += a.x * b; this.y += a.y * b; return this }, sub: function (a, b) { if (void 0 !== b) return console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b); this.x -= a.x; this.y -= a.y; return this }, subScalar: function (a) { this.x -= a; this.y -= a; return this }, subVectors: function (a, b) {
		this.x = a.x - b.x; this.y = a.y - b.y;
			return this
		}, multiply: function (a) { this.x *= a.x; this.y *= a.y; return this }, multiplyScalar: function (a) { this.x *= a; this.y *= a; return this }, divide: function (a) { this.x /= a.x; this.y /= a.y; return this }, divideScalar: function (a) { return this.multiplyScalar(1 / a) }, applyMatrix3: function (a) { var b = this.x, c = this.y; a = a.elements; this.x = a[0] * b + a[3] * c + a[6]; this.y = a[1] * b + a[4] * c + a[7]; return this }, min: function (a) { this.x = Math.min(this.x, a.x); this.y = Math.min(this.y, a.y); return this }, max: function (a) {
		this.x = Math.max(this.x, a.x); this.y =
			Math.max(this.y, a.y); return this
		}, clamp: function (a, b) { this.x = Math.max(a.x, Math.min(b.x, this.x)); this.y = Math.max(a.y, Math.min(b.y, this.y)); return this }, clampScalar: function () { var a = new C, b = new C; return function (c, d) { a.set(c, c); b.set(d, d); return this.clamp(a, b) } }(), clampLength: function (a, b) { var c = this.length(); return this.divideScalar(c || 1).multiplyScalar(Math.max(a, Math.min(b, c))) }, floor: function () { this.x = Math.floor(this.x); this.y = Math.floor(this.y); return this }, ceil: function () {
		this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y); return this
		}, round: function () { this.x = Math.round(this.x); this.y = Math.round(this.y); return this }, roundToZero: function () { this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x); this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y); return this }, negate: function () { this.x = -this.x; this.y = -this.y; return this }, dot: function (a) { return this.x * a.x + this.y * a.y }, lengthSq: function () { return this.x * this.x + this.y * this.y }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y) }, manhattanLength: function () {
			return Math.abs(this.x) +
				Math.abs(this.y)
		}, normalize: function () { return this.divideScalar(this.length() || 1) }, angle: function () { var a = Math.atan2(this.y, this.x); 0 > a && (a += 2 * Math.PI); return a }, distanceTo: function (a) { return Math.sqrt(this.distanceToSquared(a)) }, distanceToSquared: function (a) { var b = this.x - a.x; a = this.y - a.y; return b * b + a * a }, manhattanDistanceTo: function (a) { return Math.abs(this.x - a.x) + Math.abs(this.y - a.y) }, setLength: function (a) { return this.normalize().multiplyScalar(a) }, lerp: function (a, b) {
		this.x += (a.x - this.x) * b; this.y +=
			(a.y - this.y) * b; return this
		}, lerpVectors: function (a, b, c) { return this.subVectors(b, a).multiplyScalar(c).add(a) }, equals: function (a) { return a.x === this.x && a.y === this.y }, fromArray: function (a, b) { void 0 === b && (b = 0); this.x = a[b]; this.y = a[b + 1]; return this }, toArray: function (a, b) { void 0 === a && (a = []); void 0 === b && (b = 0); a[b] = this.x; a[b + 1] = this.y; return a }, fromBufferAttribute: function (a, b, c) {
		void 0 !== c && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."); this.x = a.getX(b); this.y = a.getY(b);
			return this
		}, rotateAround: function (a, b) { var c = Math.cos(b); b = Math.sin(b); var d = this.x - a.x, e = this.y - a.y; this.x = d * c - e * b + a.x; this.y = d * b + e * c + a.y; return this }
	}); Object.assign(K.prototype, {
		isMatrix4: !0, set: function (a, b, c, d, e, f, g, h, k, l, q, n, t, m, p, v) { var r = this.elements; r[0] = a; r[4] = b; r[8] = c; r[12] = d; r[1] = e; r[5] = f; r[9] = g; r[13] = h; r[2] = k; r[6] = l; r[10] = q; r[14] = n; r[3] = t; r[7] = m; r[11] = p; r[15] = v; return this }, identity: function () { this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); return this }, clone: function () { return (new K).fromArray(this.elements) },
		copy: function (a) { var b = this.elements; a = a.elements; b[0] = a[0]; b[1] = a[1]; b[2] = a[2]; b[3] = a[3]; b[4] = a[4]; b[5] = a[5]; b[6] = a[6]; b[7] = a[7]; b[8] = a[8]; b[9] = a[9]; b[10] = a[10]; b[11] = a[11]; b[12] = a[12]; b[13] = a[13]; b[14] = a[14]; b[15] = a[15]; return this }, copyPosition: function (a) { var b = this.elements; a = a.elements; b[12] = a[12]; b[13] = a[13]; b[14] = a[14]; return this }, extractBasis: function (a, b, c) { a.setFromMatrixColumn(this, 0); b.setFromMatrixColumn(this, 1); c.setFromMatrixColumn(this, 2); return this }, makeBasis: function (a, b, c) {
			this.set(a.x,
				b.x, c.x, 0, a.y, b.y, c.y, 0, a.z, b.z, c.z, 0, 0, 0, 0, 1); return this
		}, extractRotation: function () { var a = new p; return function (b) { var c = this.elements, d = b.elements, e = 1 / a.setFromMatrixColumn(b, 0).length(), f = 1 / a.setFromMatrixColumn(b, 1).length(); b = 1 / a.setFromMatrixColumn(b, 2).length(); c[0] = d[0] * e; c[1] = d[1] * e; c[2] = d[2] * e; c[4] = d[4] * f; c[5] = d[5] * f; c[6] = d[6] * f; c[8] = d[8] * b; c[9] = d[9] * b; c[10] = d[10] * b; return this } }(), makeRotationFromEuler: function (a) {
		a && a.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
			var b = this.elements, c = a.x, d = a.y, e = a.z, f = Math.cos(c), c = Math.sin(c), g = Math.cos(d), d = Math.sin(d), h = Math.cos(e), e = Math.sin(e); if ("XYZ" === a.order) { var k = f * h; var l = f * e; var q = c * h; a = c * e; b[0] = g * h; b[4] = -g * e; b[8] = d; b[1] = l + q * d; b[5] = k - a * d; b[9] = -c * g; b[2] = a - k * d; b[6] = q + l * d; b[10] = f * g } else "YXZ" === a.order ? (k = g * h, l = g * e, q = d * h, a = d * e, b[0] = k + a * c, b[4] = q * c - l, b[8] = f * d, b[1] = f * e, b[5] = f * h, b[9] = -c, b[2] = l * c - q, b[6] = a + k * c, b[10] = f * g) : "ZXY" === a.order ? (k = g * h, l = g * e, q = d * h, a = d * e, b[0] = k - a * c, b[4] = -f * e, b[8] = q + l * c, b[1] = l + q * c, b[5] = f * h, b[9] =
				a - k * c, b[2] = -f * d, b[6] = c, b[10] = f * g) : "ZYX" === a.order ? (k = f * h, l = f * e, q = c * h, a = c * e, b[0] = g * h, b[4] = q * d - l, b[8] = k * d + a, b[1] = g * e, b[5] = a * d + k, b[9] = l * d - q, b[2] = -d, b[6] = c * g, b[10] = f * g) : "YZX" === a.order ? (k = f * g, l = f * d, q = c * g, a = c * d, b[0] = g * h, b[4] = a - k * e, b[8] = q * e + l, b[1] = e, b[5] = f * h, b[9] = -c * h, b[2] = -d * h, b[6] = l * e + q, b[10] = k - a * e) : "XZY" === a.order && (k = f * g, l = f * d, q = c * g, a = c * d, b[0] = g * h, b[4] = -e, b[8] = d * h, b[1] = k * e + a, b[5] = f * h, b[9] = l * e - q, b[2] = q * e - l, b[6] = c * h, b[10] = a * e + k); b[3] = 0; b[7] = 0; b[11] = 0; b[12] = 0; b[13] = 0; b[14] = 0; b[15] = 1; return this
		}, makeRotationFromQuaternion: function (a) {
			var b =
				this.elements, c = a._x, d = a._y, e = a._z, f = a._w, g = c + c, h = d + d, k = e + e; a = c * g; var l = c * h, c = c * k, q = d * h, d = d * k, e = e * k, g = f * g, h = f * h, f = f * k; b[0] = 1 - (q + e); b[4] = l - f; b[8] = c + h; b[1] = l + f; b[5] = 1 - (a + e); b[9] = d - g; b[2] = c - h; b[6] = d + g; b[10] = 1 - (a + q); b[3] = 0; b[7] = 0; b[11] = 0; b[12] = 0; b[13] = 0; b[14] = 0; b[15] = 1; return this
		}, lookAt: function () {
			var a = new p, b = new p, c = new p; return function (d, e, f) {
				var g = this.elements; c.subVectors(d, e); 0 === c.lengthSq() && (c.z = 1); c.normalize(); a.crossVectors(f, c); 0 === a.lengthSq() && (1 === Math.abs(f.z) ? c.x += 1E-4 : c.z += 1E-4,
					c.normalize(), a.crossVectors(f, c)); a.normalize(); b.crossVectors(c, a); g[0] = a.x; g[4] = b.x; g[8] = c.x; g[1] = a.y; g[5] = b.y; g[9] = c.y; g[2] = a.z; g[6] = b.z; g[10] = c.z; return this
			}
		}(), multiply: function (a, b) { return void 0 !== b ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a) }, premultiply: function (a) { return this.multiplyMatrices(a, this) }, multiplyMatrices: function (a, b) {
			var c = a.elements, d = b.elements;
			b = this.elements; a = c[0]; var e = c[4], f = c[8], g = c[12], h = c[1], k = c[5], l = c[9], q = c[13], n = c[2], m = c[6], r = c[10], p = c[14], v = c[3], w = c[7], x = c[11], c = c[15], z = d[0], I = d[4], B = d[8], J = d[12], y = d[1], C = d[5], A = d[9], D = d[13], E = d[2], H = d[6], L = d[10], Y = d[14], N = d[3], M = d[7], V = d[11], d = d[15]; b[0] = a * z + e * y + f * E + g * N; b[4] = a * I + e * C + f * H + g * M; b[8] = a * B + e * A + f * L + g * V; b[12] = a * J + e * D + f * Y + g * d; b[1] = h * z + k * y + l * E + q * N; b[5] = h * I + k * C + l * H + q * M; b[9] = h * B + k * A + l * L + q * V; b[13] = h * J + k * D + l * Y + q * d; b[2] = n * z + m * y + r * E + p * N; b[6] = n * I + m * C + r * H + p * M; b[10] = n * B + m * A + r * L + p * V; b[14] = n * J + m *
				D + r * Y + p * d; b[3] = v * z + w * y + x * E + c * N; b[7] = v * I + w * C + x * H + c * M; b[11] = v * B + w * A + x * L + c * V; b[15] = v * J + w * D + x * Y + c * d; return this
		}, multiplyScalar: function (a) { var b = this.elements; b[0] *= a; b[4] *= a; b[8] *= a; b[12] *= a; b[1] *= a; b[5] *= a; b[9] *= a; b[13] *= a; b[2] *= a; b[6] *= a; b[10] *= a; b[14] *= a; b[3] *= a; b[7] *= a; b[11] *= a; b[15] *= a; return this }, applyToBufferAttribute: function () { var a = new p; return function (b) { for (var c = 0, d = b.count; c < d; c++)a.x = b.getX(c), a.y = b.getY(c), a.z = b.getZ(c), a.applyMatrix4(this), b.setXYZ(c, a.x, a.y, a.z); return b } }(), determinant: function () {
			var a =
				this.elements, b = a[0], c = a[4], d = a[8], e = a[12], f = a[1], g = a[5], h = a[9], k = a[13], l = a[2], q = a[6], n = a[10], m = a[14]; return a[3] * (+e * h * q - d * k * q - e * g * n + c * k * n + d * g * m - c * h * m) + a[7] * (+b * h * m - b * k * n + e * f * n - d * f * m + d * k * l - e * h * l) + a[11] * (+b * k * q - b * g * m - e * f * q + c * f * m + e * g * l - c * k * l) + a[15] * (-d * g * l - b * h * q + b * g * n + d * f * q - c * f * n + c * h * l)
		}, transpose: function () { var a = this.elements; var b = a[1]; a[1] = a[4]; a[4] = b; b = a[2]; a[2] = a[8]; a[8] = b; b = a[6]; a[6] = a[9]; a[9] = b; b = a[3]; a[3] = a[12]; a[12] = b; b = a[7]; a[7] = a[13]; a[13] = b; b = a[11]; a[11] = a[14]; a[14] = b; return this }, setPosition: function (a) {
			var b =
				this.elements; b[12] = a.x; b[13] = a.y; b[14] = a.z; return this
		}, getInverse: function (a, b) {
			var c = this.elements, d = a.elements; a = d[0]; var e = d[1], f = d[2], g = d[3], h = d[4], k = d[5], l = d[6], q = d[7], n = d[8], m = d[9], r = d[10], p = d[11], v = d[12], w = d[13], x = d[14], d = d[15], z = m * x * q - w * r * q + w * l * p - k * x * p - m * l * d + k * r * d, I = v * r * q - n * x * q - v * l * p + h * x * p + n * l * d - h * r * d, B = n * w * q - v * m * q + v * k * p - h * w * p - n * k * d + h * m * d, J = v * m * l - n * w * l - v * k * r + h * w * r + n * k * x - h * m * x, y = a * z + e * I + f * B + g * J; if (0 === y) {
				if (!0 === b) throw Error("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");
				console.warn("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"); return this.identity()
			} b = 1 / y; c[0] = z * b; c[1] = (w * r * g - m * x * g - w * f * p + e * x * p + m * f * d - e * r * d) * b; c[2] = (k * x * g - w * l * g + w * f * q - e * x * q - k * f * d + e * l * d) * b; c[3] = (m * l * g - k * r * g - m * f * q + e * r * q + k * f * p - e * l * p) * b; c[4] = I * b; c[5] = (n * x * g - v * r * g + v * f * p - a * x * p - n * f * d + a * r * d) * b; c[6] = (v * l * g - h * x * g - v * f * q + a * x * q + h * f * d - a * l * d) * b; c[7] = (h * r * g - n * l * g + n * f * q - a * r * q - h * f * p + a * l * p) * b; c[8] = B * b; c[9] = (v * m * g - n * w * g - v * e * p + a * w * p + n * e * d - a * m * d) * b; c[10] = (h * w * g - v * k * g + v * e * q - a * w * q - h * e * d + a * k * d) * b; c[11] =
				(n * k * g - h * m * g - n * e * q + a * m * q + h * e * p - a * k * p) * b; c[12] = J * b; c[13] = (n * w * f - v * m * f + v * e * r - a * w * r - n * e * x + a * m * x) * b; c[14] = (v * k * f - h * w * f - v * e * l + a * w * l + h * e * x - a * k * x) * b; c[15] = (h * m * f - n * k * f + n * e * l - a * m * l - h * e * r + a * k * r) * b; return this
		}, scale: function (a) { var b = this.elements, c = a.x, d = a.y; a = a.z; b[0] *= c; b[4] *= d; b[8] *= a; b[1] *= c; b[5] *= d; b[9] *= a; b[2] *= c; b[6] *= d; b[10] *= a; b[3] *= c; b[7] *= d; b[11] *= a; return this }, getMaxScaleOnAxis: function () {
			var a = this.elements; return Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], a[4] * a[4] + a[5] * a[5] + a[6] * a[6],
				a[8] * a[8] + a[9] * a[9] + a[10] * a[10]))
		}, makeTranslation: function (a, b, c) { this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1); return this }, makeRotationX: function (a) { var b = Math.cos(a); a = Math.sin(a); this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1); return this }, makeRotationY: function (a) { var b = Math.cos(a); a = Math.sin(a); this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1); return this }, makeRotationZ: function (a) { var b = Math.cos(a); a = Math.sin(a); this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); return this }, makeRotationAxis: function (a, b) {
			var c =
				Math.cos(b); b = Math.sin(b); var d = 1 - c, e = a.x, f = a.y; a = a.z; var g = d * e, h = d * f; this.set(g * e + c, g * f - b * a, g * a + b * f, 0, g * f + b * a, h * f + c, h * a - b * e, 0, g * a - b * f, h * a + b * e, d * a * a + c, 0, 0, 0, 0, 1); return this
		}, makeScale: function (a, b, c) { this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1); return this }, makeShear: function (a, b, c) { this.set(1, b, c, 0, a, 1, c, 0, a, b, 1, 0, 0, 0, 0, 1); return this }, compose: function (a, b, c) { this.makeRotationFromQuaternion(b); this.scale(c); this.setPosition(a); return this }, decompose: function () {
			var a = new p, b = new K; return function (c,
				d, e) { var f = this.elements, g = a.set(f[0], f[1], f[2]).length(), h = a.set(f[4], f[5], f[6]).length(), k = a.set(f[8], f[9], f[10]).length(); 0 > this.determinant() && (g = -g); c.x = f[12]; c.y = f[13]; c.z = f[14]; b.copy(this); c = 1 / g; var f = 1 / h, l = 1 / k; b.elements[0] *= c; b.elements[1] *= c; b.elements[2] *= c; b.elements[4] *= f; b.elements[5] *= f; b.elements[6] *= f; b.elements[8] *= l; b.elements[9] *= l; b.elements[10] *= l; d.setFromRotationMatrix(b); e.x = g; e.y = h; e.z = k; return this }
		}(), makePerspective: function (a, b, c, d, e, f) {
		void 0 === f && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
			var g = this.elements; g[0] = 2 * e / (b - a); g[4] = 0; g[8] = (b + a) / (b - a); g[12] = 0; g[1] = 0; g[5] = 2 * e / (c - d); g[9] = (c + d) / (c - d); g[13] = 0; g[2] = 0; g[6] = 0; g[10] = -(f + e) / (f - e); g[14] = -2 * f * e / (f - e); g[3] = 0; g[7] = 0; g[11] = -1; g[15] = 0; return this
		}, makeOrthographic: function (a, b, c, d, e, f) { var g = this.elements, h = 1 / (b - a), k = 1 / (c - d), l = 1 / (f - e); g[0] = 2 * h; g[4] = 0; g[8] = 0; g[12] = -((b + a) * h); g[1] = 0; g[5] = 2 * k; g[9] = 0; g[13] = -((c + d) * k); g[2] = 0; g[6] = 0; g[10] = -2 * l; g[14] = -((f + e) * l); g[3] = 0; g[7] = 0; g[11] = 0; g[15] = 1; return this }, equals: function (a) {
			var b = this.elements;
			a = a.elements; for (var c = 0; 16 > c; c++)if (b[c] !== a[c]) return !1; return !0
		}, fromArray: function (a, b) { void 0 === b && (b = 0); for (var c = 0; 16 > c; c++)this.elements[c] = a[c + b]; return this }, toArray: function (a, b) { void 0 === a && (a = []); void 0 === b && (b = 0); var c = this.elements; a[b] = c[0]; a[b + 1] = c[1]; a[b + 2] = c[2]; a[b + 3] = c[3]; a[b + 4] = c[4]; a[b + 5] = c[5]; a[b + 6] = c[6]; a[b + 7] = c[7]; a[b + 8] = c[8]; a[b + 9] = c[9]; a[b + 10] = c[10]; a[b + 11] = c[11]; a[b + 12] = c[12]; a[b + 13] = c[13]; a[b + 14] = c[14]; a[b + 15] = c[15]; return a }
	}); Object.assign(Z, {
		slerp: function (a, b, c, d) {
			return c.copy(a).slerp(b,
				d)
		}, slerpFlat: function (a, b, c, d, e, f, g) { var h = c[d + 0], k = c[d + 1], l = c[d + 2]; c = c[d + 3]; d = e[f + 0]; var q = e[f + 1], n = e[f + 2]; e = e[f + 3]; if (c !== e || h !== d || k !== q || l !== n) { f = 1 - g; var m = h * d + k * q + l * n + c * e, r = 0 <= m ? 1 : -1, p = 1 - m * m; p > Number.EPSILON && (p = Math.sqrt(p), m = Math.atan2(p, m * r), f = Math.sin(f * m) / p, g = Math.sin(g * m) / p); r *= g; h = h * f + d * r; k = k * f + q * r; l = l * f + n * r; c = c * f + e * r; f === 1 - g && (g = 1 / Math.sqrt(h * h + k * k + l * l + c * c), h *= g, k *= g, l *= g, c *= g) } a[b] = h; a[b + 1] = k; a[b + 2] = l; a[b + 3] = c }
	}); Object.defineProperties(Z.prototype, {
		x: {
			get: function () { return this._x },
			set: function (a) { this._x = a; this.onChangeCallback() }
		}, y: { get: function () { return this._y }, set: function (a) { this._y = a; this.onChangeCallback() } }, z: { get: function () { return this._z }, set: function (a) { this._z = a; this.onChangeCallback() } }, w: { get: function () { return this._w }, set: function (a) { this._w = a; this.onChangeCallback() } }
	}); Object.assign(Z.prototype, {
		set: function (a, b, c, d) { this._x = a; this._y = b; this._z = c; this._w = d; this.onChangeCallback(); return this }, clone: function () {
			return new this.constructor(this._x, this._y, this._z,
				this._w)
		}, copy: function (a) { this._x = a.x; this._y = a.y; this._z = a.z; this._w = a.w; this.onChangeCallback(); return this }, setFromEuler: function (a, b) {
			if (!a || !a.isEuler) throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."); var c = a._x, d = a._y, e = a._z; a = a.order; var f = Math.cos, g = Math.sin, h = f(c / 2), k = f(d / 2), f = f(e / 2), c = g(c / 2), d = g(d / 2), e = g(e / 2); "XYZ" === a ? (this._x = c * k * f + h * d * e, this._y = h * d * f - c * k * e, this._z = h * k * e + c * d * f, this._w = h * k * f - c * d * e) : "YXZ" === a ? (this._x = c * k * f +
				h * d * e, this._y = h * d * f - c * k * e, this._z = h * k * e - c * d * f, this._w = h * k * f + c * d * e) : "ZXY" === a ? (this._x = c * k * f - h * d * e, this._y = h * d * f + c * k * e, this._z = h * k * e + c * d * f, this._w = h * k * f - c * d * e) : "ZYX" === a ? (this._x = c * k * f - h * d * e, this._y = h * d * f + c * k * e, this._z = h * k * e - c * d * f, this._w = h * k * f + c * d * e) : "YZX" === a ? (this._x = c * k * f + h * d * e, this._y = h * d * f + c * k * e, this._z = h * k * e - c * d * f, this._w = h * k * f - c * d * e) : "XZY" === a && (this._x = c * k * f - h * d * e, this._y = h * d * f - c * k * e, this._z = h * k * e + c * d * f, this._w = h * k * f + c * d * e); if (!1 !== b) this.onChangeCallback(); return this
		}, setFromAxisAngle: function (a,
			b) { b /= 2; var c = Math.sin(b); this._x = a.x * c; this._y = a.y * c; this._z = a.z * c; this._w = Math.cos(b); this.onChangeCallback(); return this }, setFromRotationMatrix: function (a) {
				var b = a.elements, c = b[0]; a = b[4]; var d = b[8], e = b[1], f = b[5], g = b[9], h = b[2], k = b[6], b = b[10], l = c + f + b; 0 < l ? (c = .5 / Math.sqrt(l + 1), this._w = .25 / c, this._x = (k - g) * c, this._y = (d - h) * c, this._z = (e - a) * c) : c > f && c > b ? (c = 2 * Math.sqrt(1 + c - f - b), this._w = (k - g) / c, this._x = .25 * c, this._y = (a + e) / c, this._z = (d + h) / c) : f > b ? (c = 2 * Math.sqrt(1 + f - c - b), this._w = (d - h) / c, this._x = (a + e) / c, this._y =
					.25 * c, this._z = (g + k) / c) : (c = 2 * Math.sqrt(1 + b - c - f), this._w = (e - a) / c, this._x = (d + h) / c, this._y = (g + k) / c, this._z = .25 * c); this.onChangeCallback(); return this
			}, setFromUnitVectors: function () { var a = new p, b; return function (c, d) { void 0 === a && (a = new p); b = c.dot(d) + 1; 1E-6 > b ? (b = 0, Math.abs(c.x) > Math.abs(c.z) ? a.set(-c.y, c.x, 0) : a.set(0, -c.z, c.y)) : a.crossVectors(c, d); this._x = a.x; this._y = a.y; this._z = a.z; this._w = b; return this.normalize() } }(), inverse: function () { return this.conjugate().normalize() }, conjugate: function () {
			this._x *=
				-1; this._y *= -1; this._z *= -1; this.onChangeCallback(); return this
			}, dot: function (a) { return this._x * a._x + this._y * a._y + this._z * a._z + this._w * a._w }, lengthSq: function () { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w }, length: function () { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) }, normalize: function () { var a = this.length(); 0 === a ? (this._z = this._y = this._x = 0, this._w = 1) : (a = 1 / a, this._x *= a, this._y *= a, this._z *= a, this._w *= a); this.onChangeCallback(); return this },
		multiply: function (a, b) { return void 0 !== b ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a) }, premultiply: function (a) { return this.multiplyQuaternions(a, this) }, multiplyQuaternions: function (a, b) {
			var c = a._x, d = a._y, e = a._z; a = a._w; var f = b._x, g = b._y, h = b._z; b = b._w; this._x = c * b + a * f + d * h - e * g; this._y = d * b + a * g + e * f - c * h; this._z = e * b + a * h + c * g - d * f; this._w = a * b - c * f - d * g - e * h; this.onChangeCallback();
			return this
		}, slerp: function (a, b) {
			if (0 === b) return this; if (1 === b) return this.copy(a); var c = this._x, d = this._y, e = this._z, f = this._w, g = f * a._w + c * a._x + d * a._y + e * a._z; 0 > g ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, g = -g) : this.copy(a); if (1 <= g) return this._w = f, this._x = c, this._y = d, this._z = e, this; a = Math.sqrt(1 - g * g); if (.001 > Math.abs(a)) return this._w = .5 * (f + this._w), this._x = .5 * (c + this._x), this._y = .5 * (d + this._y), this._z = .5 * (e + this._z), this; var h = Math.atan2(a, g), g = Math.sin((1 - b) * h) / a; b = Math.sin(b * h) / a;
			this._w = f * g + this._w * b; this._x = c * g + this._x * b; this._y = d * g + this._y * b; this._z = e * g + this._z * b; this.onChangeCallback(); return this
		}, equals: function (a) { return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w }, fromArray: function (a, b) { void 0 === b && (b = 0); this._x = a[b]; this._y = a[b + 1]; this._z = a[b + 2]; this._w = a[b + 3]; this.onChangeCallback(); return this }, toArray: function (a, b) { void 0 === a && (a = []); void 0 === b && (b = 0); a[b] = this._x; a[b + 1] = this._y; a[b + 2] = this._z; a[b + 3] = this._w; return a }, onChange: function (a) {
		this.onChangeCallback =
			a; return this
		}, onChangeCallback: function () { }
	}); Object.assign(p.prototype, {
		isVector3: !0, set: function (a, b, c) { this.x = a; this.y = b; this.z = c; return this }, setScalar: function (a) { this.z = this.y = this.x = a; return this }, setX: function (a) { this.x = a; return this }, setY: function (a) { this.y = a; return this }, setZ: function (a) { this.z = a; return this }, setComponent: function (a, b) { switch (a) { case 0: this.x = b; break; case 1: this.y = b; break; case 2: this.z = b; break; default: throw Error("index is out of range: " + a); }return this }, getComponent: function (a) {
			switch (a) {
				case 0: return this.x;
				case 1: return this.y; case 2: return this.z; default: throw Error("index is out of range: " + a);
			}
		}, clone: function () { return new this.constructor(this.x, this.y, this.z) }, copy: function (a) { this.x = a.x; this.y = a.y; this.z = a.z; return this }, add: function (a, b) { if (void 0 !== b) return console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b); this.x += a.x; this.y += a.y; this.z += a.z; return this }, addScalar: function (a) { this.x += a; this.y += a; this.z += a; return this },
		addVectors: function (a, b) { this.x = a.x + b.x; this.y = a.y + b.y; this.z = a.z + b.z; return this }, addScaledVector: function (a, b) { this.x += a.x * b; this.y += a.y * b; this.z += a.z * b; return this }, sub: function (a, b) { if (void 0 !== b) return console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b); this.x -= a.x; this.y -= a.y; this.z -= a.z; return this }, subScalar: function (a) { this.x -= a; this.y -= a; this.z -= a; return this }, subVectors: function (a, b) {
		this.x = a.x - b.x; this.y = a.y - b.y; this.z =
			a.z - b.z; return this
		}, multiply: function (a, b) { if (void 0 !== b) return console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(a, b); this.x *= a.x; this.y *= a.y; this.z *= a.z; return this }, multiplyScalar: function (a) { this.x *= a; this.y *= a; this.z *= a; return this }, multiplyVectors: function (a, b) { this.x = a.x * b.x; this.y = a.y * b.y; this.z = a.z * b.z; return this }, applyEuler: function () {
			var a = new Z; return function (b) {
			b && b.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
				return this.applyQuaternion(a.setFromEuler(b))
			}
		}(), applyAxisAngle: function () { var a = new Z; return function (b, c) { return this.applyQuaternion(a.setFromAxisAngle(b, c)) } }(), applyMatrix3: function (a) { var b = this.x, c = this.y, d = this.z; a = a.elements; this.x = a[0] * b + a[3] * c + a[6] * d; this.y = a[1] * b + a[4] * c + a[7] * d; this.z = a[2] * b + a[5] * c + a[8] * d; return this }, applyMatrix4: function (a) {
			var b = this.x, c = this.y, d = this.z; a = a.elements; var e = 1 / (a[3] * b + a[7] * c + a[11] * d + a[15]); this.x = (a[0] * b + a[4] * c + a[8] * d + a[12]) * e; this.y = (a[1] * b + a[5] * c + a[9] *
				d + a[13]) * e; this.z = (a[2] * b + a[6] * c + a[10] * d + a[14]) * e; return this
		}, applyQuaternion: function (a) { var b = this.x, c = this.y, d = this.z, e = a.x, f = a.y, g = a.z; a = a.w; var h = a * b + f * d - g * c, k = a * c + g * b - e * d, l = a * d + e * c - f * b, b = -e * b - f * c - g * d; this.x = h * a + b * -e + k * -g - l * -f; this.y = k * a + b * -f + l * -e - h * -g; this.z = l * a + b * -g + h * -f - k * -e; return this }, project: function () { var a = new K; return function (b) { a.multiplyMatrices(b.projectionMatrix, a.getInverse(b.matrixWorld)); return this.applyMatrix4(a) } }(), unproject: function () {
			var a = new K; return function (b) {
				a.multiplyMatrices(b.matrixWorld,
					a.getInverse(b.projectionMatrix)); return this.applyMatrix4(a)
			}
		}(), transformDirection: function (a) { var b = this.x, c = this.y, d = this.z; a = a.elements; this.x = a[0] * b + a[4] * c + a[8] * d; this.y = a[1] * b + a[5] * c + a[9] * d; this.z = a[2] * b + a[6] * c + a[10] * d; return this.normalize() }, divide: function (a) { this.x /= a.x; this.y /= a.y; this.z /= a.z; return this }, divideScalar: function (a) { return this.multiplyScalar(1 / a) }, min: function (a) { this.x = Math.min(this.x, a.x); this.y = Math.min(this.y, a.y); this.z = Math.min(this.z, a.z); return this }, max: function (a) {
		this.x =
			Math.max(this.x, a.x); this.y = Math.max(this.y, a.y); this.z = Math.max(this.z, a.z); return this
		}, clamp: function (a, b) { this.x = Math.max(a.x, Math.min(b.x, this.x)); this.y = Math.max(a.y, Math.min(b.y, this.y)); this.z = Math.max(a.z, Math.min(b.z, this.z)); return this }, clampScalar: function () { var a = new p, b = new p; return function (c, d) { a.set(c, c, c); b.set(d, d, d); return this.clamp(a, b) } }(), clampLength: function (a, b) { var c = this.length(); return this.divideScalar(c || 1).multiplyScalar(Math.max(a, Math.min(b, c))) }, floor: function () {
		this.x =
			Math.floor(this.x); this.y = Math.floor(this.y); this.z = Math.floor(this.z); return this
		}, ceil: function () { this.x = Math.ceil(this.x); this.y = Math.ceil(this.y); this.z = Math.ceil(this.z); return this }, round: function () { this.x = Math.round(this.x); this.y = Math.round(this.y); this.z = Math.round(this.z); return this }, roundToZero: function () { this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x); this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y); this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z); return this }, negate: function () {
		this.x =
			-this.x; this.y = -this.y; this.z = -this.z; return this
		}, dot: function (a) { return this.x * a.x + this.y * a.y + this.z * a.z }, lengthSq: function () { return this.x * this.x + this.y * this.y + this.z * this.z }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) }, manhattanLength: function () { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) }, normalize: function () { return this.divideScalar(this.length() || 1) }, setLength: function (a) { return this.normalize().multiplyScalar(a) }, lerp: function (a, b) {
		this.x += (a.x -
			this.x) * b; this.y += (a.y - this.y) * b; this.z += (a.z - this.z) * b; return this
		}, lerpVectors: function (a, b, c) { return this.subVectors(b, a).multiplyScalar(c).add(a) }, cross: function (a, b) { return void 0 !== b ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(a, b)) : this.crossVectors(this, a) }, crossVectors: function (a, b) { var c = a.x, d = a.y; a = a.z; var e = b.x, f = b.y; b = b.z; this.x = d * b - a * f; this.y = a * e - c * b; this.z = c * f - d * e; return this }, projectOnVector: function (a) {
			var b =
				a.dot(this) / a.lengthSq(); return this.copy(a).multiplyScalar(b)
		}, projectOnPlane: function () { var a = new p; return function (b) { a.copy(this).projectOnVector(b); return this.sub(a) } }(), reflect: function () { var a = new p; return function (b) { return this.sub(a.copy(b).multiplyScalar(2 * this.dot(b))) } }(), angleTo: function (a) { a = this.dot(a) / Math.sqrt(this.lengthSq() * a.lengthSq()); return Math.acos(R.clamp(a, -1, 1)) }, distanceTo: function (a) { return Math.sqrt(this.distanceToSquared(a)) }, distanceToSquared: function (a) {
			var b = this.x -
				a.x, c = this.y - a.y; a = this.z - a.z; return b * b + c * c + a * a
		}, manhattanDistanceTo: function (a) { return Math.abs(this.x - a.x) + Math.abs(this.y - a.y) + Math.abs(this.z - a.z) }, setFromSpherical: function (a) { var b = Math.sin(a.phi) * a.radius; this.x = b * Math.sin(a.theta); this.y = Math.cos(a.phi) * a.radius; this.z = b * Math.cos(a.theta); return this }, setFromCylindrical: function (a) { this.x = a.radius * Math.sin(a.theta); this.y = a.y; this.z = a.radius * Math.cos(a.theta); return this }, setFromMatrixPosition: function (a) {
			a = a.elements; this.x = a[12]; this.y =
				a[13]; this.z = a[14]; return this
		}, setFromMatrixScale: function (a) { var b = this.setFromMatrixColumn(a, 0).length(), c = this.setFromMatrixColumn(a, 1).length(); a = this.setFromMatrixColumn(a, 2).length(); this.x = b; this.y = c; this.z = a; return this }, setFromMatrixColumn: function (a, b) { return this.fromArray(a.elements, 4 * b) }, equals: function (a) { return a.x === this.x && a.y === this.y && a.z === this.z }, fromArray: function (a, b) { void 0 === b && (b = 0); this.x = a[b]; this.y = a[b + 1]; this.z = a[b + 2]; return this }, toArray: function (a, b) {
		void 0 === a && (a =
			[]); void 0 === b && (b = 0); a[b] = this.x; a[b + 1] = this.y; a[b + 2] = this.z; return a
		}, fromBufferAttribute: function (a, b, c) { void 0 !== c && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."); this.x = a.getX(b); this.y = a.getY(b); this.z = a.getZ(b); return this }
	}); Object.assign(ra.prototype, {
		isMatrix3: !0, set: function (a, b, c, d, e, f, g, h, k) { var l = this.elements; l[0] = a; l[1] = d; l[2] = g; l[3] = b; l[4] = e; l[5] = h; l[6] = c; l[7] = f; l[8] = k; return this }, identity: function () { this.set(1, 0, 0, 0, 1, 0, 0, 0, 1); return this }, clone: function () { return (new this.constructor).fromArray(this.elements) },
		copy: function (a) { var b = this.elements; a = a.elements; b[0] = a[0]; b[1] = a[1]; b[2] = a[2]; b[3] = a[3]; b[4] = a[4]; b[5] = a[5]; b[6] = a[6]; b[7] = a[7]; b[8] = a[8]; return this }, setFromMatrix4: function (a) { a = a.elements; this.set(a[0], a[4], a[8], a[1], a[5], a[9], a[2], a[6], a[10]); return this }, applyToBufferAttribute: function () { var a = new p; return function (b) { for (var c = 0, d = b.count; c < d; c++)a.x = b.getX(c), a.y = b.getY(c), a.z = b.getZ(c), a.applyMatrix3(this), b.setXYZ(c, a.x, a.y, a.z); return b } }(), multiply: function (a) {
			return this.multiplyMatrices(this,
				a)
		}, premultiply: function (a) { return this.multiplyMatrices(a, this) }, multiplyMatrices: function (a, b) { var c = a.elements, d = b.elements; b = this.elements; a = c[0]; var e = c[3], f = c[6], g = c[1], h = c[4], k = c[7], l = c[2], q = c[5], c = c[8], n = d[0], m = d[3], r = d[6], p = d[1], v = d[4], w = d[7], x = d[2], z = d[5], d = d[8]; b[0] = a * n + e * p + f * x; b[3] = a * m + e * v + f * z; b[6] = a * r + e * w + f * d; b[1] = g * n + h * p + k * x; b[4] = g * m + h * v + k * z; b[7] = g * r + h * w + k * d; b[2] = l * n + q * p + c * x; b[5] = l * m + q * v + c * z; b[8] = l * r + q * w + c * d; return this }, multiplyScalar: function (a) {
			var b = this.elements; b[0] *= a; b[3] *= a;
			b[6] *= a; b[1] *= a; b[4] *= a; b[7] *= a; b[2] *= a; b[5] *= a; b[8] *= a; return this
		}, determinant: function () { var a = this.elements, b = a[0], c = a[1], d = a[2], e = a[3], f = a[4], g = a[5], h = a[6], k = a[7], a = a[8]; return b * f * a - b * g * k - c * e * a + c * g * h + d * e * k - d * f * h }, getInverse: function (a, b) {
		a && a.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument."); var c = a.elements; a = this.elements; var d = c[0], e = c[1], f = c[2], g = c[3], h = c[4], k = c[5], l = c[6], q = c[7], c = c[8], n = c * h - k * q, m = k * l - c * g, r = q * g - h * l, p = d * n + e * m + f * r; if (0 === p) {
			if (!0 ===
				b) throw Error("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"); console.warn("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"); return this.identity()
		} b = 1 / p; a[0] = n * b; a[1] = (f * q - c * e) * b; a[2] = (k * e - f * h) * b; a[3] = m * b; a[4] = (c * d - f * l) * b; a[5] = (f * g - k * d) * b; a[6] = r * b; a[7] = (e * l - q * d) * b; a[8] = (h * d - e * g) * b; return this
		}, transpose: function () { var a = this.elements; var b = a[1]; a[1] = a[3]; a[3] = b; b = a[2]; a[2] = a[6]; a[6] = b; b = a[5]; a[5] = a[7]; a[7] = b; return this }, getNormalMatrix: function (a) { return this.setFromMatrix4(a).getInverse(this).transpose() },
		transposeIntoArray: function (a) { var b = this.elements; a[0] = b[0]; a[1] = b[3]; a[2] = b[6]; a[3] = b[1]; a[4] = b[4]; a[5] = b[7]; a[6] = b[2]; a[7] = b[5]; a[8] = b[8]; return this }, setUvTransform: function (a, b, c, d, e, f, g) { var h = Math.cos(e); e = Math.sin(e); this.set(c * h, c * e, -c * (h * f + e * g) + f + a, -d * e, d * h, -d * (-e * f + h * g) + g + b, 0, 0, 1) }, scale: function (a, b) { var c = this.elements; c[0] *= a; c[3] *= a; c[6] *= a; c[1] *= b; c[4] *= b; c[7] *= b; return this }, rotate: function (a) {
			var b = Math.cos(a); a = Math.sin(a); var c = this.elements, d = c[0], e = c[3], f = c[6], g = c[1], h = c[4],
				k = c[7]; c[0] = b * d + a * g; c[3] = b * e + a * h; c[6] = b * f + a * k; c[1] = -a * d + b * g; c[4] = -a * e + b * h; c[7] = -a * f + b * k; return this
		}, translate: function (a, b) { var c = this.elements; c[0] += a * c[2]; c[3] += a * c[5]; c[6] += a * c[8]; c[1] += b * c[2]; c[4] += b * c[5]; c[7] += b * c[8]; return this }, equals: function (a) { var b = this.elements; a = a.elements; for (var c = 0; 9 > c; c++)if (b[c] !== a[c]) return !1; return !0 }, fromArray: function (a, b) { void 0 === b && (b = 0); for (var c = 0; 9 > c; c++)this.elements[c] = a[c + b]; return this }, toArray: function (a, b) {
		void 0 === a && (a = []); void 0 === b && (b = 0); var c =
			this.elements; a[b] = c[0]; a[b + 1] = c[1]; a[b + 2] = c[2]; a[b + 3] = c[3]; a[b + 4] = c[4]; a[b + 5] = c[5]; a[b + 6] = c[6]; a[b + 7] = c[7]; a[b + 8] = c[8]; return a
		}
	}); var kf = 0; ea.DEFAULT_IMAGE = void 0; ea.DEFAULT_MAPPING = 300; Object.defineProperty(ea.prototype, "needsUpdate", { set: function (a) { !0 === a && this.version++ } }); Object.assign(ea.prototype, ja.prototype, {
		constructor: ea, isTexture: !0, clone: function () { return (new this.constructor).copy(this) }, copy: function (a) {
		this.name = a.name; this.image = a.image; this.mipmaps = a.mipmaps.slice(0); this.mapping =
			a.mapping; this.wrapS = a.wrapS; this.wrapT = a.wrapT; this.magFilter = a.magFilter; this.minFilter = a.minFilter; this.anisotropy = a.anisotropy; this.format = a.format; this.type = a.type; this.offset.copy(a.offset); this.repeat.copy(a.repeat); this.center.copy(a.center); this.rotation = a.rotation; this.matrixAutoUpdate = a.matrixAutoUpdate; this.matrix.copy(a.matrix); this.generateMipmaps = a.generateMipmaps; this.premultiplyAlpha = a.premultiplyAlpha; this.flipY = a.flipY; this.unpackAlignment = a.unpackAlignment; this.encoding = a.encoding;
			return this
		}, toJSON: function (a) {
			var b = void 0 === a || "string" === typeof a; if (!b && void 0 !== a.textures[this.uuid]) return a.textures[this.uuid]; var c = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY };
			if (void 0 !== this.image) {
				var d = this.image; void 0 === d.uuid && (d.uuid = R.generateUUID()); if (!b && void 0 === a.images[d.uuid]) {
					var e = a.images, f = d.uuid, g = d.uuid; if (d instanceof HTMLCanvasElement) var h = d; else { h = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"); h.width = d.width; h.height = d.height; var k = h.getContext("2d"); d instanceof ImageData ? k.putImageData(d, 0, 0) : k.drawImage(d, 0, 0, d.width, d.height) } h = 2048 < h.width || 2048 < h.height ? h.toDataURL("image/jpeg", .6) : h.toDataURL("image/png"); e[f] = {
						uuid: g,
						url: h
					}
				} c.image = d.uuid
			} b || (a.textures[this.uuid] = c); return c
		}, dispose: function () { this.dispatchEvent({ type: "dispose" }) }, transformUv: function (a) {
			if (300 === this.mapping) {
				a.applyMatrix3(this.matrix); if (0 > a.x || 1 < a.x) switch (this.wrapS) { case 1E3: a.x -= Math.floor(a.x); break; case 1001: a.x = 0 > a.x ? 0 : 1; break; case 1002: a.x = 1 === Math.abs(Math.floor(a.x) % 2) ? Math.ceil(a.x) - a.x : a.x - Math.floor(a.x) }if (0 > a.y || 1 < a.y) switch (this.wrapT) {
					case 1E3: a.y -= Math.floor(a.y); break; case 1001: a.y = 0 > a.y ? 0 : 1; break; case 1002: a.y = 1 === Math.abs(Math.floor(a.y) %
						2) ? Math.ceil(a.y) - a.y : a.y - Math.floor(a.y)
				}this.flipY && (a.y = 1 - a.y)
			}
		}
	}); Object.assign(da.prototype, {
		isVector4: !0, set: function (a, b, c, d) { this.x = a; this.y = b; this.z = c; this.w = d; return this }, setScalar: function (a) { this.w = this.z = this.y = this.x = a; return this }, setX: function (a) { this.x = a; return this }, setY: function (a) { this.y = a; return this }, setZ: function (a) { this.z = a; return this }, setW: function (a) { this.w = a; return this }, setComponent: function (a, b) {
			switch (a) {
				case 0: this.x = b; break; case 1: this.y = b; break; case 2: this.z = b; break;
				case 3: this.w = b; break; default: throw Error("index is out of range: " + a);
			}return this
		}, getComponent: function (a) { switch (a) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw Error("index is out of range: " + a); } }, clone: function () { return new this.constructor(this.x, this.y, this.z, this.w) }, copy: function (a) { this.x = a.x; this.y = a.y; this.z = a.z; this.w = void 0 !== a.w ? a.w : 1; return this }, add: function (a, b) {
			if (void 0 !== b) return console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
				this.addVectors(a, b); this.x += a.x; this.y += a.y; this.z += a.z; this.w += a.w; return this
		}, addScalar: function (a) { this.x += a; this.y += a; this.z += a; this.w += a; return this }, addVectors: function (a, b) { this.x = a.x + b.x; this.y = a.y + b.y; this.z = a.z + b.z; this.w = a.w + b.w; return this }, addScaledVector: function (a, b) { this.x += a.x * b; this.y += a.y * b; this.z += a.z * b; this.w += a.w * b; return this }, sub: function (a, b) {
			if (void 0 !== b) return console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a,
				b); this.x -= a.x; this.y -= a.y; this.z -= a.z; this.w -= a.w; return this
		}, subScalar: function (a) { this.x -= a; this.y -= a; this.z -= a; this.w -= a; return this }, subVectors: function (a, b) { this.x = a.x - b.x; this.y = a.y - b.y; this.z = a.z - b.z; this.w = a.w - b.w; return this }, multiplyScalar: function (a) { this.x *= a; this.y *= a; this.z *= a; this.w *= a; return this }, applyMatrix4: function (a) {
			var b = this.x, c = this.y, d = this.z, e = this.w; a = a.elements; this.x = a[0] * b + a[4] * c + a[8] * d + a[12] * e; this.y = a[1] * b + a[5] * c + a[9] * d + a[13] * e; this.z = a[2] * b + a[6] * c + a[10] * d + a[14] *
				e; this.w = a[3] * b + a[7] * c + a[11] * d + a[15] * e; return this
		}, divideScalar: function (a) { return this.multiplyScalar(1 / a) }, setAxisAngleFromQuaternion: function (a) { this.w = 2 * Math.acos(a.w); var b = Math.sqrt(1 - a.w * a.w); 1E-4 > b ? (this.x = 1, this.z = this.y = 0) : (this.x = a.x / b, this.y = a.y / b, this.z = a.z / b); return this }, setAxisAngleFromRotationMatrix: function (a) {
			a = a.elements; var b = a[0]; var c = a[4]; var d = a[8], e = a[1], f = a[5], g = a[9]; var h = a[2]; var k = a[6]; var l = a[10]; if (.01 > Math.abs(c - e) && .01 > Math.abs(d - h) && .01 > Math.abs(g - k)) {
				if (.1 > Math.abs(c +
					e) && .1 > Math.abs(d + h) && .1 > Math.abs(g + k) && .1 > Math.abs(b + f + l - 3)) return this.set(1, 0, 0, 0), this; a = Math.PI; b = (b + 1) / 2; f = (f + 1) / 2; l = (l + 1) / 2; c = (c + e) / 4; d = (d + h) / 4; g = (g + k) / 4; b > f && b > l ? .01 > b ? (k = 0, c = h = .707106781) : (k = Math.sqrt(b), h = c / k, c = d / k) : f > l ? .01 > f ? (k = .707106781, h = 0, c = .707106781) : (h = Math.sqrt(f), k = c / h, c = g / h) : .01 > l ? (h = k = .707106781, c = 0) : (c = Math.sqrt(l), k = d / c, h = g / c); this.set(k, h, c, a); return this
			} a = Math.sqrt((k - g) * (k - g) + (d - h) * (d - h) + (e - c) * (e - c)); .001 > Math.abs(a) && (a = 1); this.x = (k - g) / a; this.y = (d - h) / a; this.z = (e - c) / a;
			this.w = Math.acos((b + f + l - 1) / 2); return this
		}, min: function (a) { this.x = Math.min(this.x, a.x); this.y = Math.min(this.y, a.y); this.z = Math.min(this.z, a.z); this.w = Math.min(this.w, a.w); return this }, max: function (a) { this.x = Math.max(this.x, a.x); this.y = Math.max(this.y, a.y); this.z = Math.max(this.z, a.z); this.w = Math.max(this.w, a.w); return this }, clamp: function (a, b) {
		this.x = Math.max(a.x, Math.min(b.x, this.x)); this.y = Math.max(a.y, Math.min(b.y, this.y)); this.z = Math.max(a.z, Math.min(b.z, this.z)); this.w = Math.max(a.w, Math.min(b.w,
			this.w)); return this
		}, clampScalar: function () { var a, b; return function (c, d) { void 0 === a && (a = new da, b = new da); a.set(c, c, c, c); b.set(d, d, d, d); return this.clamp(a, b) } }(), clampLength: function (a, b) { var c = this.length(); return this.divideScalar(c || 1).multiplyScalar(Math.max(a, Math.min(b, c))) }, floor: function () { this.x = Math.floor(this.x); this.y = Math.floor(this.y); this.z = Math.floor(this.z); this.w = Math.floor(this.w); return this }, ceil: function () {
		this.x = Math.ceil(this.x); this.y = Math.ceil(this.y); this.z = Math.ceil(this.z);
			this.w = Math.ceil(this.w); return this
		}, round: function () { this.x = Math.round(this.x); this.y = Math.round(this.y); this.z = Math.round(this.z); this.w = Math.round(this.w); return this }, roundToZero: function () { this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x); this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y); this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z); this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w); return this }, negate: function () { this.x = -this.x; this.y = -this.y; this.z = -this.z; this.w = -this.w; return this },
		dot: function (a) { return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w }, lengthSq: function () { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) }, manhattanLength: function () { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) }, normalize: function () { return this.divideScalar(this.length() || 1) }, setLength: function (a) { return this.normalize().multiplyScalar(a) }, lerp: function (a, b) {
		this.x +=
			(a.x - this.x) * b; this.y += (a.y - this.y) * b; this.z += (a.z - this.z) * b; this.w += (a.w - this.w) * b; return this
		}, lerpVectors: function (a, b, c) { return this.subVectors(b, a).multiplyScalar(c).add(a) }, equals: function (a) { return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w }, fromArray: function (a, b) { void 0 === b && (b = 0); this.x = a[b]; this.y = a[b + 1]; this.z = a[b + 2]; this.w = a[b + 3]; return this }, toArray: function (a, b) { void 0 === a && (a = []); void 0 === b && (b = 0); a[b] = this.x; a[b + 1] = this.y; a[b + 2] = this.z; a[b + 3] = this.w; return a }, fromBufferAttribute: function (a,
			b, c) { void 0 !== c && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."); this.x = a.getX(b); this.y = a.getY(b); this.z = a.getZ(b); this.w = a.getW(b); return this }
	}); Object.assign(Hb.prototype, ja.prototype, {
		isWebGLRenderTarget: !0, setSize: function (a, b) { if (this.width !== a || this.height !== b) this.width = a, this.height = b, this.dispose(); this.viewport.set(0, 0, a, b); this.scissor.set(0, 0, a, b) }, clone: function () { return (new this.constructor).copy(this) }, copy: function (a) {
		this.width = a.width; this.height =
			a.height; this.viewport.copy(a.viewport); this.texture = a.texture.clone(); this.depthBuffer = a.depthBuffer; this.stencilBuffer = a.stencilBuffer; this.depthTexture = a.depthTexture; return this
		}, dispose: function () { this.dispatchEvent({ type: "dispose" }) }
	}); Ib.prototype = Object.create(Hb.prototype); Ib.prototype.constructor = Ib; Ib.prototype.isWebGLRenderTargetCube = !0; fb.prototype = Object.create(ea.prototype); fb.prototype.constructor = fb; fb.prototype.isDataTexture = !0; Ua.prototype = Object.create(ea.prototype); Ua.prototype.constructor =
		Ua; Ua.prototype.isCubeTexture = !0; Object.defineProperty(Ua.prototype, "images", { get: function () { return this.image }, set: function (a) { this.image = a } }); var Be = new ea, Ce = new Ua, we = [], ye = [], Ae = new Float32Array(16), ze = new Float32Array(9); Ge.prototype.setValue = function (a, b) { for (var c = this.seq, d = 0, e = c.length; d !== e; ++d) { var f = c[d]; f.setValue(a, b[f.id]) } }; var Od = /([\w\d_]+)(\])?(\[|\.)?/g; gb.prototype.setValue = function (a, b, c) { b = this.map[b]; void 0 !== b && b.setValue(a, c, this.renderer) }; gb.prototype.setOptional = function (a,
			b, c) { b = b[c]; void 0 !== b && this.setValue(a, c, b) }; gb.upload = function (a, b, c, d) { for (var e = 0, f = b.length; e !== f; ++e) { var g = b[e], h = c[g.id]; !1 !== h.needsUpdate && g.setValue(a, h.value, d) } }; gb.seqWithValue = function (a, b) { for (var c = [], d = 0, e = a.length; d !== e; ++d) { var f = a[d]; f.id in b && c.push(f) } return c }; var sg = {
				aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231,
				cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539,
				deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536,
				lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154,
				mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519,
				royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074
			}; Object.assign(H.prototype, {
				isColor: !0, r: 1, g: 1, b: 1, set: function (a) {
					a &&
					a.isColor ? this.copy(a) : "number" === typeof a ? this.setHex(a) : "string" === typeof a && this.setStyle(a); return this
				}, setScalar: function (a) { this.b = this.g = this.r = a; return this }, setHex: function (a) { a = Math.floor(a); this.r = (a >> 16 & 255) / 255; this.g = (a >> 8 & 255) / 255; this.b = (a & 255) / 255; return this }, setRGB: function (a, b, c) { this.r = a; this.g = b; this.b = c; return this }, setHSL: function () {
					function a(a, c, d) { 0 > d && (d += 1); 1 < d && --d; return d < 1 / 6 ? a + 6 * (c - a) * d : .5 > d ? c : d < 2 / 3 ? a + 6 * (c - a) * (2 / 3 - d) : a } return function (b, c, d) {
						b = R.euclideanModulo(b,
							1); c = R.clamp(c, 0, 1); d = R.clamp(d, 0, 1); 0 === c ? this.r = this.g = this.b = d : (c = .5 >= d ? d * (1 + c) : d + c - d * c, d = 2 * d - c, this.r = a(d, c, b + 1 / 3), this.g = a(d, c, b), this.b = a(d, c, b - 1 / 3)); return this
					}
				}(), setStyle: function (a) {
					function b(b) { void 0 !== b && 1 > parseFloat(b) && console.warn("THREE.Color: Alpha component of " + a + " will be ignored.") } var c; if (c = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(a)) {
						var d = c[2]; switch (c[1]) {
							case "rgb": case "rgba": if (c = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) return this.r = Math.min(255,
								parseInt(c[1], 10)) / 255, this.g = Math.min(255, parseInt(c[2], 10)) / 255, this.b = Math.min(255, parseInt(c[3], 10)) / 255, b(c[5]), this; if (c = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) return this.r = Math.min(100, parseInt(c[1], 10)) / 100, this.g = Math.min(100, parseInt(c[2], 10)) / 100, this.b = Math.min(100, parseInt(c[3], 10)) / 100, b(c[5]), this; break; case "hsl": case "hsla": if (c = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) {
									var d = parseFloat(c[1]) / 360,
									e = parseInt(c[2], 10) / 100, f = parseInt(c[3], 10) / 100; b(c[5]); return this.setHSL(d, e, f)
								}
						}
					} else if (c = /^\#([A-Fa-f0-9]+)$/.exec(a)) { c = c[1]; d = c.length; if (3 === d) return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255, this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255, this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255, this; if (6 === d) return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255, this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255, this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255, this } a && 0 < a.length && (c = sg[a], void 0 !==
						c ? this.setHex(c) : console.warn("THREE.Color: Unknown color " + a)); return this
				}, clone: function () { return new this.constructor(this.r, this.g, this.b) }, copy: function (a) { this.r = a.r; this.g = a.g; this.b = a.b; return this }, copyGammaToLinear: function (a, b) { void 0 === b && (b = 2); this.r = Math.pow(a.r, b); this.g = Math.pow(a.g, b); this.b = Math.pow(a.b, b); return this }, copyLinearToGamma: function (a, b) { void 0 === b && (b = 2); b = 0 < b ? 1 / b : 1; this.r = Math.pow(a.r, b); this.g = Math.pow(a.g, b); this.b = Math.pow(a.b, b); return this }, convertGammaToLinear: function () {
					var a =
						this.r, b = this.g, c = this.b; this.r = a * a; this.g = b * b; this.b = c * c; return this
				}, convertLinearToGamma: function () { this.r = Math.sqrt(this.r); this.g = Math.sqrt(this.g); this.b = Math.sqrt(this.b); return this }, getHex: function () { return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0 }, getHexString: function () { return ("000000" + this.getHex().toString(16)).slice(-6) }, getHSL: function (a) {
					a = a || { h: 0, s: 0, l: 0 }; var b = this.r, c = this.g, d = this.b, e = Math.max(b, c, d), f = Math.min(b, c, d), g, h = (f + e) / 2; if (f === e) f = g = 0; else {
						var k = e - f, f = .5 >= h ? k / (e + f) :
							k / (2 - e - f); switch (e) { case b: g = (c - d) / k + (c < d ? 6 : 0); break; case c: g = (d - b) / k + 2; break; case d: g = (b - c) / k + 4 }g /= 6
					} a.h = g; a.s = f; a.l = h; return a
				}, getStyle: function () { return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")" }, offsetHSL: function (a, b, c) { var d = this.getHSL(); d.h += a; d.s += b; d.l += c; this.setHSL(d.h, d.s, d.l); return this }, add: function (a) { this.r += a.r; this.g += a.g; this.b += a.b; return this }, addColors: function (a, b) { this.r = a.r + b.r; this.g = a.g + b.g; this.b = a.b + b.b; return this }, addScalar: function (a) {
				this.r +=
					a; this.g += a; this.b += a; return this
				}, sub: function (a) { this.r = Math.max(0, this.r - a.r); this.g = Math.max(0, this.g - a.g); this.b = Math.max(0, this.b - a.b); return this }, multiply: function (a) { this.r *= a.r; this.g *= a.g; this.b *= a.b; return this }, multiplyScalar: function (a) { this.r *= a; this.g *= a; this.b *= a; return this }, lerp: function (a, b) { this.r += (a.r - this.r) * b; this.g += (a.g - this.g) * b; this.b += (a.b - this.b) * b; return this }, equals: function (a) { return a.r === this.r && a.g === this.g && a.b === this.b }, fromArray: function (a, b) {
				void 0 === b && (b =
					0); this.r = a[b]; this.g = a[b + 1]; this.b = a[b + 2]; return this
				}, toArray: function (a, b) { void 0 === a && (a = []); void 0 === b && (b = 0); a[b] = this.r; a[b + 1] = this.g; a[b + 2] = this.b; return a }, toJSON: function () { return this.getHex() }
			}); var E = {
				common: { diffuse: { value: new H(15658734) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new ra }, alphaMap: { value: null } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: .98 } }, aomap: {
					aoMap: { value: null },
					aoMapIntensity: { value: 1 }
				}, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new C(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: {
					fogDensity: { value: 2.5E-4 }, fogNear: { value: 1 },
					fogFar: { value: 2E3 }, fogColor: { value: new H(16777215) }
				}, lights: {
					ambientLightColor: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] },
					pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }
				}, points: { diffuse: { value: new H(15658734) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, uvTransform: { value: new ra } }
			},
				Ea = { merge: function (a) { for (var b = {}, c = 0; c < a.length; c++) { var d = this.clone(a[c]), e; for (e in d) b[e] = d[e] } return b }, clone: function (a) { var b = {}, c; for (c in a) { b[c] = {}; for (var d in a[c]) { var e = a[c][d]; e && (e.isColor || e.isMatrix3 || e.isMatrix4 || e.isVector2 || e.isVector3 || e.isVector4 || e.isTexture) ? b[c][d] = e.clone() : Array.isArray(e) ? b[c][d] = e.slice() : b[c][d] = e } } return b } }, W = {
					alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
					alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n", aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",
					aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", begin_vertex: "\nvec3 transformed = vec3( position );\n", beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n", bsdfs: "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\n\tfloat b = 3.45068 + (4.18814 + y) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\n\treturn result;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
					bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
					clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n",
					clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",
					color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n", color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif", common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n",
					cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",
					defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
					emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n", encodings_fragment: "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n",
					envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
					envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
					envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n", envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",
					fog_vertex: "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n", fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n", fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n",
					gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n", lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
					lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
					lights_pars: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
					lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n", lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
					lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
					lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
					lights_template: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
					logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n",
					map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n", map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n", map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n", map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n",
					metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
					morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
					normal_fragment: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
					normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n",
					packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
					premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n", project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n", dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n", dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n",
					roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
					shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
					shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
					shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
					skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
					skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n", skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
					specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n", tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
					uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif", uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n",
					uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
					uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n", cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n",
					cube_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n", depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",
					depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
					distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n",
					distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n",
					equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n", equirect_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
					linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
					linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
					meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
					meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n",
					meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
					meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
					meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
					meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
					meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
					meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
					normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",
					normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n",
					points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
					points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
					shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n", shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n"
				},
				mb = {
					basic: { uniforms: Ea.merge([E.common, E.specularmap, E.envmap, E.aomap, E.lightmap, E.fog]), vertexShader: W.meshbasic_vert, fragmentShader: W.meshbasic_frag }, lambert: { uniforms: Ea.merge([E.common, E.specularmap, E.envmap, E.aomap, E.lightmap, E.emissivemap, E.fog, E.lights, { emissive: { value: new H(0) } }]), vertexShader: W.meshlambert_vert, fragmentShader: W.meshlambert_frag }, phong: {
						uniforms: Ea.merge([E.common, E.specularmap, E.envmap, E.aomap, E.lightmap, E.emissivemap, E.bumpmap, E.normalmap, E.displacementmap, E.gradientmap,
						E.fog, E.lights, { emissive: { value: new H(0) }, specular: { value: new H(1118481) }, shininess: { value: 30 } }]), vertexShader: W.meshphong_vert, fragmentShader: W.meshphong_frag
					}, standard: { uniforms: Ea.merge([E.common, E.envmap, E.aomap, E.lightmap, E.emissivemap, E.bumpmap, E.normalmap, E.displacementmap, E.roughnessmap, E.metalnessmap, E.fog, E.lights, { emissive: { value: new H(0) }, roughness: { value: .5 }, metalness: { value: .5 }, envMapIntensity: { value: 1 } }]), vertexShader: W.meshphysical_vert, fragmentShader: W.meshphysical_frag }, points: {
						uniforms: Ea.merge([E.points,
						E.fog]), vertexShader: W.points_vert, fragmentShader: W.points_frag
					}, dashed: { uniforms: Ea.merge([E.common, E.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: W.linedashed_vert, fragmentShader: W.linedashed_frag }, depth: { uniforms: Ea.merge([E.common, E.displacementmap]), vertexShader: W.depth_vert, fragmentShader: W.depth_frag }, normal: { uniforms: Ea.merge([E.common, E.bumpmap, E.normalmap, E.displacementmap, { opacity: { value: 1 } }]), vertexShader: W.normal_vert, fragmentShader: W.normal_frag }, cube: {
						uniforms: {
							tCube: { value: null },
							tFlip: { value: -1 }, opacity: { value: 1 }
						}, vertexShader: W.cube_vert, fragmentShader: W.cube_frag
					}, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: W.equirect_vert, fragmentShader: W.equirect_frag }, distanceRGBA: { uniforms: Ea.merge([E.common, E.displacementmap, { referencePosition: { value: new p }, nearDistance: { value: 1 }, farDistance: { value: 1E3 } }]), vertexShader: W.distanceRGBA_vert, fragmentShader: W.distanceRGBA_frag }, shadow: {
						uniforms: Ea.merge([E.lights, E.fog, { color: { value: new H(0) }, opacity: { value: 1 } }]), vertexShader: W.shadow_vert,
						fragmentShader: W.shadow_frag
					}
				}; mb.physical = { uniforms: Ea.merge([mb.standard.uniforms, { clearCoat: { value: 0 }, clearCoatRoughness: { value: 0 } }]), vertexShader: W.meshphysical_vert, fragmentShader: W.meshphysical_frag }; Object.assign(kd.prototype, {
					set: function (a, b) { this.min.copy(a); this.max.copy(b); return this }, setFromPoints: function (a) { this.makeEmpty(); for (var b = 0, c = a.length; b < c; b++)this.expandByPoint(a[b]); return this }, setFromCenterAndSize: function () {
						var a = new C; return function (b, c) {
							c = a.copy(c).multiplyScalar(.5);
							this.min.copy(b).sub(c); this.max.copy(b).add(c); return this
						}
					}(), clone: function () { return (new this.constructor).copy(this) }, copy: function (a) { this.min.copy(a.min); this.max.copy(a.max); return this }, makeEmpty: function () { this.min.x = this.min.y = Infinity; this.max.x = this.max.y = -Infinity; return this }, isEmpty: function () { return this.max.x < this.min.x || this.max.y < this.min.y }, getCenter: function (a) { a = a || new C; return this.isEmpty() ? a.set(0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5) }, getSize: function (a) {
						a =
						a || new C; return this.isEmpty() ? a.set(0, 0) : a.subVectors(this.max, this.min)
					}, expandByPoint: function (a) { this.min.min(a); this.max.max(a); return this }, expandByVector: function (a) { this.min.sub(a); this.max.add(a); return this }, expandByScalar: function (a) { this.min.addScalar(-a); this.max.addScalar(a); return this }, containsPoint: function (a) { return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y ? !1 : !0 }, containsBox: function (a) {
						return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <=
							this.max.y
					}, getParameter: function (a, b) { return (b || new C).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y)) }, intersectsBox: function (a) { return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y ? !1 : !0 }, clampPoint: function (a, b) { return (b || new C).copy(a).clamp(this.min, this.max) }, distanceToPoint: function () { var a = new C; return function (b) { return a.copy(b).clamp(this.min, this.max).sub(b).length() } }(), intersect: function (a) {
						this.min.max(a.min);
						this.max.min(a.max); return this
					}, union: function (a) { this.min.min(a.min); this.max.max(a.max); return this }, translate: function (a) { this.min.add(a); this.max.add(a); return this }, equals: function (a) { return a.min.equals(this.min) && a.max.equals(this.max) }
				}); tc.prototype = Object.create(ea.prototype); tc.prototype.constructor = tc; var Lf = 0; Object.assign(Q.prototype, ja.prototype, {
					isMaterial: !0, onBeforeCompile: function () { }, setValues: function (a) {
						if (void 0 !== a) for (var b in a) {
							var c = a[b]; if (void 0 === c) console.warn("THREE.Material: '" +
								b + "' parameter is undefined."); else if ("shading" === b) console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === c ? !0 : !1; else { var d = this[b]; void 0 === d ? console.warn("THREE." + this.type + ": '" + b + "' is not a property of this material.") : d && d.isColor ? d.set(c) : d && d.isVector3 && c && c.isVector3 ? d.copy(c) : this[b] = "overdraw" === b ? Number(c) : c }
						}
					}, toJSON: function (a) {
						function b(a) { var b = [], c; for (c in a) { var d = a[c]; delete d.metadata; b.push(d) } return b } var c =
							void 0 === a || "string" === typeof a; c && (a = { textures: {}, images: {} }); var d = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } }; d.uuid = this.uuid; d.type = this.type; "" !== this.name && (d.name = this.name); this.color && this.color.isColor && (d.color = this.color.getHex()); void 0 !== this.roughness && (d.roughness = this.roughness); void 0 !== this.metalness && (d.metalness = this.metalness); this.emissive && this.emissive.isColor && (d.emissive = this.emissive.getHex()); 1 !== this.emissiveIntensity && (d.emissiveIntensity = this.emissiveIntensity);
						this.specular && this.specular.isColor && (d.specular = this.specular.getHex()); void 0 !== this.shininess && (d.shininess = this.shininess); void 0 !== this.clearCoat && (d.clearCoat = this.clearCoat); void 0 !== this.clearCoatRoughness && (d.clearCoatRoughness = this.clearCoatRoughness); this.map && this.map.isTexture && (d.map = this.map.toJSON(a).uuid); this.alphaMap && this.alphaMap.isTexture && (d.alphaMap = this.alphaMap.toJSON(a).uuid); this.lightMap && this.lightMap.isTexture && (d.lightMap = this.lightMap.toJSON(a).uuid); this.bumpMap &&
							this.bumpMap.isTexture && (d.bumpMap = this.bumpMap.toJSON(a).uuid, d.bumpScale = this.bumpScale); this.normalMap && this.normalMap.isTexture && (d.normalMap = this.normalMap.toJSON(a).uuid, d.normalScale = this.normalScale.toArray()); this.displacementMap && this.displacementMap.isTexture && (d.displacementMap = this.displacementMap.toJSON(a).uuid, d.displacementScale = this.displacementScale, d.displacementBias = this.displacementBias); this.roughnessMap && this.roughnessMap.isTexture && (d.roughnessMap = this.roughnessMap.toJSON(a).uuid);
						this.metalnessMap && this.metalnessMap.isTexture && (d.metalnessMap = this.metalnessMap.toJSON(a).uuid); this.emissiveMap && this.emissiveMap.isTexture && (d.emissiveMap = this.emissiveMap.toJSON(a).uuid); this.specularMap && this.specularMap.isTexture && (d.specularMap = this.specularMap.toJSON(a).uuid); this.envMap && this.envMap.isTexture && (d.envMap = this.envMap.toJSON(a).uuid, d.reflectivity = this.reflectivity); this.gradientMap && this.gradientMap.isTexture && (d.gradientMap = this.gradientMap.toJSON(a).uuid); void 0 !== this.size &&
							(d.size = this.size); void 0 !== this.sizeAttenuation && (d.sizeAttenuation = this.sizeAttenuation); 1 !== this.blending && (d.blending = this.blending); !0 === this.flatShading && (d.flatShading = this.flatShading); 0 !== this.side && (d.side = this.side); 0 !== this.vertexColors && (d.vertexColors = this.vertexColors); 1 > this.opacity && (d.opacity = this.opacity); !0 === this.transparent && (d.transparent = this.transparent); d.depthFunc = this.depthFunc; d.depthTest = this.depthTest; d.depthWrite = this.depthWrite; 0 !== this.rotation && (d.rotation = this.rotation);
						1 !== this.linewidth && (d.linewidth = this.linewidth); void 0 !== this.dashSize && (d.dashSize = this.dashSize); void 0 !== this.gapSize && (d.gapSize = this.gapSize); void 0 !== this.scale && (d.scale = this.scale); !0 === this.dithering && (d.dithering = !0); 0 < this.alphaTest && (d.alphaTest = this.alphaTest); !0 === this.premultipliedAlpha && (d.premultipliedAlpha = this.premultipliedAlpha); !0 === this.wireframe && (d.wireframe = this.wireframe); 1 < this.wireframeLinewidth && (d.wireframeLinewidth = this.wireframeLinewidth); "round" !== this.wireframeLinecap &&
							(d.wireframeLinecap = this.wireframeLinecap); "round" !== this.wireframeLinejoin && (d.wireframeLinejoin = this.wireframeLinejoin); !0 === this.morphTargets && (d.morphTargets = !0); !0 === this.skinning && (d.skinning = !0); !1 === this.visible && (d.visible = !1); "{}" !== JSON.stringify(this.userData) && (d.userData = this.userData); c && (c = b(a.textures), a = b(a.images), 0 < c.length && (d.textures = c), 0 < a.length && (d.images = a)); return d
					}, clone: function () { return (new this.constructor).copy(this) }, copy: function (a) {
					this.name = a.name; this.fog = a.fog;
						this.lights = a.lights; this.blending = a.blending; this.side = a.side; this.flatShading = a.flatShading; this.vertexColors = a.vertexColors; this.opacity = a.opacity; this.transparent = a.transparent; this.blendSrc = a.blendSrc; this.blendDst = a.blendDst; this.blendEquation = a.blendEquation; this.blendSrcAlpha = a.blendSrcAlpha; this.blendDstAlpha = a.blendDstAlpha; this.blendEquationAlpha = a.blendEquationAlpha; this.depthFunc = a.depthFunc; this.depthTest = a.depthTest; this.depthWrite = a.depthWrite; this.colorWrite = a.colorWrite; this.precision =
							a.precision; this.polygonOffset = a.polygonOffset; this.polygonOffsetFactor = a.polygonOffsetFactor; this.polygonOffsetUnits = a.polygonOffsetUnits; this.dithering = a.dithering; this.alphaTest = a.alphaTest; this.premultipliedAlpha = a.premultipliedAlpha; this.overdraw = a.overdraw; this.visible = a.visible; this.userData = JSON.parse(JSON.stringify(a.userData)); this.clipShadows = a.clipShadows; this.clipIntersection = a.clipIntersection; a = a.clippingPlanes; var b = null; if (null !== a) for (var c = a.length, b = Array(c), d = 0; d !== c; ++d)b[d] =
								a[d].clone(); this.clippingPlanes = b; return this
					}, dispose: function () { this.dispatchEvent({ type: "dispose" }) }
				}); Wa.prototype = Object.create(Q.prototype); Wa.prototype.constructor = Wa; Wa.prototype.isMeshDepthMaterial = !0; Wa.prototype.copy = function (a) {
					Q.prototype.copy.call(this, a); this.depthPacking = a.depthPacking; this.skinning = a.skinning; this.morphTargets = a.morphTargets; this.map = a.map; this.alphaMap = a.alphaMap; this.displacementMap = a.displacementMap; this.displacementScale = a.displacementScale; this.displacementBias =
						a.displacementBias; this.wireframe = a.wireframe; this.wireframeLinewidth = a.wireframeLinewidth; return this
				}; Xa.prototype = Object.create(Q.prototype); Xa.prototype.constructor = Xa; Xa.prototype.isMeshDistanceMaterial = !0; Xa.prototype.copy = function (a) {
					Q.prototype.copy.call(this, a); this.referencePosition.copy(a.referencePosition); this.nearDistance = a.nearDistance; this.farDistance = a.farDistance; this.skinning = a.skinning; this.morphTargets = a.morphTargets; this.map = a.map; this.alphaMap = a.alphaMap; this.displacementMap =
						a.displacementMap; this.displacementScale = a.displacementScale; this.displacementBias = a.displacementBias; return this
				}; Object.assign(Oa.prototype, {
					isBox3: !0, set: function (a, b) { this.min.copy(a); this.max.copy(b); return this }, setFromArray: function (a) { for (var b = Infinity, c = Infinity, d = Infinity, e = -Infinity, f = -Infinity, g = -Infinity, h = 0, k = a.length; h < k; h += 3) { var l = a[h], q = a[h + 1], n = a[h + 2]; l < b && (b = l); q < c && (c = q); n < d && (d = n); l > e && (e = l); q > f && (f = q); n > g && (g = n) } this.min.set(b, c, d); this.max.set(e, f, g); return this }, setFromBufferAttribute: function (a) {
						for (var b =
							Infinity, c = Infinity, d = Infinity, e = -Infinity, f = -Infinity, g = -Infinity, h = 0, k = a.count; h < k; h++) { var l = a.getX(h), q = a.getY(h), n = a.getZ(h); l < b && (b = l); q < c && (c = q); n < d && (d = n); l > e && (e = l); q > f && (f = q); n > g && (g = n) } this.min.set(b, c, d); this.max.set(e, f, g); return this
					}, setFromPoints: function (a) { this.makeEmpty(); for (var b = 0, c = a.length; b < c; b++)this.expandByPoint(a[b]); return this }, setFromCenterAndSize: function () {
						var a = new p; return function (b, c) {
							c = a.copy(c).multiplyScalar(.5); this.min.copy(b).sub(c); this.max.copy(b).add(c);
							return this
						}
					}(), setFromObject: function (a) { this.makeEmpty(); return this.expandByObject(a) }, clone: function () { return (new this.constructor).copy(this) }, copy: function (a) { this.min.copy(a.min); this.max.copy(a.max); return this }, makeEmpty: function () { this.min.x = this.min.y = this.min.z = Infinity; this.max.x = this.max.y = this.max.z = -Infinity; return this }, isEmpty: function () { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z }, getCenter: function (a) {
						a = a || new p; return this.isEmpty() ? a.set(0, 0, 0) :
							a.addVectors(this.min, this.max).multiplyScalar(.5)
					}, getSize: function (a) { a = a || new p; return this.isEmpty() ? a.set(0, 0, 0) : a.subVectors(this.max, this.min) }, expandByPoint: function (a) { this.min.min(a); this.max.max(a); return this }, expandByVector: function (a) { this.min.sub(a); this.max.add(a); return this }, expandByScalar: function (a) { this.min.addScalar(-a); this.max.addScalar(a); return this }, expandByObject: function () {
						function a(a) {
							var f = a.geometry; if (void 0 !== f) if (f.isGeometry) for (f = f.vertices, c = 0, d = f.length; c < d; c++)e.copy(f[c]),
								e.applyMatrix4(a.matrixWorld), b.expandByPoint(e); else if (f.isBufferGeometry && (f = f.attributes.position, void 0 !== f)) for (c = 0, d = f.count; c < d; c++)e.fromBufferAttribute(f, c).applyMatrix4(a.matrixWorld), b.expandByPoint(e)
						} var b, c, d, e = new p; return function (c) { b = this; c.updateMatrixWorld(!0); c.traverse(a); return this }
					}(), containsPoint: function (a) { return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z ? !1 : !0 }, containsBox: function (a) {
						return this.min.x <= a.min.x && a.max.x <=
							this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z
					}, getParameter: function (a, b) { return (b || new p).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z)) }, intersectsBox: function (a) { return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z ? !1 : !0 }, intersectsSphere: function () {
						var a = new p; return function (b) {
							this.clampPoint(b.center,
								a); return a.distanceToSquared(b.center) <= b.radius * b.radius
						}
					}(), intersectsPlane: function (a) { if (0 < a.normal.x) { var b = a.normal.x * this.min.x; var c = a.normal.x * this.max.x } else b = a.normal.x * this.max.x, c = a.normal.x * this.min.x; 0 < a.normal.y ? (b += a.normal.y * this.min.y, c += a.normal.y * this.max.y) : (b += a.normal.y * this.max.y, c += a.normal.y * this.min.y); 0 < a.normal.z ? (b += a.normal.z * this.min.z, c += a.normal.z * this.max.z) : (b += a.normal.z * this.max.z, c += a.normal.z * this.min.z); return b <= a.constant && c >= a.constant }, clampPoint: function (a,
						b) { return (b || new p).copy(a).clamp(this.min, this.max) }, distanceToPoint: function () { var a = new p; return function (b) { return a.copy(b).clamp(this.min, this.max).sub(b).length() } }(), getBoundingSphere: function () { var a = new p; return function (b) { b = b || new Da; this.getCenter(b.center); b.radius = .5 * this.getSize(a).length(); return b } }(), intersect: function (a) { this.min.max(a.min); this.max.min(a.max); this.isEmpty() && this.makeEmpty(); return this }, union: function (a) { this.min.min(a.min); this.max.max(a.max); return this }, applyMatrix4: function () {
							var a =
								[new p, new p, new p, new p, new p, new p, new p, new p]; return function (b) {
									if (this.isEmpty()) return this; a[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(b); a[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(b); a[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(b); a[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(b); a[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(b); a[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(b); a[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(b);
									a[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(b); this.setFromPoints(a); return this
								}
						}(), translate: function (a) { this.min.add(a); this.max.add(a); return this }, equals: function (a) { return a.min.equals(this.min) && a.max.equals(this.max) }
				}); Object.assign(Da.prototype, {
					set: function (a, b) { this.center.copy(a); this.radius = b; return this }, setFromPoints: function () {
						var a = new Oa; return function (b, c) {
							var d = this.center; void 0 !== c ? d.copy(c) : a.setFromPoints(b).getCenter(d); for (var e = c = 0, f = b.length; e < f; e++)c = Math.max(c,
								d.distanceToSquared(b[e])); this.radius = Math.sqrt(c); return this
						}
					}(), clone: function () { return (new this.constructor).copy(this) }, copy: function (a) { this.center.copy(a.center); this.radius = a.radius; return this }, empty: function () { return 0 >= this.radius }, containsPoint: function (a) { return a.distanceToSquared(this.center) <= this.radius * this.radius }, distanceToPoint: function (a) { return a.distanceTo(this.center) - this.radius }, intersectsSphere: function (a) {
						var b = this.radius + a.radius; return a.center.distanceToSquared(this.center) <=
							b * b
					}, intersectsBox: function (a) { return a.intersectsSphere(this) }, intersectsPlane: function (a) { return Math.abs(a.distanceToPoint(this.center)) <= this.radius }, clampPoint: function (a, b) { var c = this.center.distanceToSquared(a); b = b || new p; b.copy(a); c > this.radius * this.radius && (b.sub(this.center).normalize(), b.multiplyScalar(this.radius).add(this.center)); return b }, getBoundingBox: function (a) { a = a || new Oa; a.set(this.center, this.center); a.expandByScalar(this.radius); return a }, applyMatrix4: function (a) {
						this.center.applyMatrix4(a);
						this.radius *= a.getMaxScaleOnAxis(); return this
					}, translate: function (a) { this.center.add(a); return this }, equals: function (a) { return a.center.equals(this.center) && a.radius === this.radius }
				}); Object.assign(Aa.prototype, {
					set: function (a, b) { this.normal.copy(a); this.constant = b; return this }, setComponents: function (a, b, c, d) { this.normal.set(a, b, c); this.constant = d; return this }, setFromNormalAndCoplanarPoint: function (a, b) { this.normal.copy(a); this.constant = -b.dot(this.normal); return this }, setFromCoplanarPoints: function () {
						var a =
							new p, b = new p; return function (c, d, e) { d = a.subVectors(e, d).cross(b.subVectors(c, d)).normalize(); this.setFromNormalAndCoplanarPoint(d, c); return this }
					}(), clone: function () { return (new this.constructor).copy(this) }, copy: function (a) { this.normal.copy(a.normal); this.constant = a.constant; return this }, normalize: function () { var a = 1 / this.normal.length(); this.normal.multiplyScalar(a); this.constant *= a; return this }, negate: function () { this.constant *= -1; this.normal.negate(); return this }, distanceToPoint: function (a) {
						return this.normal.dot(a) +
							this.constant
					}, distanceToSphere: function (a) { return this.distanceToPoint(a.center) - a.radius }, projectPoint: function (a, b) { return (b || new p).copy(this.normal).multiplyScalar(-this.distanceToPoint(a)).add(a) }, intersectLine: function () { var a = new p; return function (b, c) { c = c || new p; var d = b.delta(a), e = this.normal.dot(d); if (0 === e) { if (0 === this.distanceToPoint(b.start)) return c.copy(b.start) } else if (e = -(b.start.dot(this.normal) + this.constant) / e, !(0 > e || 1 < e)) return c.copy(d).multiplyScalar(e).add(b.start) } }(), intersectsLine: function (a) {
						var b =
							this.distanceToPoint(a.start); a = this.distanceToPoint(a.end); return 0 > b && 0 < a || 0 > a && 0 < b
					}, intersectsBox: function (a) { return a.intersectsPlane(this) }, intersectsSphere: function (a) { return a.intersectsPlane(this) }, coplanarPoint: function (a) { return (a || new p).copy(this.normal).multiplyScalar(-this.constant) }, applyMatrix4: function () { var a = new p, b = new ra; return function (c, d) { d = d || b.getNormalMatrix(c); c = this.coplanarPoint(a).applyMatrix4(c); d = this.normal.applyMatrix3(d).normalize(); this.constant = -c.dot(d); return this } }(),
					translate: function (a) { this.constant -= a.dot(this.normal); return this }, equals: function (a) { return a.normal.equals(this.normal) && a.constant === this.constant }
				}); Object.assign(ld.prototype, {
					set: function (a, b, c, d, e, f) { var g = this.planes; g[0].copy(a); g[1].copy(b); g[2].copy(c); g[3].copy(d); g[4].copy(e); g[5].copy(f); return this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (a) { for (var b = this.planes, c = 0; 6 > c; c++)b[c].copy(a.planes[c]); return this }, setFromMatrix: function (a) {
						var b = this.planes,
						c = a.elements; a = c[0]; var d = c[1], e = c[2], f = c[3], g = c[4], h = c[5], k = c[6], l = c[7], q = c[8], n = c[9], m = c[10], r = c[11], p = c[12], v = c[13], w = c[14], c = c[15]; b[0].setComponents(f - a, l - g, r - q, c - p).normalize(); b[1].setComponents(f + a, l + g, r + q, c + p).normalize(); b[2].setComponents(f + d, l + h, r + n, c + v).normalize(); b[3].setComponents(f - d, l - h, r - n, c - v).normalize(); b[4].setComponents(f - e, l - k, r - m, c - w).normalize(); b[5].setComponents(f + e, l + k, r + m, c + w).normalize(); return this
					}, intersectsObject: function () {
						var a = new Da; return function (b) {
							var c =
								b.geometry; null === c.boundingSphere && c.computeBoundingSphere(); a.copy(c.boundingSphere).applyMatrix4(b.matrixWorld); return this.intersectsSphere(a)
						}
					}(), intersectsSprite: function () { var a = new Da; return function (b) { a.center.set(0, 0, 0); a.radius = .7071067811865476; a.applyMatrix4(b.matrixWorld); return this.intersectsSphere(a) } }(), intersectsSphere: function (a) { var b = this.planes, c = a.center; a = -a.radius; for (var d = 0; 6 > d; d++)if (b[d].distanceToPoint(c) < a) return !1; return !0 }, intersectsBox: function () {
						var a = new p, b =
							new p; return function (c) { for (var d = this.planes, e = 0; 6 > e; e++) { var f = d[e]; a.x = 0 < f.normal.x ? c.min.x : c.max.x; b.x = 0 < f.normal.x ? c.max.x : c.min.x; a.y = 0 < f.normal.y ? c.min.y : c.max.y; b.y = 0 < f.normal.y ? c.max.y : c.min.y; a.z = 0 < f.normal.z ? c.min.z : c.max.z; b.z = 0 < f.normal.z ? c.max.z : c.min.z; var g = f.distanceToPoint(a), f = f.distanceToPoint(b); if (0 > g && 0 > f) return !1 } return !0 }
					}(), containsPoint: function (a) { for (var b = this.planes, c = 0; 6 > c; c++)if (0 > b[c].distanceToPoint(a)) return !1; return !0 }
				}); Ya.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" ");
	Ya.DefaultOrder = "XYZ"; Object.defineProperties(Ya.prototype, { x: { get: function () { return this._x }, set: function (a) { this._x = a; this.onChangeCallback() } }, y: { get: function () { return this._y }, set: function (a) { this._y = a; this.onChangeCallback() } }, z: { get: function () { return this._z }, set: function (a) { this._z = a; this.onChangeCallback() } }, order: { get: function () { return this._order }, set: function (a) { this._order = a; this.onChangeCallback() } } }); Object.assign(Ya.prototype, {
		isEuler: !0, set: function (a, b, c, d) {
		this._x = a; this._y = b; this._z =
			c; this._order = d || this._order; this.onChangeCallback(); return this
		}, clone: function () { return new this.constructor(this._x, this._y, this._z, this._order) }, copy: function (a) { this._x = a._x; this._y = a._y; this._z = a._z; this._order = a._order; this.onChangeCallback(); return this }, setFromRotationMatrix: function (a, b, c) {
			var d = R.clamp, e = a.elements; a = e[0]; var f = e[4], g = e[8], h = e[1], k = e[5], l = e[9], q = e[2], n = e[6], e = e[10]; b = b || this._order; "XYZ" === b ? (this._y = Math.asin(d(g, -1, 1)), .99999 > Math.abs(g) ? (this._x = Math.atan2(-l, e), this._z =
				Math.atan2(-f, a)) : (this._x = Math.atan2(n, k), this._z = 0)) : "YXZ" === b ? (this._x = Math.asin(-d(l, -1, 1)), .99999 > Math.abs(l) ? (this._y = Math.atan2(g, e), this._z = Math.atan2(h, k)) : (this._y = Math.atan2(-q, a), this._z = 0)) : "ZXY" === b ? (this._x = Math.asin(d(n, -1, 1)), .99999 > Math.abs(n) ? (this._y = Math.atan2(-q, e), this._z = Math.atan2(-f, k)) : (this._y = 0, this._z = Math.atan2(h, a))) : "ZYX" === b ? (this._y = Math.asin(-d(q, -1, 1)), .99999 > Math.abs(q) ? (this._x = Math.atan2(n, e), this._z = Math.atan2(h, a)) : (this._x = 0, this._z = Math.atan2(-f, k))) : "YZX" ===
					b ? (this._z = Math.asin(d(h, -1, 1)), .99999 > Math.abs(h) ? (this._x = Math.atan2(-l, k), this._y = Math.atan2(-q, a)) : (this._x = 0, this._y = Math.atan2(g, e))) : "XZY" === b ? (this._z = Math.asin(-d(f, -1, 1)), .99999 > Math.abs(f) ? (this._x = Math.atan2(n, k), this._y = Math.atan2(g, a)) : (this._x = Math.atan2(-l, e), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + b); this._order = b; if (!1 !== c) this.onChangeCallback(); return this
		}, setFromQuaternion: function () {
			var a = new K; return function (b, c, d) {
				a.makeRotationFromQuaternion(b);
				return this.setFromRotationMatrix(a, c, d)
			}
		}(), setFromVector3: function (a, b) { return this.set(a.x, a.y, a.z, b || this._order) }, reorder: function () { var a = new Z; return function (b) { a.setFromEuler(this); return this.setFromQuaternion(a, b) } }(), equals: function (a) { return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order }, fromArray: function (a) { this._x = a[0]; this._y = a[1]; this._z = a[2]; void 0 !== a[3] && (this._order = a[3]); this.onChangeCallback(); return this }, toArray: function (a, b) {
		void 0 === a && (a = []); void 0 ===
			b && (b = 0); a[b] = this._x; a[b + 1] = this._y; a[b + 2] = this._z; a[b + 3] = this._order; return a
		}, toVector3: function (a) { return a ? a.set(this._x, this._y, this._z) : new p(this._x, this._y, this._z) }, onChange: function (a) { this.onChangeCallback = a; return this }, onChangeCallback: function () { }
	}); Object.assign(Pd.prototype, { set: function (a) { this.mask = 1 << a | 0 }, enable: function (a) { this.mask = this.mask | 1 << a | 0 }, toggle: function (a) { this.mask ^= 1 << a | 0 }, disable: function (a) { this.mask &= ~(1 << a | 0) }, test: function (a) { return 0 !== (this.mask & a.mask) } });
	var Nf = 0; A.DefaultUp = new p(0, 1, 0); A.DefaultMatrixAutoUpdate = !0; Object.assign(A.prototype, ja.prototype, {
		isObject3D: !0, onBeforeRender: function () { }, onAfterRender: function () { }, applyMatrix: function (a) { this.matrix.multiplyMatrices(a, this.matrix); this.matrix.decompose(this.position, this.quaternion, this.scale) }, applyQuaternion: function (a) { this.quaternion.premultiply(a); return this }, setRotationFromAxisAngle: function (a, b) { this.quaternion.setFromAxisAngle(a, b) }, setRotationFromEuler: function (a) {
			this.quaternion.setFromEuler(a,
				!0)
		}, setRotationFromMatrix: function (a) { this.quaternion.setFromRotationMatrix(a) }, setRotationFromQuaternion: function (a) { this.quaternion.copy(a) }, rotateOnAxis: function () { var a = new Z; return function (b, c) { a.setFromAxisAngle(b, c); this.quaternion.multiply(a); return this } }(), rotateOnWorldAxis: function () { var a = new Z; return function (b, c) { a.setFromAxisAngle(b, c); this.quaternion.premultiply(a); return this } }(), rotateX: function () { var a = new p(1, 0, 0); return function (b) { return this.rotateOnAxis(a, b) } }(), rotateY: function () {
			var a =
				new p(0, 1, 0); return function (b) { return this.rotateOnAxis(a, b) }
		}(), rotateZ: function () { var a = new p(0, 0, 1); return function (b) { return this.rotateOnAxis(a, b) } }(), translateOnAxis: function () { var a = new p; return function (b, c) { a.copy(b).applyQuaternion(this.quaternion); this.position.add(a.multiplyScalar(c)); return this } }(), translateX: function () { var a = new p(1, 0, 0); return function (b) { return this.translateOnAxis(a, b) } }(), translateY: function () {
			var a = new p(0, 1, 0); return function (b) {
				return this.translateOnAxis(a,
					b)
			}
		}(), translateZ: function () { var a = new p(0, 0, 1); return function (b) { return this.translateOnAxis(a, b) } }(), localToWorld: function (a) { return a.applyMatrix4(this.matrixWorld) }, worldToLocal: function () { var a = new K; return function (b) { return b.applyMatrix4(a.getInverse(this.matrixWorld)) } }(), lookAt: function () { var a = new K, b = new p; return function (c, d, e) { c.isVector3 ? b.copy(c) : b.set(c, d, e); this.isCamera ? a.lookAt(this.position, b, this.up) : a.lookAt(b, this.position, this.up); this.quaternion.setFromRotationMatrix(a) } }(),
		add: function (a) { if (1 < arguments.length) { for (var b = 0; b < arguments.length; b++)this.add(arguments[b]); return this } if (a === this) return console.error("THREE.Object3D.add: object can't be added as a child of itself.", a), this; a && a.isObject3D ? (null !== a.parent && a.parent.remove(a), a.parent = this, a.dispatchEvent({ type: "added" }), this.children.push(a)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", a); return this }, remove: function (a) {
			if (1 < arguments.length) {
				for (var b = 0; b < arguments.length; b++)this.remove(arguments[b]);
				return this
			} b = this.children.indexOf(a); -1 !== b && (a.parent = null, a.dispatchEvent({ type: "removed" }), this.children.splice(b, 1)); return this
		}, getObjectById: function (a) { return this.getObjectByProperty("id", a) }, getObjectByName: function (a) { return this.getObjectByProperty("name", a) }, getObjectByProperty: function (a, b) { if (this[a] === b) return this; for (var c = 0, d = this.children.length; c < d; c++) { var e = this.children[c].getObjectByProperty(a, b); if (void 0 !== e) return e } }, getWorldPosition: function (a) {
			a = a || new p; this.updateMatrixWorld(!0);
			return a.setFromMatrixPosition(this.matrixWorld)
		}, getWorldQuaternion: function () { var a = new p, b = new p; return function (c) { c = c || new Z; this.updateMatrixWorld(!0); this.matrixWorld.decompose(a, c, b); return c } }(), getWorldRotation: function () { var a = new Z; return function (b) { b = b || new Ya; this.getWorldQuaternion(a); return b.setFromQuaternion(a, this.rotation.order, !1) } }(), getWorldScale: function () { var a = new p, b = new Z; return function (c) { c = c || new p; this.updateMatrixWorld(!0); this.matrixWorld.decompose(a, b, c); return c } }(),
		getWorldDirection: function () { var a = new Z; return function (b) { b = b || new p; this.getWorldQuaternion(a); return b.set(0, 0, 1).applyQuaternion(a) } }(), raycast: function () { }, traverse: function (a) { a(this); for (var b = this.children, c = 0, d = b.length; c < d; c++)b[c].traverse(a) }, traverseVisible: function (a) { if (!1 !== this.visible) { a(this); for (var b = this.children, c = 0, d = b.length; c < d; c++)b[c].traverseVisible(a) } }, traverseAncestors: function (a) { var b = this.parent; null !== b && (a(b), b.traverseAncestors(a)) }, updateMatrix: function () {
			this.matrix.compose(this.position,
				this.quaternion, this.scale); this.matrixWorldNeedsUpdate = !0
		}, updateMatrixWorld: function (a) { this.matrixAutoUpdate && this.updateMatrix(); if (this.matrixWorldNeedsUpdate || a) null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0; for (var b = this.children, c = 0, d = b.length; c < d; c++)b[c].updateMatrixWorld(a) }, toJSON: function (a) {
			function b(b, c) { void 0 === b[c.uuid] && (b[c.uuid] = c.toJSON(a)); return c.uuid } function c(a) {
				var b =
					[], c; for (c in a) { var d = a[c]; delete d.metadata; b.push(d) } return b
			} var d = void 0 === a || "string" === typeof a, e = {}; d && (a = { geometries: {}, materials: {}, textures: {}, images: {} }, e.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" }); var f = {}; f.uuid = this.uuid; f.type = this.type; "" !== this.name && (f.name = this.name); !0 === this.castShadow && (f.castShadow = !0); !0 === this.receiveShadow && (f.receiveShadow = !0); !1 === this.visible && (f.visible = !1); "{}" !== JSON.stringify(this.userData) && (f.userData = this.userData); f.matrix =
				this.matrix.toArray(); void 0 !== this.geometry && (f.geometry = b(a.geometries, this.geometry)); if (void 0 !== this.material) if (Array.isArray(this.material)) { for (var g = [], h = 0, k = this.material.length; h < k; h++)g.push(b(a.materials, this.material[h])); f.material = g } else f.material = b(a.materials, this.material); if (0 < this.children.length) for (f.children = [], h = 0; h < this.children.length; h++)f.children.push(this.children[h].toJSON(a).object); d && (d = c(a.geometries), g = c(a.materials), h = c(a.textures), k = c(a.images), 0 < d.length &&
					(e.geometries = d), 0 < g.length && (e.materials = g), 0 < h.length && (e.textures = h), 0 < k.length && (e.images = k)); e.object = f; return e
		}, clone: function (a) { return (new this.constructor).copy(this, a) }, copy: function (a, b) {
		void 0 === b && (b = !0); this.name = a.name; this.up.copy(a.up); this.position.copy(a.position); this.quaternion.copy(a.quaternion); this.scale.copy(a.scale); this.matrix.copy(a.matrix); this.matrixWorld.copy(a.matrixWorld); this.matrixAutoUpdate = a.matrixAutoUpdate; this.matrixWorldNeedsUpdate = a.matrixWorldNeedsUpdate;
			this.layers.mask = a.layers.mask; this.visible = a.visible; this.castShadow = a.castShadow; this.receiveShadow = a.receiveShadow; this.frustumCulled = a.frustumCulled; this.renderOrder = a.renderOrder; this.userData = JSON.parse(JSON.stringify(a.userData)); if (!0 === b) for (b = 0; b < a.children.length; b++)this.add(a.children[b].clone()); return this
		}
	}); La.prototype = Object.assign(Object.create(A.prototype), {
		constructor: La, isCamera: !0, copy: function (a, b) {
			A.prototype.copy.call(this, a, b); this.matrixWorldInverse.copy(a.matrixWorldInverse);
			this.projectionMatrix.copy(a.projectionMatrix); return this
		}, getWorldDirection: function () { var a = new Z; return function (b) { b = b || new p; this.getWorldQuaternion(a); return b.set(0, 0, -1).applyQuaternion(a) } }(), updateMatrixWorld: function (a) { A.prototype.updateMatrixWorld.call(this, a); this.matrixWorldInverse.getInverse(this.matrixWorld) }, clone: function () { return (new this.constructor).copy(this) }
	}); Kb.prototype = Object.assign(Object.create(La.prototype), {
		constructor: Kb, isOrthographicCamera: !0, copy: function (a, b) {
			La.prototype.copy.call(this,
				a, b); this.left = a.left; this.right = a.right; this.top = a.top; this.bottom = a.bottom; this.near = a.near; this.far = a.far; this.zoom = a.zoom; this.view = null === a.view ? null : Object.assign({}, a.view); return this
		}, setViewOffset: function (a, b, c, d, e, f) { null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }); this.view.enabled = !0; this.view.fullWidth = a; this.view.fullHeight = b; this.view.offsetX = c; this.view.offsetY = d; this.view.width = e; this.view.height = f; this.updateProjectionMatrix() },
		clearViewOffset: function () { null !== this.view && (this.view.enabled = !1); this.updateProjectionMatrix() }, updateProjectionMatrix: function () {
			var a = (this.right - this.left) / (2 * this.zoom), b = (this.top - this.bottom) / (2 * this.zoom), c = (this.right + this.left) / 2, d = (this.top + this.bottom) / 2, e = c - a, c = c + a, a = d + b, b = d - b; if (null !== this.view && this.view.enabled) var c = this.zoom / (this.view.width / this.view.fullWidth), b = this.zoom / (this.view.height / this.view.fullHeight), f = (this.right - this.left) / this.view.width, d = (this.top - this.bottom) /
				this.view.height, e = e + this.view.offsetX / c * f, c = e + this.view.width / c * f, a = a - this.view.offsetY / b * d, b = a - this.view.height / b * d; this.projectionMatrix.makeOrthographic(e, c, a, b, this.near, this.far)
		}, toJSON: function (a) { a = A.prototype.toJSON.call(this, a); a.object.zoom = this.zoom; a.object.left = this.left; a.object.right = this.right; a.object.top = this.top; a.object.bottom = this.bottom; a.object.near = this.near; a.object.far = this.far; null !== this.view && (a.object.view = Object.assign({}, this.view)); return a }
	}); Object.assign(Pa.prototype,
		{ clone: function () { return (new this.constructor).copy(this) }, copy: function (a) { this.a = a.a; this.b = a.b; this.c = a.c; this.normal.copy(a.normal); this.color.copy(a.color); this.materialIndex = a.materialIndex; for (var b = 0, c = a.vertexNormals.length; b < c; b++)this.vertexNormals[b] = a.vertexNormals[b].clone(); b = 0; for (c = a.vertexColors.length; b < c; b++)this.vertexColors[b] = a.vertexColors[b].clone(); return this } }); var Of = 0; Object.assign(N.prototype, ja.prototype, {
			isGeometry: !0, applyMatrix: function (a) {
				for (var b = (new ra).getNormalMatrix(a),
					c = 0, d = this.vertices.length; c < d; c++)this.vertices[c].applyMatrix4(a); c = 0; for (d = this.faces.length; c < d; c++) { a = this.faces[c]; a.normal.applyMatrix3(b).normalize(); for (var e = 0, f = a.vertexNormals.length; e < f; e++)a.vertexNormals[e].applyMatrix3(b).normalize() } null !== this.boundingBox && this.computeBoundingBox(); null !== this.boundingSphere && this.computeBoundingSphere(); this.normalsNeedUpdate = this.verticesNeedUpdate = !0; return this
			}, rotateX: function () {
				var a = new K; return function (b) {
					a.makeRotationX(b); this.applyMatrix(a);
					return this
				}
			}(), rotateY: function () { var a = new K; return function (b) { a.makeRotationY(b); this.applyMatrix(a); return this } }(), rotateZ: function () { var a = new K; return function (b) { a.makeRotationZ(b); this.applyMatrix(a); return this } }(), translate: function () { var a = new K; return function (b, c, d) { a.makeTranslation(b, c, d); this.applyMatrix(a); return this } }(), scale: function () { var a = new K; return function (b, c, d) { a.makeScale(b, c, d); this.applyMatrix(a); return this } }(), lookAt: function () {
				var a = new A; return function (b) {
					a.lookAt(b);
					a.updateMatrix(); this.applyMatrix(a.matrix)
				}
			}(), fromBufferGeometry: function (a) {
				function b(a, b, d, e) { var f = void 0 !== g ? [q[a].clone(), q[b].clone(), q[d].clone()] : [], t = void 0 !== h ? [c.colors[a].clone(), c.colors[b].clone(), c.colors[d].clone()] : []; e = new Pa(a, b, d, f, t, e); c.faces.push(e); void 0 !== k && c.faceVertexUvs[0].push([n[a].clone(), n[b].clone(), n[d].clone()]); void 0 !== l && c.faceVertexUvs[1].push([m[a].clone(), m[b].clone(), m[d].clone()]) } var c = this, d = null !== a.index ? a.index.array : void 0, e = a.attributes, f = e.position.array,
					g = void 0 !== e.normal ? e.normal.array : void 0, h = void 0 !== e.color ? e.color.array : void 0, k = void 0 !== e.uv ? e.uv.array : void 0, l = void 0 !== e.uv2 ? e.uv2.array : void 0; void 0 !== l && (this.faceVertexUvs[1] = []); for (var q = [], n = [], m = [], r = e = 0; e < f.length; e += 3, r += 2)c.vertices.push(new p(f[e], f[e + 1], f[e + 2])), void 0 !== g && q.push(new p(g[e], g[e + 1], g[e + 2])), void 0 !== h && c.colors.push(new H(h[e], h[e + 1], h[e + 2])), void 0 !== k && n.push(new C(k[r], k[r + 1])), void 0 !== l && m.push(new C(l[r], l[r + 1])); var u = a.groups; if (0 < u.length) for (e = 0; e < u.length; e++)for (var f =
						u[e], v = f.start, w = f.count, r = v, v = v + w; r < v; r += 3)void 0 !== d ? b(d[r], d[r + 1], d[r + 2], f.materialIndex) : b(r, r + 1, r + 2, f.materialIndex); else if (void 0 !== d) for (e = 0; e < d.length; e += 3)b(d[e], d[e + 1], d[e + 2]); else for (e = 0; e < f.length / 3; e += 3)b(e, e + 1, e + 2); this.computeFaceNormals(); null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone()); null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone()); return this
			}, center: function () {
				this.computeBoundingBox(); var a = this.boundingBox.getCenter().negate(); this.translate(a.x,
					a.y, a.z); return a
			}, normalize: function () { this.computeBoundingSphere(); var a = this.boundingSphere.center, b = this.boundingSphere.radius, b = 0 === b ? 1 : 1 / b, c = new K; c.set(b, 0, 0, -b * a.x, 0, b, 0, -b * a.y, 0, 0, b, -b * a.z, 0, 0, 0, 1); this.applyMatrix(c); return this }, computeFaceNormals: function () { for (var a = new p, b = new p, c = 0, d = this.faces.length; c < d; c++) { var e = this.faces[c], f = this.vertices[e.a], g = this.vertices[e.b]; a.subVectors(this.vertices[e.c], g); b.subVectors(f, g); a.cross(b); a.normalize(); e.normal.copy(a) } }, computeVertexNormals: function (a) {
			void 0 ===
				a && (a = !0); var b; var c = Array(this.vertices.length); var d = 0; for (b = this.vertices.length; d < b; d++)c[d] = new p; if (a) { var e = new p, f = new p; a = 0; for (d = this.faces.length; a < d; a++) { b = this.faces[a]; var g = this.vertices[b.a]; var h = this.vertices[b.b]; var k = this.vertices[b.c]; e.subVectors(k, h); f.subVectors(g, h); e.cross(f); c[b.a].add(e); c[b.b].add(e); c[b.c].add(e) } } else for (this.computeFaceNormals(), a = 0, d = this.faces.length; a < d; a++)b = this.faces[a], c[b.a].add(b.normal), c[b.b].add(b.normal), c[b.c].add(b.normal); d = 0; for (b =
					this.vertices.length; d < b; d++)c[d].normalize(); a = 0; for (d = this.faces.length; a < d; a++)b = this.faces[a], g = b.vertexNormals, 3 === g.length ? (g[0].copy(c[b.a]), g[1].copy(c[b.b]), g[2].copy(c[b.c])) : (g[0] = c[b.a].clone(), g[1] = c[b.b].clone(), g[2] = c[b.c].clone()); 0 < this.faces.length && (this.normalsNeedUpdate = !0)
			}, computeFlatVertexNormals: function () {
				var a; this.computeFaceNormals(); var b = 0; for (a = this.faces.length; b < a; b++) {
					var c = this.faces[b]; var d = c.vertexNormals; 3 === d.length ? (d[0].copy(c.normal), d[1].copy(c.normal),
						d[2].copy(c.normal)) : (d[0] = c.normal.clone(), d[1] = c.normal.clone(), d[2] = c.normal.clone())
				} 0 < this.faces.length && (this.normalsNeedUpdate = !0)
			}, computeMorphNormals: function () {
				var a, b; var c = 0; for (b = this.faces.length; c < b; c++) {
					var d = this.faces[c]; d.__originalFaceNormal ? d.__originalFaceNormal.copy(d.normal) : d.__originalFaceNormal = d.normal.clone(); d.__originalVertexNormals || (d.__originalVertexNormals = []); var e = 0; for (a = d.vertexNormals.length; e < a; e++)d.__originalVertexNormals[e] ? d.__originalVertexNormals[e].copy(d.vertexNormals[e]) :
						d.__originalVertexNormals[e] = d.vertexNormals[e].clone()
				} var f = new N; f.faces = this.faces; e = 0; for (a = this.morphTargets.length; e < a; e++) {
					if (!this.morphNormals[e]) { this.morphNormals[e] = {}; this.morphNormals[e].faceNormals = []; this.morphNormals[e].vertexNormals = []; d = this.morphNormals[e].faceNormals; var g = this.morphNormals[e].vertexNormals; c = 0; for (b = this.faces.length; c < b; c++) { var h = new p; var k = { a: new p, b: new p, c: new p }; d.push(h); g.push(k) } } g = this.morphNormals[e]; f.vertices = this.morphTargets[e].vertices; f.computeFaceNormals();
					f.computeVertexNormals(); c = 0; for (b = this.faces.length; c < b; c++)d = this.faces[c], h = g.faceNormals[c], k = g.vertexNormals[c], h.copy(d.normal), k.a.copy(d.vertexNormals[0]), k.b.copy(d.vertexNormals[1]), k.c.copy(d.vertexNormals[2])
				} c = 0; for (b = this.faces.length; c < b; c++)d = this.faces[c], d.normal = d.__originalFaceNormal, d.vertexNormals = d.__originalVertexNormals
			}, computeLineDistances: function () { for (var a = 0, b = this.vertices, c = 0, d = b.length; c < d; c++)0 < c && (a += b[c].distanceTo(b[c - 1])), this.lineDistances[c] = a }, computeBoundingBox: function () {
			null ===
				this.boundingBox && (this.boundingBox = new Oa); this.boundingBox.setFromPoints(this.vertices)
			}, computeBoundingSphere: function () { null === this.boundingSphere && (this.boundingSphere = new Da); this.boundingSphere.setFromPoints(this.vertices) }, merge: function (a, b, c) {
				if (a && a.isGeometry) {
					var d, e = this.vertices.length, f = this.vertices, g = a.vertices, h = this.faces, k = a.faces, l = this.faceVertexUvs[0], q = a.faceVertexUvs[0], n = this.colors, m = a.colors; void 0 === c && (c = 0); void 0 !== b && (d = (new ra).getNormalMatrix(b)); a = 0; for (var r = g.length; a <
						r; a++) { var p = g[a].clone(); void 0 !== b && p.applyMatrix4(b); f.push(p) } a = 0; for (r = m.length; a < r; a++)n.push(m[a].clone()); a = 0; for (r = k.length; a < r; a++) {
							var g = k[a], v = g.vertexNormals, m = g.vertexColors, n = new Pa(g.a + e, g.b + e, g.c + e); n.normal.copy(g.normal); void 0 !== d && n.normal.applyMatrix3(d).normalize(); b = 0; for (f = v.length; b < f; b++)p = v[b].clone(), void 0 !== d && p.applyMatrix3(d).normalize(), n.vertexNormals.push(p); n.color.copy(g.color); b = 0; for (f = m.length; b < f; b++)p = m[b], n.vertexColors.push(p.clone()); n.materialIndex = g.materialIndex +
								c; h.push(n)
						} a = 0; for (r = q.length; a < r; a++)if (c = q[a], d = [], void 0 !== c) { b = 0; for (f = c.length; b < f; b++)d.push(c[b].clone()); l.push(d) }
				} else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", a)
			}, mergeMesh: function (a) { a && a.isMesh ? (a.matrixAutoUpdate && a.updateMatrix(), this.merge(a.geometry, a.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", a) }, mergeVertices: function () {
				var a = {}, b = [], c = [], d = Math.pow(10, 4), e; var f = 0; for (e = this.vertices.length; f <
					e; f++) { var g = this.vertices[f]; g = Math.round(g.x * d) + "_" + Math.round(g.y * d) + "_" + Math.round(g.z * d); void 0 === a[g] ? (a[g] = f, b.push(this.vertices[f]), c[f] = b.length - 1) : c[f] = c[a[g]] } a = []; f = 0; for (e = this.faces.length; f < e; f++)for (d = this.faces[f], d.a = c[d.a], d.b = c[d.b], d.c = c[d.c], d = [d.a, d.b, d.c], g = 0; 3 > g; g++)if (d[g] === d[(g + 1) % 3]) { a.push(f); break } for (f = a.length - 1; 0 <= f; f--)for (d = a[f], this.faces.splice(d, 1), c = 0, e = this.faceVertexUvs.length; c < e; c++)this.faceVertexUvs[c].splice(d, 1); f = this.vertices.length - b.length; this.vertices =
						b; return f
			}, setFromPoints: function (a) { this.vertices = []; for (var b = 0, c = a.length; b < c; b++) { var d = a[b]; this.vertices.push(new p(d.x, d.y, d.z || 0)) } return this }, sortFacesByMaterialIndex: function () {
				for (var a = this.faces, b = a.length, c = 0; c < b; c++)a[c]._id = c; a.sort(function (a, b) { return a.materialIndex - b.materialIndex }); var d = this.faceVertexUvs[0], e = this.faceVertexUvs[1], f, g; d && d.length === b && (f = []); e && e.length === b && (g = []); for (c = 0; c < b; c++) { var h = a[c]._id; f && f.push(d[h]); g && g.push(e[h]) } f && (this.faceVertexUvs[0] = f);
				g && (this.faceVertexUvs[1] = g)
			}, toJSON: function () {
				function a(a, b, c) { return c ? a | 1 << b : a & ~(1 << b) } function b(a) { var b = a.x.toString() + a.y.toString() + a.z.toString(); if (void 0 !== l[b]) return l[b]; l[b] = k.length / 3; k.push(a.x, a.y, a.z); return l[b] } function c(a) { var b = a.r.toString() + a.g.toString() + a.b.toString(); if (void 0 !== n[b]) return n[b]; n[b] = q.length; q.push(a.getHex()); return n[b] } function d(a) { var b = a.x.toString() + a.y.toString(); if (void 0 !== p[b]) return p[b]; p[b] = m.length / 2; m.push(a.x, a.y); return p[b] } var e =
					{ metadata: { version: 4.5, type: "Geometry", generator: "Geometry.toJSON" } }; e.uuid = this.uuid; e.type = this.type; "" !== this.name && (e.name = this.name); if (void 0 !== this.parameters) { var f = this.parameters, g; for (g in f) void 0 !== f[g] && (e[g] = f[g]); return e } f = []; for (g = 0; g < this.vertices.length; g++) { var h = this.vertices[g]; f.push(h.x, h.y, h.z) } var h = [], k = [], l = {}, q = [], n = {}, m = [], p = {}; for (g = 0; g < this.faces.length; g++) {
						var u = this.faces[g], v = void 0 !== this.faceVertexUvs[0][g], w = 0 < u.normal.length(), x = 0 < u.vertexNormals.length, z =
							1 !== u.color.r || 1 !== u.color.g || 1 !== u.color.b, I = 0 < u.vertexColors.length, B = 0, B = a(B, 0, 0), B = a(B, 1, !0), B = a(B, 2, !1), B = a(B, 3, v), B = a(B, 4, w), B = a(B, 5, x), B = a(B, 6, z), B = a(B, 7, I); h.push(B); h.push(u.a, u.b, u.c); h.push(u.materialIndex); v && (v = this.faceVertexUvs[0][g], h.push(d(v[0]), d(v[1]), d(v[2]))); w && h.push(b(u.normal)); x && (w = u.vertexNormals, h.push(b(w[0]), b(w[1]), b(w[2]))); z && h.push(c(u.color)); I && (u = u.vertexColors, h.push(c(u[0]), c(u[1]), c(u[2])))
					} e.data = {}; e.data.vertices = f; e.data.normals = k; 0 < q.length && (e.data.colors =
						q); 0 < m.length && (e.data.uvs = [m]); e.data.faces = h; return e
			}, clone: function () { return (new N).copy(this) }, copy: function (a) {
				var b, c, d; this.vertices = []; this.colors = []; this.faces = []; this.faceVertexUvs = [[]]; this.morphTargets = []; this.morphNormals = []; this.skinWeights = []; this.skinIndices = []; this.lineDistances = []; this.boundingSphere = this.boundingBox = null; this.name = a.name; var e = a.vertices; var f = 0; for (b = e.length; f < b; f++)this.vertices.push(e[f].clone()); e = a.colors; f = 0; for (b = e.length; f < b; f++)this.colors.push(e[f].clone());
				e = a.faces; f = 0; for (b = e.length; f < b; f++)this.faces.push(e[f].clone()); f = 0; for (b = a.faceVertexUvs.length; f < b; f++) { var g = a.faceVertexUvs[f]; void 0 === this.faceVertexUvs[f] && (this.faceVertexUvs[f] = []); e = 0; for (c = g.length; e < c; e++) { var h = g[e], k = []; var l = 0; for (d = h.length; l < d; l++)k.push(h[l].clone()); this.faceVertexUvs[f].push(k) } } l = a.morphTargets; f = 0; for (b = l.length; f < b; f++) {
					d = {}; d.name = l[f].name; if (void 0 !== l[f].vertices) for (d.vertices = [], e = 0, c = l[f].vertices.length; e < c; e++)d.vertices.push(l[f].vertices[e].clone());
					if (void 0 !== l[f].normals) for (d.normals = [], e = 0, c = l[f].normals.length; e < c; e++)d.normals.push(l[f].normals[e].clone()); this.morphTargets.push(d)
				} l = a.morphNormals; f = 0; for (b = l.length; f < b; f++) {
					d = {}; if (void 0 !== l[f].vertexNormals) for (d.vertexNormals = [], e = 0, c = l[f].vertexNormals.length; e < c; e++)g = l[f].vertexNormals[e], h = {}, h.a = g.a.clone(), h.b = g.b.clone(), h.c = g.c.clone(), d.vertexNormals.push(h); if (void 0 !== l[f].faceNormals) for (d.faceNormals = [], e = 0, c = l[f].faceNormals.length; e < c; e++)d.faceNormals.push(l[f].faceNormals[e].clone());
					this.morphNormals.push(d)
				} e = a.skinWeights; f = 0; for (b = e.length; f < b; f++)this.skinWeights.push(e[f].clone()); e = a.skinIndices; f = 0; for (b = e.length; f < b; f++)this.skinIndices.push(e[f].clone()); e = a.lineDistances; f = 0; for (b = e.length; f < b; f++)this.lineDistances.push(e[f]); f = a.boundingBox; null !== f && (this.boundingBox = f.clone()); f = a.boundingSphere; null !== f && (this.boundingSphere = f.clone()); this.elementsNeedUpdate = a.elementsNeedUpdate; this.verticesNeedUpdate = a.verticesNeedUpdate; this.uvsNeedUpdate = a.uvsNeedUpdate; this.normalsNeedUpdate =
					a.normalsNeedUpdate; this.colorsNeedUpdate = a.colorsNeedUpdate; this.lineDistancesNeedUpdate = a.lineDistancesNeedUpdate; this.groupsNeedUpdate = a.groupsNeedUpdate; return this
			}, dispose: function () { this.dispatchEvent({ type: "dispose" }) }
		}); Object.defineProperty(P.prototype, "needsUpdate", { set: function (a) { !0 === a && this.version++ } }); Object.assign(P.prototype, {
			isBufferAttribute: !0, setArray: function (a) {
				if (Array.isArray(a)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.count = void 0 !==
					a ? a.length / this.itemSize : 0; this.array = a
			}, setDynamic: function (a) { this.dynamic = a; return this }, copy: function (a) { this.array = new a.array.constructor(a.array); this.itemSize = a.itemSize; this.count = a.count; this.normalized = a.normalized; this.dynamic = a.dynamic; return this }, copyAt: function (a, b, c) { a *= this.itemSize; c *= b.itemSize; for (var d = 0, e = this.itemSize; d < e; d++)this.array[a + d] = b.array[c + d]; return this }, copyArray: function (a) { this.array.set(a); return this }, copyColorsArray: function (a) {
				for (var b = this.array, c = 0, d =
					0, e = a.length; d < e; d++) { var f = a[d]; void 0 === f && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", d), f = new H); b[c++] = f.r; b[c++] = f.g; b[c++] = f.b } return this
			}, copyIndicesArray: function (a) { for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) { var f = a[d]; b[c++] = f.a; b[c++] = f.b; b[c++] = f.c } return this }, copyVector2sArray: function (a) {
				for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
					var f = a[d]; void 0 === f && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", d), f = new C);
					b[c++] = f.x; b[c++] = f.y
				} return this
			}, copyVector3sArray: function (a) { for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) { var f = a[d]; void 0 === f && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", d), f = new p); b[c++] = f.x; b[c++] = f.y; b[c++] = f.z } return this }, copyVector4sArray: function (a) {
				for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
					var f = a[d]; void 0 === f && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", d), f = new da); b[c++] = f.x; b[c++] = f.y; b[c++] = f.z;
					b[c++] = f.w
				} return this
			}, set: function (a, b) { void 0 === b && (b = 0); this.array.set(a, b); return this }, getX: function (a) { return this.array[a * this.itemSize] }, setX: function (a, b) { this.array[a * this.itemSize] = b; return this }, getY: function (a) { return this.array[a * this.itemSize + 1] }, setY: function (a, b) { this.array[a * this.itemSize + 1] = b; return this }, getZ: function (a) { return this.array[a * this.itemSize + 2] }, setZ: function (a, b) { this.array[a * this.itemSize + 2] = b; return this }, getW: function (a) { return this.array[a * this.itemSize + 3] },
			setW: function (a, b) { this.array[a * this.itemSize + 3] = b; return this }, setXY: function (a, b, c) { a *= this.itemSize; this.array[a + 0] = b; this.array[a + 1] = c; return this }, setXYZ: function (a, b, c, d) { a *= this.itemSize; this.array[a + 0] = b; this.array[a + 1] = c; this.array[a + 2] = d; return this }, setXYZW: function (a, b, c, d, e) { a *= this.itemSize; this.array[a + 0] = b; this.array[a + 1] = c; this.array[a + 2] = d; this.array[a + 3] = e; return this }, onUpload: function (a) { this.onUploadCallback = a; return this }, clone: function () {
				return (new this.constructor(this.array,
					this.itemSize)).copy(this)
			}
		}); uc.prototype = Object.create(P.prototype); uc.prototype.constructor = uc; vc.prototype = Object.create(P.prototype); vc.prototype.constructor = vc; wc.prototype = Object.create(P.prototype); wc.prototype.constructor = wc; xc.prototype = Object.create(P.prototype); xc.prototype.constructor = xc; hb.prototype = Object.create(P.prototype); hb.prototype.constructor = hb; yc.prototype = Object.create(P.prototype); yc.prototype.constructor = yc; ib.prototype = Object.create(P.prototype); ib.prototype.constructor =
			ib; y.prototype = Object.create(P.prototype); y.prototype.constructor = y; zc.prototype = Object.create(P.prototype); zc.prototype.constructor = zc; Object.assign(Je.prototype, {
				computeGroups: function (a) { var b = [], c = void 0; a = a.faces; for (var d = 0; d < a.length; d++) { var e = a[d]; if (e.materialIndex !== c) { c = e.materialIndex; void 0 !== f && (f.count = 3 * d - f.start, b.push(f)); var f = { start: 3 * d, materialIndex: c } } } void 0 !== f && (f.count = 3 * d - f.start, b.push(f)); this.groups = b }, fromGeometry: function (a) {
					var b = a.faces, c = a.vertices, d = a.faceVertexUvs,
					e = d[0] && 0 < d[0].length, f = d[1] && 0 < d[1].length, g = a.morphTargets, h = g.length; if (0 < h) { var k = []; for (var l = 0; l < h; l++)k[l] = []; this.morphTargets.position = k } var q = a.morphNormals, n = q.length; if (0 < n) { var m = []; for (l = 0; l < n; l++)m[l] = []; this.morphTargets.normal = m } for (var p = a.skinIndices, u = a.skinWeights, v = p.length === c.length, w = u.length === c.length, l = 0; l < b.length; l++) {
						var x = b[l]; this.vertices.push(c[x.a], c[x.b], c[x.c]); var z = x.vertexNormals; 3 === z.length ? this.normals.push(z[0], z[1], z[2]) : (z = x.normal, this.normals.push(z,
							z, z)); z = x.vertexColors; 3 === z.length ? this.colors.push(z[0], z[1], z[2]) : (z = x.color, this.colors.push(z, z, z)); !0 === e && (z = d[0][l], void 0 !== z ? this.uvs.push(z[0], z[1], z[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", l), this.uvs.push(new C, new C, new C))); !0 === f && (z = d[1][l], void 0 !== z ? this.uvs2.push(z[0], z[1], z[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", l), this.uvs2.push(new C, new C, new C))); for (z = 0; z < h; z++) {
								var I = g[z].vertices; k[z].push(I[x.a],
									I[x.b], I[x.c])
							} for (z = 0; z < n; z++)I = q[z].vertexNormals[l], m[z].push(I.a, I.b, I.c); v && this.skinIndices.push(p[x.a], p[x.b], p[x.c]); w && this.skinWeights.push(u[x.a], u[x.b], u[x.c])
					} this.computeGroups(a); this.verticesNeedUpdate = a.verticesNeedUpdate; this.normalsNeedUpdate = a.normalsNeedUpdate; this.colorsNeedUpdate = a.colorsNeedUpdate; this.uvsNeedUpdate = a.uvsNeedUpdate; this.groupsNeedUpdate = a.groupsNeedUpdate; return this
				}
			}); var Pf = 1; Object.assign(D.prototype, ja.prototype, {
				isBufferGeometry: !0, getIndex: function () { return this.index },
				setIndex: function (a) { Array.isArray(a) ? this.index = new (65535 < Qd(a) ? ib : hb)(a, 1) : this.index = a }, addAttribute: function (a, b, c) { if (b && b.isBufferAttribute || b && b.isInterleavedBufferAttribute) if ("index" === a) console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(b); else return this.attributes[a] = b, this; else console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(a, new P(b, c)) }, getAttribute: function (a) { return this.attributes[a] },
				removeAttribute: function (a) { delete this.attributes[a]; return this }, addGroup: function (a, b, c) { this.groups.push({ start: a, count: b, materialIndex: void 0 !== c ? c : 0 }) }, clearGroups: function () { this.groups = [] }, setDrawRange: function (a, b) { this.drawRange.start = a; this.drawRange.count = b }, applyMatrix: function (a) {
					var b = this.attributes.position; void 0 !== b && (a.applyToBufferAttribute(b), b.needsUpdate = !0); b = this.attributes.normal; void 0 !== b && ((new ra).getNormalMatrix(a).applyToBufferAttribute(b), b.needsUpdate = !0); null !==
						this.boundingBox && this.computeBoundingBox(); null !== this.boundingSphere && this.computeBoundingSphere(); return this
				}, rotateX: function () { var a = new K; return function (b) { a.makeRotationX(b); this.applyMatrix(a); return this } }(), rotateY: function () { var a = new K; return function (b) { a.makeRotationY(b); this.applyMatrix(a); return this } }(), rotateZ: function () { var a = new K; return function (b) { a.makeRotationZ(b); this.applyMatrix(a); return this } }(), translate: function () {
					var a = new K; return function (b, c, d) {
						a.makeTranslation(b,
							c, d); this.applyMatrix(a); return this
					}
				}(), scale: function () { var a = new K; return function (b, c, d) { a.makeScale(b, c, d); this.applyMatrix(a); return this } }(), lookAt: function () { var a = new A; return function (b) { a.lookAt(b); a.updateMatrix(); this.applyMatrix(a.matrix) } }(), center: function () { this.computeBoundingBox(); var a = this.boundingBox.getCenter().negate(); this.translate(a.x, a.y, a.z); return a }, setFromObject: function (a) {
					var b = a.geometry; if (a.isPoints || a.isLine) {
						a = new y(3 * b.vertices.length, 3); var c = new y(3 * b.colors.length,
							3); this.addAttribute("position", a.copyVector3sArray(b.vertices)); this.addAttribute("color", c.copyColorsArray(b.colors)); b.lineDistances && b.lineDistances.length === b.vertices.length && (a = new y(b.lineDistances.length, 1), this.addAttribute("lineDistance", a.copyArray(b.lineDistances))); null !== b.boundingSphere && (this.boundingSphere = b.boundingSphere.clone()); null !== b.boundingBox && (this.boundingBox = b.boundingBox.clone())
					} else a.isMesh && b && b.isGeometry && this.fromGeometry(b); return this
				}, setFromPoints: function (a) {
					for (var b =
						[], c = 0, d = a.length; c < d; c++) { var e = a[c]; b.push(e.x, e.y, e.z || 0) } this.addAttribute("position", new y(b, 3)); return this
				}, updateFromObject: function (a) {
					var b = a.geometry; if (a.isMesh) {
						var c = b.__directGeometry; !0 === b.elementsNeedUpdate && (c = void 0, b.elementsNeedUpdate = !1); if (void 0 === c) return this.fromGeometry(b); c.verticesNeedUpdate = b.verticesNeedUpdate; c.normalsNeedUpdate = b.normalsNeedUpdate; c.colorsNeedUpdate = b.colorsNeedUpdate; c.uvsNeedUpdate = b.uvsNeedUpdate; c.groupsNeedUpdate = b.groupsNeedUpdate; b.verticesNeedUpdate =
							!1; b.normalsNeedUpdate = !1; b.colorsNeedUpdate = !1; b.uvsNeedUpdate = !1; b.groupsNeedUpdate = !1; b = c
					} !0 === b.verticesNeedUpdate && (c = this.attributes.position, void 0 !== c && (c.copyVector3sArray(b.vertices), c.needsUpdate = !0), b.verticesNeedUpdate = !1); !0 === b.normalsNeedUpdate && (c = this.attributes.normal, void 0 !== c && (c.copyVector3sArray(b.normals), c.needsUpdate = !0), b.normalsNeedUpdate = !1); !0 === b.colorsNeedUpdate && (c = this.attributes.color, void 0 !== c && (c.copyColorsArray(b.colors), c.needsUpdate = !0), b.colorsNeedUpdate =
						!1); b.uvsNeedUpdate && (c = this.attributes.uv, void 0 !== c && (c.copyVector2sArray(b.uvs), c.needsUpdate = !0), b.uvsNeedUpdate = !1); b.lineDistancesNeedUpdate && (c = this.attributes.lineDistance, void 0 !== c && (c.copyArray(b.lineDistances), c.needsUpdate = !0), b.lineDistancesNeedUpdate = !1); b.groupsNeedUpdate && (b.computeGroups(a.geometry), this.groups = b.groups, b.groupsNeedUpdate = !1); return this
				}, fromGeometry: function (a) { a.__directGeometry = (new Je).fromGeometry(a); return this.fromDirectGeometry(a.__directGeometry) }, fromDirectGeometry: function (a) {
					var b =
						new Float32Array(3 * a.vertices.length); this.addAttribute("position", (new P(b, 3)).copyVector3sArray(a.vertices)); 0 < a.normals.length && (b = new Float32Array(3 * a.normals.length), this.addAttribute("normal", (new P(b, 3)).copyVector3sArray(a.normals))); 0 < a.colors.length && (b = new Float32Array(3 * a.colors.length), this.addAttribute("color", (new P(b, 3)).copyColorsArray(a.colors))); 0 < a.uvs.length && (b = new Float32Array(2 * a.uvs.length), this.addAttribute("uv", (new P(b, 2)).copyVector2sArray(a.uvs))); 0 < a.uvs2.length && (b =
							new Float32Array(2 * a.uvs2.length), this.addAttribute("uv2", (new P(b, 2)).copyVector2sArray(a.uvs2))); 0 < a.indices.length && (b = new (65535 < Qd(a.indices) ? Uint32Array : Uint16Array)(3 * a.indices.length), this.setIndex((new P(b, 1)).copyIndicesArray(a.indices))); this.groups = a.groups; for (var c in a.morphTargets) { for (var b = [], d = a.morphTargets[c], e = 0, f = d.length; e < f; e++) { var g = d[e], h = new y(3 * g.length, 3); b.push(h.copyVector3sArray(g)) } this.morphAttributes[c] = b } 0 < a.skinIndices.length && (c = new y(4 * a.skinIndices.length,
								4), this.addAttribute("skinIndex", c.copyVector4sArray(a.skinIndices))); 0 < a.skinWeights.length && (c = new y(4 * a.skinWeights.length, 4), this.addAttribute("skinWeight", c.copyVector4sArray(a.skinWeights))); null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone()); null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone()); return this
				}, computeBoundingBox: function () {
				null === this.boundingBox && (this.boundingBox = new Oa); var a = this.attributes.position; void 0 !== a ? this.boundingBox.setFromBufferAttribute(a) :
					this.boundingBox.makeEmpty(); (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
				}, computeBoundingSphere: function () {
					var a = new Oa, b = new p; return function () {
					null === this.boundingSphere && (this.boundingSphere = new Da); var c = this.attributes.position; if (c) {
						var d = this.boundingSphere.center; a.setFromBufferAttribute(c);
						a.getCenter(d); for (var e = 0, f = 0, g = c.count; f < g; f++)b.x = c.getX(f), b.y = c.getY(f), b.z = c.getZ(f), e = Math.max(e, d.distanceToSquared(b)); this.boundingSphere.radius = Math.sqrt(e); isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
					}
					}
				}(), computeFaceNormals: function () { }, computeVertexNormals: function () {
					var a = this.index, b = this.attributes, c = this.groups; if (b.position) {
						var d = b.position.array;
						if (void 0 === b.normal) this.addAttribute("normal", new P(new Float32Array(d.length), 3)); else for (var e = b.normal.array, f = 0, g = e.length; f < g; f++)e[f] = 0; var e = b.normal.array, h = new p, k = new p, l = new p, q = new p, n = new p; if (a) {
							a = a.array; 0 === c.length && this.addGroup(0, a.length); for (var m = 0, r = c.length; m < r; ++m) {
								f = c[m]; g = f.start; var u = f.count; f = g; for (g += u; f < g; f += 3) {
									u = 3 * a[f + 0]; var v = 3 * a[f + 1]; var w = 3 * a[f + 2]; h.fromArray(d, u); k.fromArray(d, v); l.fromArray(d, w); q.subVectors(l, k); n.subVectors(h, k); q.cross(n); e[u] += q.x; e[u +
										1] += q.y; e[u + 2] += q.z; e[v] += q.x; e[v + 1] += q.y; e[v + 2] += q.z; e[w] += q.x; e[w + 1] += q.y; e[w + 2] += q.z
								}
							}
						} else for (f = 0, g = d.length; f < g; f += 9)h.fromArray(d, f), k.fromArray(d, f + 3), l.fromArray(d, f + 6), q.subVectors(l, k), n.subVectors(h, k), q.cross(n), e[f] = q.x, e[f + 1] = q.y, e[f + 2] = q.z, e[f + 3] = q.x, e[f + 4] = q.y, e[f + 5] = q.z, e[f + 6] = q.x, e[f + 7] = q.y, e[f + 8] = q.z; this.normalizeNormals(); b.normal.needsUpdate = !0
					}
				}, merge: function (a, b) {
					if (a && a.isBufferGeometry) {
					void 0 === b && (b = 0); var c = this.attributes, d; for (d in c) if (void 0 !== a.attributes[d]) for (var e =
						c[d].array, f = a.attributes[d], g = f.array, h = 0, f = f.itemSize * b; h < g.length; h++ , f++)e[f] = g[h]; return this
					} console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", a)
				}, normalizeNormals: function () { var a = new p; return function () { for (var b = this.attributes.normal, c = 0, d = b.count; c < d; c++)a.x = b.getX(c), a.y = b.getY(c), a.z = b.getZ(c), a.normalize(), b.setXYZ(c, a.x, a.y, a.z) } }(), toNonIndexed: function () {
					if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."),
						this; var a = new D, b = this.index.array, c = this.attributes, d; for (d in c) { for (var e = c[d], f = e.array, e = e.itemSize, g = new f.constructor(b.length * e), h, k = 0, l = 0, q = b.length; l < q; l++) { h = b[l] * e; for (var n = 0; n < e; n++)g[k++] = f[h++] } a.addAttribute(d, new P(g, e)) } return a
				}, toJSON: function () {
					var a = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; a.uuid = this.uuid; a.type = this.type; "" !== this.name && (a.name = this.name); if (void 0 !== this.parameters) {
						var b = this.parameters; for (var c in b) void 0 !== b[c] &&
							(a[c] = b[c]); return a
					} a.data = { attributes: {} }; var d = this.index; null !== d && (b = Array.prototype.slice.call(d.array), a.data.index = { type: d.array.constructor.name, array: b }); d = this.attributes; for (c in d) { var e = d[c]; b = Array.prototype.slice.call(e.array); a.data.attributes[c] = { itemSize: e.itemSize, type: e.array.constructor.name, array: b, normalized: e.normalized } } c = this.groups; 0 < c.length && (a.data.groups = JSON.parse(JSON.stringify(c))); c = this.boundingSphere; null !== c && (a.data.boundingSphere = {
						center: c.center.toArray(),
						radius: c.radius
					}); return a
				}, clone: function () { return (new D).copy(this) }, copy: function (a) {
					var b; this.index = null; this.attributes = {}; this.morphAttributes = {}; this.groups = []; this.boundingSphere = this.boundingBox = null; this.name = a.name; var c = a.index; null !== c && this.setIndex(c.clone()); c = a.attributes; for (g in c) this.addAttribute(g, c[g].clone()); var d = a.morphAttributes; for (g in d) { var e = [], f = d[g]; c = 0; for (b = f.length; c < b; c++)e.push(f[c].clone()); this.morphAttributes[g] = e } var g = a.groups; c = 0; for (b = g.length; c < b; c++)d =
						g[c], this.addGroup(d.start, d.count, d.materialIndex); g = a.boundingBox; null !== g && (this.boundingBox = g.clone()); g = a.boundingSphere; null !== g && (this.boundingSphere = g.clone()); this.drawRange.start = a.drawRange.start; this.drawRange.count = a.drawRange.count; return this
				}, dispose: function () { this.dispatchEvent({ type: "dispose" }) }
			}); Lb.prototype = Object.create(N.prototype); Lb.prototype.constructor = Lb; jb.prototype = Object.create(D.prototype); jb.prototype.constructor = jb; Ac.prototype = Object.create(N.prototype); Ac.prototype.constructor =
				Ac; kb.prototype = Object.create(D.prototype); kb.prototype.constructor = kb; va.prototype = Object.create(Q.prototype); va.prototype.constructor = va; va.prototype.isMeshBasicMaterial = !0; va.prototype.copy = function (a) {
					Q.prototype.copy.call(this, a); this.color.copy(a.color); this.map = a.map; this.lightMap = a.lightMap; this.lightMapIntensity = a.lightMapIntensity; this.aoMap = a.aoMap; this.aoMapIntensity = a.aoMapIntensity; this.specularMap = a.specularMap; this.alphaMap = a.alphaMap; this.envMap = a.envMap; this.combine = a.combine; this.reflectivity =
						a.reflectivity; this.refractionRatio = a.refractionRatio; this.wireframe = a.wireframe; this.wireframeLinewidth = a.wireframeLinewidth; this.wireframeLinecap = a.wireframeLinecap; this.wireframeLinejoin = a.wireframeLinejoin; this.skinning = a.skinning; this.morphTargets = a.morphTargets; return this
				}; oa.prototype = Object.create(Q.prototype); oa.prototype.constructor = oa; oa.prototype.isShaderMaterial = !0; oa.prototype.copy = function (a) {
					Q.prototype.copy.call(this, a); this.fragmentShader = a.fragmentShader; this.vertexShader = a.vertexShader;
					this.uniforms = Ea.clone(a.uniforms); this.defines = a.defines; this.wireframe = a.wireframe; this.wireframeLinewidth = a.wireframeLinewidth; this.lights = a.lights; this.clipping = a.clipping; this.skinning = a.skinning; this.morphTargets = a.morphTargets; this.morphNormals = a.morphNormals; this.extensions = a.extensions; return this
				}; oa.prototype.toJSON = function (a) { a = Q.prototype.toJSON.call(this, a); a.uniforms = this.uniforms; a.vertexShader = this.vertexShader; a.fragmentShader = this.fragmentShader; return a }; Object.assign(lb.prototype,
					{
						set: function (a, b) { this.origin.copy(a); this.direction.copy(b); return this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (a) { this.origin.copy(a.origin); this.direction.copy(a.direction); return this }, at: function (a, b) { return (b || new p).copy(this.direction).multiplyScalar(a).add(this.origin) }, lookAt: function (a) { this.direction.copy(a).sub(this.origin).normalize(); return this }, recast: function () { var a = new p; return function (b) { this.origin.copy(this.at(b, a)); return this } }(), closestPointToPoint: function (a,
							b) { b = b || new p; b.subVectors(a, this.origin); a = b.dot(this.direction); return 0 > a ? b.copy(this.origin) : b.copy(this.direction).multiplyScalar(a).add(this.origin) }, distanceToPoint: function (a) { return Math.sqrt(this.distanceSqToPoint(a)) }, distanceSqToPoint: function () { var a = new p; return function (b) { var c = a.subVectors(b, this.origin).dot(this.direction); if (0 > c) return this.origin.distanceToSquared(b); a.copy(this.direction).multiplyScalar(c).add(this.origin); return a.distanceToSquared(b) } }(), distanceSqToSegment: function () {
								var a =
									new p, b = new p, c = new p; return function (d, e, f, g) {
										a.copy(d).add(e).multiplyScalar(.5); b.copy(e).sub(d).normalize(); c.copy(this.origin).sub(a); var h = .5 * d.distanceTo(e), k = -this.direction.dot(b), l = c.dot(this.direction), q = -c.dot(b), n = c.lengthSq(), m = Math.abs(1 - k * k); if (0 < m) {
											d = k * q - l; e = k * l - q; var p = h * m; 0 <= d ? e >= -p ? e <= p ? (h = 1 / m, d *= h, e *= h, k = d * (d + k * e + 2 * l) + e * (k * d + e + 2 * q) + n) : (e = h, d = Math.max(0, -(k * e + l)), k = -d * d + e * (e + 2 * q) + n) : (e = -h, d = Math.max(0, -(k * e + l)), k = -d * d + e * (e + 2 * q) + n) : e <= -p ? (d = Math.max(0, -(-k * h + l)), e = 0 < d ? -h : Math.min(Math.max(-h,
												-q), h), k = -d * d + e * (e + 2 * q) + n) : e <= p ? (d = 0, e = Math.min(Math.max(-h, -q), h), k = e * (e + 2 * q) + n) : (d = Math.max(0, -(k * h + l)), e = 0 < d ? h : Math.min(Math.max(-h, -q), h), k = -d * d + e * (e + 2 * q) + n)
										} else e = 0 < k ? -h : h, d = Math.max(0, -(k * e + l)), k = -d * d + e * (e + 2 * q) + n; f && f.copy(this.direction).multiplyScalar(d).add(this.origin); g && g.copy(b).multiplyScalar(e).add(a); return k
									}
							}(), intersectSphere: function () {
								var a = new p; return function (b, c) {
									a.subVectors(b.center, this.origin); var d = a.dot(this.direction), e = a.dot(a) - d * d; b = b.radius * b.radius; if (e > b) return null;
									b = Math.sqrt(b - e); e = d - b; d += b; return 0 > e && 0 > d ? null : 0 > e ? this.at(d, c) : this.at(e, c)
								}
							}(), intersectsSphere: function (a) { return this.distanceToPoint(a.center) <= a.radius }, distanceToPlane: function (a) { var b = a.normal.dot(this.direction); if (0 === b) return 0 === a.distanceToPoint(this.origin) ? 0 : null; a = -(this.origin.dot(a.normal) + a.constant) / b; return 0 <= a ? a : null }, intersectPlane: function (a, b) { a = this.distanceToPlane(a); return null === a ? null : this.at(a, b) }, intersectsPlane: function (a) {
								var b = a.distanceToPoint(this.origin);
								return 0 === b || 0 > a.normal.dot(this.direction) * b ? !0 : !1
							}, intersectBox: function (a, b) {
								var c = 1 / this.direction.x; var d = 1 / this.direction.y; var e = 1 / this.direction.z, f = this.origin; if (0 <= c) { var g = (a.min.x - f.x) * c; c *= a.max.x - f.x } else g = (a.max.x - f.x) * c, c *= a.min.x - f.x; if (0 <= d) { var h = (a.min.y - f.y) * d; d *= a.max.y - f.y } else h = (a.max.y - f.y) * d, d *= a.min.y - f.y; if (g > d || h > c) return null; if (h > g || g !== g) g = h; if (d < c || c !== c) c = d; 0 <= e ? (h = (a.min.z - f.z) * e, a = (a.max.z - f.z) * e) : (h = (a.max.z - f.z) * e, a = (a.min.z - f.z) * e); if (g > a || h > c) return null;
								if (h > g || g !== g) g = h; if (a < c || c !== c) c = a; return 0 > c ? null : this.at(0 <= g ? g : c, b)
							}, intersectsBox: function () { var a = new p; return function (b) { return null !== this.intersectBox(b, a) } }(), intersectTriangle: function () {
								var a = new p, b = new p, c = new p, d = new p; return function (e, f, g, h, k) {
									b.subVectors(f, e); c.subVectors(g, e); d.crossVectors(b, c); f = this.direction.dot(d); if (0 < f) { if (h) return null; h = 1 } else if (0 > f) h = -1, f = -f; else return null; a.subVectors(this.origin, e); e = h * this.direction.dot(c.crossVectors(a, c)); if (0 > e) return null;
									g = h * this.direction.dot(b.cross(a)); if (0 > g || e + g > f) return null; e = -h * a.dot(d); return 0 > e ? null : this.at(e / f, k)
								}
							}(), applyMatrix4: function (a) { this.origin.applyMatrix4(a); this.direction.transformDirection(a); return this }, equals: function (a) { return a.origin.equals(this.origin) && a.direction.equals(this.direction) }
					}); Object.assign(Mb.prototype, {
						set: function (a, b) { this.start.copy(a); this.end.copy(b); return this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (a) {
							this.start.copy(a.start);
							this.end.copy(a.end); return this
						}, getCenter: function (a) { return (a || new p).addVectors(this.start, this.end).multiplyScalar(.5) }, delta: function (a) { return (a || new p).subVectors(this.end, this.start) }, distanceSq: function () { return this.start.distanceToSquared(this.end) }, distance: function () { return this.start.distanceTo(this.end) }, at: function (a, b) { b = b || new p; return this.delta(b).multiplyScalar(a).add(this.start) }, closestPointToPointParameter: function () {
							var a = new p, b = new p; return function (c, d) {
								a.subVectors(c,
									this.start); b.subVectors(this.end, this.start); c = b.dot(b); c = b.dot(a) / c; d && (c = R.clamp(c, 0, 1)); return c
							}
						}(), closestPointToPoint: function (a, b, c) { a = this.closestPointToPointParameter(a, b); c = c || new p; return this.delta(c).multiplyScalar(a).add(this.start) }, applyMatrix4: function (a) { this.start.applyMatrix4(a); this.end.applyMatrix4(a); return this }, equals: function (a) { return a.start.equals(this.start) && a.end.equals(this.end) }
					}); Object.assign(Qa, {
						normal: function () {
							var a = new p; return function (b, c, d, e) {
								e = e || new p;
								e.subVectors(d, c); a.subVectors(b, c); e.cross(a); b = e.lengthSq(); return 0 < b ? e.multiplyScalar(1 / Math.sqrt(b)) : e.set(0, 0, 0)
							}
						}(), barycoordFromPoint: function () { var a = new p, b = new p, c = new p; return function (d, e, f, g, h) { a.subVectors(g, e); b.subVectors(f, e); c.subVectors(d, e); d = a.dot(a); e = a.dot(b); f = a.dot(c); var k = b.dot(b); g = b.dot(c); var l = d * k - e * e; h = h || new p; if (0 === l) return h.set(-2, -1, -1); l = 1 / l; k = (k * f - e * g) * l; d = (d * g - e * f) * l; return h.set(1 - k - d, d, k) } }(), containsPoint: function () {
							var a = new p; return function (b, c, d, e) {
								b =
								Qa.barycoordFromPoint(b, c, d, e, a); return 0 <= b.x && 0 <= b.y && 1 >= b.x + b.y
							}
						}()
					}); Object.assign(Qa.prototype, {
						set: function (a, b, c) { this.a.copy(a); this.b.copy(b); this.c.copy(c); return this }, setFromPointsAndIndices: function (a, b, c, d) { this.a.copy(a[b]); this.b.copy(a[c]); this.c.copy(a[d]); return this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (a) { this.a.copy(a.a); this.b.copy(a.b); this.c.copy(a.c); return this }, area: function () {
							var a = new p, b = new p; return function () {
								a.subVectors(this.c,
									this.b); b.subVectors(this.a, this.b); return .5 * a.cross(b).length()
							}
						}(), midpoint: function (a) { return (a || new p).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) }, normal: function (a) { return Qa.normal(this.a, this.b, this.c, a) }, plane: function (a) { return (a || new Aa).setFromCoplanarPoints(this.a, this.b, this.c) }, barycoordFromPoint: function (a, b) { return Qa.barycoordFromPoint(a, this.a, this.b, this.c, b) }, containsPoint: function (a) { return Qa.containsPoint(a, this.a, this.b, this.c) }, closestPointToPoint: function () {
							var a =
								new Aa, b = [new Mb, new Mb, new Mb], c = new p, d = new p; return function (e, f) { f = f || new p; var g = Infinity; a.setFromCoplanarPoints(this.a, this.b, this.c); a.projectPoint(e, c); if (!0 === this.containsPoint(c)) f.copy(c); else for (b[0].set(this.a, this.b), b[1].set(this.b, this.c), b[2].set(this.c, this.a), e = 0; e < b.length; e++) { b[e].closestPointToPoint(c, !0, d); var h = c.distanceToSquared(d); h < g && (g = h, f.copy(d)) } return f }
						}(), equals: function (a) { return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c) }
					}); pa.prototype = Object.assign(Object.create(A.prototype),
						{
							constructor: pa, isMesh: !0, setDrawMode: function (a) { this.drawMode = a }, copy: function (a) { A.prototype.copy.call(this, a); this.drawMode = a.drawMode; void 0 !== a.morphTargetInfluences && (this.morphTargetInfluences = a.morphTargetInfluences.slice()); void 0 !== a.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, a.morphTargetDictionary)); return this }, updateMorphTargets: function () {
								var a = this.geometry; if (a.isBufferGeometry) {
									a = a.morphAttributes; var b = Object.keys(a); if (0 < b.length) {
										var c = a[b[0]]; if (void 0 !==
											c) for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, a = 0, b = c.length; a < b; a++) { var d = c[a].name || String(a); this.morphTargetInfluences.push(0); this.morphTargetDictionary[d] = a }
									}
								} else if (c = a.morphTargets, void 0 !== c && 0 < c.length) for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, a = 0, b = c.length; a < b; a++)d = c[a].name || String(a), this.morphTargetInfluences.push(0), this.morphTargetDictionary[d] = a
							}, raycast: function () {
								function a(a, b, c, d, e, f, g) {
									Qa.barycoordFromPoint(a, b, c, d, v); e.multiplyScalar(v.x);
									f.multiplyScalar(v.y); g.multiplyScalar(v.z); e.add(f).add(g); return e.clone()
								} function b(a, b, c, d, e, f, g, h) { if (null === (1 === b.side ? d.intersectTriangle(g, f, e, !0, h) : d.intersectTriangle(e, f, g, 2 !== b.side, h))) return null; x.copy(h); x.applyMatrix4(a.matrixWorld); b = c.ray.origin.distanceTo(x); return b < c.near || b > c.far ? null : { distance: b, point: x.clone(), object: a } } function c(c, d, e, f, l, n, q, t) {
									g.fromBufferAttribute(f, n); h.fromBufferAttribute(f, q); k.fromBufferAttribute(f, t); if (c = b(c, c.material, d, e, g, h, k, w)) l && (m.fromBufferAttribute(l,
										n), r.fromBufferAttribute(l, q), u.fromBufferAttribute(l, t), c.uv = a(w, g, h, k, m, r, u)), c.face = new Pa(n, q, t, Qa.normal(g, h, k)), c.faceIndex = n; return c
								} var d = new K, e = new lb, f = new Da, g = new p, h = new p, k = new p, l = new p, q = new p, n = new p, m = new C, r = new C, u = new C, v = new p, w = new p, x = new p; return function (t, p) {
									var v = this.geometry, x = this.material, z = this.matrixWorld; if (void 0 !== x && (null === v.boundingSphere && v.computeBoundingSphere(), f.copy(v.boundingSphere), f.applyMatrix4(z), !1 !== t.ray.intersectsSphere(f) && (d.getInverse(z),
										e.copy(t.ray).applyMatrix4(d), null === v.boundingBox || !1 !== e.intersectsBox(v.boundingBox)))) {
											var y; if (v.isBufferGeometry) { var x = v.index, I = v.attributes.position, z = v.attributes.uv, C; if (null !== x) { var A = 0; for (C = x.count; A < C; A += 3) { v = x.getX(A); var D = x.getX(A + 1); var E = x.getX(A + 2); if (y = c(this, t, e, I, z, v, D, E)) y.faceIndex = Math.floor(A / 3), p.push(y) } } else if (void 0 !== I) for (A = 0, C = I.count; A < C; A += 3)if (v = A, D = A + 1, E = A + 2, y = c(this, t, e, I, z, v, D, E)) y.index = v, p.push(y) } else if (v.isGeometry) {
												var z = Array.isArray(x); A = v.vertices;
												C = v.faces; D = v.faceVertexUvs[0]; 0 < D.length && (I = D); for (var H = 0, N = C.length; H < N; H++) {
													var M = C[H]; y = z ? x[M.materialIndex] : x; if (void 0 !== y) {
														D = A[M.a]; E = A[M.b]; var V = A[M.c]; if (!0 === y.morphTargets) {
															var K = v.morphTargets, P = this.morphTargetInfluences; g.set(0, 0, 0); h.set(0, 0, 0); k.set(0, 0, 0); for (var Q = 0, R = K.length; Q < R; Q++) { var O = P[Q]; if (0 !== O) { var S = K[Q].vertices; g.addScaledVector(l.subVectors(S[M.a], D), O); h.addScaledVector(q.subVectors(S[M.b], E), O); k.addScaledVector(n.subVectors(S[M.c], V), O) } } g.add(D); h.add(E); k.add(V);
															D = g; E = h; V = k
														} if (y = b(this, y, t, e, D, E, V, w)) I && I[H] && (K = I[H], m.copy(K[0]), r.copy(K[1]), u.copy(K[2]), y.uv = a(w, D, E, V, m, r, u)), y.face = M, y.faceIndex = H, p.push(y)
													}
												}
											}
									}
								}
							}(), clone: function () { return (new this.constructor(this.geometry, this.material)).copy(this) }
						}); var ig = 0; U.prototype = Object.assign(Object.create(La.prototype), {
							constructor: U, isPerspectiveCamera: !0, copy: function (a, b) {
								La.prototype.copy.call(this, a, b); this.fov = a.fov; this.zoom = a.zoom; this.near = a.near; this.far = a.far; this.focus = a.focus; this.aspect = a.aspect;
								this.view = null === a.view ? null : Object.assign({}, a.view); this.filmGauge = a.filmGauge; this.filmOffset = a.filmOffset; return this
							}, setFocalLength: function (a) { a = .5 * this.getFilmHeight() / a; this.fov = 2 * R.RAD2DEG * Math.atan(a); this.updateProjectionMatrix() }, getFocalLength: function () { var a = Math.tan(.5 * R.DEG2RAD * this.fov); return .5 * this.getFilmHeight() / a }, getEffectiveFOV: function () { return 2 * R.RAD2DEG * Math.atan(Math.tan(.5 * R.DEG2RAD * this.fov) / this.zoom) }, getFilmWidth: function () {
								return this.filmGauge * Math.min(this.aspect,
									1)
							}, getFilmHeight: function () { return this.filmGauge / Math.max(this.aspect, 1) }, setViewOffset: function (a, b, c, d, e, f) { this.aspect = a / b; null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }); this.view.enabled = !0; this.view.fullWidth = a; this.view.fullHeight = b; this.view.offsetX = c; this.view.offsetY = d; this.view.width = e; this.view.height = f; this.updateProjectionMatrix() }, clearViewOffset: function () { null !== this.view && (this.view.enabled = !1); this.updateProjectionMatrix() },
							updateProjectionMatrix: function () { var a = this.near, b = a * Math.tan(.5 * R.DEG2RAD * this.fov) / this.zoom, c = 2 * b, d = this.aspect * c, e = -.5 * d, f = this.view; if (null !== this.view && this.view.enabled) var g = f.fullWidth, h = f.fullHeight, e = e + f.offsetX * d / g, b = b - f.offsetY * c / h, d = f.width / g * d, c = f.height / h * c; f = this.filmOffset; 0 !== f && (e += a * f / this.getFilmWidth()); this.projectionMatrix.makePerspective(e, e + d, b, b - c, a, this.far) }, toJSON: function (a) {
								a = A.prototype.toJSON.call(this, a); a.object.fov = this.fov; a.object.zoom = this.zoom; a.object.near =
									this.near; a.object.far = this.far; a.object.focus = this.focus; a.object.aspect = this.aspect; null !== this.view && (a.object.view = Object.assign({}, this.view)); a.object.filmGauge = this.filmGauge; a.object.filmOffset = this.filmOffset; return a
							}
						}); nd.prototype = Object.assign(Object.create(U.prototype), { constructor: nd, isArrayCamera: !0 }); Ob.prototype.isFogExp2 = !0; Ob.prototype.clone = function () { return new Ob(this.color.getHex(), this.density) }; Ob.prototype.toJSON = function () {
							return {
								type: "FogExp2", color: this.color.getHex(),
								density: this.density
							}
						}; Pb.prototype.isFog = !0; Pb.prototype.clone = function () { return new Pb(this.color.getHex(), this.near, this.far) }; Pb.prototype.toJSON = function () { return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far } }; od.prototype = Object.assign(Object.create(A.prototype), {
							constructor: od, copy: function (a, b) {
								A.prototype.copy.call(this, a, b); null !== a.background && (this.background = a.background.clone()); null !== a.fog && (this.fog = a.fog.clone()); null !== a.overrideMaterial && (this.overrideMaterial =
									a.overrideMaterial.clone()); this.autoUpdate = a.autoUpdate; this.matrixAutoUpdate = a.matrixAutoUpdate; return this
							}, toJSON: function (a) { var b = A.prototype.toJSON.call(this, a); null !== this.background && (b.object.background = this.background.toJSON(a)); null !== this.fog && (b.object.fog = this.fog.toJSON()); return b }
						}); Xd.prototype = Object.assign(Object.create(A.prototype), {
							constructor: Xd, isLensFlare: !0, copy: function (a) {
								A.prototype.copy.call(this, a); this.positionScreen.copy(a.positionScreen); this.customUpdateCallback =
									a.customUpdateCallback; for (var b = 0, c = a.lensFlares.length; b < c; b++)this.lensFlares.push(a.lensFlares[b]); return this
							}, add: function (a, b, c, d, e, f) { void 0 === b && (b = -1); void 0 === c && (c = 0); void 0 === f && (f = 1); void 0 === e && (e = new H(16777215)); void 0 === d && (d = 1); c = Math.min(c, Math.max(0, c)); this.lensFlares.push({ texture: a, size: b, distance: c, x: 0, y: 0, z: 0, scale: 1, rotation: 0, opacity: f, color: e, blending: d }) }, updateLensFlares: function () {
								var a, b = this.lensFlares.length, c = 2 * -this.positionScreen.x, d = 2 * -this.positionScreen.y;
								for (a = 0; a < b; a++) { var e = this.lensFlares[a]; e.x = this.positionScreen.x + c * e.distance; e.y = this.positionScreen.y + d * e.distance; e.wantedRotation = e.x * Math.PI * .25; e.rotation += .25 * (e.wantedRotation - e.rotation) }
							}
						}); Za.prototype = Object.create(Q.prototype); Za.prototype.constructor = Za; Za.prototype.isSpriteMaterial = !0; Za.prototype.copy = function (a) { Q.prototype.copy.call(this, a); this.color.copy(a.color); this.map = a.map; this.rotation = a.rotation; return this }; Cc.prototype = Object.assign(Object.create(A.prototype), {
							constructor: Cc,
							isSprite: !0, raycast: function () { var a = new p, b = new p, c = new p; return function (d, e) { b.setFromMatrixPosition(this.matrixWorld); d.ray.closestPointToPoint(b, a); c.setFromMatrixScale(this.matrixWorld); var f = c.x * c.y / 4; b.distanceToSquared(a) > f || (f = d.ray.origin.distanceTo(a), f < d.near || f > d.far || e.push({ distance: f, point: a.clone(), face: null, object: this })) } }(), clone: function () { return (new this.constructor(this.material)).copy(this) }
						}); Dc.prototype = Object.assign(Object.create(A.prototype), {
							constructor: Dc, copy: function (a) {
								A.prototype.copy.call(this,
									a, !1); a = a.levels; for (var b = 0, c = a.length; b < c; b++) { var d = a[b]; this.addLevel(d.object.clone(), d.distance) } return this
							}, addLevel: function (a, b) { void 0 === b && (b = 0); b = Math.abs(b); for (var c = this.levels, d = 0; d < c.length && !(b < c[d].distance); d++); c.splice(d, 0, { distance: b, object: a }); this.add(a) }, getObjectForDistance: function (a) { for (var b = this.levels, c = 1, d = b.length; c < d && !(a < b[c].distance); c++); return b[c - 1].object }, raycast: function () {
								var a = new p; return function (b, c) {
									a.setFromMatrixPosition(this.matrixWorld); var d =
										b.ray.origin.distanceTo(a); this.getObjectForDistance(d).raycast(b, c)
								}
							}(), update: function () { var a = new p, b = new p; return function (c) { var d = this.levels; if (1 < d.length) { a.setFromMatrixPosition(c.matrixWorld); b.setFromMatrixPosition(this.matrixWorld); c = a.distanceTo(b); d[0].object.visible = !0; for (var e = 1, f = d.length; e < f; e++)if (c >= d[e].distance) d[e - 1].object.visible = !1, d[e].object.visible = !0; else break; for (; e < f; e++)d[e].object.visible = !1 } } }(), toJSON: function (a) {
								a = A.prototype.toJSON.call(this, a); a.object.levels =
									[]; for (var b = this.levels, c = 0, d = b.length; c < d; c++) { var e = b[c]; a.object.levels.push({ object: e.object.uuid, distance: e.distance }) } return a
							}
						}); Object.assign(Ec.prototype, {
							calculateInverses: function () { this.boneInverses = []; for (var a = 0, b = this.bones.length; a < b; a++) { var c = new K; this.bones[a] && c.getInverse(this.bones[a].matrixWorld); this.boneInverses.push(c) } }, pose: function () {
								var a, b; var c = 0; for (b = this.bones.length; c < b; c++)(a = this.bones[c]) && a.matrixWorld.getInverse(this.boneInverses[c]); c = 0; for (b = this.bones.length; c <
									b; c++)if (a = this.bones[c]) a.parent && a.parent.isBone ? (a.matrix.getInverse(a.parent.matrixWorld), a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale)
							}, update: function () { var a = new K, b = new K; return function () { for (var c = this.bones, d = this.boneInverses, e = this.boneMatrices, f = this.boneTexture, g = 0, h = c.length; g < h; g++)a.multiplyMatrices(c[g] ? c[g].matrixWorld : b, d[g]), a.toArray(e, 16 * g); void 0 !== f && (f.needsUpdate = !0) } }(), clone: function () {
								return new Ec(this.bones,
									this.boneInverses)
							}
						}); pd.prototype = Object.assign(Object.create(A.prototype), { constructor: pd, isBone: !0 }); qd.prototype = Object.assign(Object.create(pa.prototype), {
							constructor: qd, isSkinnedMesh: !0, initBones: function () {
								var a = [], b; if (this.geometry && void 0 !== this.geometry.bones) {
									var c = 0; for (b = this.geometry.bones.length; c < b; c++) { var d = this.geometry.bones[c]; var e = new pd; a.push(e); e.name = d.name; e.position.fromArray(d.pos); e.quaternion.fromArray(d.rotq); void 0 !== d.scl && e.scale.fromArray(d.scl) } c = 0; for (b = this.geometry.bones.length; c <
										b; c++)d = this.geometry.bones[c], -1 !== d.parent && null !== d.parent && void 0 !== a[d.parent] ? a[d.parent].add(a[c]) : this.add(a[c])
								} this.updateMatrixWorld(!0); return a
							}, bind: function (a, b) { this.skeleton = a; void 0 === b && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), b = this.matrixWorld); this.bindMatrix.copy(b); this.bindMatrixInverse.getInverse(b) }, pose: function () { this.skeleton.pose() }, normalizeSkinWeights: function () {
								var a; if (this.geometry && this.geometry.isGeometry) for (a = 0; a < this.geometry.skinWeights.length; a++) {
									var b =
										this.geometry.skinWeights[a]; var c = 1 / b.manhattanLength(); Infinity !== c ? b.multiplyScalar(c) : b.set(1, 0, 0, 0)
								} else if (this.geometry && this.geometry.isBufferGeometry) { var b = new da, d = this.geometry.attributes.skinWeight; for (a = 0; a < d.count; a++)b.x = d.getX(a), b.y = d.getY(a), b.z = d.getZ(a), b.w = d.getW(a), c = 1 / b.manhattanLength(), Infinity !== c ? b.multiplyScalar(c) : b.set(1, 0, 0, 0), d.setXYZW(a, b.x, b.y, b.z, b.w) }
							}, updateMatrixWorld: function (a) {
								pa.prototype.updateMatrixWorld.call(this, a); "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) :
									"detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
							}, clone: function () { return (new this.constructor(this.geometry, this.material)).copy(this) }
						}); O.prototype = Object.create(Q.prototype); O.prototype.constructor = O; O.prototype.isLineBasicMaterial = !0; O.prototype.copy = function (a) { Q.prototype.copy.call(this, a); this.color.copy(a.color); this.linewidth = a.linewidth; this.linecap = a.linecap; this.linejoin = a.linejoin; return this };
	ma.prototype = Object.assign(Object.create(A.prototype), {
		constructor: ma, isLine: !0, raycast: function () {
			var a = new K, b = new lb, c = new Da; return function (d, e) {
				var f = d.linePrecision, f = f * f, g = this.geometry, h = this.matrixWorld; null === g.boundingSphere && g.computeBoundingSphere(); c.copy(g.boundingSphere); c.applyMatrix4(h); if (!1 !== d.ray.intersectsSphere(c)) {
					a.getInverse(h); b.copy(d.ray).applyMatrix4(a); var k = new p, l = new p, h = new p, q = new p, n = this && this.isLineSegments ? 2 : 1; if (g.isBufferGeometry) {
						var m = g.index; var r = g.attributes.position.array;
						if (null !== m) for (var u = m.array, g = 0, v = u.length - 1; g < v; g += n)m = u[g + 1], k.fromArray(r, 3 * u[g]), l.fromArray(r, 3 * m), m = b.distanceSqToSegment(k, l, q, h), m > f || (q.applyMatrix4(this.matrixWorld), m = d.ray.origin.distanceTo(q), m < d.near || m > d.far || e.push({ distance: m, point: h.clone().applyMatrix4(this.matrixWorld), index: g, face: null, faceIndex: null, object: this })); else for (g = 0, v = r.length / 3 - 1; g < v; g += n)k.fromArray(r, 3 * g), l.fromArray(r, 3 * g + 3), m = b.distanceSqToSegment(k, l, q, h), m > f || (q.applyMatrix4(this.matrixWorld), m = d.ray.origin.distanceTo(q),
							m < d.near || m > d.far || e.push({ distance: m, point: h.clone().applyMatrix4(this.matrixWorld), index: g, face: null, faceIndex: null, object: this }))
					} else if (g.isGeometry) for (k = g.vertices, l = k.length, g = 0; g < l - 1; g += n)m = b.distanceSqToSegment(k[g], k[g + 1], q, h), m > f || (q.applyMatrix4(this.matrixWorld), m = d.ray.origin.distanceTo(q), m < d.near || m > d.far || e.push({ distance: m, point: h.clone().applyMatrix4(this.matrixWorld), index: g, face: null, faceIndex: null, object: this }))
				}
			}
		}(), clone: function () {
			return (new this.constructor(this.geometry,
				this.material)).copy(this)
		}
	}); ca.prototype = Object.assign(Object.create(ma.prototype), { constructor: ca, isLineSegments: !0 }); rd.prototype = Object.assign(Object.create(ma.prototype), { constructor: rd, isLineLoop: !0 }); Ba.prototype = Object.create(Q.prototype); Ba.prototype.constructor = Ba; Ba.prototype.isPointsMaterial = !0; Ba.prototype.copy = function (a) { Q.prototype.copy.call(this, a); this.color.copy(a.color); this.map = a.map; this.size = a.size; this.sizeAttenuation = a.sizeAttenuation; return this }; Qb.prototype = Object.assign(Object.create(A.prototype),
		{
			constructor: Qb, isPoints: !0, raycast: function () {
				var a = new K, b = new lb, c = new Da; return function (d, e) {
					function f(a, c) { var f = b.distanceSqToPoint(a); if (f < m) { a = b.closestPointToPoint(a); a.applyMatrix4(k); var h = d.ray.origin.distanceTo(a); h < d.near || h > d.far || e.push({ distance: h, distanceToRay: Math.sqrt(f), point: a.clone(), index: c, face: null, object: g }) } } var g = this, h = this.geometry, k = this.matrixWorld, l = d.params.Points.threshold; null === h.boundingSphere && h.computeBoundingSphere(); c.copy(h.boundingSphere); c.applyMatrix4(k);
					c.radius += l; if (!1 !== d.ray.intersectsSphere(c)) { a.getInverse(k); b.copy(d.ray).applyMatrix4(a); var l = l / ((this.scale.x + this.scale.y + this.scale.z) / 3), m = l * l, l = new p; if (h.isBufferGeometry) { var n = h.index, h = h.attributes.position.array; if (null !== n) for (var t = n.array, n = 0, r = t.length; n < r; n++) { var u = t[n]; l.fromArray(h, 3 * u); f(l, u) } else for (n = 0, t = h.length / 3; n < t; n++)l.fromArray(h, 3 * n), f(l, n) } else for (l = h.vertices, n = 0, t = l.length; n < t; n++)f(l[n], n) }
				}
			}(), clone: function () { return (new this.constructor(this.geometry, this.material)).copy(this) }
		});
	Fc.prototype = Object.assign(Object.create(A.prototype), { constructor: Fc }); sd.prototype = Object.create(ea.prototype); sd.prototype.constructor = sd; Rb.prototype = Object.create(ea.prototype); Rb.prototype.constructor = Rb; Rb.prototype.isCompressedTexture = !0; Gc.prototype = Object.create(ea.prototype); Gc.prototype.constructor = Gc; Gc.prototype.isDepthTexture = !0; Sb.prototype = Object.create(D.prototype); Sb.prototype.constructor = Sb; Hc.prototype = Object.create(N.prototype); Hc.prototype.constructor = Hc; Tb.prototype = Object.create(D.prototype);
	Tb.prototype.constructor = Tb; Ic.prototype = Object.create(N.prototype); Ic.prototype.constructor = Ic; qa.prototype = Object.create(D.prototype); qa.prototype.constructor = qa; Jc.prototype = Object.create(N.prototype); Jc.prototype.constructor = Jc; Ub.prototype = Object.create(qa.prototype); Ub.prototype.constructor = Ub; Kc.prototype = Object.create(N.prototype); Kc.prototype.constructor = Kc; nb.prototype = Object.create(qa.prototype); nb.prototype.constructor = nb; Lc.prototype = Object.create(N.prototype); Lc.prototype.constructor =
		Lc; Vb.prototype = Object.create(qa.prototype); Vb.prototype.constructor = Vb; Mc.prototype = Object.create(N.prototype); Mc.prototype.constructor = Mc; Wb.prototype = Object.create(qa.prototype); Wb.prototype.constructor = Wb; Nc.prototype = Object.create(N.prototype); Nc.prototype.constructor = Nc; Xb.prototype = Object.create(D.prototype); Xb.prototype.constructor = Xb; Oc.prototype = Object.create(N.prototype); Oc.prototype.constructor = Oc; Yb.prototype = Object.create(D.prototype); Yb.prototype.constructor = Yb; Pc.prototype = Object.create(N.prototype);
	Pc.prototype.constructor = Pc; Zb.prototype = Object.create(D.prototype); Zb.prototype.constructor = Zb; var Ha = {
		area: function (a) { for (var b = a.length, c = 0, d = b - 1, e = 0; e < b; d = e++)c += a[d].x * a[e].y - a[e].x * a[d].y; return .5 * c }, triangulate: function () {
			return function (a, b) {
				var c = a.length; if (3 > c) return null; var d = [], e = [], f = [], g; if (0 < Ha.area(a)) for (g = 0; g < c; g++)e[g] = g; else for (g = 0; g < c; g++)e[g] = c - 1 - g; var h = 2 * c; for (g = c - 1; 2 < c;) {
					if (0 >= h--) { console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()"); break } var k =
						g; c <= k && (k = 0); g = k + 1; c <= g && (g = 0); var l = g + 1; c <= l && (l = 0); a: {
							var m; var n = a[e[k]].x; var p = a[e[k]].y; var r = a[e[g]].x; var u = a[e[g]].y; var v = a[e[l]].x; var w = a[e[l]].y; if (0 >= (r - n) * (w - p) - (u - p) * (v - n)) var x = !1; else {
								var z = v - r; var y = w - u; var B = n - v; var C = p - w; var A = r - n; x = u - p; for (m = 0; m < c; m++) {
									var D = a[e[m]].x; var E = a[e[m]].y; if (!(D === n && E === p || D === r && E === u || D === v && E === w)) {
										var H = D - n; var N = E - p; var K = D - r; var L = E - u; D -= v; E -= w; L = z * L - y * K; N = A * N - x * H; D = B * E - C * D; if (L >= -Number.EPSILON && D >= -Number.EPSILON && N >= -Number.EPSILON) {
											x =
											!1; break a
										}
									}
								} x = !0
							}
						} if (x) { d.push([a[e[k]], a[e[g]], a[e[l]]]); f.push([e[k], e[g], e[l]]); k = g; for (l = g + 1; l < c; k++ , l++)e[k] = e[l]; c--; h = 2 * c }
				} return b ? f : d
			}
		}(), triangulateShape: function (a, b) {
			function c(a) { var b = a.length; 2 < b && a[b - 1].equals(a[0]) && a.pop() } function d(a, b, c) { return a.x !== b.x ? a.x < b.x ? a.x <= c.x && c.x <= b.x : b.x <= c.x && c.x <= a.x : a.y < b.y ? a.y <= c.y && c.y <= b.y : b.y <= c.y && c.y <= a.y } function e(a, b, c, e, f) {
				var g = b.x - a.x, h = b.y - a.y, k = e.x - c.x, l = e.y - c.y, m = a.x - c.x, n = a.y - c.y, q = h * k - g * l, p = h * m - g * n; if (Math.abs(q) > Number.EPSILON) {
					if (0 <
						q) { if (0 > p || p > q) return []; k = l * m - k * n; if (0 > k || k > q) return [] } else { if (0 < p || p < q) return []; k = l * m - k * n; if (0 < k || k < q) return [] } if (0 === k) return !f || 0 !== p && p !== q ? [a] : []; if (k === q) return !f || 0 !== p && p !== q ? [b] : []; if (0 === p) return [c]; if (p === q) return [e]; f = k / q; return [{ x: a.x + f * g, y: a.y + f * h }]
				} if (0 !== p || l * m !== k * n) return []; h = 0 === g && 0 === h; k = 0 === k && 0 === l; if (h && k) return a.x !== c.x || a.y !== c.y ? [] : [a]; if (h) return d(c, e, a) ? [a] : []; if (k) return d(a, b, c) ? [c] : []; 0 !== g ? (a.x < b.x ? (g = a, k = a.x, h = b, a = b.x) : (g = b, k = b.x, h = a, a = a.x), c.x < e.x ? (b = c, q = c.x, l =
					e, c = e.x) : (b = e, q = e.x, l = c, c = c.x)) : (a.y < b.y ? (g = a, k = a.y, h = b, a = b.y) : (g = b, k = b.y, h = a, a = a.y), c.y < e.y ? (b = c, q = c.y, l = e, c = e.y) : (b = e, q = e.y, l = c, c = c.y)); return k <= q ? a < q ? [] : a === q ? f ? [] : [b] : a <= c ? [b, h] : [b, l] : k > c ? [] : k === c ? f ? [] : [g] : a <= c ? [g, h] : [g, l]
			} function f(a, b, c, d) { var e = b.x - a.x, f = b.y - a.y; b = c.x - a.x; c = c.y - a.y; var g = d.x - a.x; d = d.y - a.y; a = e * c - f * b; e = e * d - f * g; return Math.abs(a) > Number.EPSILON ? (b = g * c - d * b, 0 < a ? 0 <= e && 0 <= b : 0 <= e || 0 <= b) : 0 < e } c(a); b.forEach(c); var g, h = {}, k = a.concat(); var l = 0; for (g = b.length; l < g; l++)Array.prototype.push.apply(k,
				b[l]); l = 0; for (g = k.length; l < g; l++) { var m = k[l].x + ":" + k[l].y; void 0 !== h[m] && console.warn("THREE.ShapeUtils: Duplicate point", m, l); h[m] = l } l = function (a, b) {
					function c(a, b) { var c = h.length - 1, d = a - 1; 0 > d && (d = c); var e = a + 1; e > c && (e = 0); c = f(h[a], h[d], h[e], D[b]); if (!c) return !1; c = D.length - 1; d = b - 1; 0 > d && (d = c); e = b + 1; e > c && (e = 0); return (c = f(D[b], D[d], D[e], h[a])) ? !0 : !1 } function d(a, b) { var c; for (c = 0; c < h.length; c++) { var d = c + 1; d %= h.length; d = e(a, b, h[c], h[d], !0); if (0 < d.length) return !0 } return !1 } function g(a, c) {
						var d, f; for (d = 0; d <
							k.length; d++) { var g = b[k[d]]; for (f = 0; f < g.length; f++) { var h = f + 1; h %= g.length; h = e(a, c, g[f], g[h], !0); if (0 < h.length) return !0 } } return !1
					} var h = a.concat(), k = [], l, m; a = []; var q, n = 0; for (l = b.length; n < l; n++)k.push(n); var p = 0; for (var t = 2 * k.length; 0 < k.length;) {
						t--; if (0 > t) { console.log('THREE.ShapeUtils: Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!'); break } for (m = p; m < h.length; m++) {
							var y = h[m]; l = -1; for (n = 0; n < k.length; n++) {
								var C = k[n]; var A = y.x + ":" + y.y + ":" + C; if (void 0 === a[A]) {
									var D =
										b[C]; for (q = 0; q < D.length; q++)if (C = D[q], c(m, q) && !d(y, C) && !g(y, C)) { l = q; k.splice(n, 1); p = h.slice(0, m + 1); C = h.slice(m); q = D.slice(l); var E = D.slice(0, l + 1); h = p.concat(q).concat(E).concat(C); p = m; break } if (0 <= l) break; a[A] = !0
								}
							} if (0 <= l) break
						}
					} return h
				}(a, b); k = Ha.triangulate(l, !1); l = 0; for (g = k.length; l < g; l++)for (b = k[l], a = 0; 3 > a; a++)m = b[a].x + ":" + b[a].y, m = h[m], void 0 !== m && (b[a] = m); return k.concat()
		}, isClockWise: function (a) { return 0 > Ha.area(a) }
	}; $a.prototype = Object.create(N.prototype); $a.prototype.constructor = $a; Ga.prototype =
		Object.create(D.prototype); Ga.prototype.constructor = Ga; Ga.prototype.getArrays = function () { var a = this.getAttribute("position"), a = a ? Array.prototype.slice.call(a.array) : [], b = this.getAttribute("uv"), b = b ? Array.prototype.slice.call(b.array) : [], c = this.index, c = c ? Array.prototype.slice.call(c.array) : []; return { position: a, uv: b, index: c } }; Ga.prototype.addShapeList = function (a, b) {
			var c = a.length; b.arrays = this.getArrays(); for (var d = 0; d < c; d++)this.addShape(a[d], b); this.setIndex(b.arrays.index); this.addAttribute("position",
				new y(b.arrays.position, 3)); this.addAttribute("uv", new y(b.arrays.uv, 2))
		}; Ga.prototype.addShape = function (a, b) {
			function c(a, b, c) { b || console.error("THREE.ExtrudeGeometry: vec does not exist"); return b.clone().multiplyScalar(c).add(a) } function d(a, b, c) {
				var d = a.x - b.x; var e = a.y - b.y; var f = c.x - a.x; var g = c.y - a.y, h = d * d + e * e; if (Math.abs(d * g - e * f) > Number.EPSILON) {
					var k = Math.sqrt(h), l = Math.sqrt(f * f + g * g), h = b.x - e / k; b = b.y + d / k; g = ((c.x - g / l - h) * g - (c.y + f / l - b) * f) / (d * g - e * f); f = h + d * g - a.x; d = b + e * g - a.y; e = f * f + d * d; if (2 >= e) return new C(f,
						d); e = Math.sqrt(e / 2)
				} else a = !1, d > Number.EPSILON ? f > Number.EPSILON && (a = !0) : d < -Number.EPSILON ? f < -Number.EPSILON && (a = !0) : Math.sign(e) === Math.sign(g) && (a = !0), a ? (f = -e, e = Math.sqrt(h)) : (f = d, d = e, e = Math.sqrt(h / 2)); return new C(f / e, d / e)
			} function e(a, b) {
				for (G = a.length; 0 <= --G;) {
					var c = G; var d = G - 1; 0 > d && (d = a.length - 1); var e, f = A + 2 * w; for (e = 0; e < f; e++) {
						var g = Z * e, l = Z * (e + 1), q = b + d + g, n = b + d + l, l = b + c + l; h(b + c + g); h(q); h(l); h(q); h(n); h(l); g = m.length / 3; g = E.generateSideWallUV(R, m, g - 6, g - 3, g - 2, g - 1); k(g[0]); k(g[1]); k(g[3]); k(g[1]);
						k(g[2]); k(g[3])
					}
				}
			} function f(a, b, c) { r.push(a); r.push(b); r.push(c) } function g(a, b, c) { h(a); h(b); h(c); a = m.length / 3; a = E.generateTopUV(R, m, a - 3, a - 2, a - 1); k(a[0]); k(a[1]); k(a[2]) } function h(a) { n.push(m.length / 3); m.push(r[3 * a + 0]); m.push(r[3 * a + 1]); m.push(r[3 * a + 2]) } function k(a) { t.push(a.x); t.push(a.y) } var l = b.arrays ? b.arrays : this.getArrays(), m = l.position, n = l.index, t = l.uv, r = [], l = void 0 !== b.amount ? b.amount : 100, u = void 0 !== b.bevelThickness ? b.bevelThickness : 6, v = void 0 !== b.bevelSize ? b.bevelSize : u - 2, w = void 0 !== b.bevelSegments ?
				b.bevelSegments : 3, x = void 0 !== b.bevelEnabled ? b.bevelEnabled : !0, z = void 0 !== b.curveSegments ? b.curveSegments : 12, A = void 0 !== b.steps ? b.steps : 1, B = b.extrudePath, D = !1, E = void 0 !== b.UVGenerator ? b.UVGenerator : $a.WorldUVGenerator; if (B) { var H = B.getSpacedPoints(A); D = !0; x = !1; var N = void 0 !== b.frames ? b.frames : B.computeFrenetFrames(A, !1); var K = new p; var Q = new p; var P = new p } x || (v = u = w = 0); var L, R = this, z = a.extractPoints(z); a = z.shape; var O = z.holes; if (!Ha.isClockWise(a)) {
					a = a.reverse(); var M = 0; for (L = O.length; M < L; M++) {
						var V =
							O[M]; Ha.isClockWise(V) && (O[M] = V.reverse())
					}
				} var S = Ha.triangulateShape(a, O), W = a; M = 0; for (L = O.length; M < L; M++)V = O[M], a = a.concat(V); var aa, Z = a.length, U, ca = S.length, z = [], G = 0; var X = W.length; var fa = X - 1; for (aa = G + 1; G < X; G++ , fa++ , aa++)fa === X && (fa = 0), aa === X && (aa = 0), z[G] = d(W[G], W[fa], W[aa]); var B = [], ea = z.concat(); M = 0; for (L = O.length; M < L; M++) { V = O[M]; var da = []; G = 0; X = V.length; fa = X - 1; for (aa = G + 1; G < X; G++ , fa++ , aa++)fa === X && (fa = 0), aa === X && (aa = 0), da[G] = d(V[G], V[fa], V[aa]); B.push(da); ea = ea.concat(da) } for (fa = 0; fa < w; fa++) {
					X =
					fa / w; var ga = u * Math.cos(X * Math.PI / 2); aa = v * Math.sin(X * Math.PI / 2); G = 0; for (X = W.length; G < X; G++) { var T = c(W[G], z[G], aa); f(T.x, T.y, -ga) } M = 0; for (L = O.length; M < L; M++)for (V = O[M], da = B[M], G = 0, X = V.length; G < X; G++)T = c(V[G], da[G], aa), f(T.x, T.y, -ga)
				} aa = v; for (G = 0; G < Z; G++)T = x ? c(a[G], ea[G], aa) : a[G], D ? (Q.copy(N.normals[0]).multiplyScalar(T.x), K.copy(N.binormals[0]).multiplyScalar(T.y), P.copy(H[0]).add(Q).add(K), f(P.x, P.y, P.z)) : f(T.x, T.y, 0); for (X = 1; X <= A; X++)for (G = 0; G < Z; G++)T = x ? c(a[G], ea[G], aa) : a[G], D ? (Q.copy(N.normals[X]).multiplyScalar(T.x),
					K.copy(N.binormals[X]).multiplyScalar(T.y), P.copy(H[X]).add(Q).add(K), f(P.x, P.y, P.z)) : f(T.x, T.y, l / A * X); for (fa = w - 1; 0 <= fa; fa--) { X = fa / w; ga = u * Math.cos(X * Math.PI / 2); aa = v * Math.sin(X * Math.PI / 2); G = 0; for (X = W.length; G < X; G++)T = c(W[G], z[G], aa), f(T.x, T.y, l + ga); M = 0; for (L = O.length; M < L; M++)for (V = O[M], da = B[M], G = 0, X = V.length; G < X; G++)T = c(V[G], da[G], aa), D ? f(T.x, T.y + H[A - 1].y, H[A - 1].x + ga) : f(T.x, T.y, l + ga) } (function () {
						var a = m.length / 3; if (x) {
							var c = 0 * Z; for (G = 0; G < ca; G++)U = S[G], g(U[2] + c, U[1] + c, U[0] + c); c = Z * (A + 2 * w); for (G = 0; G <
								ca; G++)U = S[G], g(U[0] + c, U[1] + c, U[2] + c)
						} else { for (G = 0; G < ca; G++)U = S[G], g(U[2], U[1], U[0]); for (G = 0; G < ca; G++)U = S[G], g(U[0] + Z * A, U[1] + Z * A, U[2] + Z * A) } R.addGroup(a, m.length / 3 - a, void 0 !== b.material ? b.material : 0)
					})(); (function () { var a = m.length / 3, c = 0; e(W, c); c += W.length; M = 0; for (L = O.length; M < L; M++)V = O[M], e(V, c), c += V.length; R.addGroup(a, m.length / 3 - a, void 0 !== b.extrudeMaterial ? b.extrudeMaterial : 1) })(); b.arrays || (this.setIndex(n), this.addAttribute("position", new y(m, 3)), this.addAttribute("uv", new y(b.arrays.uv, 2)))
		};
	$a.WorldUVGenerator = { generateTopUV: function (a, b, c, d, e) { a = b[3 * d]; d = b[3 * d + 1]; var f = b[3 * e]; e = b[3 * e + 1]; return [new C(b[3 * c], b[3 * c + 1]), new C(a, d), new C(f, e)] }, generateSideWallUV: function (a, b, c, d, e, f) { a = b[3 * c]; var g = b[3 * c + 1]; c = b[3 * c + 2]; var h = b[3 * d], k = b[3 * d + 1]; d = b[3 * d + 2]; var l = b[3 * e], m = b[3 * e + 1]; e = b[3 * e + 2]; var n = b[3 * f], p = b[3 * f + 1]; b = b[3 * f + 2]; return .01 > Math.abs(g - k) ? [new C(a, 1 - c), new C(h, 1 - d), new C(l, 1 - e), new C(n, 1 - b)] : [new C(g, 1 - c), new C(k, 1 - d), new C(m, 1 - e), new C(p, 1 - b)] } }; Qc.prototype = Object.create(N.prototype);
	Qc.prototype.constructor = Qc; $b.prototype = Object.create(Ga.prototype); $b.prototype.constructor = $b; Rc.prototype = Object.create(N.prototype); Rc.prototype.constructor = Rc; ob.prototype = Object.create(D.prototype); ob.prototype.constructor = ob; Sc.prototype = Object.create(N.prototype); Sc.prototype.constructor = Sc; ac.prototype = Object.create(D.prototype); ac.prototype.constructor = ac; Tc.prototype = Object.create(N.prototype); Tc.prototype.constructor = Tc; bc.prototype = Object.create(D.prototype); bc.prototype.constructor =
		bc; cc.prototype = Object.create(N.prototype); cc.prototype.constructor = cc; dc.prototype = Object.create(D.prototype); dc.prototype.constructor = dc; ec.prototype = Object.create(D.prototype); ec.prototype.constructor = ec; pb.prototype = Object.create(N.prototype); pb.prototype.constructor = pb; Sa.prototype = Object.create(D.prototype); Sa.prototype.constructor = Sa; Uc.prototype = Object.create(pb.prototype); Uc.prototype.constructor = Uc; Vc.prototype = Object.create(Sa.prototype); Vc.prototype.constructor = Vc; Wc.prototype = Object.create(N.prototype);
	Wc.prototype.constructor = Wc; fc.prototype = Object.create(D.prototype); fc.prototype.constructor = fc; var Ca = Object.freeze({
		WireframeGeometry: Sb, ParametricGeometry: Hc, ParametricBufferGeometry: Tb, TetrahedronGeometry: Jc, TetrahedronBufferGeometry: Ub, OctahedronGeometry: Kc, OctahedronBufferGeometry: nb, IcosahedronGeometry: Lc, IcosahedronBufferGeometry: Vb, DodecahedronGeometry: Mc, DodecahedronBufferGeometry: Wb, PolyhedronGeometry: Ic, PolyhedronBufferGeometry: qa, TubeGeometry: Nc, TubeBufferGeometry: Xb, TorusKnotGeometry: Oc,
		TorusKnotBufferGeometry: Yb, TorusGeometry: Pc, TorusBufferGeometry: Zb, TextGeometry: Qc, TextBufferGeometry: $b, SphereGeometry: Rc, SphereBufferGeometry: ob, RingGeometry: Sc, RingBufferGeometry: ac, PlaneGeometry: Ac, PlaneBufferGeometry: kb, LatheGeometry: Tc, LatheBufferGeometry: bc, ShapeGeometry: cc, ShapeBufferGeometry: dc, ExtrudeGeometry: $a, ExtrudeBufferGeometry: Ga, EdgesGeometry: ec, ConeGeometry: Uc, ConeBufferGeometry: Vc, CylinderGeometry: pb, CylinderBufferGeometry: Sa, CircleGeometry: Wc, CircleBufferGeometry: fc, BoxGeometry: Lb,
		BoxBufferGeometry: jb
	}); gc.prototype = Object.create(Q.prototype); gc.prototype.constructor = gc; gc.prototype.isShadowMaterial = !0; hc.prototype = Object.create(oa.prototype); hc.prototype.constructor = hc; hc.prototype.isRawShaderMaterial = !0; Ma.prototype = Object.create(Q.prototype); Ma.prototype.constructor = Ma; Ma.prototype.isMeshStandardMaterial = !0; Ma.prototype.copy = function (a) {
		Q.prototype.copy.call(this, a); this.defines = { STANDARD: "" }; this.color.copy(a.color); this.roughness = a.roughness; this.metalness = a.metalness;
		this.map = a.map; this.lightMap = a.lightMap; this.lightMapIntensity = a.lightMapIntensity; this.aoMap = a.aoMap; this.aoMapIntensity = a.aoMapIntensity; this.emissive.copy(a.emissive); this.emissiveMap = a.emissiveMap; this.emissiveIntensity = a.emissiveIntensity; this.bumpMap = a.bumpMap; this.bumpScale = a.bumpScale; this.normalMap = a.normalMap; this.normalScale.copy(a.normalScale); this.displacementMap = a.displacementMap; this.displacementScale = a.displacementScale; this.displacementBias = a.displacementBias; this.roughnessMap = a.roughnessMap;
		this.metalnessMap = a.metalnessMap; this.alphaMap = a.alphaMap; this.envMap = a.envMap; this.envMapIntensity = a.envMapIntensity; this.refractionRatio = a.refractionRatio; this.wireframe = a.wireframe; this.wireframeLinewidth = a.wireframeLinewidth; this.wireframeLinecap = a.wireframeLinecap; this.wireframeLinejoin = a.wireframeLinejoin; this.skinning = a.skinning; this.morphTargets = a.morphTargets; this.morphNormals = a.morphNormals; return this
	}; qb.prototype = Object.create(Ma.prototype); qb.prototype.constructor = qb; qb.prototype.isMeshPhysicalMaterial =
		!0; qb.prototype.copy = function (a) { Ma.prototype.copy.call(this, a); this.defines = { PHYSICAL: "" }; this.reflectivity = a.reflectivity; this.clearCoat = a.clearCoat; this.clearCoatRoughness = a.clearCoatRoughness; return this }; Ia.prototype = Object.create(Q.prototype); Ia.prototype.constructor = Ia; Ia.prototype.isMeshPhongMaterial = !0; Ia.prototype.copy = function (a) {
			Q.prototype.copy.call(this, a); this.color.copy(a.color); this.specular.copy(a.specular); this.shininess = a.shininess; this.map = a.map; this.lightMap = a.lightMap; this.lightMapIntensity =
				a.lightMapIntensity; this.aoMap = a.aoMap; this.aoMapIntensity = a.aoMapIntensity; this.emissive.copy(a.emissive); this.emissiveMap = a.emissiveMap; this.emissiveIntensity = a.emissiveIntensity; this.bumpMap = a.bumpMap; this.bumpScale = a.bumpScale; this.normalMap = a.normalMap; this.normalScale.copy(a.normalScale); this.displacementMap = a.displacementMap; this.displacementScale = a.displacementScale; this.displacementBias = a.displacementBias; this.specularMap = a.specularMap; this.alphaMap = a.alphaMap; this.envMap = a.envMap; this.combine =
					a.combine; this.reflectivity = a.reflectivity; this.refractionRatio = a.refractionRatio; this.wireframe = a.wireframe; this.wireframeLinewidth = a.wireframeLinewidth; this.wireframeLinecap = a.wireframeLinecap; this.wireframeLinejoin = a.wireframeLinejoin; this.skinning = a.skinning; this.morphTargets = a.morphTargets; this.morphNormals = a.morphNormals; return this
		}; rb.prototype = Object.create(Ia.prototype); rb.prototype.constructor = rb; rb.prototype.isMeshToonMaterial = !0; rb.prototype.copy = function (a) {
			Ia.prototype.copy.call(this,
				a); this.gradientMap = a.gradientMap; return this
		}; sb.prototype = Object.create(Q.prototype); sb.prototype.constructor = sb; sb.prototype.isMeshNormalMaterial = !0; sb.prototype.copy = function (a) {
			Q.prototype.copy.call(this, a); this.bumpMap = a.bumpMap; this.bumpScale = a.bumpScale; this.normalMap = a.normalMap; this.normalScale.copy(a.normalScale); this.displacementMap = a.displacementMap; this.displacementScale = a.displacementScale; this.displacementBias = a.displacementBias; this.wireframe = a.wireframe; this.wireframeLinewidth = a.wireframeLinewidth;
			this.skinning = a.skinning; this.morphTargets = a.morphTargets; this.morphNormals = a.morphNormals; return this
		}; tb.prototype = Object.create(Q.prototype); tb.prototype.constructor = tb; tb.prototype.isMeshLambertMaterial = !0; tb.prototype.copy = function (a) {
			Q.prototype.copy.call(this, a); this.color.copy(a.color); this.map = a.map; this.lightMap = a.lightMap; this.lightMapIntensity = a.lightMapIntensity; this.aoMap = a.aoMap; this.aoMapIntensity = a.aoMapIntensity; this.emissive.copy(a.emissive); this.emissiveMap = a.emissiveMap; this.emissiveIntensity =
				a.emissiveIntensity; this.specularMap = a.specularMap; this.alphaMap = a.alphaMap; this.envMap = a.envMap; this.combine = a.combine; this.reflectivity = a.reflectivity; this.refractionRatio = a.refractionRatio; this.wireframe = a.wireframe; this.wireframeLinewidth = a.wireframeLinewidth; this.wireframeLinecap = a.wireframeLinecap; this.wireframeLinejoin = a.wireframeLinejoin; this.skinning = a.skinning; this.morphTargets = a.morphTargets; this.morphNormals = a.morphNormals; return this
		}; ub.prototype = Object.create(O.prototype); ub.prototype.constructor =
			ub; ub.prototype.isLineDashedMaterial = !0; ub.prototype.copy = function (a) { O.prototype.copy.call(this, a); this.scale = a.scale; this.dashSize = a.dashSize; this.gapSize = a.gapSize; return this }; var tg = Object.freeze({
				ShadowMaterial: gc, SpriteMaterial: Za, RawShaderMaterial: hc, ShaderMaterial: oa, PointsMaterial: Ba, MeshPhysicalMaterial: qb, MeshStandardMaterial: Ma, MeshPhongMaterial: Ia, MeshToonMaterial: rb, MeshNormalMaterial: sb, MeshLambertMaterial: tb, MeshDepthMaterial: Wa, MeshDistanceMaterial: Xa, MeshBasicMaterial: va, LineDashedMaterial: ub,
				LineBasicMaterial: O, Material: Q
			}), jd = { enabled: !1, files: {}, add: function (a, b) { !1 !== this.enabled && (this.files[a] = b) }, get: function (a) { if (!1 !== this.enabled) return this.files[a] }, remove: function (a) { delete this.files[a] }, clear: function () { this.files = {} } }, wa = new Yd, Ta = {}; Object.assign(Ja.prototype, {
				load: function (a, b, c, d) {
				void 0 === a && (a = ""); void 0 !== this.path && (a = this.path + a); a = this.manager.resolveURL(a); var e = this, f = jd.get(a); if (void 0 !== f) return e.manager.itemStart(a), setTimeout(function () { b && b(f); e.manager.itemEnd(a) },
					0), f; if (void 0 !== Ta[a]) Ta[a].push({ onLoad: b, onProgress: c, onError: d }); else {
						var g = a.match(/^data:(.*?)(;base64)?,(.*)$/); if (g) {
							c = g[1]; var h = !!g[2], g = g[3], g = window.decodeURIComponent(g); h && (g = window.atob(g)); try {
								var k = (this.responseType || "").toLowerCase(); switch (k) {
									case "arraybuffer": case "blob": for (var l = new Uint8Array(g.length), h = 0; h < g.length; h++)l[h] = g.charCodeAt(h); var m = "blob" === k ? new Blob([l.buffer], { type: c }) : l.buffer; break; case "document": m = (new DOMParser).parseFromString(g, c); break; case "json": m =
										JSON.parse(g); break; default: m = g
								}window.setTimeout(function () { b && b(m); e.manager.itemEnd(a) }, 0)
							} catch (t) { window.setTimeout(function () { d && d(t); e.manager.itemEnd(a); e.manager.itemError(a) }, 0) }
						} else {
						Ta[a] = []; Ta[a].push({ onLoad: b, onProgress: c, onError: d }); var n = new XMLHttpRequest; n.open("GET", a, !0); n.addEventListener("load", function (b) {
							var c = b.target.response; jd.add(a, c); var d = Ta[a]; delete Ta[a]; if (200 === this.status) { for (var f = 0, g = d.length; f < g; f++) { var h = d[f]; if (h.onLoad) h.onLoad(c) } e.manager.itemEnd(a) } else if (0 ===
								this.status) { console.warn("THREE.FileLoader: HTTP Status 0 received."); f = 0; for (g = d.length; f < g; f++)if (h = d[f], h.onLoad) h.onLoad(c); e.manager.itemEnd(a) } else { f = 0; for (g = d.length; f < g; f++)if (h = d[f], h.onError) h.onError(b); e.manager.itemEnd(a); e.manager.itemError(a) }
						}, !1); n.addEventListener("progress", function (b) { for (var c = Ta[a], d = 0, e = c.length; d < e; d++) { var f = c[d]; if (f.onProgress) f.onProgress(b) } }, !1); n.addEventListener("error", function (b) {
							var c = Ta[a]; delete Ta[a]; for (var d = 0, f = c.length; d < f; d++) {
								var g = c[d];
								if (g.onError) g.onError(b)
							} e.manager.itemEnd(a); e.manager.itemError(a)
						}, !1); void 0 !== this.responseType && (n.responseType = this.responseType); void 0 !== this.withCredentials && (n.withCredentials = this.withCredentials); n.overrideMimeType && n.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"); for (h in this.requestHeader) n.setRequestHeader(h, this.requestHeader[h]); n.send(null)
						} e.manager.itemStart(a); return n
					}
				}, setPath: function (a) { this.path = a; return this }, setResponseType: function (a) {
				this.responseType =
					a; return this
				}, setWithCredentials: function (a) { this.withCredentials = a; return this }, setMimeType: function (a) { this.mimeType = a; return this }, setRequestHeader: function (a) { this.requestHeader = a; return this }
			}); Object.assign(Qe.prototype, {
				load: function (a, b, c, d) {
					function e(e) { l.load(a[e], function (a) { a = g._parser(a, !0); h[e] = { width: a.width, height: a.height, format: a.format, mipmaps: a.mipmaps }; f += 1; 6 === f && (1 === a.mipmapCount && (k.minFilter = 1006), k.format = a.format, k.needsUpdate = !0, b && b(k)) }, c, d) } var f, g = this, h = [], k = new Rb;
					k.image = h; var l = new Ja(this.manager); l.setPath(this.path); l.setResponseType("arraybuffer"); if (Array.isArray(a)) for (var m = f = 0, n = a.length; m < n; ++m)e(m); else l.load(a, function (a) {
						a = g._parser(a, !0); if (a.isCubemap) for (var c = a.mipmaps.length / a.mipmapCount, d = 0; d < c; d++) { h[d] = { mipmaps: [] }; for (var e = 0; e < a.mipmapCount; e++)h[d].mipmaps.push(a.mipmaps[d * a.mipmapCount + e]), h[d].format = a.format, h[d].width = a.width, h[d].height = a.height } else k.image.width = a.width, k.image.height = a.height, k.mipmaps = a.mipmaps; 1 === a.mipmapCount &&
							(k.minFilter = 1006); k.format = a.format; k.needsUpdate = !0; b && b(k)
					}, c, d); return k
				}, setPath: function (a) { this.path = a; return this }
			}); Object.assign(Zd.prototype, {
				load: function (a, b, c, d) {
					var e = this, f = new fb, g = new Ja(this.manager); g.setResponseType("arraybuffer"); g.load(a, function (a) {
						if (a = e._parser(a)) void 0 !== a.image ? f.image = a.image : void 0 !== a.data && (f.image.width = a.width, f.image.height = a.height, f.image.data = a.data), f.wrapS = void 0 !== a.wrapS ? a.wrapS : 1001, f.wrapT = void 0 !== a.wrapT ? a.wrapT : 1001, f.magFilter = void 0 !==
							a.magFilter ? a.magFilter : 1006, f.minFilter = void 0 !== a.minFilter ? a.minFilter : 1008, f.anisotropy = void 0 !== a.anisotropy ? a.anisotropy : 1, void 0 !== a.format && (f.format = a.format), void 0 !== a.type && (f.type = a.type), void 0 !== a.mipmaps && (f.mipmaps = a.mipmaps), 1 === a.mipmapCount && (f.minFilter = 1006), f.needsUpdate = !0, b && b(f, a)
					}, c, d); return f
				}
			}); Object.assign(Xc.prototype, {
				crossOrigin: "Anonymous", load: function (a, b, c, d) {
				void 0 === a && (a = ""); void 0 !== this.path && (a = this.path + a); a = this.manager.resolveURL(a); var e = this, f = jd.get(a);
					if (void 0 !== f) return e.manager.itemStart(a), setTimeout(function () { b && b(f); e.manager.itemEnd(a) }, 0), f; c = document.createElementNS("http://www.w3.org/1999/xhtml", "img"); c.addEventListener("load", function () { jd.add(a, this); b && b(this); e.manager.itemEnd(a) }, !1); c.addEventListener("error", function (b) { d && d(b); e.manager.itemEnd(a); e.manager.itemError(a) }, !1); "data:" !== a.substr(0, 5) && void 0 !== this.crossOrigin && (c.crossOrigin = this.crossOrigin); e.manager.itemStart(a); c.src = a; return c
				}, setCrossOrigin: function (a) {
				this.crossOrigin =
					a; return this
				}, setPath: function (a) { this.path = a; return this }
			}); Object.assign($d.prototype, { crossOrigin: "Anonymous", load: function (a, b, c, d) { function e(c) { g.load(a[c], function (a) { f.images[c] = a; h++; 6 === h && (f.needsUpdate = !0, b && b(f)) }, void 0, d) } var f = new Ua, g = new Xc(this.manager); g.setCrossOrigin(this.crossOrigin); g.setPath(this.path); var h = 0; for (c = 0; c < a.length; ++c)e(c); return f }, setCrossOrigin: function (a) { this.crossOrigin = a; return this }, setPath: function (a) { this.path = a; return this } }); Object.assign(td.prototype,
				{ crossOrigin: "Anonymous", load: function (a, b, c, d) { var e = new Xc(this.manager); e.setCrossOrigin(this.crossOrigin); e.setPath(this.path); var f = new ea; f.image = e.load(a, function () { var c = 0 < a.search(/\.(jpg|jpeg)$/) || 0 === a.search(/^data\:image\/jpeg/); f.format = c ? 1022 : 1023; f.needsUpdate = !0; void 0 !== b && b(f) }, c, d); return f }, setCrossOrigin: function (a) { this.crossOrigin = a; return this }, setPath: function (a) { this.path = a; return this } }); ga.prototype = Object.assign(Object.create(A.prototype), {
					constructor: ga, isLight: !0, copy: function (a) {
						A.prototype.copy.call(this,
							a); this.color.copy(a.color); this.intensity = a.intensity; return this
					}, toJSON: function (a) {
						a = A.prototype.toJSON.call(this, a); a.object.color = this.color.getHex(); a.object.intensity = this.intensity; void 0 !== this.groundColor && (a.object.groundColor = this.groundColor.getHex()); void 0 !== this.distance && (a.object.distance = this.distance); void 0 !== this.angle && (a.object.angle = this.angle); void 0 !== this.decay && (a.object.decay = this.decay); void 0 !== this.penumbra && (a.object.penumbra = this.penumbra); void 0 !== this.shadow &&
							(a.object.shadow = this.shadow.toJSON()); return a
					}
				}); ud.prototype = Object.assign(Object.create(ga.prototype), { constructor: ud, isHemisphereLight: !0, copy: function (a) { ga.prototype.copy.call(this, a); this.groundColor.copy(a.groundColor); return this } }); Object.assign(vb.prototype, {
					copy: function (a) { this.camera = a.camera.clone(); this.bias = a.bias; this.radius = a.radius; this.mapSize.copy(a.mapSize); return this }, clone: function () { return (new this.constructor).copy(this) }, toJSON: function () {
						var a = {}; 0 !== this.bias && (a.bias =
							this.bias); 1 !== this.radius && (a.radius = this.radius); if (512 !== this.mapSize.x || 512 !== this.mapSize.y) a.mapSize = this.mapSize.toArray(); a.camera = this.camera.toJSON(!1).object; delete a.camera.matrix; return a
					}
				}); vd.prototype = Object.assign(Object.create(vb.prototype), { constructor: vd, isSpotLightShadow: !0, update: function (a) { var b = this.camera, c = 2 * R.RAD2DEG * a.angle, d = this.mapSize.width / this.mapSize.height; a = a.distance || b.far; if (c !== b.fov || d !== b.aspect || a !== b.far) b.fov = c, b.aspect = d, b.far = a, b.updateProjectionMatrix() } });
	wd.prototype = Object.assign(Object.create(ga.prototype), { constructor: wd, isSpotLight: !0, copy: function (a) { ga.prototype.copy.call(this, a); this.distance = a.distance; this.angle = a.angle; this.penumbra = a.penumbra; this.decay = a.decay; this.target = a.target.clone(); this.shadow = a.shadow.clone(); return this } }); xd.prototype = Object.assign(Object.create(ga.prototype), {
		constructor: xd, isPointLight: !0, copy: function (a) {
			ga.prototype.copy.call(this, a); this.distance = a.distance; this.decay = a.decay; this.shadow = a.shadow.clone();
			return this
		}
	}); yd.prototype = Object.assign(Object.create(vb.prototype), { constructor: yd }); zd.prototype = Object.assign(Object.create(ga.prototype), { constructor: zd, isDirectionalLight: !0, copy: function (a) { ga.prototype.copy.call(this, a); this.target = a.target.clone(); this.shadow = a.shadow.clone(); return this } }); Ad.prototype = Object.assign(Object.create(ga.prototype), { constructor: Ad, isAmbientLight: !0 }); Bd.prototype = Object.assign(Object.create(ga.prototype), {
		constructor: Bd, isRectAreaLight: !0, copy: function (a) {
			ga.prototype.copy.call(this,
				a); this.width = a.width; this.height = a.height; return this
		}, toJSON: function (a) { a = ga.prototype.toJSON.call(this, a); a.object.width = this.width; a.object.height = this.height; return a }
	}); var T = {
		arraySlice: function (a, b, c) { return T.isTypedArray(a) ? new a.constructor(a.subarray(b, void 0 !== c ? c : a.length)) : a.slice(b, c) }, convertArray: function (a, b, c) { return !a || !c && a.constructor === b ? a : "number" === typeof b.BYTES_PER_ELEMENT ? new b(a) : Array.prototype.slice.call(a) }, isTypedArray: function (a) {
			return ArrayBuffer.isView(a) && !(a instanceof
				DataView)
		}, getKeyframeOrder: function (a) { for (var b = a.length, c = Array(b), d = 0; d !== b; ++d)c[d] = d; c.sort(function (b, c) { return a[b] - a[c] }); return c }, sortedArray: function (a, b, c) { for (var d = a.length, e = new a.constructor(d), f = 0, g = 0; g !== d; ++f)for (var h = c[f] * b, k = 0; k !== b; ++k)e[g++] = a[h + k]; return e }, flattenJSON: function (a, b, c, d) {
			for (var e = 1, f = a[0]; void 0 !== f && void 0 === f[d];)f = a[e++]; if (void 0 !== f) {
				var g = f[d]; if (void 0 !== g) if (Array.isArray(g)) {
					do g = f[d], void 0 !== g && (b.push(f.time), c.push.apply(c, g)), f = a[e++]; while (void 0 !==
						f)
				} else if (void 0 !== g.toArray) { do g = f[d], void 0 !== g && (b.push(f.time), g.toArray(c, c.length)), f = a[e++]; while (void 0 !== f) } else { do g = f[d], void 0 !== g && (b.push(f.time), c.push(g)), f = a[e++]; while (void 0 !== f) }
			}
		}
	}; Object.assign(xa.prototype, {
		evaluate: function (a) {
			var b = this.parameterPositions, c = this._cachedIndex, d = b[c], e = b[c - 1]; a: {
				b: {
					c: {
						d: if (!(a < d)) {
							for (var f = c + 2; ;) { if (void 0 === d) { if (a < e) break d; this._cachedIndex = c = b.length; return this.afterEnd_(c - 1, a, e) } if (c === f) break; e = d; d = b[++c]; if (a < d) break b } d = b.length;
							break c
						} if (a >= e) break a; else { f = b[1]; a < f && (c = 2, e = f); for (f = c - 2; ;) { if (void 0 === e) return this._cachedIndex = 0, this.beforeStart_(0, a, d); if (c === f) break; d = e; e = b[--c - 1]; if (a >= e) break b } d = c; c = 0 }
					} for (; c < d;)e = c + d >>> 1, a < b[e] ? d = e : c = e + 1; d = b[c]; e = b[c - 1]; if (void 0 === e) return this._cachedIndex = 0, this.beforeStart_(0, a, d); if (void 0 === d) return this._cachedIndex = c = b.length, this.afterEnd_(c - 1, e, a)
				} this._cachedIndex = c; this.intervalChanged_(c, e, d)
			} return this.interpolate_(c, e, a, d)
		}, settings: null, DefaultSettings_: {}, getSettings_: function () {
			return this.settings ||
				this.DefaultSettings_
		}, copySampleValue_: function (a) { var b = this.resultBuffer, c = this.sampleValues, d = this.valueSize; a *= d; for (var e = 0; e !== d; ++e)b[e] = c[a + e]; return b }, interpolate_: function () { throw Error("call to abstract method"); }, intervalChanged_: function () { }
	}); Object.assign(xa.prototype, { beforeStart_: xa.prototype.copySampleValue_, afterEnd_: xa.prototype.copySampleValue_ }); Cd.prototype = Object.assign(Object.create(xa.prototype), {
		constructor: Cd, DefaultSettings_: { endingStart: 2400, endingEnd: 2400 }, intervalChanged_: function (a,
			b, c) { var d = this.parameterPositions, e = a - 2, f = a + 1, g = d[e], h = d[f]; if (void 0 === g) switch (this.getSettings_().endingStart) { case 2401: e = a; g = 2 * b - c; break; case 2402: e = d.length - 2; g = b + d[e] - d[e + 1]; break; default: e = a, g = c }if (void 0 === h) switch (this.getSettings_().endingEnd) { case 2401: f = a; h = 2 * c - b; break; case 2402: f = 1; h = c + d[1] - d[0]; break; default: f = a - 1, h = b }a = .5 * (c - b); d = this.valueSize; this._weightPrev = a / (b - g); this._weightNext = a / (h - c); this._offsetPrev = e * d; this._offsetNext = f * d }, interpolate_: function (a, b, c, d) {
				var e = this.resultBuffer,
				f = this.sampleValues, g = this.valueSize; a *= g; var h = a - g, k = this._offsetPrev, l = this._offsetNext, m = this._weightPrev, n = this._weightNext, p = (c - b) / (d - b); c = p * p; d = c * p; b = -m * d + 2 * m * c - m * p; m = (1 + m) * d + (-1.5 - 2 * m) * c + (-.5 + m) * p + 1; p = (-1 - n) * d + (1.5 + n) * c + .5 * p; n = n * d - n * c; for (c = 0; c !== g; ++c)e[c] = b * f[k + c] + m * f[h + c] + p * f[a + c] + n * f[l + c]; return e
			}
	}); Yc.prototype = Object.assign(Object.create(xa.prototype), {
		constructor: Yc, interpolate_: function (a, b, c, d) {
			var e = this.resultBuffer, f = this.sampleValues, g = this.valueSize; a *= g; var h = a - g; b = (c - b) / (d -
				b); c = 1 - b; for (d = 0; d !== g; ++d)e[d] = f[h + d] * c + f[a + d] * b; return e
		}
	}); Dd.prototype = Object.assign(Object.create(xa.prototype), { constructor: Dd, interpolate_: function (a) { return this.copySampleValue_(a - 1) } }); var eb = {
		TimeBufferType: Float32Array, ValueBufferType: Float32Array, DefaultInterpolation: 2301, InterpolantFactoryMethodDiscrete: function (a) { return new Dd(this.times, this.values, this.getValueSize(), a) }, InterpolantFactoryMethodLinear: function (a) { return new Yc(this.times, this.values, this.getValueSize(), a) }, InterpolantFactoryMethodSmooth: function (a) {
			return new Cd(this.times,
				this.values, this.getValueSize(), a)
		}, setInterpolation: function (a) {
			switch (a) { case 2300: var b = this.InterpolantFactoryMethodDiscrete; break; case 2301: b = this.InterpolantFactoryMethodLinear; break; case 2302: b = this.InterpolantFactoryMethodSmooth }if (void 0 === b) {
				b = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (void 0 === this.createInterpolant) if (a !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation); else throw Error(b); console.warn("THREE.KeyframeTrackPrototype:",
					b)
			} else this.createInterpolant = b
		}, getInterpolation: function () { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return 2300; case this.InterpolantFactoryMethodLinear: return 2301; case this.InterpolantFactoryMethodSmooth: return 2302 } }, getValueSize: function () { return this.values.length / this.times.length }, shift: function (a) { if (0 !== a) for (var b = this.times, c = 0, d = b.length; c !== d; ++c)b[c] += a; return this }, scale: function (a) { if (1 !== a) for (var b = this.times, c = 0, d = b.length; c !== d; ++c)b[c] *= a; return this },
		trim: function (a, b) { for (var c = this.times, d = c.length, e = 0, f = d - 1; e !== d && c[e] < a;)++e; for (; -1 !== f && c[f] > b;)--f; ++f; if (0 !== e || f !== d) e >= f && (f = Math.max(f, 1), e = f - 1), a = this.getValueSize(), this.times = T.arraySlice(c, e, f), this.values = T.arraySlice(this.values, e * a, f * a); return this }, validate: function () {
			var a = !0, b = this.getValueSize(); 0 !== b - Math.floor(b) && (console.error("THREE.KeyframeTrackPrototype: Invalid value size in track.", this), a = !1); var c = this.times, b = this.values, d = c.length; 0 === d && (console.error("THREE.KeyframeTrackPrototype: Track is empty.",
				this), a = !1); for (var e = null, f = 0; f !== d; f++) { var g = c[f]; if ("number" === typeof g && isNaN(g)) { console.error("THREE.KeyframeTrackPrototype: Time is not a valid number.", this, f, g); a = !1; break } if (null !== e && e > g) { console.error("THREE.KeyframeTrackPrototype: Out of order keys.", this, f, g, e); a = !1; break } e = g } if (void 0 !== b && T.isTypedArray(b)) for (f = 0, c = b.length; f !== c; ++f)if (d = b[f], isNaN(d)) { console.error("THREE.KeyframeTrackPrototype: Value is not a valid number.", this, f, d); a = !1; break } return a
		}, optimize: function () {
			for (var a,
				b, c = this.times, d = this.values, e = this.getValueSize(), f = 2302 === this.getInterpolation(), g = 1, h = c.length - 1, k = 1; k < h; ++k) { a = !1; var l = c[k]; if (l !== c[k + 1] && (1 !== k || l !== l[0])) if (f) a = !0; else { b = k * e; for (var m = b - e, n = b + e, l = 0; l !== e; ++l) { var p = d[b + l]; if (p !== d[m + l] || p !== d[n + l]) { a = !0; break } } } if (a) { if (k !== g) for (c[g] = c[k], b = k * e, a = g * e, l = 0; l !== e; ++l)d[a + l] = d[b + l]; ++g } } if (0 < h) { c[g] = c[h]; b = h * e; a = g * e; for (l = 0; l !== e; ++l)d[a + l] = d[b + l]; ++g } g !== c.length && (this.times = T.arraySlice(c, 0, g), this.values = T.arraySlice(d, 0, g * e)); return this
		}
	};
	ic.prototype = Object.assign(Object.create(eb), { constructor: ic, ValueTypeName: "vector" }); Ed.prototype = Object.assign(Object.create(xa.prototype), { constructor: Ed, interpolate_: function (a, b, c, d) { var e = this.resultBuffer, f = this.sampleValues, g = this.valueSize; a *= g; b = (c - b) / (d - b); for (c = a + g; a !== c; a += 4)Z.slerpFlat(e, 0, f, a - g, f, a, b); return e } }); Zc.prototype = Object.assign(Object.create(eb), {
		constructor: Zc, ValueTypeName: "quaternion", DefaultInterpolation: 2301, InterpolantFactoryMethodLinear: function (a) {
			return new Ed(this.times,
				this.values, this.getValueSize(), a)
		}, InterpolantFactoryMethodSmooth: void 0
	}); jc.prototype = Object.assign(Object.create(eb), { constructor: jc, ValueTypeName: "number" }); Fd.prototype = Object.assign(Object.create(eb), { constructor: Fd, ValueTypeName: "string", ValueBufferType: Array, DefaultInterpolation: 2300, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }); Gd.prototype = Object.assign(Object.create(eb), {
		constructor: Gd, ValueTypeName: "bool", ValueBufferType: Array, DefaultInterpolation: 2300,
		InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0
	}); Hd.prototype = Object.assign(Object.create(eb), { constructor: Hd, ValueTypeName: "color" }); xb.prototype = eb; eb.constructor = xb; Object.assign(xb, {
		parse: function (a) {
			if (void 0 === a.type) throw Error("track type undefined, can not parse"); var b = xb._getTrackTypeForValueTypeName(a.type); if (void 0 === a.times) { var c = [], d = []; T.flattenJSON(a.keys, c, d, "value"); a.times = c; a.values = d } return void 0 !== b.parse ? b.parse(a) : new b(a.name, a.times, a.values,
				a.interpolation)
		}, toJSON: function (a) { var b = a.constructor; if (void 0 !== b.toJSON) b = b.toJSON(a); else { var b = { name: a.name, times: T.convertArray(a.times, Array), values: T.convertArray(a.values, Array) }, c = a.getInterpolation(); c !== a.DefaultInterpolation && (b.interpolation = c) } b.type = a.ValueTypeName; return b }, _getTrackTypeForValueTypeName: function (a) {
			switch (a.toLowerCase()) {
				case "scalar": case "double": case "float": case "number": case "integer": return jc; case "vector": case "vector2": case "vector3": case "vector4": return ic;
				case "color": return Hd; case "quaternion": return Zc; case "bool": case "boolean": return Gd; case "string": return Fd
			}throw Error("Unsupported typeName: " + a);
		}
	}); Object.assign(ka, {
		parse: function (a) { for (var b = [], c = a.tracks, d = 1 / (a.fps || 1), e = 0, f = c.length; e !== f; ++e)b.push(xb.parse(c[e]).scale(d)); return new ka(a.name, a.duration, b) }, toJSON: function (a) { var b = [], c = a.tracks; a = { name: a.name, duration: a.duration, tracks: b }; for (var d = 0, e = c.length; d !== e; ++d)b.push(xb.toJSON(c[d])); return a }, CreateFromMorphTargetSequence: function (a,
			b, c, d) { for (var e = b.length, f = [], g = 0; g < e; g++) { var h = [], k = []; h.push((g + e - 1) % e, g, (g + 1) % e); k.push(0, 1, 0); var l = T.getKeyframeOrder(h), h = T.sortedArray(h, 1, l), k = T.sortedArray(k, 1, l); d || 0 !== h[0] || (h.push(e), k.push(k[0])); f.push((new jc(".morphTargetInfluences[" + b[g].name + "]", h, k)).scale(1 / c)) } return new ka(a, -1, f) }, findByName: function (a, b) { var c = a; Array.isArray(a) || (c = a.geometry && a.geometry.animations || a.animations); for (a = 0; a < c.length; a++)if (c[a].name === b) return c[a]; return null }, CreateClipsFromMorphTargetSequences: function (a,
				b, c) { for (var d, e = {}, f = /^([\w-]*?)([\d]+)$/, g = 0, h = a.length; g < h; g++) { var k = a[g], l = k.name.match(f); l && 1 < l.length && (d = l[1], (l = e[d]) || (e[d] = l = []), l.push(k)) } a = []; for (d in e) a.push(ka.CreateFromMorphTargetSequence(d, e[d], b, c)); return a }, parseAnimation: function (a, b) {
					if (!a) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; var c = function (a, b, c, d, e) { if (0 !== c.length) { var f = [], g = []; T.flattenJSON(c, f, g, d); 0 !== f.length && e.push(new a(b, f, g)) } }, d = [], e = a.name || "default", f = a.length ||
						-1, g = a.fps || 30; a = a.hierarchy || []; for (var h = 0; h < a.length; h++) {
							var k = a[h].keys; if (k && 0 !== k.length) if (k[0].morphTargets) { for (var f = {}, l = 0; l < k.length; l++)if (k[l].morphTargets) for (var m = 0; m < k[l].morphTargets.length; m++)f[k[l].morphTargets[m]] = -1; for (var n in f) { for (var p = [], r = [], m = 0; m !== k[l].morphTargets.length; ++m) { var u = k[l]; p.push(u.time); r.push(u.morphTarget === n ? 1 : 0) } d.push(new jc(".morphTargetInfluence[" + n + "]", p, r)) } f = f.length * (g || 1) } else l = ".bones[" + b[h].name + "]", c(ic, l + ".position", k, "pos", d), c(Zc,
								l + ".quaternion", k, "rot", d), c(ic, l + ".scale", k, "scl", d)
						} return 0 === d.length ? null : new ka(e, f, d)
				}
	}); Object.assign(ka.prototype, { resetDuration: function () { for (var a = 0, b = 0, c = this.tracks.length; b !== c; ++b)var d = this.tracks[b], a = Math.max(a, d.times[d.times.length - 1]); this.duration = a }, trim: function () { for (var a = 0; a < this.tracks.length; a++)this.tracks[a].trim(0, this.duration); return this }, optimize: function () { for (var a = 0; a < this.tracks.length; a++)this.tracks[a].optimize(); return this } }); Object.assign(Id.prototype,
		{
			load: function (a, b, c, d) { var e = this; (new Ja(e.manager)).load(a, function (a) { b(e.parse(JSON.parse(a))) }, c, d) }, setTextures: function (a) { this.textures = a }, parse: function (a) {
				function b(a) { void 0 === c[a] && console.warn("THREE.MaterialLoader: Undefined texture", a); return c[a] } var c = this.textures, d = new tg[a.type]; void 0 !== a.uuid && (d.uuid = a.uuid); void 0 !== a.name && (d.name = a.name); void 0 !== a.color && d.color.setHex(a.color); void 0 !== a.roughness && (d.roughness = a.roughness); void 0 !== a.metalness && (d.metalness = a.metalness);
				void 0 !== a.emissive && d.emissive.setHex(a.emissive); void 0 !== a.specular && d.specular.setHex(a.specular); void 0 !== a.shininess && (d.shininess = a.shininess); void 0 !== a.clearCoat && (d.clearCoat = a.clearCoat); void 0 !== a.clearCoatRoughness && (d.clearCoatRoughness = a.clearCoatRoughness); void 0 !== a.uniforms && (d.uniforms = a.uniforms); void 0 !== a.vertexShader && (d.vertexShader = a.vertexShader); void 0 !== a.fragmentShader && (d.fragmentShader = a.fragmentShader); void 0 !== a.vertexColors && (d.vertexColors = a.vertexColors); void 0 !==
					a.fog && (d.fog = a.fog); void 0 !== a.flatShading && (d.flatShading = a.flatShading); void 0 !== a.blending && (d.blending = a.blending); void 0 !== a.side && (d.side = a.side); void 0 !== a.opacity && (d.opacity = a.opacity); void 0 !== a.transparent && (d.transparent = a.transparent); void 0 !== a.alphaTest && (d.alphaTest = a.alphaTest); void 0 !== a.depthTest && (d.depthTest = a.depthTest); void 0 !== a.depthWrite && (d.depthWrite = a.depthWrite); void 0 !== a.colorWrite && (d.colorWrite = a.colorWrite); void 0 !== a.wireframe && (d.wireframe = a.wireframe); void 0 !==
						a.wireframeLinewidth && (d.wireframeLinewidth = a.wireframeLinewidth); void 0 !== a.wireframeLinecap && (d.wireframeLinecap = a.wireframeLinecap); void 0 !== a.wireframeLinejoin && (d.wireframeLinejoin = a.wireframeLinejoin); void 0 !== a.rotation && (d.rotation = a.rotation); 1 !== a.linewidth && (d.linewidth = a.linewidth); void 0 !== a.dashSize && (d.dashSize = a.dashSize); void 0 !== a.gapSize && (d.gapSize = a.gapSize); void 0 !== a.scale && (d.scale = a.scale); void 0 !== a.skinning && (d.skinning = a.skinning); void 0 !== a.morphTargets && (d.morphTargets =
							a.morphTargets); void 0 !== a.dithering && (d.dithering = a.dithering); void 0 !== a.visible && (d.visible = a.visible); void 0 !== a.userData && (d.userData = a.userData); void 0 !== a.shading && (d.flatShading = 1 === a.shading); void 0 !== a.size && (d.size = a.size); void 0 !== a.sizeAttenuation && (d.sizeAttenuation = a.sizeAttenuation); void 0 !== a.map && (d.map = b(a.map)); void 0 !== a.alphaMap && (d.alphaMap = b(a.alphaMap), d.transparent = !0); void 0 !== a.bumpMap && (d.bumpMap = b(a.bumpMap)); void 0 !== a.bumpScale && (d.bumpScale = a.bumpScale); void 0 !== a.normalMap &&
								(d.normalMap = b(a.normalMap)); if (void 0 !== a.normalScale) { var e = a.normalScale; !1 === Array.isArray(e) && (e = [e, e]); d.normalScale = (new C).fromArray(e) } void 0 !== a.displacementMap && (d.displacementMap = b(a.displacementMap)); void 0 !== a.displacementScale && (d.displacementScale = a.displacementScale); void 0 !== a.displacementBias && (d.displacementBias = a.displacementBias); void 0 !== a.roughnessMap && (d.roughnessMap = b(a.roughnessMap)); void 0 !== a.metalnessMap && (d.metalnessMap = b(a.metalnessMap)); void 0 !== a.emissiveMap && (d.emissiveMap =
									b(a.emissiveMap)); void 0 !== a.emissiveIntensity && (d.emissiveIntensity = a.emissiveIntensity); void 0 !== a.specularMap && (d.specularMap = b(a.specularMap)); void 0 !== a.envMap && (d.envMap = b(a.envMap)); void 0 !== a.reflectivity && (d.reflectivity = a.reflectivity); void 0 !== a.lightMap && (d.lightMap = b(a.lightMap)); void 0 !== a.lightMapIntensity && (d.lightMapIntensity = a.lightMapIntensity); void 0 !== a.aoMap && (d.aoMap = b(a.aoMap)); void 0 !== a.aoMapIntensity && (d.aoMapIntensity = a.aoMapIntensity); void 0 !== a.gradientMap && (d.gradientMap =
										b(a.gradientMap)); return d
			}
		}); Object.assign(ae.prototype, {
			load: function (a, b, c, d) { var e = this; (new Ja(e.manager)).load(a, function (a) { b(e.parse(JSON.parse(a))) }, c, d) }, parse: function (a) {
				var b = new D; var c = a.data.index; void 0 !== c && (c = new gf[c.type](c.array), b.setIndex(new P(c, 1))); var d = a.data.attributes; for (f in d) { var e = d[f]; c = new gf[e.type](e.array); b.addAttribute(f, new P(c, e.itemSize, e.normalized)) } var f = a.data.groups || a.data.drawcalls || a.data.offsets; if (void 0 !== f) for (c = 0, d = f.length; c !== d; ++c)e = f[c],
					b.addGroup(e.start, e.count, e.materialIndex); a = a.data.boundingSphere; void 0 !== a && (f = new p, void 0 !== a.center && f.fromArray(a.center), b.boundingSphere = new Da(f, a.radius)); return b
			}
		}); var gf = { Int8Array: Int8Array, Uint8Array: Uint8Array, Uint8ClampedArray: "undefined" !== typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array, Int16Array: Int16Array, Uint16Array: Uint16Array, Int32Array: Int32Array, Uint32Array: Uint32Array, Float32Array: Float32Array, Float64Array: Float64Array }; kc.Handlers = {
			handlers: [], add: function (a, b) {
				this.handlers.push(a,
					b)
			}, get: function (a) { for (var b = this.handlers, c = 0, d = b.length; c < d; c += 2) { var e = b[c + 1]; if (b[c].test(a)) return e } return null }
		}; Object.assign(kc.prototype, {
			crossOrigin: void 0, extractUrlBase: function (a) { a = a.split("/"); if (1 === a.length) return "./"; a.pop(); return a.join("/") + "/" }, initMaterials: function (a, b, c) { for (var d = [], e = 0; e < a.length; ++e)d[e] = this.createMaterial(a[e], b, c); return d }, createMaterial: function () {
				var a = { NoBlending: 0, NormalBlending: 1, AdditiveBlending: 2, SubtractiveBlending: 3, MultiplyBlending: 4, CustomBlending: 5 },
				b = new H, c = new td, d = new Id; return function (e, f, g) {
					function h(a, b, d, e, h) { a = f + a; var l = kc.Handlers.get(a); null !== l ? a = l.load(a) : (c.setCrossOrigin(g), a = c.load(a)); void 0 !== b && (a.repeat.fromArray(b), 1 !== b[0] && (a.wrapS = 1E3), 1 !== b[1] && (a.wrapT = 1E3)); void 0 !== d && a.offset.fromArray(d); void 0 !== e && ("repeat" === e[0] && (a.wrapS = 1E3), "mirror" === e[0] && (a.wrapS = 1002), "repeat" === e[1] && (a.wrapT = 1E3), "mirror" === e[1] && (a.wrapT = 1002)); void 0 !== h && (a.anisotropy = h); b = R.generateUUID(); k[b] = a; return b } var k = {}, l = {
						uuid: R.generateUUID(),
						type: "MeshLambertMaterial"
					}, m; for (m in e) {
						var n = e[m]; switch (m) {
							case "DbgColor": case "DbgIndex": case "opticalDensity": case "illumination": break; case "DbgName": l.name = n; break; case "blending": l.blending = a[n]; break; case "colorAmbient": case "mapAmbient": console.warn("THREE.Loader.createMaterial:", m, "is no longer supported."); break; case "colorDiffuse": l.color = b.fromArray(n).getHex(); break; case "colorSpecular": l.specular = b.fromArray(n).getHex(); break; case "colorEmissive": l.emissive = b.fromArray(n).getHex();
								break; case "specularCoef": l.shininess = n; break; case "shading": "basic" === n.toLowerCase() && (l.type = "MeshBasicMaterial"); "phong" === n.toLowerCase() && (l.type = "MeshPhongMaterial"); "standard" === n.toLowerCase() && (l.type = "MeshStandardMaterial"); break; case "mapDiffuse": l.map = h(n, e.mapDiffuseRepeat, e.mapDiffuseOffset, e.mapDiffuseWrap, e.mapDiffuseAnisotropy); break; case "mapDiffuseRepeat": case "mapDiffuseOffset": case "mapDiffuseWrap": case "mapDiffuseAnisotropy": break; case "mapEmissive": l.emissiveMap = h(n, e.mapEmissiveRepeat,
									e.mapEmissiveOffset, e.mapEmissiveWrap, e.mapEmissiveAnisotropy); break; case "mapEmissiveRepeat": case "mapEmissiveOffset": case "mapEmissiveWrap": case "mapEmissiveAnisotropy": break; case "mapLight": l.lightMap = h(n, e.mapLightRepeat, e.mapLightOffset, e.mapLightWrap, e.mapLightAnisotropy); break; case "mapLightRepeat": case "mapLightOffset": case "mapLightWrap": case "mapLightAnisotropy": break; case "mapAO": l.aoMap = h(n, e.mapAORepeat, e.mapAOOffset, e.mapAOWrap, e.mapAOAnisotropy); break; case "mapAORepeat": case "mapAOOffset": case "mapAOWrap": case "mapAOAnisotropy": break;
							case "mapBump": l.bumpMap = h(n, e.mapBumpRepeat, e.mapBumpOffset, e.mapBumpWrap, e.mapBumpAnisotropy); break; case "mapBumpScale": l.bumpScale = n; break; case "mapBumpRepeat": case "mapBumpOffset": case "mapBumpWrap": case "mapBumpAnisotropy": break; case "mapNormal": l.normalMap = h(n, e.mapNormalRepeat, e.mapNormalOffset, e.mapNormalWrap, e.mapNormalAnisotropy); break; case "mapNormalFactor": l.normalScale = [n, n]; break; case "mapNormalRepeat": case "mapNormalOffset": case "mapNormalWrap": case "mapNormalAnisotropy": break; case "mapSpecular": l.specularMap =
								h(n, e.mapSpecularRepeat, e.mapSpecularOffset, e.mapSpecularWrap, e.mapSpecularAnisotropy); break; case "mapSpecularRepeat": case "mapSpecularOffset": case "mapSpecularWrap": case "mapSpecularAnisotropy": break; case "mapMetalness": l.metalnessMap = h(n, e.mapMetalnessRepeat, e.mapMetalnessOffset, e.mapMetalnessWrap, e.mapMetalnessAnisotropy); break; case "mapMetalnessRepeat": case "mapMetalnessOffset": case "mapMetalnessWrap": case "mapMetalnessAnisotropy": break; case "mapRoughness": l.roughnessMap = h(n, e.mapRoughnessRepeat,
									e.mapRoughnessOffset, e.mapRoughnessWrap, e.mapRoughnessAnisotropy); break; case "mapRoughnessRepeat": case "mapRoughnessOffset": case "mapRoughnessWrap": case "mapRoughnessAnisotropy": break; case "mapAlpha": l.alphaMap = h(n, e.mapAlphaRepeat, e.mapAlphaOffset, e.mapAlphaWrap, e.mapAlphaAnisotropy); break; case "mapAlphaRepeat": case "mapAlphaOffset": case "mapAlphaWrap": case "mapAlphaAnisotropy": break; case "flipSided": l.side = 1; break; case "doubleSided": l.side = 2; break; case "transparency": console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity");
								l.opacity = n; break; case "depthTest": case "depthWrite": case "colorWrite": case "opacity": case "reflectivity": case "transparent": case "visible": case "wireframe": l[m] = n; break; case "vertexColors": !0 === n && (l.vertexColors = 2); "face" === n && (l.vertexColors = 1); break; default: console.error("THREE.Loader.createMaterial: Unsupported", m, n)
						}
					} "MeshBasicMaterial" === l.type && delete l.emissive; "MeshPhongMaterial" !== l.type && delete l.specular; 1 > l.opacity && (l.transparent = !0); d.setTextures(k); return d.parse(l)
				}
			}()
		}); Object.assign(be.prototype,
			{
				load: function (a, b, c, d) {
					var e = this, f = this.texturePath && "string" === typeof this.texturePath ? this.texturePath : kc.prototype.extractUrlBase(a), g = new Ja(this.manager); g.setWithCredentials(this.withCredentials); g.load(a, function (c) {
						c = JSON.parse(c); var d = c.metadata; if (void 0 !== d && (d = d.type, void 0 !== d)) {
							if ("object" === d.toLowerCase()) { console.error("THREE.JSONLoader: " + a + " should be loaded with THREE.ObjectLoader instead."); return } if ("scene" === d.toLowerCase()) {
								console.error("THREE.JSONLoader: " + a + " should be loaded with THREE.SceneLoader instead.");
								return
							}
						} c = e.parse(c, f); b(c.geometry, c.materials)
					}, c, d)
				}, setTexturePath: function (a) { this.texturePath = a }, parse: function () {
					return function (a, b) {
					void 0 !== a.data && (a = a.data); a.scale = void 0 !== a.scale ? 1 / a.scale : 1; var c = new N, d = a, e, f, g, h = d.faces; var k = d.vertices; var l = d.normals, m = d.colors; var n = d.scale; var t = 0; if (void 0 !== d.uvs) { for (e = 0; e < d.uvs.length; e++)d.uvs[e].length && t++; for (e = 0; e < t; e++)c.faceVertexUvs[e] = [] } var r = 0; for (g = k.length; r < g;)e = new p, e.x = k[r++] * n, e.y = k[r++] * n, e.z = k[r++] * n, c.vertices.push(e);
						r = 0; for (g = h.length; r < g;) {
							k = h[r++]; var u = k & 1; var v = k & 2; e = k & 8; var w = k & 16; var x = k & 32; n = k & 64; k &= 128; if (u) {
								u = new Pa; u.a = h[r]; u.b = h[r + 1]; u.c = h[r + 3]; var z = new Pa; z.a = h[r + 1]; z.b = h[r + 2]; z.c = h[r + 3]; r += 4; v && (v = h[r++], u.materialIndex = v, z.materialIndex = v); v = c.faces.length; if (e) for (e = 0; e < t; e++) { var y = d.uvs[e]; c.faceVertexUvs[e][v] = []; c.faceVertexUvs[e][v + 1] = []; for (f = 0; 4 > f; f++) { var B = h[r++]; var A = y[2 * B]; B = y[2 * B + 1]; A = new C(A, B); 2 !== f && c.faceVertexUvs[e][v].push(A); 0 !== f && c.faceVertexUvs[e][v + 1].push(A) } } w && (w = 3 *
									h[r++], u.normal.set(l[w++], l[w++], l[w]), z.normal.copy(u.normal)); if (x) for (e = 0; 4 > e; e++)w = 3 * h[r++], x = new p(l[w++], l[w++], l[w]), 2 !== e && u.vertexNormals.push(x), 0 !== e && z.vertexNormals.push(x); n && (n = h[r++], n = m[n], u.color.setHex(n), z.color.setHex(n)); if (k) for (e = 0; 4 > e; e++)n = h[r++], n = m[n], 2 !== e && u.vertexColors.push(new H(n)), 0 !== e && z.vertexColors.push(new H(n)); c.faces.push(u); c.faces.push(z)
							} else {
								u = new Pa; u.a = h[r++]; u.b = h[r++]; u.c = h[r++]; v && (v = h[r++], u.materialIndex = v); v = c.faces.length; if (e) for (e = 0; e < t; e++)for (y =
									d.uvs[e], c.faceVertexUvs[e][v] = [], f = 0; 3 > f; f++)B = h[r++], A = y[2 * B], B = y[2 * B + 1], A = new C(A, B), c.faceVertexUvs[e][v].push(A); w && (w = 3 * h[r++], u.normal.set(l[w++], l[w++], l[w])); if (x) for (e = 0; 3 > e; e++)w = 3 * h[r++], x = new p(l[w++], l[w++], l[w]), u.vertexNormals.push(x); n && (n = h[r++], u.color.setHex(m[n])); if (k) for (e = 0; 3 > e; e++)n = h[r++], u.vertexColors.push(new H(m[n])); c.faces.push(u)
							}
						} d = a; r = void 0 !== d.influencesPerVertex ? d.influencesPerVertex : 2; if (d.skinWeights) for (g = 0, h = d.skinWeights.length; g < h; g += r)c.skinWeights.push(new da(d.skinWeights[g],
							1 < r ? d.skinWeights[g + 1] : 0, 2 < r ? d.skinWeights[g + 2] : 0, 3 < r ? d.skinWeights[g + 3] : 0)); if (d.skinIndices) for (g = 0, h = d.skinIndices.length; g < h; g += r)c.skinIndices.push(new da(d.skinIndices[g], 1 < r ? d.skinIndices[g + 1] : 0, 2 < r ? d.skinIndices[g + 2] : 0, 3 < r ? d.skinIndices[g + 3] : 0)); c.bones = d.bones; c.bones && 0 < c.bones.length && (c.skinWeights.length !== c.skinIndices.length || c.skinIndices.length !== c.vertices.length) && console.warn("When skinning, number of vertices (" + c.vertices.length + "), skinIndices (" + c.skinIndices.length + "), and skinWeights (" +
								c.skinWeights.length + ") should match."); g = a; h = g.scale; if (void 0 !== g.morphTargets) for (d = 0, r = g.morphTargets.length; d < r; d++)for (c.morphTargets[d] = {}, c.morphTargets[d].name = g.morphTargets[d].name, c.morphTargets[d].vertices = [], l = c.morphTargets[d].vertices, m = g.morphTargets[d].vertices, t = 0, k = m.length; t < k; t += 3)n = new p, n.x = m[t] * h, n.y = m[t + 1] * h, n.z = m[t + 2] * h, l.push(n); if (void 0 !== g.morphColors && 0 < g.morphColors.length) for (console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.'),
									h = c.faces, g = g.morphColors[0].colors, d = 0, r = h.length; d < r; d++)h[d].color.fromArray(g, 3 * d); g = a; d = []; r = []; void 0 !== g.animation && r.push(g.animation); void 0 !== g.animations && (g.animations.length ? r = r.concat(g.animations) : r.push(g.animations)); for (g = 0; g < r.length; g++)(h = ka.parseAnimation(r[g], c.bones)) && d.push(h); c.morphTargets && (r = ka.CreateClipsFromMorphTargetSequences(c.morphTargets, 10), d = d.concat(r)); 0 < d.length && (c.animations = d); c.computeFaceNormals(); c.computeBoundingSphere(); if (void 0 === a.materials || 0 ===
										a.materials.length) return { geometry: c }; a = kc.prototype.initMaterials(a.materials, b, this.crossOrigin); return { geometry: c, materials: a }
					}
				}()
			}); Object.assign(Re.prototype, {
				load: function (a, b, c, d) {
				"" === this.texturePath && (this.texturePath = a.substring(0, a.lastIndexOf("/") + 1)); var e = this; (new Ja(e.manager)).load(a, function (c) {
					var f = null; try { f = JSON.parse(c) } catch (h) { void 0 !== d && d(h); console.error("THREE:ObjectLoader: Can't parse " + a + ".", h.message); return } c = f.metadata; void 0 === c || void 0 === c.type || "geometry" === c.type.toLowerCase() ?
						console.error("THREE.ObjectLoader: Can't load " + a + ". Use THREE.JSONLoader instead.") : e.parse(f, b)
				}, c, d)
				}, setTexturePath: function (a) { this.texturePath = a }, setCrossOrigin: function (a) { this.crossOrigin = a }, parse: function (a, b) {
					var c = this.parseGeometries(a.geometries), d = this.parseImages(a.images, function () { void 0 !== b && b(e) }), d = this.parseTextures(a.textures, d), d = this.parseMaterials(a.materials, d), e = this.parseObject(a.object, c, d); a.animations && (e.animations = this.parseAnimations(a.animations)); void 0 !== a.images &&
						0 !== a.images.length || void 0 === b || b(e); return e
				}, parseGeometries: function (a) {
					var b = {}; if (void 0 !== a) for (var c = new be, d = new ae, e = 0, f = a.length; e < f; e++) {
						var g = a[e]; switch (g.type) {
							case "PlaneGeometry": case "PlaneBufferGeometry": var h = new Ca[g.type](g.width, g.height, g.widthSegments, g.heightSegments); break; case "BoxGeometry": case "BoxBufferGeometry": case "CubeGeometry": h = new Ca[g.type](g.width, g.height, g.depth, g.widthSegments, g.heightSegments, g.depthSegments); break; case "CircleGeometry": case "CircleBufferGeometry": h =
								new Ca[g.type](g.radius, g.segments, g.thetaStart, g.thetaLength); break; case "CylinderGeometry": case "CylinderBufferGeometry": h = new Ca[g.type](g.radiusTop, g.radiusBottom, g.height, g.radialSegments, g.heightSegments, g.openEnded, g.thetaStart, g.thetaLength); break; case "ConeGeometry": case "ConeBufferGeometry": h = new Ca[g.type](g.radius, g.height, g.radialSegments, g.heightSegments, g.openEnded, g.thetaStart, g.thetaLength); break; case "SphereGeometry": case "SphereBufferGeometry": h = new Ca[g.type](g.radius, g.widthSegments,
									g.heightSegments, g.phiStart, g.phiLength, g.thetaStart, g.thetaLength); break; case "DodecahedronGeometry": case "DodecahedronBufferGeometry": case "IcosahedronGeometry": case "IcosahedronBufferGeometry": case "OctahedronGeometry": case "OctahedronBufferGeometry": case "TetrahedronGeometry": case "TetrahedronBufferGeometry": h = new Ca[g.type](g.radius, g.detail); break; case "RingGeometry": case "RingBufferGeometry": h = new Ca[g.type](g.innerRadius, g.outerRadius, g.thetaSegments, g.phiSegments, g.thetaStart, g.thetaLength);
								break; case "TorusGeometry": case "TorusBufferGeometry": h = new Ca[g.type](g.radius, g.tube, g.radialSegments, g.tubularSegments, g.arc); break; case "TorusKnotGeometry": case "TorusKnotBufferGeometry": h = new Ca[g.type](g.radius, g.tube, g.tubularSegments, g.radialSegments, g.p, g.q); break; case "LatheGeometry": case "LatheBufferGeometry": h = new Ca[g.type](g.points, g.segments, g.phiStart, g.phiLength); break; case "PolyhedronGeometry": case "PolyhedronBufferGeometry": h = new Ca[g.type](g.vertices, g.indices, g.radius, g.details);
								break; case "BufferGeometry": h = d.parse(g); break; case "Geometry": h = c.parse(g, this.texturePath).geometry; break; default: console.warn('THREE.ObjectLoader: Unsupported geometry type "' + g.type + '"'); continue
						}h.uuid = g.uuid; void 0 !== g.name && (h.name = g.name); b[g.uuid] = h
					} return b
				}, parseMaterials: function (a, b) {
					var c = {}; if (void 0 !== a) {
						var d = new Id; d.setTextures(b); b = 0; for (var e = a.length; b < e; b++) {
							var f = a[b]; if ("MultiMaterial" === f.type) {
								for (var g = [], h = 0; h < f.materials.length; h++)g.push(d.parse(f.materials[h])); c[f.uuid] =
									g
							} else c[f.uuid] = d.parse(f)
						}
					} return c
				}, parseAnimations: function (a) { for (var b = [], c = 0; c < a.length; c++) { var d = ka.parse(a[c]); b.push(d) } return b }, parseImages: function (a, b) {
					function c(a) { d.manager.itemStart(a); return f.load(a, function () { d.manager.itemEnd(a) }, void 0, function () { d.manager.itemEnd(a); d.manager.itemError(a) }) } var d = this, e = {}; if (void 0 !== a && 0 < a.length) {
						b = new Yd(b); var f = new Xc(b); f.setCrossOrigin(this.crossOrigin); b = 0; for (var g = a.length; b < g; b++) {
							var h = a[b], k = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(h.url) ?
								h.url : d.texturePath + h.url; e[h.uuid] = c(k)
						}
					} return e
				}, parseTextures: function (a, b) {
					function c(a, b) { if ("number" === typeof a) return a; console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", a); return b[a] } var d = {}; if (void 0 !== a) for (var e = 0, f = a.length; e < f; e++) {
						var g = a[e]; void 0 === g.image && console.warn('THREE.ObjectLoader: No "image" specified for', g.uuid); void 0 === b[g.image] && console.warn("THREE.ObjectLoader: Undefined image", g.image); var h = new ea(b[g.image]); h.needsUpdate = !0;
						h.uuid = g.uuid; void 0 !== g.name && (h.name = g.name); void 0 !== g.mapping && (h.mapping = c(g.mapping, ug)); void 0 !== g.offset && h.offset.fromArray(g.offset); void 0 !== g.repeat && h.repeat.fromArray(g.repeat); void 0 !== g.center && h.center.fromArray(g.center); void 0 !== g.rotation && (h.rotation = g.rotation); void 0 !== g.wrap && (h.wrapS = c(g.wrap[0], hf), h.wrapT = c(g.wrap[1], hf)); void 0 !== g.minFilter && (h.minFilter = c(g.minFilter, jf)); void 0 !== g.magFilter && (h.magFilter = c(g.magFilter, jf)); void 0 !== g.anisotropy && (h.anisotropy = g.anisotropy);
						void 0 !== g.flipY && (h.flipY = g.flipY); d[g.uuid] = h
					} return d
				}, parseObject: function () {
					var a = new K; return function (b, c, d) {
						function e(a) { void 0 === c[a] && console.warn("THREE.ObjectLoader: Undefined geometry", a); return c[a] } function f(a) { if (void 0 !== a) { if (Array.isArray(a)) { for (var b = [], c = 0, e = a.length; c < e; c++) { var f = a[c]; void 0 === d[f] && console.warn("THREE.ObjectLoader: Undefined material", f); b.push(d[f]) } return b } void 0 === d[a] && console.warn("THREE.ObjectLoader: Undefined material", a); return d[a] } } switch (b.type) {
							case "Scene": var g =
								new od; void 0 !== b.background && Number.isInteger(b.background) && (g.background = new H(b.background)); void 0 !== b.fog && ("Fog" === b.fog.type ? g.fog = new Pb(b.fog.color, b.fog.near, b.fog.far) : "FogExp2" === b.fog.type && (g.fog = new Ob(b.fog.color, b.fog.density))); break; case "PerspectiveCamera": g = new U(b.fov, b.aspect, b.near, b.far); void 0 !== b.focus && (g.focus = b.focus); void 0 !== b.zoom && (g.zoom = b.zoom); void 0 !== b.filmGauge && (g.filmGauge = b.filmGauge); void 0 !== b.filmOffset && (g.filmOffset = b.filmOffset); void 0 !== b.view && (g.view =
									Object.assign({}, b.view)); break; case "OrthographicCamera": g = new Kb(b.left, b.right, b.top, b.bottom, b.near, b.far); break; case "AmbientLight": g = new Ad(b.color, b.intensity); break; case "DirectionalLight": g = new zd(b.color, b.intensity); break; case "PointLight": g = new xd(b.color, b.intensity, b.distance, b.decay); break; case "RectAreaLight": g = new Bd(b.color, b.intensity, b.width, b.height); break; case "SpotLight": g = new wd(b.color, b.intensity, b.distance, b.angle, b.penumbra, b.decay); break; case "HemisphereLight": g = new ud(b.color,
										b.groundColor, b.intensity); break; case "SkinnedMesh": console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet."); case "Mesh": g = e(b.geometry); var h = f(b.material); g = g.bones && 0 < g.bones.length ? new qd(g, h) : new pa(g, h); break; case "LOD": g = new Dc; break; case "Line": g = new ma(e(b.geometry), f(b.material), b.mode); break; case "LineLoop": g = new rd(e(b.geometry), f(b.material)); break; case "LineSegments": g = new ca(e(b.geometry), f(b.material)); break; case "PointCloud": case "Points": g = new Qb(e(b.geometry),
											f(b.material)); break; case "Sprite": g = new Cc(f(b.material)); break; case "Group": g = new Fc; break; default: g = new A
						}g.uuid = b.uuid; void 0 !== b.name && (g.name = b.name); void 0 !== b.matrix ? (a.fromArray(b.matrix), a.decompose(g.position, g.quaternion, g.scale)) : (void 0 !== b.position && g.position.fromArray(b.position), void 0 !== b.rotation && g.rotation.fromArray(b.rotation), void 0 !== b.quaternion && g.quaternion.fromArray(b.quaternion), void 0 !== b.scale && g.scale.fromArray(b.scale)); void 0 !== b.castShadow && (g.castShadow = b.castShadow);
						void 0 !== b.receiveShadow && (g.receiveShadow = b.receiveShadow); b.shadow && (void 0 !== b.shadow.bias && (g.shadow.bias = b.shadow.bias), void 0 !== b.shadow.radius && (g.shadow.radius = b.shadow.radius), void 0 !== b.shadow.mapSize && g.shadow.mapSize.fromArray(b.shadow.mapSize), void 0 !== b.shadow.camera && (g.shadow.camera = this.parseObject(b.shadow.camera))); void 0 !== b.visible && (g.visible = b.visible); void 0 !== b.userData && (g.userData = b.userData); if (void 0 !== b.children) for (var h = b.children, k = 0; k < h.length; k++)g.add(this.parseObject(h[k],
							c, d)); if ("LOD" === b.type) for (b = b.levels, h = 0; h < b.length; h++) { var k = b[h], l = g.getObjectByProperty("uuid", k.object); void 0 !== l && g.addLevel(l, k.distance) } return g
					}
				}()
			}); var ug = { UVMapping: 300, CubeReflectionMapping: 301, CubeRefractionMapping: 302, EquirectangularReflectionMapping: 303, EquirectangularRefractionMapping: 304, SphericalReflectionMapping: 305, CubeUVReflectionMapping: 306, CubeUVRefractionMapping: 307 }, hf = { RepeatWrapping: 1E3, ClampToEdgeWrapping: 1001, MirroredRepeatWrapping: 1002 }, jf = {
				NearestFilter: 1003, NearestMipMapNearestFilter: 1004,
				NearestMipMapLinearFilter: 1005, LinearFilter: 1006, LinearMipMapNearestFilter: 1007, LinearMipMapLinearFilter: 1008
			}; Object.assign(S.prototype, {
				getPoint: function () { console.warn("THREE.Curve: .getPoint() not implemented."); return null }, getPointAt: function (a, b) { a = this.getUtoTmapping(a); return this.getPoint(a, b) }, getPoints: function (a) { void 0 === a && (a = 5); for (var b = [], c = 0; c <= a; c++)b.push(this.getPoint(c / a)); return b }, getSpacedPoints: function (a) {
				void 0 === a && (a = 5); for (var b = [], c = 0; c <= a; c++)b.push(this.getPointAt(c /
					a)); return b
				}, getLength: function () { var a = this.getLengths(); return a[a.length - 1] }, getLengths: function (a) { void 0 === a && (a = this.arcLengthDivisions); if (this.cacheArcLengths && this.cacheArcLengths.length === a + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; var b = [], c = this.getPoint(0), d, e = 0; b.push(0); for (d = 1; d <= a; d++) { var f = this.getPoint(d / a); e += f.distanceTo(c); b.push(e); c = f } return this.cacheArcLengths = b }, updateArcLengths: function () { this.needsUpdate = !0; this.getLengths() }, getUtoTmapping: function (a,
					b) { var c = this.getLengths(), d = c.length; b = b ? b : a * c[d - 1]; for (var e = 0, f = d - 1, g; e <= f;)if (a = Math.floor(e + (f - e) / 2), g = c[a] - b, 0 > g) e = a + 1; else if (0 < g) f = a - 1; else { f = a; break } a = f; if (c[a] === b) return a / (d - 1); e = c[a]; return (a + (b - e) / (c[a + 1] - e)) / (d - 1) }, getTangent: function (a) { var b = a - 1E-4; a += 1E-4; 0 > b && (b = 0); 1 < a && (a = 1); b = this.getPoint(b); return this.getPoint(a).clone().sub(b).normalize() }, getTangentAt: function (a) { a = this.getUtoTmapping(a); return this.getTangent(a) }, computeFrenetFrames: function (a, b) {
						var c = new p, d = [], e = [], f =
							[], g = new p, h = new K, k; for (k = 0; k <= a; k++) { var l = k / a; d[k] = this.getTangentAt(l); d[k].normalize() } e[0] = new p; f[0] = new p; k = Number.MAX_VALUE; l = Math.abs(d[0].x); var m = Math.abs(d[0].y), n = Math.abs(d[0].z); l <= k && (k = l, c.set(1, 0, 0)); m <= k && (k = m, c.set(0, 1, 0)); n <= k && c.set(0, 0, 1); g.crossVectors(d[0], c).normalize(); e[0].crossVectors(d[0], g); f[0].crossVectors(d[0], e[0]); for (k = 1; k <= a; k++)e[k] = e[k - 1].clone(), f[k] = f[k - 1].clone(), g.crossVectors(d[k - 1], d[k]), g.length() > Number.EPSILON && (g.normalize(), c = Math.acos(R.clamp(d[k -
								1].dot(d[k]), -1, 1)), e[k].applyMatrix4(h.makeRotationAxis(g, c))), f[k].crossVectors(d[k], e[k]); if (!0 === b) for (c = Math.acos(R.clamp(e[0].dot(e[a]), -1, 1)), c /= a, 0 < d[0].dot(g.crossVectors(e[0], e[a])) && (c = -c), k = 1; k <= a; k++)e[k].applyMatrix4(h.makeRotationAxis(d[k], c * k)), f[k].crossVectors(d[k], e[k]); return { tangents: d, normals: e, binormals: f }
					}, clone: function () { return (new this.constructor).copy(this) }, copy: function (a) { this.arcLengthDivisions = a.arcLengthDivisions; return this }
			}); Ka.prototype = Object.create(S.prototype);
	Ka.prototype.constructor = Ka; Ka.prototype.isLineCurve = !0; Ka.prototype.getPoint = function (a, b) { b = b || new C; 1 === a ? b.copy(this.v2) : (b.copy(this.v2).sub(this.v1), b.multiplyScalar(a).add(this.v1)); return b }; Ka.prototype.getPointAt = function (a, b) { return this.getPoint(a, b) }; Ka.prototype.getTangent = function () { return this.v2.clone().sub(this.v1).normalize() }; Ka.prototype.copy = function (a) { S.prototype.copy.call(this, a); this.v1.copy(a.v1); this.v2.copy(a.v2); return this }; Ab.prototype = Object.assign(Object.create(S.prototype),
		{
			constructor: Ab, add: function (a) { this.curves.push(a) }, closePath: function () { var a = this.curves[0].getPoint(0), b = this.curves[this.curves.length - 1].getPoint(1); a.equals(b) || this.curves.push(new Ka(b, a)) }, getPoint: function (a) { var b = a * this.getLength(), c = this.getCurveLengths(); for (a = 0; a < c.length;) { if (c[a] >= b) return b = c[a] - b, a = this.curves[a], c = a.getLength(), a.getPointAt(0 === c ? 0 : 1 - b / c); a++ } return null }, getLength: function () { var a = this.getCurveLengths(); return a[a.length - 1] }, updateArcLengths: function () {
			this.needsUpdate =
				!0; this.cacheLengths = null; this.getCurveLengths()
			}, getCurveLengths: function () { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; for (var a = [], b = 0, c = 0, d = this.curves.length; c < d; c++)b += this.curves[c].getLength(), a.push(b); return this.cacheLengths = a }, getSpacedPoints: function (a) { void 0 === a && (a = 40); for (var b = [], c = 0; c <= a; c++)b.push(this.getPoint(c / a)); this.autoClose && b.push(b[0]); return b }, getPoints: function (a) {
				a = a || 12; for (var b = [], c, d = 0, e = this.curves; d < e.length; d++)for (var f =
					e[d], f = f.getPoints(f && f.isEllipseCurve ? 2 * a : f && f.isLineCurve ? 1 : f && f.isSplineCurve ? a * f.points.length : a), g = 0; g < f.length; g++) { var h = f[g]; c && c.equals(h) || (b.push(h), c = h) } this.autoClose && 1 < b.length && !b[b.length - 1].equals(b[0]) && b.push(b[0]); return b
			}, copy: function (a) { S.prototype.copy.call(this, a); this.curves = []; for (var b = 0, c = a.curves.length; b < c; b++)this.curves.push(a.curves[b].clone()); this.autoClose = a.autoClose; return this }
		}); Na.prototype = Object.create(S.prototype); Na.prototype.constructor = Na; Na.prototype.isEllipseCurve =
			!0; Na.prototype.getPoint = function (a, b) { b = b || new C; for (var c = 2 * Math.PI, d = this.aEndAngle - this.aStartAngle, e = Math.abs(d) < Number.EPSILON; 0 > d;)d += c; for (; d > c;)d -= c; d < Number.EPSILON && (d = e ? 0 : c); !0 !== this.aClockwise || e || (d = d === c ? -c : d - c); c = this.aStartAngle + a * d; a = this.aX + this.xRadius * Math.cos(c); var f = this.aY + this.yRadius * Math.sin(c); 0 !== this.aRotation && (c = Math.cos(this.aRotation), d = Math.sin(this.aRotation), e = a - this.aX, f -= this.aY, a = e * c - f * d + this.aX, f = e * d + f * c + this.aY); return b.set(a, f) }; Na.prototype.copy = function (a) {
				S.prototype.copy.call(this,
					a); this.aX = a.aX; this.aY = a.aY; this.xRadius = a.xRadius; this.yRadius = a.yRadius; this.aStartAngle = a.aStartAngle; this.aEndAngle = a.aEndAngle; this.aClockwise = a.aClockwise; this.aRotation = a.aRotation; return this
			}; ab.prototype = Object.create(S.prototype); ab.prototype.constructor = ab; ab.prototype.isSplineCurve = !0; ab.prototype.getPoint = function (a, b) {
				b = b || new C; var c = this.points, d = (c.length - 1) * a; a = Math.floor(d); var d = d - a, e = c[0 === a ? a : a - 1], f = c[a], g = c[a > c.length - 2 ? c.length - 1 : a + 1], c = c[a > c.length - 3 ? c.length - 1 : a + 2]; b.set(Se(d,
					e.x, f.x, g.x, c.x), Se(d, e.y, f.y, g.y, c.y)); return b
			}; ab.prototype.copy = function (a) { S.prototype.copy.call(this, a); this.points = []; for (var b = 0, c = a.points.length; b < c; b++)this.points.push(a.points[b].clone()); return this }; bb.prototype = Object.create(S.prototype); bb.prototype.constructor = bb; bb.prototype.isCubicBezierCurve = !0; bb.prototype.getPoint = function (a, b) { b = b || new C; var c = this.v0, d = this.v1, e = this.v2, f = this.v3; b.set(zb(a, c.x, d.x, e.x, f.x), zb(a, c.y, d.y, e.y, f.y)); return b }; bb.prototype.copy = function (a) {
				S.prototype.copy.call(this,
					a); this.v0.copy(a.v0); this.v1.copy(a.v1); this.v2.copy(a.v2); this.v3.copy(a.v3); return this
			}; cb.prototype = Object.create(S.prototype); cb.prototype.constructor = cb; cb.prototype.isQuadraticBezierCurve = !0; cb.prototype.getPoint = function (a, b) { b = b || new C; var c = this.v0, d = this.v1, e = this.v2; b.set(yb(a, c.x, d.x, e.x), yb(a, c.y, d.y, e.y)); return b }; cb.prototype.copy = function (a) { S.prototype.copy.call(this, a); this.v0.copy(a.v0); this.v1.copy(a.v1); this.v2.copy(a.v2); return this }; var se = Object.assign(Object.create(Ab.prototype),
				{
					setFromPoints: function (a) { this.moveTo(a[0].x, a[0].y); for (var b = 1, c = a.length; b < c; b++)this.lineTo(a[b].x, a[b].y) }, moveTo: function (a, b) { this.currentPoint.set(a, b) }, lineTo: function (a, b) { var c = new Ka(this.currentPoint.clone(), new C(a, b)); this.curves.push(c); this.currentPoint.set(a, b) }, quadraticCurveTo: function (a, b, c, d) { a = new cb(this.currentPoint.clone(), new C(a, b), new C(c, d)); this.curves.push(a); this.currentPoint.set(c, d) }, bezierCurveTo: function (a, b, c, d, e, f) {
						a = new bb(this.currentPoint.clone(), new C(a,
							b), new C(c, d), new C(e, f)); this.curves.push(a); this.currentPoint.set(e, f)
					}, splineThru: function (a) { var b = [this.currentPoint.clone()].concat(a), b = new ab(b); this.curves.push(b); this.currentPoint.copy(a[a.length - 1]) }, arc: function (a, b, c, d, e, f) { this.absarc(a + this.currentPoint.x, b + this.currentPoint.y, c, d, e, f) }, absarc: function (a, b, c, d, e, f) { this.absellipse(a, b, c, c, d, e, f) }, ellipse: function (a, b, c, d, e, f, g, h) { this.absellipse(a + this.currentPoint.x, b + this.currentPoint.y, c, d, e, f, g, h) }, absellipse: function (a, b, c, d,
						e, f, g, h) { a = new Na(a, b, c, d, e, f, g, h); 0 < this.curves.length && (b = a.getPoint(0), b.equals(this.currentPoint) || this.lineTo(b.x, b.y)); this.curves.push(a); a = a.getPoint(1); this.currentPoint.copy(a) }, copy: function (a) { Ab.prototype.copy.call(this, a); this.currentPoint.copy(a.currentPoint); return this }
				}); Bb.prototype = se; se.constructor = Bb; Cb.prototype = Object.assign(Object.create(se), {
					constructor: Cb, getPointsHoles: function (a) { for (var b = [], c = 0, d = this.holes.length; c < d; c++)b[c] = this.holes[c].getPoints(a); return b }, extractPoints: function (a) {
						return {
							shape: this.getPoints(a),
							holes: this.getPointsHoles(a)
						}
					}, copy: function (a) { Bb.prototype.copy.call(this, a); this.holes = []; for (var b = 0, c = a.holes.length; b < c; b++)this.holes.push(a.holes[b].clone()); return this }
				}); Object.assign(ce.prototype, {
					moveTo: function (a, b) { this.currentPath = new Bb; this.subPaths.push(this.currentPath); this.currentPath.moveTo(a, b) }, lineTo: function (a, b) { this.currentPath.lineTo(a, b) }, quadraticCurveTo: function (a, b, c, d) { this.currentPath.quadraticCurveTo(a, b, c, d) }, bezierCurveTo: function (a, b, c, d, e, f) {
						this.currentPath.bezierCurveTo(a,
							b, c, d, e, f)
					}, splineThru: function (a) { this.currentPath.splineThru(a) }, toShapes: function (a, b) {
						function c(a) { for (var b = [], c = 0, d = a.length; c < d; c++) { var e = a[c], f = new Cb; f.curves = e.curves; b.push(f) } return b } function d(a, b) {
							for (var c = b.length, d = !1, e = c - 1, f = 0; f < c; e = f++) {
								var g = b[e], h = b[f], k = h.x - g.x, l = h.y - g.y; if (Math.abs(l) > Number.EPSILON) { if (0 > l && (g = b[f], k = -k, h = b[e], l = -l), !(a.y < g.y || a.y > h.y)) if (a.y === g.y) { if (a.x === g.x) return !0 } else { e = l * (a.x - g.x) - k * (a.y - g.y); if (0 === e) return !0; 0 > e || (d = !d) } } else if (a.y === g.y && (h.x <=
									a.x && a.x <= g.x || g.x <= a.x && a.x <= h.x)) return !0
							} return d
						} var e = Ha.isClockWise, f = this.subPaths; if (0 === f.length) return []; if (!0 === b) return c(f); b = []; if (1 === f.length) { var g = f[0]; var h = new Cb; h.curves = g.curves; b.push(h); return b } var k = !e(f[0].getPoints()), k = a ? !k : k; h = []; var l = [], m = [], n = 0; l[n] = void 0; m[n] = []; for (var p = 0, r = f.length; p < r; p++) { g = f[p]; var u = g.getPoints(); var v = e(u); (v = a ? !v : v) ? (!k && l[n] && n++ , l[n] = { s: new Cb, p: u }, l[n].s.curves = g.curves, k && n++ , m[n] = []) : m[n].push({ h: g, p: u[0] }) } if (!l[0]) return c(f); if (1 <
							l.length) { p = !1; a = []; e = 0; for (f = l.length; e < f; e++)h[e] = []; e = 0; for (f = l.length; e < f; e++)for (g = m[e], v = 0; v < g.length; v++) { k = g[v]; n = !0; for (u = 0; u < l.length; u++)d(k.p, l[u].p) && (e !== u && a.push({ froms: e, tos: u, hole: v }), n ? (n = !1, h[u].push(k)) : p = !0); n && h[e].push(k) } 0 < a.length && (p || (m = h)) } p = 0; for (e = l.length; p < e; p++)for (h = l[p].s, b.push(h), a = m[p], f = 0, g = a.length; f < g; f++)h.holes.push(a[f].h); return b
					}
				}); Object.assign(de.prototype, {
					isFont: !0, generateShapes: function (a, b, c) {
					void 0 === b && (b = 100); void 0 === c && (c = 4); var d = this.data;
						a = String(a).split(""); var e = b / d.resolution, f = (d.boundingBox.yMax - d.boundingBox.yMin + d.underlineThickness) * e, g = 0, h = 0; b = []; for (var k = 0; k < a.length; k++) {
							var l = a[k]; if ("\n" === l) g = 0, h -= f; else {
								var m; var n = e; var p = g, r = h; if (l = d.glyphs[l] || d.glyphs["?"]) {
									var u = new ce, v = []; if (l.o) for (var w = l._cachedOutline || (l._cachedOutline = l.o.split(" ")), x = 0, y = w.length; x < y;)switch (w[x++]) {
										case "m": var A = w[x++] * n + p; var B = w[x++] * n + r; u.moveTo(A, B); break; case "l": A = w[x++] * n + p; B = w[x++] * n + r; u.lineTo(A, B); break; case "q": var C = w[x++] *
											n + p; var D = w[x++] * n + r; var E = w[x++] * n + p; var H = w[x++] * n + r; u.quadraticCurveTo(E, H, C, D); if (m = v[v.length - 1]) { var N = m.x; m = m.y; for (var K = 1; K <= c; K++) { var O = K / c; yb(O, N, E, C); yb(O, m, H, D) } } break; case "b": if (C = w[x++] * n + p, D = w[x++] * n + r, E = w[x++] * n + p, H = w[x++] * n + r, A = w[x++] * n + p, B = w[x++] * n + r, u.bezierCurveTo(E, H, A, B, C, D), m = v[v.length - 1]) for (N = m.x, m = m.y, K = 1; K <= c; K++)O = K / c, zb(O, N, E, A, C), zb(O, m, H, B, D)
									}n = { offsetX: l.ha * n, path: u }
								} else n = void 0; g += n.offsetX; b.push(n.path)
							}
						} c = []; d = 0; for (a = b.length; d < a; d++)Array.prototype.push.apply(c,
							b[d].toShapes()); return c
					}
				}); Object.assign(Te.prototype, { load: function (a, b, c, d) { var e = this, f = new Ja(this.manager); f.setPath(this.path); f.load(a, function (a) { try { var c = JSON.parse(a) } catch (k) { console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), c = JSON.parse(a.substring(65, a.length - 2)) } a = e.parse(c); b && b(a) }, c, d) }, parse: function (a) { return new de(a) }, setPath: function (a) { this.path = a; return this } }); var Md, ge = {
					getContext: function () {
					void 0 === Md && (Md = new (window.AudioContext ||
						window.webkitAudioContext)); return Md
					}, setContext: function (a) { Md = a }
				}; Object.assign(ee.prototype, { load: function (a, b, c, d) { var e = new Ja(this.manager); e.setResponseType("arraybuffer"); e.load(a, function (a) { ge.getContext().decodeAudioData(a, function (a) { b(a) }) }, c, d) } }); Object.assign(Ue.prototype, {
					update: function () {
						var a, b, c, d, e, f, g, h, k = new K, l = new K; return function (m) {
							if (a !== this || b !== m.focus || c !== m.fov || d !== m.aspect * this.aspect || e !== m.near || f !== m.far || g !== m.zoom || h !== this.eyeSep) {
								a = this; b = m.focus; c = m.fov;
								d = m.aspect * this.aspect; e = m.near; f = m.far; g = m.zoom; var n = m.projectionMatrix.clone(); h = this.eyeSep / 2; var q = h * e / b, p = e * Math.tan(R.DEG2RAD * c * .5) / g; l.elements[12] = -h; k.elements[12] = h; var u = -p * d + q; var v = p * d + q; n.elements[0] = 2 * e / (v - u); n.elements[8] = (v + u) / (v - u); this.cameraL.projectionMatrix.copy(n); u = -p * d - q; v = p * d - q; n.elements[0] = 2 * e / (v - u); n.elements[8] = (v + u) / (v - u); this.cameraR.projectionMatrix.copy(n)
							} this.cameraL.matrixWorld.copy(m.matrixWorld).multiply(l); this.cameraR.matrixWorld.copy(m.matrixWorld).multiply(k)
						}
					}()
				});
	$c.prototype = Object.create(A.prototype); $c.prototype.constructor = $c; fe.prototype = Object.assign(Object.create(A.prototype), {
		constructor: fe, getInput: function () { return this.gain }, removeFilter: function () { null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null) }, getFilter: function () { return this.filter }, setFilter: function (a) {
			null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) :
			this.gain.disconnect(this.context.destination); this.filter = a; this.gain.connect(this.filter); this.filter.connect(this.context.destination)
		}, getMasterVolume: function () { return this.gain.gain.value }, setMasterVolume: function (a) { this.gain.gain.value = a }, updateMatrixWorld: function () {
			var a = new p, b = new Z, c = new p, d = new p; return function (e) {
				A.prototype.updateMatrixWorld.call(this, e); e = this.context.listener; var f = this.up; this.matrixWorld.decompose(a, b, c); d.set(0, 0, -1).applyQuaternion(b); e.positionX ? (e.positionX.setValueAtTime(a.x,
					this.context.currentTime), e.positionY.setValueAtTime(a.y, this.context.currentTime), e.positionZ.setValueAtTime(a.z, this.context.currentTime), e.forwardX.setValueAtTime(d.x, this.context.currentTime), e.forwardY.setValueAtTime(d.y, this.context.currentTime), e.forwardZ.setValueAtTime(d.z, this.context.currentTime), e.upX.setValueAtTime(f.x, this.context.currentTime), e.upY.setValueAtTime(f.y, this.context.currentTime), e.upZ.setValueAtTime(f.z, this.context.currentTime)) : (e.setPosition(a.x, a.y, a.z), e.setOrientation(d.x,
						d.y, d.z, f.x, f.y, f.z))
			}
		}()
	}); lc.prototype = Object.assign(Object.create(A.prototype), {
		constructor: lc, getOutput: function () { return this.gain }, setNodeSource: function (a) { this.hasPlaybackControl = !1; this.sourceType = "audioNode"; this.source = a; this.connect(); return this }, setBuffer: function (a) { this.buffer = a; this.sourceType = "buffer"; this.autoplay && this.play(); return this }, play: function () {
			if (!0 === this.isPlaying) console.warn("THREE.Audio: Audio is already playing."); else if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
			else { var a = this.context.createBufferSource(); a.buffer = this.buffer; a.loop = this.loop; a.onended = this.onEnded.bind(this); a.playbackRate.setValueAtTime(this.playbackRate, this.startTime); this.startTime = this.context.currentTime; a.start(this.startTime, this.offset); this.isPlaying = !0; this.source = a; return this.connect() }
		}, pause: function () {
			if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control."); else return !0 === this.isPlaying && (this.source.stop(), this.offset += (this.context.currentTime -
				this.startTime) * this.playbackRate, this.isPlaying = !1), this
		}, stop: function () { if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control."); else return this.source.stop(), this.offset = 0, this.isPlaying = !1, this }, connect: function () {
			if (0 < this.filters.length) { this.source.connect(this.filters[0]); for (var a = 1, b = this.filters.length; a < b; a++)this.filters[a - 1].connect(this.filters[a]); this.filters[this.filters.length - 1].connect(this.getOutput()) } else this.source.connect(this.getOutput());
			return this
		}, disconnect: function () { if (0 < this.filters.length) { this.source.disconnect(this.filters[0]); for (var a = 1, b = this.filters.length; a < b; a++)this.filters[a - 1].disconnect(this.filters[a]); this.filters[this.filters.length - 1].disconnect(this.getOutput()) } else this.source.disconnect(this.getOutput()); return this }, getFilters: function () { return this.filters }, setFilters: function (a) { a || (a = []); !0 === this.isPlaying ? (this.disconnect(), this.filters = a, this.connect()) : this.filters = a; return this }, getFilter: function () { return this.getFilters()[0] },
		setFilter: function (a) { return this.setFilters(a ? [a] : []) }, setPlaybackRate: function (a) { if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control."); else return this.playbackRate = a, !0 === this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime), this }, getPlaybackRate: function () { return this.playbackRate }, onEnded: function () { this.isPlaying = !1 }, getLoop: function () {
			return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."),
				!1) : this.loop
		}, setLoop: function (a) { if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control."); else return this.loop = a, !0 === this.isPlaying && (this.source.loop = this.loop), this }, getVolume: function () { return this.gain.gain.value }, setVolume: function (a) { this.gain.gain.value = a; return this }
	}); he.prototype = Object.assign(Object.create(lc.prototype), {
		constructor: he, getOutput: function () { return this.panner }, getRefDistance: function () { return this.panner.refDistance }, setRefDistance: function (a) {
			this.panner.refDistance =
			a
		}, getRolloffFactor: function () { return this.panner.rolloffFactor }, setRolloffFactor: function (a) { this.panner.rolloffFactor = a }, getDistanceModel: function () { return this.panner.distanceModel }, setDistanceModel: function (a) { this.panner.distanceModel = a }, getMaxDistance: function () { return this.panner.maxDistance }, setMaxDistance: function (a) { this.panner.maxDistance = a }, updateMatrixWorld: function () {
			var a = new p; return function (b) {
				A.prototype.updateMatrixWorld.call(this, b); a.setFromMatrixPosition(this.matrixWorld); this.panner.setPosition(a.x,
					a.y, a.z)
			}
		}()
	}); Object.assign(ie.prototype, { getFrequencyData: function () { this.analyser.getByteFrequencyData(this.data); return this.data }, getAverageFrequency: function () { for (var a = 0, b = this.getFrequencyData(), c = 0; c < b.length; c++)a += b[c]; return a / b.length } }); Object.assign(je.prototype, {
		accumulate: function (a, b) { var c = this.buffer, d = this.valueSize; a = a * d + d; var e = this.cumulativeWeight; if (0 === e) { for (e = 0; e !== d; ++e)c[a + e] = c[e]; e = b } else e += b, this._mixBufferRegion(c, a, 0, b / e, d); this.cumulativeWeight = e }, apply: function (a) {
			var b =
				this.valueSize, c = this.buffer; a = a * b + b; var d = this.cumulativeWeight, e = this.binding; this.cumulativeWeight = 0; 1 > d && this._mixBufferRegion(c, a, 3 * b, 1 - d, b); for (var d = b, f = b + b; d !== f; ++d)if (c[d] !== c[d + b]) { e.setValue(c, a); break }
		}, saveOriginalState: function () { var a = this.buffer, b = this.valueSize, c = 3 * b; this.binding.getValue(a, c); for (var d = b; d !== c; ++d)a[d] = a[c + d % b]; this.cumulativeWeight = 0 }, restoreOriginalState: function () { this.binding.setValue(this.buffer, 3 * this.valueSize) }, _select: function (a, b, c, d, e) {
			if (.5 <= d) for (d =
				0; d !== e; ++d)a[b + d] = a[c + d]
		}, _slerp: function (a, b, c, d) { Z.slerpFlat(a, b, a, b, a, c, d) }, _lerp: function (a, b, c, d, e) { for (var f = 1 - d, g = 0; g !== e; ++g) { var h = b + g; a[h] = a[h] * f + a[c + g] * d } }
	}); Object.assign(Ve.prototype, {
		getValue: function (a, b) { this.bind(); var c = this._bindings[this._targetGroup.nCachedObjects_]; void 0 !== c && c.getValue(a, b) }, setValue: function (a, b) { for (var c = this._bindings, d = this._targetGroup.nCachedObjects_, e = c.length; d !== e; ++d)c[d].setValue(a, b) }, bind: function () {
			for (var a = this._bindings, b = this._targetGroup.nCachedObjects_,
				c = a.length; b !== c; ++b)a[b].bind()
		}, unbind: function () { for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b)a[b].unbind() }
	}); Object.assign(na, {
		Composite: Ve, create: function (a, b, c) { return a && a.isAnimationObjectGroup ? new na.Composite(a, b, c) : new na(a, b, c) }, sanitizeNodeName: function (a) { return a.replace(/\s/g, "_").replace(/[^\w-]/g, "") }, parseTrackName: function () {
			var a = new RegExp("^" + /((?:[\w-]+[\/:])*)/.source + /([\w-\.]+)?/.source + /(?:\.([\w-]+)(?:\[(.+)\])?)?/.source + /\.([\w-]+)(?:\[(.+)\])?/.source +
				"$"), b = ["material", "materials", "bones"]; return function (c) {
					var d = a.exec(c); if (!d) throw Error("PropertyBinding: Cannot parse trackName: " + c); var d = { nodeName: d[2], objectName: d[3], objectIndex: d[4], propertyName: d[5], propertyIndex: d[6] }, e = d.nodeName && d.nodeName.lastIndexOf("."); if (void 0 !== e && -1 !== e) { var f = d.nodeName.substring(e + 1); -1 !== b.indexOf(f) && (d.nodeName = d.nodeName.substring(0, e), d.objectName = f) } if (null === d.propertyName || 0 === d.propertyName.length) throw Error("PropertyBinding: can not parse propertyName from trackName: " +
						c); return d
				}
		}(), findNode: function (a, b) { if (!b || "" === b || "root" === b || "." === b || -1 === b || b === a.name || b === a.uuid) return a; if (a.skeleton) { var c = function (a) { for (var c = 0; c < a.bones.length; c++) { var d = a.bones[c]; if (d.name === b) return d } return null }(a.skeleton); if (c) return c } if (a.children) { var d = function (a) { for (var c = 0; c < a.length; c++) { var e = a[c]; if (e.name === b || e.uuid === b || (e = d(e.children))) return e } return null }; if (a = d(a.children)) return a } return null }
	}); Object.assign(na.prototype, {
		_getValue_unavailable: function () { },
		_setValue_unavailable: function () { }, BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, GetterByBindingType: [function (a, b) { a[b] = this.node[this.propertyName] }, function (a, b) { for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d)a[b++] = c[d] }, function (a, b) { a[b] = this.resolvedProperty[this.propertyIndex] }, function (a, b) { this.resolvedProperty.toArray(a, b) }], SetterByBindingTypeAndVersioning: [[function (a, b) {
		this.targetObject[this.propertyName] =
			a[b]
		}, function (a, b) { this.targetObject[this.propertyName] = a[b]; this.targetObject.needsUpdate = !0 }, function (a, b) { this.targetObject[this.propertyName] = a[b]; this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (a, b) { for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d)c[d] = a[b++] }, function (a, b) { for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d)c[d] = a[b++]; this.targetObject.needsUpdate = !0 }, function (a, b) {
			for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d)c[d] = a[b++]; this.targetObject.matrixWorldNeedsUpdate =
				!0
		}], [function (a, b) { this.resolvedProperty[this.propertyIndex] = a[b] }, function (a, b) { this.resolvedProperty[this.propertyIndex] = a[b]; this.targetObject.needsUpdate = !0 }, function (a, b) { this.resolvedProperty[this.propertyIndex] = a[b]; this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (a, b) { this.resolvedProperty.fromArray(a, b) }, function (a, b) { this.resolvedProperty.fromArray(a, b); this.targetObject.needsUpdate = !0 }, function (a, b) { this.resolvedProperty.fromArray(a, b); this.targetObject.matrixWorldNeedsUpdate = !0 }]],
		getValue: function (a, b) { this.bind(); this.getValue(a, b) }, setValue: function (a, b) { this.bind(); this.setValue(a, b) }, bind: function () {
			var a = this.node, b = this.parsedPath, c = b.objectName, d = b.propertyName, e = b.propertyIndex; a || (this.node = a = na.findNode(this.rootNode, b.nodeName) || this.rootNode); this.getValue = this._getValue_unavailable; this.setValue = this._setValue_unavailable; if (a) {
				if (c) {
					var f = b.objectIndex; switch (c) {
						case "materials": if (!a.material) {
							console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",
								this); return
						} if (!a.material.materials) { console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this); return } a = a.material.materials; break; case "bones": if (!a.skeleton) { console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); return } a = a.skeleton.bones; for (c = 0; c < a.length; c++)if (a[c].name === f) { f = c; break } break; default: if (void 0 === a[c]) {
							console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",
								this); return
						} a = a[c]
					}if (void 0 !== f) { if (void 0 === a[f]) { console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, a); return } a = a[f] }
				} f = a[d]; if (void 0 === f) console.error("THREE.PropertyBinding: Trying to update property for track: " + b.nodeName + "." + d + " but it wasn't found.", a); else {
					b = this.Versioning.None; void 0 !== a.needsUpdate ? (b = this.Versioning.NeedsUpdate, this.targetObject = a) : void 0 !== a.matrixWorldNeedsUpdate && (b = this.Versioning.MatrixWorldNeedsUpdate, this.targetObject =
						a); c = this.BindingType.Direct; if (void 0 !== e) {
							if ("morphTargetInfluences" === d) {
								if (!a.geometry) { console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); return } if (a.geometry.isBufferGeometry) {
									if (!a.geometry.morphAttributes) { console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); return } for (c = 0; c < this.node.geometry.morphAttributes.position.length; c++)if (a.geometry.morphAttributes.position[c].name ===
										e) { e = c; break }
								} else { if (!a.geometry.morphTargets) { console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this); return } for (c = 0; c < this.node.geometry.morphTargets.length; c++)if (a.geometry.morphTargets[c].name === e) { e = c; break } }
							} c = this.BindingType.ArrayElement; this.resolvedProperty = f; this.propertyIndex = e
						} else void 0 !== f.fromArray && void 0 !== f.toArray ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = f) : Array.isArray(f) ? (c = this.BindingType.EntireArray,
							this.resolvedProperty = f) : this.propertyName = d; this.getValue = this.GetterByBindingType[c]; this.setValue = this.SetterByBindingTypeAndVersioning[c][b]
				}
			} else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
		}, unbind: function () { this.node = null; this.getValue = this._getValue_unbound; this.setValue = this._setValue_unbound }
	}); Object.assign(na.prototype, { _getValue_unbound: na.prototype.getValue, _setValue_unbound: na.prototype.setValue }); Object.assign(We.prototype,
		{
			isAnimationObjectGroup: !0, add: function () {
				for (var a = this._objects, b = a.length, c = this.nCachedObjects_, d = this._indicesByUUID, e = this._paths, f = this._parsedPaths, g = this._bindings, h = g.length, k = 0, l = arguments.length; k !== l; ++k) {
					var m = arguments[k], n = m.uuid, p = d[n]; if (void 0 === p) { p = b++; d[n] = p; a.push(m); for (var n = 0, r = h; n !== r; ++n)g[n].push(new na(m, e[n], f[n])) } else if (p < c) {
						var u = --c, r = a[u]; d[r.uuid] = p; a[p] = r; d[n] = u; a[u] = m; n = 0; for (r = h; n !== r; ++n) {
							var v = g[n], w = v[p]; v[p] = v[u]; void 0 === w && (w = new na(m, e[n], f[n])); v[u] =
								w
						}
					} else void 0 !== a[p] && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
				} this.nCachedObjects_ = c
			}, remove: function () {
				for (var a = this._objects, b = this.nCachedObjects_, c = this._indicesByUUID, d = this._bindings, e = d.length, f = 0, g = arguments.length; f !== g; ++f) {
					var h = arguments[f], k = h.uuid, l = c[k]; if (void 0 !== l && l >= b) {
						var m = b++, n = a[m]; c[n.uuid] = l; a[l] = n; c[k] = m; a[m] = h; h = 0; for (k = e; h !== k; ++h) {
							var n = d[h], p =
								n[l]; n[l] = n[m]; n[m] = p
						}
					}
				} this.nCachedObjects_ = b
			}, uncache: function () {
				for (var a, b, c = this._objects, d = c.length, e = this.nCachedObjects_, f = this._indicesByUUID, g = this._bindings, h = g.length, k = 0, l = arguments.length; k !== l; ++k) {
					b = arguments[k].uuid; var m = f[b]; if (void 0 !== m) if (delete f[b], m < e) { var n = --e, p = c[n]; b = --d; a = c[b]; f[p.uuid] = m; c[m] = p; f[a.uuid] = n; c[n] = a; c.pop(); for (var p = 0, r = h; p !== r; ++p) { a = g[p]; var u = a[b]; a[m] = a[n]; a[n] = u; a.pop() } } else for (b = --d, a = c[b], f[a.uuid] = m, c[m] = a, c.pop(), p = 0, r = h; p !== r; ++p)a = g[p], a[m] =
						a[b], a.pop()
				} this.nCachedObjects_ = e
			}, subscribe_: function (a, b) { var c = this._bindingsIndicesByPath, d = c[a], e = this._bindings; if (void 0 !== d) return e[d]; var f = this._paths, g = this._parsedPaths, h = this._objects, k = this.nCachedObjects_, l = Array(h.length), d = e.length; c[a] = d; f.push(a); g.push(b); e.push(l); c = k; for (d = h.length; c !== d; ++c)l[c] = new na(h[c], a, b); return l }, unsubscribe_: function (a) {
				var b = this._bindingsIndicesByPath, c = b[a]; if (void 0 !== c) {
					var d = this._paths, e = this._parsedPaths, f = this._bindings, g = f.length - 1, h =
						f[g]; b[a[g]] = c; f[c] = h; f.pop(); e[c] = e[g]; e.pop(); d[c] = d[g]; d.pop()
				}
			}
		}); Object.assign(Xe.prototype, {
			play: function () { this._mixer._activateAction(this); return this }, stop: function () { this._mixer._deactivateAction(this); return this.reset() }, reset: function () { this.paused = !1; this.enabled = !0; this.time = 0; this._loopCount = -1; this._startTime = null; return this.stopFading().stopWarping() }, isRunning: function () { return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this) },
			isScheduled: function () { return this._mixer._isActiveAction(this) }, startAt: function (a) { this._startTime = a; return this }, setLoop: function (a, b) { this.loop = a; this.repetitions = b; return this }, setEffectiveWeight: function (a) { this.weight = a; this._effectiveWeight = this.enabled ? a : 0; return this.stopFading() }, getEffectiveWeight: function () { return this._effectiveWeight }, fadeIn: function (a) { return this._scheduleFading(a, 0, 1) }, fadeOut: function (a) { return this._scheduleFading(a, 1, 0) }, crossFadeFrom: function (a, b, c) {
				a.fadeOut(b);
				this.fadeIn(b); if (c) { c = this._clip.duration; var d = a._clip.duration, e = c / d; a.warp(1, d / c, b); this.warp(e, 1, b) } return this
			}, crossFadeTo: function (a, b, c) { return a.crossFadeFrom(this, b, c) }, stopFading: function () { var a = this._weightInterpolant; null !== a && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(a)); return this }, setEffectiveTimeScale: function (a) { this.timeScale = a; this._effectiveTimeScale = this.paused ? 0 : a; return this.stopWarping() }, getEffectiveTimeScale: function () { return this._effectiveTimeScale },
			setDuration: function (a) { this.timeScale = this._clip.duration / a; return this.stopWarping() }, syncWith: function (a) { this.time = a.time; this.timeScale = a.timeScale; return this.stopWarping() }, halt: function (a) { return this.warp(this._effectiveTimeScale, 0, a) }, warp: function (a, b, c) { var d = this._mixer, e = d.time, f = this._timeScaleInterpolant, g = this.timeScale; null === f && (this._timeScaleInterpolant = f = d._lendControlInterpolant()); d = f.parameterPositions; f = f.sampleValues; d[0] = e; d[1] = e + c; f[0] = a / g; f[1] = b / g; return this }, stopWarping: function () {
				var a =
					this._timeScaleInterpolant; null !== a && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(a)); return this
			}, getMixer: function () { return this._mixer }, getClip: function () { return this._clip }, getRoot: function () { return this._localRoot || this._mixer._root }, _update: function (a, b, c, d) {
				if (this.enabled) {
					var e = this._startTime; if (null !== e) { b = (a - e) * c; if (0 > b || 0 === c) return; this._startTime = null; b *= c } b *= this._updateTimeScale(a); c = this._updateTime(b); a = this._updateWeight(a); if (0 < a) {
						b = this._interpolants;
						for (var e = this._propertyBindings, f = 0, g = b.length; f !== g; ++f)b[f].evaluate(c), e[f].accumulate(d, a)
					}
				} else this._updateWeight(a)
			}, _updateWeight: function (a) { var b = 0; if (this.enabled) { var b = this.weight, c = this._weightInterpolant; if (null !== c) { var d = c.evaluate(a)[0], b = b * d; a > c.parameterPositions[1] && (this.stopFading(), 0 === d && (this.enabled = !1)) } } return this._effectiveWeight = b }, _updateTimeScale: function (a) {
				var b = 0; if (!this.paused) {
					var b = this.timeScale, c = this._timeScaleInterpolant; if (null !== c) {
						var d = c.evaluate(a)[0],
						b = b * d; a > c.parameterPositions[1] && (this.stopWarping(), 0 === b ? this.paused = !0 : this.timeScale = b)
					}
				} return this._effectiveTimeScale = b
			}, _updateTime: function (a) {
				var b = this.time + a; if (0 === a) return b; var c = this._clip.duration, d = this.loop, e = this._loopCount; if (2200 === d) a: { if (-1 === e && (this._loopCount = 0, this._setEndings(!0, !0, !1)), b >= c) b = c; else if (0 > b) b = 0; else break a; this.clampWhenFinished ? this.paused = !0 : this.enabled = !1; this._mixer.dispatchEvent({ type: "finished", action: this, direction: 0 > a ? -1 : 1 }) } else {
					d = 2202 === d;
					-1 === e && (0 <= a ? (e = 0, this._setEndings(!0, 0 === this.repetitions, d)) : this._setEndings(0 === this.repetitions, !0, d)); if (b >= c || 0 > b) { var f = Math.floor(b / c), b = b - c * f, e = e + Math.abs(f), g = this.repetitions - e; 0 > g ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, b = 0 < a ? c : 0, this._mixer.dispatchEvent({ type: "finished", action: this, direction: 0 < a ? 1 : -1 })) : (0 === g ? (a = 0 > a, this._setEndings(a, !a, d)) : this._setEndings(!1, !1, d), this._loopCount = e, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: f })) } if (d && 1 === (e & 1)) return this.time =
						b, c - b
				} return this.time = b
			}, _setEndings: function (a, b, c) { var d = this._interpolantSettings; c ? (d.endingStart = 2401, d.endingEnd = 2401) : (d.endingStart = a ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, d.endingEnd = b ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402) }, _scheduleFading: function (a, b, c) { var d = this._mixer, e = d.time, f = this._weightInterpolant; null === f && (this._weightInterpolant = f = d._lendControlInterpolant()); d = f.parameterPositions; f = f.sampleValues; d[0] = e; f[0] = b; d[1] = e + a; f[1] = c; return this }
		}); Object.assign(Ye.prototype, ja.prototype,
			{
				_bindAction: function (a, b) {
					var c = a._localRoot || this._root, d = a._clip.tracks, e = d.length, f = a._propertyBindings; a = a._interpolants; var g = c.uuid, h = this._bindingsByRootAndName, k = h[g]; void 0 === k && (k = {}, h[g] = k); for (h = 0; h !== e; ++h) {
						var l = d[h], m = l.name, n = k[m]; if (void 0 === n) {
							n = f[h]; if (void 0 !== n) { null === n._cacheIndex && (++n.referenceCount, this._addInactiveBinding(n, g, m)); continue } n = new je(na.create(c, m, b && b._propertyBindings[h].binding.parsedPath), l.ValueTypeName, l.getValueSize()); ++n.referenceCount; this._addInactiveBinding(n,
								g, m)
						} f[h] = n; a[h].resultBuffer = n.buffer
					}
				}, _activateAction: function (a) { if (!this._isActiveAction(a)) { if (null === a._cacheIndex) { var b = (a._localRoot || this._root).uuid, c = a._clip.uuid, d = this._actionsByClip[c]; this._bindAction(a, d && d.knownActions[0]); this._addInactiveAction(a, c, b) } b = a._propertyBindings; c = 0; for (d = b.length; c !== d; ++c) { var e = b[c]; 0 === e.useCount++ && (this._lendBinding(e), e.saveOriginalState()) } this._lendAction(a) } }, _deactivateAction: function (a) {
					if (this._isActiveAction(a)) {
						for (var b = a._propertyBindings,
							c = 0, d = b.length; c !== d; ++c) { var e = b[c]; 0 === --e.useCount && (e.restoreOriginalState(), this._takeBackBinding(e)) } this._takeBackAction(a)
					}
				}, _initMemoryManager: function () {
				this._actions = []; this._nActiveActions = 0; this._actionsByClip = {}; this._bindings = []; this._nActiveBindings = 0; this._bindingsByRootAndName = {}; this._controlInterpolants = []; this._nActiveControlInterpolants = 0; var a = this; this.stats = {
					actions: { get total() { return a._actions.length }, get inUse() { return a._nActiveActions } }, bindings: {
						get total() { return a._bindings.length },
						get inUse() { return a._nActiveBindings }
					}, controlInterpolants: { get total() { return a._controlInterpolants.length }, get inUse() { return a._nActiveControlInterpolants } }
				}
				}, _isActiveAction: function (a) { a = a._cacheIndex; return null !== a && a < this._nActiveActions }, _addInactiveAction: function (a, b, c) {
					var d = this._actions, e = this._actionsByClip, f = e[b]; void 0 === f ? (f = { knownActions: [a], actionByRoot: {} }, a._byClipCacheIndex = 0, e[b] = f) : (b = f.knownActions, a._byClipCacheIndex = b.length, b.push(a)); a._cacheIndex = d.length; d.push(a);
					f.actionByRoot[c] = a
				}, _removeInactiveAction: function (a) { var b = this._actions, c = b[b.length - 1], d = a._cacheIndex; c._cacheIndex = d; b[d] = c; b.pop(); a._cacheIndex = null; var b = a._clip.uuid, c = this._actionsByClip, d = c[b], e = d.knownActions, f = e[e.length - 1], g = a._byClipCacheIndex; f._byClipCacheIndex = g; e[g] = f; e.pop(); a._byClipCacheIndex = null; delete d.actionByRoot[(a._localRoot || this._root).uuid]; 0 === e.length && delete c[b]; this._removeInactiveBindingsForAction(a) }, _removeInactiveBindingsForAction: function (a) {
					a = a._propertyBindings;
					for (var b = 0, c = a.length; b !== c; ++b) { var d = a[b]; 0 === --d.referenceCount && this._removeInactiveBinding(d) }
				}, _lendAction: function (a) { var b = this._actions, c = a._cacheIndex, d = this._nActiveActions++, e = b[d]; a._cacheIndex = d; b[d] = a; e._cacheIndex = c; b[c] = e }, _takeBackAction: function (a) { var b = this._actions, c = a._cacheIndex, d = --this._nActiveActions, e = b[d]; a._cacheIndex = d; b[d] = a; e._cacheIndex = c; b[c] = e }, _addInactiveBinding: function (a, b, c) {
					var d = this._bindingsByRootAndName, e = d[b], f = this._bindings; void 0 === e && (e = {}, d[b] =
						e); e[c] = a; a._cacheIndex = f.length; f.push(a)
				}, _removeInactiveBinding: function (a) { var b = this._bindings, c = a.binding, d = c.rootNode.uuid, c = c.path, e = this._bindingsByRootAndName, f = e[d], g = b[b.length - 1]; a = a._cacheIndex; g._cacheIndex = a; b[a] = g; b.pop(); delete f[c]; a: { for (var h in f) break a; delete e[d] } }, _lendBinding: function (a) { var b = this._bindings, c = a._cacheIndex, d = this._nActiveBindings++, e = b[d]; a._cacheIndex = d; b[d] = a; e._cacheIndex = c; b[c] = e }, _takeBackBinding: function (a) {
					var b = this._bindings, c = a._cacheIndex, d =
						--this._nActiveBindings, e = b[d]; a._cacheIndex = d; b[d] = a; e._cacheIndex = c; b[c] = e
				}, _lendControlInterpolant: function () { var a = this._controlInterpolants, b = this._nActiveControlInterpolants++, c = a[b]; void 0 === c && (c = new Yc(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), c.__cacheIndex = b, a[b] = c); return c }, _takeBackControlInterpolant: function (a) {
					var b = this._controlInterpolants, c = a.__cacheIndex, d = --this._nActiveControlInterpolants, e = b[d]; a.__cacheIndex = d; b[d] = a; e.__cacheIndex = c;
					b[c] = e
				}, _controlInterpolantsResultBuffer: new Float32Array(1), clipAction: function (a, b) { var c = b || this._root, d = c.uuid, c = "string" === typeof a ? ka.findByName(c, a) : a; a = null !== c ? c.uuid : a; var e = this._actionsByClip[a], f = null; if (void 0 !== e) { f = e.actionByRoot[d]; if (void 0 !== f) return f; f = e.knownActions[0]; null === c && (c = f._clip) } if (null === c) return null; b = new Xe(this, c, b); this._bindAction(b, f); this._addInactiveAction(b, a, d); return b }, existingAction: function (a, b) {
					var c = b || this._root; b = c.uuid; c = "string" === typeof a ? ka.findByName(c,
						a) : a; a = this._actionsByClip[c ? c.uuid : a]; return void 0 !== a ? a.actionByRoot[b] || null : null
				}, stopAllAction: function () { for (var a = this._actions, b = this._nActiveActions, c = this._bindings, d = this._nActiveBindings, e = this._nActiveBindings = this._nActiveActions = 0; e !== b; ++e)a[e].reset(); for (e = 0; e !== d; ++e)c[e].useCount = 0; return this }, update: function (a) {
					a *= this.timeScale; for (var b = this._actions, c = this._nActiveActions, d = this.time += a, e = Math.sign(a), f = this._accuIndex ^= 1, g = 0; g !== c; ++g)b[g]._update(d, a, e, f); a = this._bindings;
					b = this._nActiveBindings; for (g = 0; g !== b; ++g)a[g].apply(f); return this
				}, getRoot: function () { return this._root }, uncacheClip: function (a) { var b = this._actions; a = a.uuid; var c = this._actionsByClip, d = c[a]; if (void 0 !== d) { for (var d = d.knownActions, e = 0, f = d.length; e !== f; ++e) { var g = d[e]; this._deactivateAction(g); var h = g._cacheIndex, k = b[b.length - 1]; g._cacheIndex = null; g._byClipCacheIndex = null; k._cacheIndex = h; b[h] = k; b.pop(); this._removeInactiveBindingsForAction(g) } delete c[a] } }, uncacheRoot: function (a) {
					a = a.uuid; var b =
						this._actionsByClip; for (d in b) { var c = b[d].actionByRoot[a]; void 0 !== c && (this._deactivateAction(c), this._removeInactiveAction(c)) } var d = this._bindingsByRootAndName[a]; if (void 0 !== d) for (var e in d) a = d[e], a.restoreOriginalState(), this._removeInactiveBinding(a)
				}, uncacheAction: function (a, b) { a = this.existingAction(a, b); null !== a && (this._deactivateAction(a), this._removeInactiveAction(a)) }
			}); Jd.prototype.clone = function () { return new Jd(void 0 === this.value.clone ? this.value : this.value.clone()) }; ke.prototype = Object.assign(Object.create(D.prototype),
				{ constructor: ke, isInstancedBufferGeometry: !0, copy: function (a) { D.prototype.copy.call(this, a); this.maxInstancedCount = a.maxInstancedCount; return this }, clone: function () { return (new this.constructor).copy(this) } }); Object.defineProperties(le.prototype, { count: { get: function () { return this.data.count } }, array: { get: function () { return this.data.array } } }); Object.assign(le.prototype, {
					isInterleavedBufferAttribute: !0, setX: function (a, b) { this.data.array[a * this.data.stride + this.offset] = b; return this }, setY: function (a, b) {
						this.data.array[a *
							this.data.stride + this.offset + 1] = b; return this
					}, setZ: function (a, b) { this.data.array[a * this.data.stride + this.offset + 2] = b; return this }, setW: function (a, b) { this.data.array[a * this.data.stride + this.offset + 3] = b; return this }, getX: function (a) { return this.data.array[a * this.data.stride + this.offset] }, getY: function (a) { return this.data.array[a * this.data.stride + this.offset + 1] }, getZ: function (a) { return this.data.array[a * this.data.stride + this.offset + 2] }, getW: function (a) {
						return this.data.array[a * this.data.stride + this.offset +
							3]
					}, setXY: function (a, b, c) { a = a * this.data.stride + this.offset; this.data.array[a + 0] = b; this.data.array[a + 1] = c; return this }, setXYZ: function (a, b, c, d) { a = a * this.data.stride + this.offset; this.data.array[a + 0] = b; this.data.array[a + 1] = c; this.data.array[a + 2] = d; return this }, setXYZW: function (a, b, c, d, e) { a = a * this.data.stride + this.offset; this.data.array[a + 0] = b; this.data.array[a + 1] = c; this.data.array[a + 2] = d; this.data.array[a + 3] = e; return this }
				}); Object.defineProperty(mc.prototype, "needsUpdate", { set: function (a) { !0 === a && this.version++ } });
	Object.assign(mc.prototype, {
		isInterleavedBuffer: !0, setArray: function (a) { if (Array.isArray(a)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.count = void 0 !== a ? a.length / this.stride : 0; this.array = a }, setDynamic: function (a) { this.dynamic = a; return this }, copy: function (a) { this.array = new a.array.constructor(a.array); this.count = a.count; this.stride = a.stride; this.dynamic = a.dynamic; return this }, copyAt: function (a, b, c) {
			a *= this.stride; c *= b.stride; for (var d = 0, e = this.stride; d < e; d++)this.array[a +
				d] = b.array[c + d]; return this
		}, set: function (a, b) { void 0 === b && (b = 0); this.array.set(a, b); return this }, clone: function () { return (new this.constructor).copy(this) }, onUpload: function (a) { this.onUploadCallback = a; return this }
	}); me.prototype = Object.assign(Object.create(mc.prototype), { constructor: me, isInstancedInterleavedBuffer: !0, copy: function (a) { mc.prototype.copy.call(this, a); this.meshPerAttribute = a.meshPerAttribute; return this } }); ne.prototype = Object.assign(Object.create(P.prototype), {
		constructor: ne, isInstancedBufferAttribute: !0,
		copy: function (a) { P.prototype.copy.call(this, a); this.meshPerAttribute = a.meshPerAttribute; return this }
	}); Object.assign(Ze.prototype, {
		linePrecision: 1, set: function (a, b) { this.ray.set(a, b) }, setFromCamera: function (a, b) {
			b && b.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(b.matrixWorld), this.ray.direction.set(a.x, a.y, .5).unproject(b).sub(this.ray.origin).normalize()) : b && b.isOrthographicCamera ? (this.ray.origin.set(a.x, a.y, (b.near + b.far) / (b.near - b.far)).unproject(b), this.ray.direction.set(0, 0, -1).transformDirection(b.matrixWorld)) :
				console.error("THREE.Raycaster: Unsupported camera type.")
		}, intersectObject: function (a, b) { var c = []; oe(a, this, c, b); c.sort($e); return c }, intersectObjects: function (a, b) { var c = []; if (!1 === Array.isArray(a)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), c; for (var d = 0, e = a.length; d < e; d++)oe(a[d], this, c, b); c.sort($e); return c }
	}); Object.assign(af.prototype, {
		start: function () {
		this.oldTime = this.startTime = ("undefined" === typeof performance ? Date : performance).now(); this.elapsedTime =
			0; this.running = !0
		}, stop: function () { this.getElapsedTime(); this.autoStart = this.running = !1 }, getElapsedTime: function () { this.getDelta(); return this.elapsedTime }, getDelta: function () { var a = 0; if (this.autoStart && !this.running) return this.start(), 0; if (this.running) { var b = ("undefined" === typeof performance ? Date : performance).now(), a = (b - this.oldTime) / 1E3; this.oldTime = b; this.elapsedTime += a } return a }
	}); Object.assign(bf.prototype, {
		set: function (a, b, c) { this.radius = a; this.phi = b; this.theta = c; return this }, clone: function () { return (new this.constructor).copy(this) },
		copy: function (a) { this.radius = a.radius; this.phi = a.phi; this.theta = a.theta; return this }, makeSafe: function () { this.phi = Math.max(1E-6, Math.min(Math.PI - 1E-6, this.phi)); return this }, setFromVector3: function (a) { this.radius = a.length(); 0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(a.x, a.z), this.phi = Math.acos(R.clamp(a.y / this.radius, -1, 1))); return this }
	}); Object.assign(cf.prototype, {
		set: function (a, b, c) { this.radius = a; this.theta = b; this.y = c; return this }, clone: function () { return (new this.constructor).copy(this) },
		copy: function (a) { this.radius = a.radius; this.theta = a.theta; this.y = a.y; return this }, setFromVector3: function (a) { this.radius = Math.sqrt(a.x * a.x + a.z * a.z); this.theta = Math.atan2(a.x, a.z); this.y = a.y; return this }
	}); ad.prototype = Object.create(A.prototype); ad.prototype.constructor = ad; ad.prototype.isImmediateRenderObject = !0; bd.prototype = Object.create(ca.prototype); bd.prototype.constructor = bd; bd.prototype.update = function () {
		var a = new p, b = new p, c = new ra; return function () {
			var d, e = ["a", "b", "c"]; this.object.updateMatrixWorld(!0);
			c.getNormalMatrix(this.object.matrixWorld); var f = this.object.matrixWorld, g = this.geometry.attributes.position; if ((d = this.object.geometry) && d.isGeometry) for (var h = d.vertices, k = d.faces, l = d = 0, m = k.length; l < m; l++)for (var n = k[l], p = 0, r = n.vertexNormals.length; p < r; p++) { var u = n.vertexNormals[p]; a.copy(h[n[e[p]]]).applyMatrix4(f); b.copy(u).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a); g.setXYZ(d, a.x, a.y, a.z); d += 1; g.setXYZ(d, b.x, b.y, b.z); d += 1 } else if (d && d.isBufferGeometry) for (e = d.attributes.position,
				h = d.attributes.normal, p = d = 0, r = e.count; p < r; p++)a.set(e.getX(p), e.getY(p), e.getZ(p)).applyMatrix4(f), b.set(h.getX(p), h.getY(p), h.getZ(p)), b.applyMatrix3(c).normalize().multiplyScalar(this.size).add(a), g.setXYZ(d, a.x, a.y, a.z), d += 1, g.setXYZ(d, b.x, b.y, b.z), d += 1; g.needsUpdate = !0
		}
	}(); nc.prototype = Object.create(A.prototype); nc.prototype.constructor = nc; nc.prototype.dispose = function () { this.cone.geometry.dispose(); this.cone.material.dispose() }; nc.prototype.update = function () {
		var a = new p, b = new p; return function () {
			this.light.updateMatrixWorld();
			var c = this.light.distance ? this.light.distance : 1E3, d = c * Math.tan(this.light.angle); this.cone.scale.set(d, d, c); a.setFromMatrixPosition(this.light.matrixWorld); b.setFromMatrixPosition(this.light.target.matrixWorld); this.cone.lookAt(b.sub(a)); void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
		}
	}(); oc.prototype = Object.create(ca.prototype); oc.prototype.constructor = oc; oc.prototype.updateMatrixWorld = function () {
		var a = new p, b = new K, c = new K; return function (d) {
			var e =
				this.bones, f = this.geometry, g = f.getAttribute("position"); c.getInverse(this.root.matrixWorld); for (var h = 0, k = 0; h < e.length; h++) { var l = e[h]; l.parent && l.parent.isBone && (b.multiplyMatrices(c, l.matrixWorld), a.setFromMatrixPosition(b), g.setXYZ(k, a.x, a.y, a.z), b.multiplyMatrices(c, l.parent.matrixWorld), a.setFromMatrixPosition(b), g.setXYZ(k + 1, a.x, a.y, a.z), k += 2) } f.getAttribute("position").needsUpdate = !0; A.prototype.updateMatrixWorld.call(this, d)
		}
	}(); pc.prototype = Object.create(pa.prototype); pc.prototype.constructor =
		pc; pc.prototype.dispose = function () { this.geometry.dispose(); this.material.dispose() }; pc.prototype.update = function () { void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color) }; qc.prototype = Object.create(A.prototype); qc.prototype.constructor = qc; qc.prototype.dispose = function () { this.children[0].geometry.dispose(); this.children[0].material.dispose() }; qc.prototype.update = function () {
			var a = .5 * this.light.width, b = .5 * this.light.height, c = this.line.geometry.attributes.position,
			d = c.array; d[0] = a; d[1] = -b; d[2] = 0; d[3] = a; d[4] = b; d[5] = 0; d[6] = -a; d[7] = b; d[8] = 0; d[9] = -a; d[10] = -b; d[11] = 0; d[12] = a; d[13] = -b; d[14] = 0; c.needsUpdate = !0; void 0 !== this.color ? this.line.material.color.set(this.color) : this.line.material.color.copy(this.light.color)
		}; rc.prototype = Object.create(A.prototype); rc.prototype.constructor = rc; rc.prototype.dispose = function () { this.children[0].geometry.dispose(); this.children[0].material.dispose() }; rc.prototype.update = function () {
			var a = new p, b = new H, c = new H; return function () {
				var d =
					this.children[0]; if (void 0 !== this.color) this.material.color.set(this.color); else { var e = d.geometry.getAttribute("color"); b.copy(this.light.color); c.copy(this.light.groundColor); for (var f = 0, g = e.count; f < g; f++) { var h = f < g / 2 ? b : c; e.setXYZ(f, h.r, h.g, h.b) } e.needsUpdate = !0 } d.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate())
			}
		}(); cd.prototype = Object.create(ca.prototype); cd.prototype.constructor = cd; Kd.prototype = Object.create(ca.prototype); Kd.prototype.constructor = Kd; dd.prototype = Object.create(ca.prototype);
	dd.prototype.constructor = dd; dd.prototype.update = function () {
		var a = new p, b = new p, c = new ra; return function () {
			this.object.updateMatrixWorld(!0); c.getNormalMatrix(this.object.matrixWorld); for (var d = this.object.matrixWorld, e = this.geometry.attributes.position, f = this.object.geometry, g = f.vertices, f = f.faces, h = 0, k = 0, l = f.length; k < l; k++) {
				var m = f[k], n = m.normal; a.copy(g[m.a]).add(g[m.b]).add(g[m.c]).divideScalar(3).applyMatrix4(d); b.copy(n).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a); e.setXYZ(h,
					a.x, a.y, a.z); h += 1; e.setXYZ(h, b.x, b.y, b.z); h += 1
			} e.needsUpdate = !0
		}
	}(); sc.prototype = Object.create(A.prototype); sc.prototype.constructor = sc; sc.prototype.dispose = function () { this.lightPlane.geometry.dispose(); this.lightPlane.material.dispose(); this.targetLine.geometry.dispose(); this.targetLine.material.dispose() }; sc.prototype.update = function () {
		var a = new p, b = new p, c = new p; return function () {
			a.setFromMatrixPosition(this.light.matrixWorld); b.setFromMatrixPosition(this.light.target.matrixWorld); c.subVectors(b,
				a); this.lightPlane.lookAt(c); void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)); this.targetLine.lookAt(c); this.targetLine.scale.z = c.length()
		}
	}(); ed.prototype = Object.create(ca.prototype); ed.prototype.constructor = ed; ed.prototype.update = function () {
		function a(a, g, h, k) {
			d.set(g, h, k).unproject(e); a = c[a]; if (void 0 !== a) for (g = b.getAttribute("position"),
				h = 0, k = a.length; h < k; h++)g.setXYZ(a[h], d.x, d.y, d.z)
		} var b, c, d = new p, e = new La; return function () {
			b = this.geometry; c = this.pointMap; e.projectionMatrix.copy(this.camera.projectionMatrix); a("c", 0, 0, -1); a("t", 0, 0, 1); a("n1", -1, -1, -1); a("n2", 1, -1, -1); a("n3", -1, 1, -1); a("n4", 1, 1, -1); a("f1", -1, -1, 1); a("f2", 1, -1, 1); a("f3", -1, 1, 1); a("f4", 1, 1, 1); a("u1", .7, 1.1, -1); a("u2", -.7, 1.1, -1); a("u3", 0, 2, -1); a("cf1", -1, 0, 1); a("cf2", 1, 0, 1); a("cf3", 0, -1, 1); a("cf4", 0, 1, 1); a("cn1", -1, 0, -1); a("cn2", 1, 0, -1); a("cn3", 0, -1, -1); a("cn4",
				0, 1, -1); b.getAttribute("position").needsUpdate = !0
		}
	}(); Db.prototype = Object.create(ca.prototype); Db.prototype.constructor = Db; Db.prototype.update = function () {
		var a = new Oa; return function (b) {
		void 0 !== b && console.warn("THREE.BoxHelper: .update() has no longer arguments."); void 0 !== this.object && a.setFromObject(this.object); if (!a.isEmpty()) {
			b = a.min; var c = a.max, d = this.geometry.attributes.position, e = d.array; e[0] = c.x; e[1] = c.y; e[2] = c.z; e[3] = b.x; e[4] = c.y; e[5] = c.z; e[6] = b.x; e[7] = b.y; e[8] = c.z; e[9] = c.x; e[10] = b.y; e[11] =
				c.z; e[12] = c.x; e[13] = c.y; e[14] = b.z; e[15] = b.x; e[16] = c.y; e[17] = b.z; e[18] = b.x; e[19] = b.y; e[20] = b.z; e[21] = c.x; e[22] = b.y; e[23] = b.z; d.needsUpdate = !0; this.geometry.computeBoundingSphere()
		}
		}
	}(); Db.prototype.setFromObject = function (a) { this.object = a; this.update(); return this }; fd.prototype = Object.create(ca.prototype); fd.prototype.constructor = fd; fd.prototype.updateMatrixWorld = function (a) {
		var b = this.box; b.isEmpty() || (b.getCenter(this.position), b.getSize(this.scale), this.scale.multiplyScalar(.5), A.prototype.updateMatrixWorld.call(this,
			a))
	}; gd.prototype = Object.create(ma.prototype); gd.prototype.constructor = gd; gd.prototype.updateMatrixWorld = function (a) { var b = -this.plane.constant; 1E-8 > Math.abs(b) && (b = 1E-8); this.scale.set(.5 * this.size, .5 * this.size, b); this.lookAt(this.plane.normal); A.prototype.updateMatrixWorld.call(this, a) }; var Ld, pe; Eb.prototype = Object.create(A.prototype); Eb.prototype.constructor = Eb; Eb.prototype.setDirection = function () {
		var a = new p, b; return function (c) {
			.99999 < c.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > c.y ? this.quaternion.set(1,
				0, 0, 0) : (a.set(c.z, 0, -c.x).normalize(), b = Math.acos(c.y), this.quaternion.setFromAxisAngle(a, b))
		}
	}(); Eb.prototype.setLength = function (a, b, c) { void 0 === b && (b = .2 * a); void 0 === c && (c = .2 * b); this.line.scale.set(1, Math.max(0, a - b), 1); this.line.updateMatrix(); this.cone.scale.set(c, b, c); this.cone.position.y = a; this.cone.updateMatrix() }; Eb.prototype.setColor = function (a) { this.line.material.color.copy(a); this.cone.material.color.copy(a) }; hd.prototype = Object.create(ca.prototype); hd.prototype.constructor = hd; var Nd = new p,
		te = new qe, ue = new qe, ve = new qe; ya.prototype = Object.create(S.prototype); ya.prototype.constructor = ya; ya.prototype.isCatmullRomCurve3 = !0; ya.prototype.getPoint = function (a, b) {
			b = b || new p; var c = this.points, d = c.length; a *= d - (this.closed ? 0 : 1); var e = Math.floor(a); a -= e; this.closed ? e += 0 < e ? 0 : (Math.floor(Math.abs(e) / c.length) + 1) * c.length : 0 === a && e === d - 1 && (e = d - 2, a = 1); if (this.closed || 0 < e) var f = c[(e - 1) % d]; else Nd.subVectors(c[0], c[1]).add(c[0]), f = Nd; var g = c[e % d]; var h = c[(e + 1) % d]; this.closed || e + 2 < d ? c = c[(e + 2) % d] : (Nd.subVectors(c[d -
				1], c[d - 2]).add(c[d - 1]), c = Nd); if ("centripetal" === this.curveType || "chordal" === this.curveType) { var k = "chordal" === this.curveType ? .5 : .25, d = Math.pow(f.distanceToSquared(g), k), e = Math.pow(g.distanceToSquared(h), k), k = Math.pow(h.distanceToSquared(c), k); 1E-4 > e && (e = 1); 1E-4 > d && (d = e); 1E-4 > k && (k = e); te.initNonuniformCatmullRom(f.x, g.x, h.x, c.x, d, e, k); ue.initNonuniformCatmullRom(f.y, g.y, h.y, c.y, d, e, k); ve.initNonuniformCatmullRom(f.z, g.z, h.z, c.z, d, e, k) } else "catmullrom" === this.curveType && (te.initCatmullRom(f.x, g.x, h.x,
					c.x, this.tension), ue.initCatmullRom(f.y, g.y, h.y, c.y, this.tension), ve.initCatmullRom(f.z, g.z, h.z, c.z, this.tension)); b.set(te.calc(a), ue.calc(a), ve.calc(a)); return b
		}; ya.prototype.copy = function (a) { S.prototype.copy.call(this, a); this.points = []; for (var b = 0, c = a.points.length; b < c; b++)this.points.push(a.points[b].clone()); this.closed = a.closed; this.curveType = a.curveType; this.tension = a.tension; return this }; Fb.prototype = Object.create(S.prototype); Fb.prototype.constructor = Fb; Fb.prototype.isCubicBezierCurve3 =
			!0; Fb.prototype.getPoint = function (a, b) { b = b || new p; var c = this.v0, d = this.v1, e = this.v2, f = this.v3; b.set(zb(a, c.x, d.x, e.x, f.x), zb(a, c.y, d.y, e.y, f.y), zb(a, c.z, d.z, e.z, f.z)); return b }; Fb.prototype.copy = function (a) { S.prototype.copy.call(this, a); this.v0.copy(a.v0); this.v1.copy(a.v1); this.v2.copy(a.v2); this.v3.copy(a.v3); return this }; Gb.prototype = Object.create(S.prototype); Gb.prototype.constructor = Gb; Gb.prototype.isQuadraticBezierCurve3 = !0; Gb.prototype.getPoint = function (a, b) {
				b = b || new p; var c = this.v0, d = this.v1,
					e = this.v2; b.set(yb(a, c.x, d.x, e.x), yb(a, c.y, d.y, e.y), yb(a, c.z, d.z, e.z)); return b
			}; Gb.prototype.copy = function (a) { S.prototype.copy.call(this, a); this.v0.copy(a.v0); this.v1.copy(a.v1); this.v2.copy(a.v2); return this }; db.prototype = Object.create(S.prototype); db.prototype.constructor = db; db.prototype.isLineCurve3 = !0; db.prototype.getPoint = function (a, b) { b = b || new p; 1 === a ? b.copy(this.v2) : (b.copy(this.v2).sub(this.v1), b.multiplyScalar(a).add(this.v1)); return b }; db.prototype.getPointAt = function (a, b) {
				return this.getPoint(a,
					b)
			}; db.prototype.copy = function (a) { S.prototype.copy.call(this, a); this.v1.copy(a.v1); this.v2.copy(a.v2); return this }; id.prototype = Object.create(Na.prototype); id.prototype.constructor = id; id.prototype.isArcCurve = !0; S.create = function (a, b) { console.log("THREE.Curve.create() has been deprecated"); a.prototype = Object.create(S.prototype); a.prototype.constructor = a; a.prototype.getPoint = b; return a }; Object.assign(Ab.prototype, {
				createPointsGeometry: function (a) {
					console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
					a = this.getPoints(a); return this.createGeometry(a)
				}, createSpacedPointsGeometry: function (a) { console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."); a = this.getSpacedPoints(a); return this.createGeometry(a) }, createGeometry: function (a) {
					console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."); for (var b = new N, c = 0, d = a.length; c < d; c++) {
						var e = a[c]; b.vertices.push(new p(e.x,
							e.y, e.z || 0))
					} return b
				}
			}); Object.assign(Bb.prototype, { fromPoints: function (a) { console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."); this.setFromPoints(a) } }); ef.prototype = Object.create(ya.prototype); ff.prototype = Object.create(ya.prototype); re.prototype = Object.create(ya.prototype); Object.assign(re.prototype, {
				initFromArray: function () { console.error("THREE.Spline: .initFromArray() has been removed.") }, getControlPointsArray: function () { console.error("THREE.Spline: .getControlPointsArray() has been removed.") },
				reparametrizeByArcLength: function () { console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.") }
			}); cd.prototype.setColors = function () { console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.") }; oc.prototype.update = function () { console.error("THREE.SkeletonHelper: update() no longer needs to be called.") }; Object.assign(kd.prototype, {
				center: function (a) { console.warn("THREE.Box2: .center() has been renamed to .getCenter()."); return this.getCenter(a) },
				empty: function () { console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."); return this.isEmpty() }, isIntersectionBox: function (a) { console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."); return this.intersectsBox(a) }, size: function (a) { console.warn("THREE.Box2: .size() has been renamed to .getSize()."); return this.getSize(a) }
			}); Object.assign(Oa.prototype, {
				center: function (a) { console.warn("THREE.Box3: .center() has been renamed to .getCenter()."); return this.getCenter(a) },
				empty: function () { console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."); return this.isEmpty() }, isIntersectionBox: function (a) { console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."); return this.intersectsBox(a) }, isIntersectionSphere: function (a) { console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."); return this.intersectsSphere(a) }, size: function (a) { console.warn("THREE.Box3: .size() has been renamed to .getSize()."); return this.getSize(a) }
			});
	Mb.prototype.center = function (a) { console.warn("THREE.Line3: .center() has been renamed to .getCenter()."); return this.getCenter(a) }; Object.assign(R, {
		random16: function () { console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."); return Math.random() }, nearestPowerOfTwo: function (a) { console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."); return R.floorPowerOfTwo(a) }, nextPowerOfTwo: function (a) {
			console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().");
			return R.ceilPowerOfTwo(a)
		}
	}); Object.assign(ra.prototype, {
		flattenToArrayOffset: function (a, b) { console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."); return this.toArray(a, b) }, multiplyVector3: function (a) { console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."); return a.applyMatrix3(this) }, multiplyVector3Array: function () { console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.") }, applyToBuffer: function (a) {
			console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");
			return this.applyToBufferAttribute(a)
		}, applyToVector3Array: function () { console.error("THREE.Matrix3: .applyToVector3Array() has been removed.") }
	}); Object.assign(K.prototype, {
		extractPosition: function (a) { console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."); return this.copyPosition(a) }, flattenToArrayOffset: function (a, b) { console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."); return this.toArray(a, b) }, getPosition: function () {
			var a;
			return function () { void 0 === a && (a = new p); console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."); return a.setFromMatrixColumn(this, 3) }
		}(), setRotationFromQuaternion: function (a) { console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."); return this.makeRotationFromQuaternion(a) }, multiplyToArray: function () { console.warn("THREE.Matrix4: .multiplyToArray() has been removed.") }, multiplyVector3: function (a) {
			console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
			return a.applyMatrix4(this)
		}, multiplyVector4: function (a) { console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."); return a.applyMatrix4(this) }, multiplyVector3Array: function () { console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.") }, rotateAxis: function (a) { console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."); a.transformDirection(this) }, crossVector: function (a) {
			console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
			return a.applyMatrix4(this)
		}, translate: function () { console.error("THREE.Matrix4: .translate() has been removed.") }, rotateX: function () { console.error("THREE.Matrix4: .rotateX() has been removed.") }, rotateY: function () { console.error("THREE.Matrix4: .rotateY() has been removed.") }, rotateZ: function () { console.error("THREE.Matrix4: .rotateZ() has been removed.") }, rotateByAxis: function () { console.error("THREE.Matrix4: .rotateByAxis() has been removed.") }, applyToBuffer: function (a) {
			console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");
			return this.applyToBufferAttribute(a)
		}, applyToVector3Array: function () { console.error("THREE.Matrix4: .applyToVector3Array() has been removed.") }, makeFrustum: function (a, b, c, d, e, f) { console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."); return this.makePerspective(a, b, d, c, e, f) }
	}); Aa.prototype.isIntersectionLine = function (a) { console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."); return this.intersectsLine(a) };
	Z.prototype.multiplyVector3 = function (a) { console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."); return a.applyQuaternion(this) }; Object.assign(lb.prototype, {
		isIntersectionBox: function (a) { console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."); return this.intersectsBox(a) }, isIntersectionPlane: function (a) { console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."); return this.intersectsPlane(a) },
		isIntersectionSphere: function (a) { console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."); return this.intersectsSphere(a) }
	}); Object.assign(Cb.prototype, {
		extractAllPoints: function (a) { console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."); return this.extractPoints(a) }, extrude: function (a) { console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."); return new $a(this, a) }, makeGeometry: function (a) {
			console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
			return new cc(this, a)
		}
	}); Object.assign(C.prototype, { fromAttribute: function (a, b, c) { console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."); return this.fromBufferAttribute(a, b, c) }, distanceToManhattan: function (a) { console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."); return this.manhattanDistanceTo(a) }, lengthManhattan: function () { console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."); return this.manhattanLength() } });
	Object.assign(p.prototype, {
		setEulerFromRotationMatrix: function () { console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.") }, setEulerFromQuaternion: function () { console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.") }, getPositionFromMatrix: function (a) { console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."); return this.setFromMatrixPosition(a) },
		getScaleFromMatrix: function (a) { console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."); return this.setFromMatrixScale(a) }, getColumnFromMatrix: function (a, b) { console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."); return this.setFromMatrixColumn(b, a) }, applyProjection: function (a) { console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."); return this.applyMatrix4(a) }, fromAttribute: function (a,
			b, c) { console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."); return this.fromBufferAttribute(a, b, c) }, distanceToManhattan: function (a) { console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."); return this.manhattanDistanceTo(a) }, lengthManhattan: function () { console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."); return this.manhattanLength() }
	}); Object.assign(da.prototype, {
		fromAttribute: function (a,
			b, c) { console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."); return this.fromBufferAttribute(a, b, c) }, lengthManhattan: function () { console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."); return this.manhattanLength() }
	}); N.prototype.computeTangents = function () { console.warn("THREE.Geometry: .computeTangents() has been removed.") }; Object.assign(A.prototype, {
		getChildByName: function (a) {
			console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
			return this.getObjectByName(a)
		}, renderDepth: function () { console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.") }, translate: function (a, b) { console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."); return this.translateOnAxis(b, a) }
	}); Object.defineProperties(A.prototype, {
		eulerOrder: {
			get: function () { console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."); return this.rotation.order }, set: function (a) {
				console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
				this.rotation.order = a
			}
		}, useQuaternion: { get: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") }, set: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") } }
	}); Object.defineProperties(Dc.prototype, { objects: { get: function () { console.warn("THREE.LOD: .objects has been renamed to .levels."); return this.levels } } }); Object.defineProperty(Ec.prototype, "useVertexTexture", {
		get: function () { console.warn("THREE.Skeleton: useVertexTexture has been removed.") },
		set: function () { console.warn("THREE.Skeleton: useVertexTexture has been removed.") }
	}); Object.defineProperty(S.prototype, "__arcLengthDivisions", { get: function () { console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."); return this.arcLengthDivisions }, set: function (a) { console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."); this.arcLengthDivisions = a } }); U.prototype.setLens = function (a, b) {
		console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
		void 0 !== b && (this.filmGauge = b); this.setFocalLength(a)
	}; Object.defineProperties(ga.prototype, {
		onlyShadow: { set: function () { console.warn("THREE.Light: .onlyShadow has been removed.") } }, shadowCameraFov: { set: function (a) { console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."); this.shadow.camera.fov = a } }, shadowCameraLeft: { set: function (a) { console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."); this.shadow.camera.left = a } }, shadowCameraRight: {
			set: function (a) {
				console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
				this.shadow.camera.right = a
			}
		}, shadowCameraTop: { set: function (a) { console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."); this.shadow.camera.top = a } }, shadowCameraBottom: { set: function (a) { console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."); this.shadow.camera.bottom = a } }, shadowCameraNear: { set: function (a) { console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."); this.shadow.camera.near = a } }, shadowCameraFar: {
			set: function (a) {
				console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
				this.shadow.camera.far = a
			}
		}, shadowCameraVisible: { set: function () { console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.") } }, shadowBias: { set: function (a) { console.warn("THREE.Light: .shadowBias is now .shadow.bias."); this.shadow.bias = a } }, shadowDarkness: { set: function () { console.warn("THREE.Light: .shadowDarkness has been removed.") } }, shadowMapWidth: {
			set: function (a) {
				console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
				this.shadow.mapSize.width = a
			}
		}, shadowMapHeight: { set: function (a) { console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."); this.shadow.mapSize.height = a } }
	}); Object.defineProperties(P.prototype, { length: { get: function () { console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."); return this.array.length } } }); Object.assign(D.prototype, {
		addIndex: function (a) { console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."); this.setIndex(a) }, addDrawCall: function (a,
			b, c) { void 0 !== c && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."); console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."); this.addGroup(a, b) }, clearDrawCalls: function () { console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."); this.clearGroups() }, computeTangents: function () { console.warn("THREE.BufferGeometry: .computeTangents() has been removed.") }, computeOffsets: function () { console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.") }
	});
	Object.defineProperties(D.prototype, { drawcalls: { get: function () { console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."); return this.groups } }, offsets: { get: function () { console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."); return this.groups } } }); Object.defineProperties(Jd.prototype, {
		dynamic: { set: function () { console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.") } }, onUpdate: {
			value: function () {
				console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
				return this
			}
		}
	}); Object.defineProperties(Q.prototype, {
		wrapAround: { get: function () { console.warn("THREE.Material: .wrapAround has been removed.") }, set: function () { console.warn("THREE.Material: .wrapAround has been removed.") } }, wrapRGB: { get: function () { console.warn("THREE.Material: .wrapRGB has been removed."); return new H } }, shading: {
			get: function () { console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.") }, set: function (a) {
				console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
				this.flatShading = 1 === a
			}
		}
	}); Object.defineProperties(Ia.prototype, { metal: { get: function () { console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."); return !1 }, set: function () { console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead") } } }); Object.defineProperties(oa.prototype, {
		derivatives: {
			get: function () { console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."); return this.extensions.derivatives },
			set: function (a) { console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."); this.extensions.derivatives = a }
		}
	}); Object.assign(Wd.prototype, {
		getCurrentRenderTarget: function () { console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."); return this.getRenderTarget() }, getMaxAnisotropy: function () { console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."); return this.capabilities.getMaxAnisotropy() }, getPrecision: function () {
			console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
			return this.capabilities.precision
		}, resetGLState: function () { console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."); return this.state.reset() }, supportsFloatTextures: function () { console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."); return this.extensions.get("OES_texture_float") }, supportsHalfFloatTextures: function () {
			console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
			return this.extensions.get("OES_texture_half_float")
		}, supportsStandardDerivatives: function () { console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."); return this.extensions.get("OES_standard_derivatives") }, supportsCompressedTextureS3TC: function () { console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."); return this.extensions.get("WEBGL_compressed_texture_s3tc") },
		supportsCompressedTexturePVRTC: function () { console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."); return this.extensions.get("WEBGL_compressed_texture_pvrtc") }, supportsBlendMinMax: function () { console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."); return this.extensions.get("EXT_blend_minmax") }, supportsVertexTextures: function () {
			console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
			return this.capabilities.vertexTextures
		}, supportsInstancedArrays: function () { console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."); return this.extensions.get("ANGLE_instanced_arrays") }, enableScissorTest: function (a) { console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."); this.setScissorTest(a) }, initMaterial: function () { console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.") }, addPrePlugin: function () { console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.") },
		addPostPlugin: function () { console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.") }, updateShadowMap: function () { console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.") }
	}); Object.defineProperties(Wd.prototype, {
		shadowMapEnabled: { get: function () { return this.shadowMap.enabled }, set: function (a) { console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."); this.shadowMap.enabled = a } }, shadowMapType: {
			get: function () { return this.shadowMap.type }, set: function (a) {
				console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
				this.shadowMap.type = a
			}
		}, shadowMapCullFace: { get: function () { return this.shadowMap.cullFace }, set: function (a) { console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace."); this.shadowMap.cullFace = a } }
	}); Object.defineProperties(Ie.prototype, { cullFace: { get: function () { return this.renderReverseSided ? 2 : 1 }, set: function (a) { a = 1 !== a; console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + a + "."); this.renderReverseSided = a } } }); Object.defineProperties(Hb.prototype,
		{
			wrapS: { get: function () { console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."); return this.texture.wrapS }, set: function (a) { console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."); this.texture.wrapS = a } }, wrapT: { get: function () { console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."); return this.texture.wrapT }, set: function (a) { console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."); this.texture.wrapT = a } }, magFilter: {
				get: function () {
					console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
					return this.texture.magFilter
				}, set: function (a) { console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."); this.texture.magFilter = a }
			}, minFilter: { get: function () { console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."); return this.texture.minFilter }, set: function (a) { console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."); this.texture.minFilter = a } }, anisotropy: {
				get: function () {
					console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
					return this.texture.anisotropy
				}, set: function (a) { console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."); this.texture.anisotropy = a }
			}, offset: { get: function () { console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."); return this.texture.offset }, set: function (a) { console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."); this.texture.offset = a } }, repeat: {
				get: function () { console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."); return this.texture.repeat },
				set: function (a) { console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."); this.texture.repeat = a }
			}, format: { get: function () { console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."); return this.texture.format }, set: function (a) { console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."); this.texture.format = a } }, type: {
				get: function () { console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."); return this.texture.type }, set: function (a) {
					console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
					this.texture.type = a
				}
			}, generateMipmaps: { get: function () { console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."); return this.texture.generateMipmaps }, set: function (a) { console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."); this.texture.generateMipmaps = a } }
		}); lc.prototype.load = function (a) { console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."); var b = this; (new ee).load(a, function (a) { b.setBuffer(a) }); return this };
	ie.prototype.getData = function () { console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."); return this.getFrequencyData() }; $c.prototype.updateCubeMap = function (a, b) { console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."); return this.update(a, b) }; m.WebGLRenderTargetCube = Ib; m.WebGLRenderTarget = Hb; m.WebGLRenderer = Wd; m.ShaderLib = mb; m.UniformsLib = E; m.UniformsUtils = Ea; m.ShaderChunk = W; m.FogExp2 = Ob; m.Fog = Pb; m.Scene = od; m.LensFlare = Xd; m.Sprite = Cc; m.LOD = Dc; m.SkinnedMesh = qd; m.Skeleton =
		Ec; m.Bone = pd; m.Mesh = pa; m.LineSegments = ca; m.LineLoop = rd; m.Line = ma; m.Points = Qb; m.Group = Fc; m.VideoTexture = sd; m.DataTexture = fb; m.CompressedTexture = Rb; m.CubeTexture = Ua; m.CanvasTexture = tc; m.DepthTexture = Gc; m.Texture = ea; m.CompressedTextureLoader = Qe; m.DataTextureLoader = Zd; m.CubeTextureLoader = $d; m.TextureLoader = td; m.ObjectLoader = Re; m.MaterialLoader = Id; m.BufferGeometryLoader = ae; m.DefaultLoadingManager = wa; m.LoadingManager = Yd; m.JSONLoader = be; m.ImageLoader = Xc; m.FontLoader = Te; m.FileLoader = Ja; m.Loader = kc; m.Cache =
			jd; m.AudioLoader = ee; m.SpotLightShadow = vd; m.SpotLight = wd; m.PointLight = xd; m.RectAreaLight = Bd; m.HemisphereLight = ud; m.DirectionalLightShadow = yd; m.DirectionalLight = zd; m.AmbientLight = Ad; m.LightShadow = vb; m.Light = ga; m.StereoCamera = Ue; m.PerspectiveCamera = U; m.OrthographicCamera = Kb; m.CubeCamera = $c; m.ArrayCamera = nd; m.Camera = La; m.AudioListener = fe; m.PositionalAudio = he; m.AudioContext = ge; m.AudioAnalyser = ie; m.Audio = lc; m.VectorKeyframeTrack = ic; m.StringKeyframeTrack = Fd; m.QuaternionKeyframeTrack = Zc; m.NumberKeyframeTrack =
				jc; m.ColorKeyframeTrack = Hd; m.BooleanKeyframeTrack = Gd; m.PropertyMixer = je; m.PropertyBinding = na; m.KeyframeTrack = xb; m.AnimationUtils = T; m.AnimationObjectGroup = We; m.AnimationMixer = Ye; m.AnimationClip = ka; m.Uniform = Jd; m.InstancedBufferGeometry = ke; m.BufferGeometry = D; m.Geometry = N; m.InterleavedBufferAttribute = le; m.InstancedInterleavedBuffer = me; m.InterleavedBuffer = mc; m.InstancedBufferAttribute = ne; m.Face3 = Pa; m.Object3D = A; m.Raycaster = Ze; m.Layers = Pd; m.EventDispatcher = ja; m.Clock = af; m.QuaternionLinearInterpolant = Ed;
	m.LinearInterpolant = Yc; m.DiscreteInterpolant = Dd; m.CubicInterpolant = Cd; m.Interpolant = xa; m.Triangle = Qa; m.Math = R; m.Spherical = bf; m.Cylindrical = cf; m.Plane = Aa; m.Frustum = ld; m.Sphere = Da; m.Ray = lb; m.Matrix4 = K; m.Matrix3 = ra; m.Box3 = Oa; m.Box2 = kd; m.Line3 = Mb; m.Euler = Ya; m.Vector4 = da; m.Vector3 = p; m.Vector2 = C; m.Quaternion = Z; m.Color = H; m.ImmediateRenderObject = ad; m.VertexNormalsHelper = bd; m.SpotLightHelper = nc; m.SkeletonHelper = oc; m.PointLightHelper = pc; m.RectAreaLightHelper = qc; m.HemisphereLightHelper = rc; m.GridHelper = cd; m.PolarGridHelper =
		Kd; m.FaceNormalsHelper = dd; m.DirectionalLightHelper = sc; m.CameraHelper = ed; m.BoxHelper = Db; m.Box3Helper = fd; m.PlaneHelper = gd; m.ArrowHelper = Eb; m.AxesHelper = hd; m.CatmullRomCurve3 = ya; m.CubicBezierCurve3 = Fb; m.QuadraticBezierCurve3 = Gb; m.LineCurve3 = db; m.ArcCurve = id; m.EllipseCurve = Na; m.SplineCurve = ab; m.CubicBezierCurve = bb; m.QuadraticBezierCurve = cb; m.LineCurve = Ka; m.Shape = Cb; m.Path = Bb; m.ShapePath = ce; m.Font = de; m.CurvePath = Ab; m.Curve = S; m.ShapeUtils = Ha; m.SceneUtils = {
			createMultiMaterialObject: function (a, b) {
				for (var c =
					new Fc, d = 0, e = b.length; d < e; d++)c.add(new pa(a, b[d])); return c
			}, detach: function (a, b, c) { a.applyMatrix(b.matrixWorld); b.remove(a); c.add(a) }, attach: function (a, b, c) { a.applyMatrix((new K).getInverse(c.matrixWorld)); b.remove(a); c.add(a) }
		}; m.WebGLUtils = Pe; m.WireframeGeometry = Sb; m.ParametricGeometry = Hc; m.ParametricBufferGeometry = Tb; m.TetrahedronGeometry = Jc; m.TetrahedronBufferGeometry = Ub; m.OctahedronGeometry = Kc; m.OctahedronBufferGeometry = nb; m.IcosahedronGeometry = Lc; m.IcosahedronBufferGeometry = Vb; m.DodecahedronGeometry =
			Mc; m.DodecahedronBufferGeometry = Wb; m.PolyhedronGeometry = Ic; m.PolyhedronBufferGeometry = qa; m.TubeGeometry = Nc; m.TubeBufferGeometry = Xb; m.TorusKnotGeometry = Oc; m.TorusKnotBufferGeometry = Yb; m.TorusGeometry = Pc; m.TorusBufferGeometry = Zb; m.TextGeometry = Qc; m.TextBufferGeometry = $b; m.SphereGeometry = Rc; m.SphereBufferGeometry = ob; m.RingGeometry = Sc; m.RingBufferGeometry = ac; m.PlaneGeometry = Ac; m.PlaneBufferGeometry = kb; m.LatheGeometry = Tc; m.LatheBufferGeometry = bc; m.ShapeGeometry = cc; m.ShapeBufferGeometry = dc; m.ExtrudeGeometry =
				$a; m.ExtrudeBufferGeometry = Ga; m.EdgesGeometry = ec; m.ConeGeometry = Uc; m.ConeBufferGeometry = Vc; m.CylinderGeometry = pb; m.CylinderBufferGeometry = Sa; m.CircleGeometry = Wc; m.CircleBufferGeometry = fc; m.BoxGeometry = Lb; m.BoxBufferGeometry = jb; m.ShadowMaterial = gc; m.SpriteMaterial = Za; m.RawShaderMaterial = hc; m.ShaderMaterial = oa; m.PointsMaterial = Ba; m.MeshPhysicalMaterial = qb; m.MeshStandardMaterial = Ma; m.MeshPhongMaterial = Ia; m.MeshToonMaterial = rb; m.MeshNormalMaterial = sb; m.MeshLambertMaterial = tb; m.MeshDepthMaterial = Wa; m.MeshDistanceMaterial =
					Xa; m.MeshBasicMaterial = va; m.LineDashedMaterial = ub; m.LineBasicMaterial = O; m.Material = Q; m.Float64BufferAttribute = zc; m.Float32BufferAttribute = y; m.Uint32BufferAttribute = ib; m.Int32BufferAttribute = yc; m.Uint16BufferAttribute = hb; m.Int16BufferAttribute = xc; m.Uint8ClampedBufferAttribute = wc; m.Uint8BufferAttribute = vc; m.Int8BufferAttribute = uc; m.BufferAttribute = P; m.REVISION = "88"; m.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 }; m.CullFaceNone = 0; m.CullFaceBack = 1; m.CullFaceFront = 2; m.CullFaceFrontBack = 3; m.FrontFaceDirectionCW = 0; m.FrontFaceDirectionCCW =
						1; m.BasicShadowMap = 0; m.PCFShadowMap = 1; m.PCFSoftShadowMap = 2; m.FrontSide = 0; m.BackSide = 1; m.DoubleSide = 2; m.FlatShading = 1; m.SmoothShading = 2; m.NoColors = 0; m.FaceColors = 1; m.VertexColors = 2; m.NoBlending = 0; m.NormalBlending = 1; m.AdditiveBlending = 2; m.SubtractiveBlending = 3; m.MultiplyBlending = 4; m.CustomBlending = 5; m.AddEquation = 100; m.SubtractEquation = 101; m.ReverseSubtractEquation = 102; m.MinEquation = 103; m.MaxEquation = 104; m.ZeroFactor = 200; m.OneFactor = 201; m.SrcColorFactor = 202; m.OneMinusSrcColorFactor = 203; m.SrcAlphaFactor =
							204; m.OneMinusSrcAlphaFactor = 205; m.DstAlphaFactor = 206; m.OneMinusDstAlphaFactor = 207; m.DstColorFactor = 208; m.OneMinusDstColorFactor = 209; m.SrcAlphaSaturateFactor = 210; m.NeverDepth = 0; m.AlwaysDepth = 1; m.LessDepth = 2; m.LessEqualDepth = 3; m.EqualDepth = 4; m.GreaterEqualDepth = 5; m.GreaterDepth = 6; m.NotEqualDepth = 7; m.MultiplyOperation = 0; m.MixOperation = 1; m.AddOperation = 2; m.NoToneMapping = 0; m.LinearToneMapping = 1; m.ReinhardToneMapping = 2; m.Uncharted2ToneMapping = 3; m.CineonToneMapping = 4; m.UVMapping = 300; m.CubeReflectionMapping =
								301; m.CubeRefractionMapping = 302; m.EquirectangularReflectionMapping = 303; m.EquirectangularRefractionMapping = 304; m.SphericalReflectionMapping = 305; m.CubeUVReflectionMapping = 306; m.CubeUVRefractionMapping = 307; m.RepeatWrapping = 1E3; m.ClampToEdgeWrapping = 1001; m.MirroredRepeatWrapping = 1002; m.NearestFilter = 1003; m.NearestMipMapNearestFilter = 1004; m.NearestMipMapLinearFilter = 1005; m.LinearFilter = 1006; m.LinearMipMapNearestFilter = 1007; m.LinearMipMapLinearFilter = 1008; m.UnsignedByteType = 1009; m.ByteType = 1010; m.ShortType =
									1011; m.UnsignedShortType = 1012; m.IntType = 1013; m.UnsignedIntType = 1014; m.FloatType = 1015; m.HalfFloatType = 1016; m.UnsignedShort4444Type = 1017; m.UnsignedShort5551Type = 1018; m.UnsignedShort565Type = 1019; m.UnsignedInt248Type = 1020; m.AlphaFormat = 1021; m.RGBFormat = 1022; m.RGBAFormat = 1023; m.LuminanceFormat = 1024; m.LuminanceAlphaFormat = 1025; m.RGBEFormat = 1023; m.DepthFormat = 1026; m.DepthStencilFormat = 1027; m.RGB_S3TC_DXT1_Format = 2001; m.RGBA_S3TC_DXT1_Format = 2002; m.RGBA_S3TC_DXT3_Format = 2003; m.RGBA_S3TC_DXT5_Format = 2004;
	m.RGB_PVRTC_4BPPV1_Format = 2100; m.RGB_PVRTC_2BPPV1_Format = 2101; m.RGBA_PVRTC_4BPPV1_Format = 2102; m.RGBA_PVRTC_2BPPV1_Format = 2103; m.RGB_ETC1_Format = 2151; m.LoopOnce = 2200; m.LoopRepeat = 2201; m.LoopPingPong = 2202; m.InterpolateDiscrete = 2300; m.InterpolateLinear = 2301; m.InterpolateSmooth = 2302; m.ZeroCurvatureEnding = 2400; m.ZeroSlopeEnding = 2401; m.WrapAroundEnding = 2402; m.TrianglesDrawMode = 0; m.TriangleStripDrawMode = 1; m.TriangleFanDrawMode = 2; m.LinearEncoding = 3E3; m.sRGBEncoding = 3001; m.GammaEncoding = 3007; m.RGBEEncoding =
		3002; m.LogLuvEncoding = 3003; m.RGBM7Encoding = 3004; m.RGBM16Encoding = 3005; m.RGBDEncoding = 3006; m.BasicDepthPacking = 3200; m.RGBADepthPacking = 3201; m.CubeGeometry = Lb; m.Face4 = function (a, b, c, d, e, f, g) { console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."); return new Pa(a, b, c, e, f, g) }; m.LineStrip = 0; m.LinePieces = 1; m.MeshFaceMaterial = function (a) { console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."); return a }; m.MultiMaterial = function (a) {
		void 0 === a && (a = []); console.warn("THREE.MultiMaterial has been removed. Use an Array instead.");
			a.isMultiMaterial = !0; a.materials = a; a.clone = function () { return a.slice() }; return a
		}; m.PointCloud = function (a, b) { console.warn("THREE.PointCloud has been renamed to THREE.Points."); return new Qb(a, b) }; m.Particle = function (a) { console.warn("THREE.Particle has been renamed to THREE.Sprite."); return new Cc(a) }; m.ParticleSystem = function (a, b) { console.warn("THREE.ParticleSystem has been renamed to THREE.Points."); return new Qb(a, b) }; m.PointCloudMaterial = function (a) {
			console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.");
			return new Ba(a)
		}; m.ParticleBasicMaterial = function (a) { console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."); return new Ba(a) }; m.ParticleSystemMaterial = function (a) { console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."); return new Ba(a) }; m.Vertex = function (a, b, c) { console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."); return new p(a, b, c) }; m.DynamicBufferAttribute = function (a, b) {
			console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.");
			return (new P(a, b)).setDynamic(!0)
		}; m.Int8Attribute = function (a, b) { console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."); return new uc(a, b) }; m.Uint8Attribute = function (a, b) { console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."); return new vc(a, b) }; m.Uint8ClampedAttribute = function (a, b) {
			console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."); return new wc(a,
				b)
		}; m.Int16Attribute = function (a, b) { console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."); return new xc(a, b) }; m.Uint16Attribute = function (a, b) { console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."); return new hb(a, b) }; m.Int32Attribute = function (a, b) { console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."); return new yc(a, b) }; m.Uint32Attribute = function (a, b) {
			console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.");
			return new ib(a, b)
		}; m.Float32Attribute = function (a, b) { console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."); return new y(a, b) }; m.Float64Attribute = function (a, b) { console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."); return new zc(a, b) }; m.ClosedSplineCurve3 = ef; m.SplineCurve3 = ff; m.Spline = re; m.AxisHelper = function (a) { console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."); return new hd(a) };
	m.BoundingBoxHelper = function (a, b) { console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."); return new Db(a, b) }; m.EdgesHelper = function (a, b) { console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."); return new ca(new ec(a.geometry), new O({ color: void 0 !== b ? b : 16777215 })) }; m.WireframeHelper = function (a, b) {
		console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."); return new ca(new Sb(a.geometry), new O({
			color: void 0 !==
				b ? b : 16777215
		}))
	}; m.XHRLoader = function (a) { console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."); return new Ja(a) }; m.BinaryTextureLoader = function (a) { console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."); return new Zd(a) }; m.GeometryUtils = {
		merge: function (a, b, c) {
			console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."); if (b.isMesh) {
			b.matrixAutoUpdate && b.updateMatrix();
				var d = b.matrix; b = b.geometry
			} a.merge(b, d, c)
		}, center: function (a) { console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."); return a.center() }
	}; m.ImageUtils = {
		crossOrigin: void 0, loadTexture: function (a, b, c, d) { console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."); var e = new td; e.setCrossOrigin(this.crossOrigin); a = e.load(a, c, void 0, d); b && (a.mapping = b); return a }, loadTextureCube: function (a, b, c, d) {
			console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
			var e = new $d; e.setCrossOrigin(this.crossOrigin); a = e.load(a, c, void 0, d); b && (a.mapping = b); return a
		}, loadCompressedTexture: function () { console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.") }, loadCompressedTextureCube: function () { console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.") }
	}; m.Projector = function () {
		console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."); this.projectVector =
			function (a, b) { console.warn("THREE.Projector: .projectVector() is now vector.project()."); a.project(b) }; this.unprojectVector = function (a, b) { console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."); a.unproject(b) }; this.pickingRay = function () { console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().") }
	}; m.CanvasRenderer = function () {
		console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"); this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml",
			"canvas"); this.clear = function () { }; this.render = function () { }; this.setClearColor = function () { }; this.setSize = function () { }
	}; Object.defineProperty(m, "__esModule", { value: !0 })
});

/**
 * @author richt / http://richt.me
 * @author WestLangley / http://github.com/WestLangley
 *
 * W3C Device Orientation control (http://w3c.github.io/deviceorientation/spec-source-orientation.html)
 */

THREE.DeviceOrientationControls = function (object) {

	var scope = this;

	this.object = object;
	this.object.rotation.reorder("YXZ");

	this.enabled = true;

	this.deviceOrientation = {};
	this.screenOrientation = 0;

	this.alphaOffset = 0; // radians

	var onDeviceOrientationChangeEvent = function (event) {

		scope.deviceOrientation = event;

	};

	var onScreenOrientationChangeEvent = function () {

		scope.screenOrientation = window.orientation || 0;

	};

	// The angles alpha, beta and gamma form a set of intrinsic Tait-Bryan angles of type Z-X'-Y''

	var setObjectQuaternion = function () {

		var zee = new THREE.Vector3(0, 0, 1);

		var euler = new THREE.Euler();

		var q0 = new THREE.Quaternion();

		var q1 = new THREE.Quaternion(- Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)); // - PI/2 around the x-axis

		return function (quaternion, alpha, beta, gamma, orient) {

			euler.set(beta, alpha, - gamma, 'YXZ'); // 'ZXY' for the device, but 'YXZ' for us

			quaternion.setFromEuler(euler); // orient the device

			quaternion.multiply(q1); // camera looks out the back of the device, not the top

			quaternion.multiply(q0.setFromAxisAngle(zee, - orient)); // adjust for screen orientation

		}

	}();

	this.connect = function () {

		onScreenOrientationChangeEvent(); // run once on load

		window.addEventListener('orientationchange', onScreenOrientationChangeEvent, false);
		window.addEventListener('deviceorientation', onDeviceOrientationChangeEvent, false);

		scope.enabled = true;

	};

	this.disconnect = function () {

		window.removeEventListener('orientationchange', onScreenOrientationChangeEvent, false);
		window.removeEventListener('deviceorientation', onDeviceOrientationChangeEvent, false);

		scope.enabled = false;

	};

	this.update = function () {

		if (scope.enabled === false) return;

		var alpha = scope.deviceOrientation.alpha ? THREE.Math.degToRad(scope.deviceOrientation.alpha) + this.alphaOffset : 0; // Z
		var beta = scope.deviceOrientation.beta ? THREE.Math.degToRad(scope.deviceOrientation.beta) : 0; // X'
		var gamma = scope.deviceOrientation.gamma ? THREE.Math.degToRad(scope.deviceOrientation.gamma) : 0; // Y''
		var orient = scope.screenOrientation ? THREE.Math.degToRad(scope.screenOrientation) : 0; // O

		setObjectQuaternion(scope.object.quaternion, alpha, beta, gamma, orient);

	};

	this.dispose = function () {

		this.disconnect();

	};

	this.connect();

};
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/* global mat4, WGLUProgram */

window.VRPanorama = (function () {
  "use strict";

  var panoVS = [
    "uniform mat4 projectionMat;",
    "uniform mat4 modelViewMat;",
    "attribute vec3 position;",
    "attribute vec2 texCoord;",
    "varying vec2 vTexCoord;",

    "void main() {",
    "  vTexCoord = texCoord;",
    "  gl_Position = projectionMat * modelViewMat * vec4( position, 1.0 );",
    "}",
  ].join("\n");

  var panoFS = [
    "precision mediump float;",
    "uniform sampler2D diffuse;",
    "varying vec2 vTexCoord;",

    "void main() {",
    "  gl_FragColor = texture2D(diffuse, vTexCoord);",
    "}",
  ].join("\n");

  var Panorama = function (gl) {
    this.gl = gl;

    this.texture = gl.createTexture();

    this.program = new WGLUProgram(gl);
    this.program.attachShaderSource(panoVS, gl.VERTEX_SHADER);
    this.program.attachShaderSource(panoFS, gl.FRAGMENT_SHADER);
    this.program.bindAttribLocation({
      position: 0,
      texCoord: 1
    });
    this.program.link();

    var panoVerts = [];
    var panoIndices = [];

    var radius = 2; // 2 meter radius sphere
    var latSegments = 40;
    var lonSegments = 40;

    // Create the vertices
    for (var i=0; i <= latSegments; ++i) {
      var theta = i * Math.PI / latSegments;
      var sinTheta = Math.sin(theta);
      var cosTheta = Math.cos(theta);

      for (var j=0; j <= lonSegments; ++j) {
        var phi = j * 2 * Math.PI / lonSegments;
        var sinPhi = Math.sin(phi);
        var cosPhi = Math.cos(phi);

        var x = sinPhi * sinTheta;
        var y = cosTheta;
        var z = -cosPhi * sinTheta;
        var u = (j / lonSegments);
        var v = (i / latSegments);

        panoVerts.push(x * radius, y * radius, z * radius, u, v);
      }
    }

    // Create the indices
    for (var i = 0; i < latSegments; ++i) {
      var offset0 = i * (lonSegments+1);
      var offset1 = (i+1) * (lonSegments+1);
      for (var j = 0; j < lonSegments; ++j) {
        var index0 = offset0+j;
        var index1 = offset1+j;
        panoIndices.push(
          index0, index1, index0+1,
          index1, index1+1, index0+1
        );
      }
    }

    this.vertBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(panoVerts), gl.STATIC_DRAW);

    this.indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(panoIndices), gl.STATIC_DRAW);

    this.indexCount = panoIndices.length;

    this.imgElement = null;
    this.videoElement = null;
  };

  Panorama.prototype.setImage = function (url) {
    var gl = this.gl;
    var self = this;

    return new Promise(function(resolve, reject) {
      var img = new Image();
      img.addEventListener('load', function() {
        self.imgElement = img;
        self.videoElement = null;

        gl.bindTexture(gl.TEXTURE_2D, self.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, img);

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        resolve(self.imgElement);
      });
      img.addEventListener('error', function(ev) {
        console.error(ev.message);
        reject(ev.message);
      }, false);
      img.crossOrigin = 'anonymous';
      img.src = url;
    });
  };

  Panorama.prototype.useImage = function (img) {
    var gl = this.gl;
    var self = this;
    img.crossOrigin = 'anonymous';
    self.imgElement = img;
    self.videoElement = null;

    gl.bindTexture(gl.TEXTURE_2D, self.texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, img);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  };

  Panorama.prototype.setVideo = function (url) {
    var gl = this.gl;
    var self = this;

    return new Promise(function(resolve, reject) {
      var video = document.createElement('video');
      video.addEventListener('canplay', function() {
        // Added "click to play" UI?
      });

      video.addEventListener('playing', function() {
        self.videoElement = video;
        self.imgElement = null;

        gl.bindTexture(gl.TEXTURE_2D, self.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, self.videoElement);

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        resolve(self.videoElement);
      });

      video.addEventListener('error', function(ev) {
        console.error(video.error);
        reject(video.error);
      }, false);

      video.loop = true;
      video.autoplay = true;
      video.crossOrigin = 'anonymous';
      video.setAttribute('webkit-playsinline', '');
      video.src = url;
    });
  };

  Panorama.prototype.play = function() {
    if (this.videoElement)
      this.videoElement.play();
  };

  Panorama.prototype.pause = function() {
    if (this.videoElement)
      this.videoElement.pause();
  };

  Panorama.prototype.isPaused = function() {
    if (this.videoElement)
      return this.videoElement.paused;
    return false;
  };

  Panorama.prototype.render = function (projectionMat, modelViewMat) {
    var gl = this.gl;
    var program = this.program;

    if (!this.imgElement && !this.videoElement)
      return;

    program.use();

    gl.uniformMatrix4fv(program.uniform.projectionMat, false, projectionMat);
    gl.uniformMatrix4fv(program.uniform.modelViewMat, false, modelViewMat);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertBuffer);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);

    gl.enableVertexAttribArray(program.attrib.position);
    gl.enableVertexAttribArray(program.attrib.texCoord);

    gl.vertexAttribPointer(program.attrib.position, 3, gl.FLOAT, false, 20, 0);
    gl.vertexAttribPointer(program.attrib.texCoord, 2, gl.FLOAT, false, 20, 12);

    gl.activeTexture(gl.TEXTURE0);
    gl.uniform1i(this.program.uniform.diffuse, 0);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);

    if (this.videoElement && !this.videoElement.paused) {
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, this.videoElement);
    }

    gl.drawElements(gl.TRIANGLES, this.indexCount, gl.UNSIGNED_SHORT, 0);
  };

  return Panorama;
})();

window.imageRenderer = {
	data: null,
	stats: {},
	subscriptions: {},

	resetStats: function () {
		window.imageRenderer.stats = {
			x: 0,
			y: 0,
			z: 0,
			viewWidth: 0,
			viewHeight: 0,
			renderWidth: 0,
			renderHeight: 0,
			previewProgress: 0,
			imageProgress: 0,
			status: "initializing"
		};
	},

	subscribe: function (event, callback) {
		console.log("event", event);
		if (!window.imageRenderer.subscriptions[event]) {
			window.imageRenderer.subscriptions[event] = [];
		}

		window.imageRenderer.subscriptions[event].push(callback);
	},

	trigger: function (event, data) {
		var self = window.imageRenderer;

		if (!self.subscriptions[event]) {
			return;
		}

		for (var i = 0; i < self.subscriptions[event].length; i++){
			self.subscriptions[event][i](data);
		}
	},

	passToMethod: function (data, method) {
		window.imageRenderer.methods[method](data);
	},

	loadImage: function (url, endCB, progressCB, errorCB) {
		var xmlHTTP = new window.XMLHttpRequest();
		xmlHTTP.open("GET", url, true);
		xmlHTTP.responseType = "arraybuffer";
		xmlHTTP.onload = function (e) {

			if (e.target.status === 200 && e.target.response.byteLength) {
				var blob = new window.Blob([e.target.response]);
				var uri = window.URL.createObjectURL(blob);
				var img = new window.Image();

				img.onload = function (e) {
					// window.URL.revokeObjectURL(uri);
					if (endCB) {
						endCB(e.target);
					}
				};

				img.src = uri;
			} else if (errorCB) {
				errorCB(e.target.status);
			}
		};
		xmlHTTP.onerror = function (e) {
			if (errorCB) { errorCB(e.target.status); }
		};

		xmlHTTP.onprogress = function (e) {
			if (progressCB) {
				progressCB(parseInt((e.loaded / e.total) * 100), function () {
					xmlHTTP.abort();
				});
			}
		};

		xmlHTTP.send();
	},

	methods: {},

	isFullscreen: function () {
		return window.outerWidth === screen.width && window.innerHeight === screen.height;
	},

	toggleFullscreen: function () {
		var canvasWrapper = window.imageRenderer.data.element;

		if (window.imageRenderer.isFullscreen()) {
			canvasWrapper.classList.remove("fullscreen");

			if (document.exitFullscreen) {
				document.exitFullscreen();
			} else if (document.webkitExitFullscreen) {
				document.webkitExitFullscreen();
			} else if (document.mozCancelFullScreen) {
				document.mozCancelFullScreen();
			} else if (document.msExitFullscreen) {
				document.msExitFullscreen();
			}
			return;
		}

		canvasWrapper.classList.add("fullscreen");

		if (canvasWrapper.requestFullscreen) {
			canvasWrapper.requestFullscreen();
		} else if (canvasWrapper.webkitRequestFullscreen) {
			canvasWrapper.webkitRequestFullscreen();
		} else if (canvasWrapper.mozRequestFullScreen) {
			canvasWrapper.mozRequestFullScreen();
		} else if (canvasWrapper.msRequestFullscreen) {
			canvasWrapper.msRequestFullscreen();
		}
	},

	init: function (data) {
		var self = window.imageRenderer;

		return new Promise(function (resolve, reject) {

			if (!data.element || !data.image) {
				return reject();
			}

			self.data = data;
			self.resetStats();
			self.subscriptions = [];
			data.element.setAttribute("imageRenderer", true)

			var method = self.methods.renderFlat;

			if (data["360"]) {
				method = self.methods.render360;
			}

			if (method) {
				return method(data).then(function () {
					if (data.crop) {
						window.imageRenderer.cropper.init(data.element, data.crop)
					}

					return resolve()

				});
			}

			reject();
		});
	}
};
window.imageRenderer.methods.renderVr = function (data) {
	return new Promise(function (resolve, reject) {
		var allowNonVR = data.allowNonVR;
		var imageItem = data.image;
		var previewItem = data.preview;
		var is3D = data["3D"];
		var canvasWrapper = data.element;
		canvasWrapper.style.height = "100%";
		canvasWrapper.style.width = "100%";
		canvasWrapper.innerHTML = "";

		var glAttribs = {
			antialias: true,
		};

		var frameData = new window.VRFrameData();
		var vrDisplay;
		var vrSceneFrame;
		var panorama = null;
		var panorama2 = null;
		var viewMat = window.mat4.create();

		var canvas = window.document.createElement("canvas");
		var img1 = new window.Image();
		var img2 = new window.Image();
		var ctxTop = window.document.createElement("canvas").getContext("2d");
		var ctxBottom = window.document.createElement("canvas").getContext("2d");

		var gl = canvas.getContext("webgl", glAttribs);
		var isPresenting = false;
		var canPresent = false;
		var normalSceneFrame = null;

		canvasWrapper.appendChild(canvas);
		canvas.setAttribute("type", "vr");

		if (!gl) {
			gl = canvas.getContext("experimental-webgl", glAttribs);
		}

		function getPoseMatrix(out, pose) {
			var orientation = pose.orientation;
			if (!orientation) { orientation = [0, 0, 0, 1]; }

			window.mat4.fromQuat(out, orientation);
			window.mat4.invert(out, out);
		}

		function drawVRScene() {
			vrSceneFrame = vrDisplay.requestAnimationFrame(drawVRScene);
			vrDisplay.getFrameData(frameData);

			getPoseMatrix(viewMat, frameData.pose);

			gl.clear(gl.COLOR_BUFFER_BIT || gl.DEPTH_BUFFER_BIT);

			gl.viewport(0, 0, canvas.width * 0.5, canvas.height);
			panorama.render(frameData.leftProjectionMatrix, viewMat);

			gl.viewport(canvas.width * 0.5, 0, canvas.width * 0.5, canvas.height);

			if (is3D) {
				panorama2.render(frameData.rightProjectionMatrix, viewMat);
			} else {
				panorama.render(frameData.rightProjectionMatrix, viewMat);
			}

			vrDisplay.submitFrame();

			window.imageRenderer.stats.x = 0;
			window.imageRenderer.stats.y = 0;
			window.imageRenderer.stats.z = 0;
			window.imageRenderer.stats.viewWidth = window.imageRenderer.stats.renderWidth = canvasWrapper.offsetWidth * window.devicePixelRatio;
			window.imageRenderer.stats.viewHeight = window.imageRenderer.stats.renderHeight = canvasWrapper.offsetHeight * window.devicePixelRatio;
			window.imageRenderer.stats.status = "drawing";
		}


		function positionCanvas() {
			canvas.style.position = "fixed";

			if (isPresenting) {
				var leftEye = vrDisplay.getEyeParameters("left");
				var rightEye = vrDisplay.getEyeParameters("right");
				canvas.width = (Math.max(leftEye.renderWidth, rightEye.renderWidth) * 2) * window.devicePixelRatio;
				canvas.height = (Math.max(leftEye.renderHeight, rightEye.renderHeight)) * window.devicePixelRatio;
				canvas.style.width = "100%";
				canvas.style.height = "100%";
				canvas.style.top = "0px";
				canvas.style.left = "0px";
				canvas.style.zIndex = "9999";
			} else {
				canvas.width = Math.max(window.innerWidth, window.innerHeight) * window.devicePixelRatio;
				canvas.height = Math.max(window.innerWidth, window.innerHeight) * window.devicePixelRatio;
				canvas.style.width = (canvas.width / window.devicePixelRatio) + "px";
				canvas.style.height = (canvas.height / window.devicePixelRatio) + "px";
				canvas.style.top = ((window.innerHeight - (canvas.height / window.devicePixelRatio)) / 2) + "px";
				canvas.style.left = ((window.innerWidth - (canvas.width / window.devicePixelRatio)) / 2) + "px";
				canvas.style.zIndex = "9999";
			}
		}

		function onPresent() {
			try {
				window.cancelAnimationFrame(normalSceneFrame);
			} catch (e) { }

			setTimeout(function () {
				isPresenting = true;

				positionCanvas();

				if (is3D) {

					if (!panorama) {
						panorama = new window.VRPanorama(gl);
					}
					panorama.useImage(img1);

					if (!panorama2) {
						panorama2 = new window.VRPanorama(gl);
					}
					panorama2.useImage(img2);

					drawVRScene();
				} else {
					if (!panorama) {
						panorama = new window.VRPanorama(gl);
					}
					panorama.useImage(img1);
					drawVRScene();
				}
			}, 500);
		}

		function drawScene() {
			normalSceneFrame = window.requestAnimationFrame(drawScene);
			vrDisplay.getFrameData(frameData);

			getPoseMatrix(viewMat, frameData.pose);

			gl.clear(gl.COLOR_BUFFER_BIT || gl.DEPTH_BUFFER_BIT);

			gl.viewport(0, 0, canvas.width, canvas.height);
			panorama.render(frameData.leftProjectionMatrix, viewMat);
		}

		function onNormalScene() {
			try {
				vrDisplay.cancelAnimationFrame(vrSceneFrame);
			} catch (e) { }

			window.removeEventListener("resize", positionCanvas, false);
			window.removeEventListener("vrdisplaypresentchange", presentChange, false);

			if (allowNonVR) {
				positionCanvas();

				// window.parent.document.getElementById("ansel_viewer_frame").classList.remove("in-vr-mode")

				isPresenting = false;

				if (!panorama) {
					panorama = new window.VRPanorama(gl);
				}

				panorama.useImage(img1);
				return drawScene();
			}

			window.imageRenderer.methods.render360(data);
		}

		function setImages(img) {
			if (is3D) {
				ctxTop.canvas.width = img.naturalWidth;
				ctxTop.canvas.height = img.naturalHeight / 2;
				ctxTop.drawImage(img, 0, 0);

				ctxBottom.canvas.width = img.naturalWidth;
				ctxBottom.canvas.height = img.naturalHeight / 2;
				ctxBottom.drawImage(img, 0, -ctxBottom.canvas.height);

				img1 = ctxTop.canvas;
				img2 = ctxBottom.canvas;
			} else {
				img1 = img;
			}
		}

		function present() {
			vrDisplay.requestPresent([{ source: canvas }]).then(function () {
				onPresent();
			});
		}

		function presentChange() {
			if (!vrDisplay.isPresenting) {
				onNormalScene();
			}
		}

		function run() {
			resolve();

			function loadMain() {

				window.imageRenderer.loadImage(imageItem, function (mainimg) {
					window.imageRenderer.stats.imageProgress = 100;
					setImages(mainimg);

					progressBar.style.opacity = 0;

					setTimeout(function () {
						canvasWrapper.removeChild(progressBar);
					}, 600);

					if (allowNonVR) {
						onNormalScene();
					} else {

						present();
					}

				}, function (prog) {
					window.imageRenderer.stats.imageProgress = prog;
					progressBar.style.width = prog + "%";
					window.imageRenderer.trigger("statsUpdate", window.imageRenderer.stats);
				});
			}

			function loadPreview () {
				window.imageRenderer.loadImage(previewItem, function (previmg) {
					window.imageRenderer.stats.previewProgress = 100;
					setImages(previmg);

					if (allowNonVR) {
						onNormalScene();
					} else {

						present();
					}

					var progressBar = document.createElement("div");
					progressBar.classList.add("renderer-progressbar");
					canvasWrapper.appendChild(progressBar);

					loadMain();
				}, function (prog) {
					window.imageRenderer.stats.previewProgress = prog;
					window.imageRenderer.trigger("statsUpdate", window.previewProgress.stats);
				}, function () {
					loadMain();
				});
			}

			if (previewItem) {
				loadPreview();
			} else {
				loadMain();
			}

			window.addEventListener("resize", positionCanvas, false);
			window.addEventListener("vrdisplaypresentchange", presentChange, false);
		}

		if (window.navigator.getVRDisplays) {
			try {
				window.navigator.getVRDisplays().then(function (displays) {
					if (displays.length > 0) {
						vrDisplay = displays[0];
						canPresent = vrDisplay.capabilities.canPresent;
					}

					if ((!vrDisplay || !vrDisplay.getFrameData || !canPresent) && !allowNonVR) {
						return window.imageRenderer.methods.render360(data);
					}

					run();
				});
			} catch (e) {
				return window.imageRenderer.methods.render360(data);
			}
		} else {
			return window.imageRenderer.methods.render360(data);
		}
	});
};
window.imageRenderer.methods.render360 = function (data) {
	return new Promise(function (resolve) {
		var imageItem = data.image;
		var previewItem = data.preview;
		var is3D = data["3D"];
		var canvasWrapper = data.element;
		canvasWrapper.style.height = "100%";
		canvasWrapper.style.width = "100%";
		canvasWrapper.innerHTML = "";

		var minZoom = 5, maxZoom = 100, zoom = 40, distance = 50,
			lon = 0, lat = 0, phi = 0, theta = 0, // Pan / tilt settings
			renderer = null, scene = null, camera = null, texture = null, material = null, controls = null, // Three elements
			isUserInteracting,

			img = null,
			ctxTop = window.document.createElement("canvas").getContext("2d"), // for 3d photospheres

			onPointerDownPointerX = 0,
			onPointerDownPointerY = 0,
			onPointerDownLon = 0,
			onPointerDownLat = 0,

			canDoVR = false,
			animationFrame = null,

			vrButton, fullscreenButton;

		/* RENDER METHODS */

		function draw() {
			lat = Math.max(- 85, Math.min(85, lat));
			phi = window.THREE.Math.degToRad(90 - lat);
			theta = window.THREE.Math.degToRad(lon - 180);
			camera.position.x = distance * Math.sin(phi) * Math.cos(theta);
			camera.position.y = distance * Math.cos(phi);
			camera.position.z = distance * Math.sin(phi) * Math.sin(theta);
			camera.lookAt(scene.position);

			if (canDoVR) {
				controls.update();
			}
			renderer.render(scene, camera);

			if (
				window.imageRenderer.stats.x !== lon ||
				window.imageRenderer.stats.y !== lat ||
				window.imageRenderer.stats.z !== distance ||
				window.imageRenderer.stats.viewWidth !== canvasWrapper.offsetWidth * window.devicePixelRatio ||
				window.imageRenderer.stats.viewHeight !== canvasWrapper.offsetHeight * window.devicePixelRatio
			) {
				window.imageRenderer.stats.x = lon;
				window.imageRenderer.stats.y = lat;
				window.imageRenderer.stats.z = distance;
				window.imageRenderer.stats.viewWidth = window.imageRenderer.stats.renderWidth = canvasWrapper.offsetWidth * window.devicePixelRatio;
				window.imageRenderer.stats.viewHeight = window.imageRenderer.stats.renderHeight = canvasWrapper.offsetHeight * window.devicePixelRatio;
				window.imageRenderer.stats.status = "drawing";

				window.imageRenderer.trigger("statsUpdate", window.imageRenderer.stats);
			}

		}

		function animate() {
			animationFrame = window.requestAnimationFrame(animate);
			draw();
		}


		/* EVENT HANDLERS */

		function onDocumentMouseDown(event) {
			event.preventDefault();
			isUserInteracting = true;
			onPointerDownPointerX = event.clientX;
			onPointerDownPointerY = event.clientY;
			onPointerDownLon = lon;
			onPointerDownLat = lat;
		}

		function onDocumentMouseMove(event) {
			if (isUserInteracting === true) {
				lon = (onPointerDownPointerX - event.clientX) * 0.1 + onPointerDownLon;
				lat = (onPointerDownPointerY - event.clientY) * 0.1 + onPointerDownLat;
			}
		}

		function onDocumentMouseUp() {
			isUserInteracting = false;
		}

		function onDocumentMouseWheel(event) {
			event.preventDefault();
			distance += event.deltaY * 0.05;

			if (distance < minZoom) {
				distance = minZoom;
			}

			if (distance > maxZoom) {
				distance = maxZoom;
			}
		}

		function resize() {
			renderer.setSize(canvasWrapper.offsetWidth, canvasWrapper.offsetHeight);
			camera.aspect = renderer.domElement.clientWidth / renderer.domElement.clientHeight;
			camera.updateProjectionMatrix();
		}


		/* SETUP */

		function setImages(_img) {
			if (is3D) {
				ctxTop.canvas.width = _img.naturalWidth;
				ctxTop.canvas.height = _img.naturalHeight / 2;
				ctxTop.drawImage(_img, 0, 0);
				img = ctxTop.canvas;
			} else {
				img = _img;
			}

			return img;
		}

		function goVR() {
			window.cancelAnimationFrame(animationFrame);
			window.document.removeEventListener("mouseup", onDocumentMouseUp, false);
			window.removeEventListener("resize", resize, true);

			window.imageRenderer.passToMethod(data, "renderVr");
		}

		function createControlButtons() {
			var buttonWrapper = window.document.createElement("div");
			buttonWrapper.classList.add("buttonWrapper")
			canvasWrapper.appendChild(buttonWrapper);

			if (canDoVR) {
				vrButton = window.document.createElement("button");
				vrButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" data-name="Layer 86" viewBox="0 0 196.33 123.31"><path d="M194.33 14a12 12 0 0 0-12-12s-63.12-2-84.17-2-84.17 2-84.17 2a12 12 0 0 0-12 12S0 57.73 0 70.33c0 11.76 2 41 2 41a12 12 0 0 0 12 12h56.33s15.31-41.21 27.67-41c12.09.21 25.67 41 25.67 41h58.67a12 12 0 0 0 12-12s2-36.48 2-48.65S194.33 14 194.33 14zM46.67 86.66A28.33 28.33 0 1 1 75 58.33a28.33 28.33 0 0 1-28.33 28.33zm102 0A28.33 28.33 0 1 1 177 58.33a28.33 28.33 0 0 1-28.33 28.33z"/></svg>';
				vrButton.addEventListener('click', goVR, false);
				buttonWrapper.appendChild(vrButton);
			}


			fullscreenButton = window.document.createElement("button");
			fullscreenButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" data-name="Layer 59" viewBox="0 0 193.57 193.57"><path d="M69.2.04q.06 13.21.12 26.43c0 1.05-.49 1.49-1.48 1.5H30.66c-2.59 0-2.64 0-2.64 2.64v35.88c0 2.8 0 2.81-2.84 2.8L.04 69.16V1.6C.04.24.32-.04 1.68-.04Q35.42.08 69.2.04zM193.54 69.16q-13.21.06-26.43.12c-1.05 0-1.49-.49-1.5-1.48v-1.89V30.6c0-2.59 0-2.64-2.64-2.64h-35.91c-2.8 0-2.81 0-2.8-2.84q0-12.55.12-25.11h67.65c1.29 0 1.55.25 1.55 1.55q-.08 33.81-.04 67.6zM.04 124.38q13.21-.06 26.43-.12c1.05 0 1.49.49 1.5 1.48v37.2c0 2.59 0 2.64 2.64 2.64h35.91c2.8 0 2.81 0 2.8 2.84q0 12.55-.12 25.11H1.55c-1.29 0-1.55-.25-1.55-1.55q.08-33.82.04-67.6zM124.38 193.54q-.06-13.21-.12-26.43c0-1.05.49-1.49 1.48-1.5h37.2c2.59 0 2.64 0 2.64-2.64v-35.88c0-2.8 0-2.81 2.84-2.8l25.11.12v67.65c0 1.29-.25 1.55-1.55 1.55q-33.78-.11-67.6-.07z"></path></svg>';
			fullscreenButton.addEventListener('click', window.imageRenderer.toggleFullscreen, false);
			buttonWrapper.appendChild(fullscreenButton);
		}

		function respond() {
			createControlButtons();

			resolve();
		}

		function finish(_img) {
			var i = setImages(_img);
			texture.image = i;
			texture.needsUpdate = true;
			draw();
		}

		function run() {
			renderer = new window.THREE.WebGLRenderer({ antialiasing: false, preserveDrawingBuffer: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(canvasWrapper.offsetWidth, canvasWrapper.offsetHeight);
			canvasWrapper.appendChild(renderer.domElement);
			renderer.domElement.preserveDrawingBuffer = true;
			renderer.domElement.id = "viewer-canvas";
			renderer.domElement.setAttribute("type", "360");

			scene = new window.THREE.Scene();

			camera = new window.THREE.PerspectiveCamera(zoom, canvasWrapper.offsetWidth / canvasWrapper.offsetHeight, 1, 2000);
			camera.layers.enable(1); // render left view when no stereo available
			camera.target = new window.THREE.Vector3(0, 0, 0);
			camera.lookAt(camera.target);
			camera.aspect = renderer.domElement.clientWidth / renderer.domElement.clientHeight;
			camera.updateProjectionMatrix();

			// Allows VR devices to control view
			// There seems to be some conflict with these controls, commenting out for now
			if (canDoVR) {
				controls = new window.THREE.DeviceOrientationControls(camera);
			}

			var geometry = new window.THREE.SphereGeometry(100, 100, 40);
			geometry.applyMatrix(new window.THREE.Matrix4().makeScale(-1, 1, 1));
			geometry.applyMatrix(new window.THREE.Matrix4().makeRotationY(-Math.PI / 2));

			texture = new window.THREE.Texture();
			texture.format = 1022;

			material = new window.THREE.MeshBasicMaterial({ transparent: true, map: texture });
			var mesh = new window.THREE.Mesh(geometry, material);
			scene.add(mesh);

			animate();

			respond();

			var progressBar = window.document.createElement("div");
			progressBar.classList.add("renderer-progressbar");
			canvasWrapper.appendChild(progressBar);

			function loadMain() {
				window.imageRenderer.loadImage(imageItem, function (mainimg) {
					window.imageRenderer.stats.imageProgress = 100;
					progressBar.style.opacity = 0;

					setTimeout(function () {
						canvasWrapper.removeChild(progressBar);
					}, 600);

					finish(mainimg);

				}, function (prog) {
					window.imageRenderer.stats.imageProgress = prog;
					progressBar.style.width = prog + "%";
					window.imageRenderer.trigger("statsUpdate", window.imageRenderer.stats);
				});
			}



			function loadPreview() {
				window.imageRenderer.loadImage(previewItem, function (previmg) {
					window.imageRenderer.stats.previewProgress = 100;
					finish(previmg);
					loadMain();

				}, function (prog) {
					window.imageRenderer.stats.previewProgress = prog;
					window.imageRenderer.trigger("statsUpdate", window.imageRenderer.stats);
				}, function () {
					loadMain();
				});
			}

			if (previewItem) {
				loadPreview();
			} else {
				loadMain();
			}


			canvasWrapper.addEventListener("mousedown", onDocumentMouseDown, false);
			canvasWrapper.addEventListener("mousemove", onDocumentMouseMove, false);
			canvasWrapper.addEventListener("wheel", onDocumentMouseWheel, false);

			window.document.addEventListener("mouseup", onDocumentMouseUp, false);
			window.addEventListener("resize", resize, true);
		}

		if (window.navigator.getVRDisplays) {
			try {
				window.navigator.getVRDisplays().then(function (displays) {
					if (displays.length > 0) {
						var vrDisplay = displays[0];
						canDoVR = vrDisplay.capabilities.canPresent;
					}

					run();
				});
			} catch (e) {
				run();
			}
		} else {
			run();
		}
	});
};
window.imageRenderer.methods.renderFlat = function (data) {
	return new Promise(function (resolve, reject) {
		var canDoVR;
		var fill = data.fill;
		var imageItem = data.image;
		var previewItem = data.preview;
		var is3D = data["3D"];
		var canvasWrapper = data.element;
		canvasWrapper.style.height = "100%";
		canvasWrapper.style.width = "100%";
		canvasWrapper.innerHTML = "";

		function sendUpdate() {
			window.imageRenderer.stats.x = image.oCoords.tl.x * window.devicePixelRatio;
			window.imageRenderer.stats.y = image.oCoords.tl.y * window.devicePixelRatio;
			window.imageRenderer.stats.z = zoom;
			window.imageRenderer.stats.viewWidth = canvasWrapper.offsetWidth * window.devicePixelRatio;
			window.imageRenderer.stats.viewHeight = canvasWrapper.offsetHeight * window.devicePixelRatio;
			window.imageRenderer.stats.renderWidth = (image.oCoords.tr.x - image.oCoords.tl.x) * window.devicePixelRatio;
			window.imageRenderer.stats.renderHeight = (image.oCoords.bl.y - image.oCoords.tl.y) * window.devicePixelRatio;
			window.imageRenderer.stats.status = "drawing";
			window.imageRenderer.trigger("statsUpdate", window.imageRenderer.stats);
		}

		var image, image2D, image3D, zoomMin, zoom, canvas, fullscreenButton, vrButton;

		function getMinZoom() {
			if (!image) {
				return 0;
			}

			var method = fill ? 'max' : 'min';

			return Math[method](canvasWrapper.offsetWidth / image.width, canvasWrapper.offsetHeight / image.height);
		}

		function isOutOfBounds(x, y) {
			image.setCoords();
			var top = image.oCoords.tl.y;
			var left = image.oCoords.tl.x;
			var bottom = image.oCoords.bl.y;
			var right = image.oCoords.br.x;
			var height = bottom - top;
			var width = right - left;
			var cHeight = canvas.height;
			var cWidth = canvas.width;
			var xOutOfBounds = false;
			var yOutOfBounds = false;
			var correctedY = y;
			var correctedX = x;

			if (((bottom + y) <= cHeight) || ((bottom + y) >= height && (top + y) >= 0)) {
				yOutOfBounds = true;

				if ((bottom + y) <= cHeight) {
					correctedY = cHeight - (bottom + y);
				} else {
					correctedY = height - (bottom + y);
				}

				if (cHeight > height) {
					correctedY = correctedY - ((cHeight - height) / 2);
				}
			}

			if (((right + x) <= cWidth) || ((right + x) >= width && (left + x) >= 0)) {
				xOutOfBounds = true;

				if ((right + x) <= cWidth) {
					correctedX = cWidth - (right + x);
				} else {
					correctedX = width - (right + x);
				}

				if (cWidth > width) {
					correctedX = correctedX - ((cWidth - width) / 2);
				}
			}

			return {
				x: xOutOfBounds,
				correctedX: correctedX,
				y: yOutOfBounds,
				correctedY: correctedY
			};
		}

		function zooming(point, amount) {
			amount = (amount * (zoom * 0.025));

			if (zoom + amount > getMinZoom() || amount > 0) {
				zoom = zoom + amount;
				canvas.zoomToPoint(point, zoom);
			} else {
				canvas.zoomToPoint(point, zoom);
			}

			var outOfBounds = isOutOfBounds(0, 0);

			if (outOfBounds.x || outOfBounds.y) {
				var delta = new window.fabric.Point(outOfBounds.correctedX, outOfBounds.correctedY);
				canvas.relativePan(delta);
			}

			sendUpdate();
		}

		function setZoomingPoint(amount) {
			var canvasCenterX = canvasWrapper.offsetWidth / 2;
			var canvasCenterY = canvasWrapper.offsetHeight / 2;
			var point = new window.fabric.Point(canvasCenterX, canvasCenterY);
			zooming(point, -amount * 16);
		}

		function mouseWheel(e) {
			e.preventDefault();
			var delta = Math.max(-1, Math.min(1, (e.wheelDelta || -e.detail)));
			if (delta !== 0) {
				setZoomingPoint(-delta / 16);
			}
		}

		function reCenter() {
			zoom = zoomMin = getMinZoom();
			canvas.setZoom(zoomMin);
			if (image) {
				image.viewportCenter();
				image.setCoords();
			}

			canvas.renderAll();

			sendUpdate();
		}

		function elResize() {
			canvas.setDimensions({ width: Math.floor(canvasWrapper.offsetWidth), height: Math.floor(canvasWrapper.offsetHeight) });

			zoomMin = getMinZoom();

			if (zoom < zoomMin) {
				zoom = zoomMin;
				canvas.setZoom(zoomMin);
			}

			if (image) {

				var outOfBounds = isOutOfBounds(0, 0);

				if (outOfBounds.x || outOfBounds.y) {
					var delta = new window.fabric.Point(outOfBounds.correctedX, outOfBounds.correctedY);
					canvas.relativePan(delta);
				}

				image.setCoords();
			}

			sendUpdate();
		}

		function setEvents() {

			var panning = false;
			var previousEvent = null;

			canvas.on("mouse:down", function () {
				panning = true;
			});

			canvas.on("mouse:up", function () {
				panning = false;
			});

			canvas.on("mouse:move", function (e) {
				if (panning && e && e.e) {
					var x = e.e.movementX;
					var y = e.e.movementY;
					if (!x && previousEvent) {
						x = e.e.screenX - previousEvent.e.screenX;
						y = e.e.screenY - previousEvent.e.screenY;
					}

					var outOfBounds = isOutOfBounds(x, y);

					if (outOfBounds.y) { y = 0; }
					if (outOfBounds.x) { x = 0; }

					var delta = new window.fabric.Point(x, y);
					canvas.relativePan(delta);

					sendUpdate();
				}
				previousEvent = e;
			});

			canvasWrapper.addEventListener("mousewheel", mouseWheel, false);
			window.document.addEventListener("fullscreenchange", reCenter, false);
			window.document.addEventListener("webkitfullscreenchange", reCenter, false);
			window.document.addEventListener("mozfullscreenchange", reCenter, false);

		}

		function toggleFullscreen() {

			if (is3D && canDoVR) {
				if (window.imageRenderer.isFullscreen()) {
					updateImage(image2D);
				} else {
					updateImage(image3D);
				}

				reCenter();
			}

			window.imageRenderer.toggleFullscreen();
		}

		function createControlButtons() {
			if (!fullscreenButton) {

				var buttonWrapper = document.createElement("div");
				buttonWrapper.classList.add("buttonWrapper")
				canvasWrapper.appendChild(buttonWrapper);

				if (is3D && canDoVR) {
					vrButton = document.createElement("button");
					vrButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" data-name="Layer 86" viewBox="0 0 196.33 123.31"><path d="M194.33 14a12 12 0 0 0-12-12s-63.12-2-84.17-2-84.17 2-84.17 2a12 12 0 0 0-12 12S0 57.73 0 70.33c0 11.76 2 41 2 41a12 12 0 0 0 12 12h56.33s15.31-41.21 27.67-41c12.09.21 25.67 41 25.67 41h58.67a12 12 0 0 0 12-12s2-36.48 2-48.65S194.33 14 194.33 14zM46.67 86.66A28.33 28.33 0 1 1 75 58.33a28.33 28.33 0 0 1-28.33 28.33zm102 0A28.33 28.33 0 1 1 177 58.33a28.33 28.33 0 0 1-28.33 28.33z"/></svg>';
					vrButton.addEventListener('click', toggleFullscreen, false);
					buttonWrapper.appendChild(vrButton);
				}

				fullscreenButton = document.createElement("button");
				fullscreenButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" data-name="Layer 59" viewBox="0 0 193.57 193.57"><path d="M69.2.04q.06 13.21.12 26.43c0 1.05-.49 1.49-1.48 1.5H30.66c-2.59 0-2.64 0-2.64 2.64v35.88c0 2.8 0 2.81-2.84 2.8L.04 69.16V1.6C.04.24.32-.04 1.68-.04Q35.42.08 69.2.04zM193.54 69.16q-13.21.06-26.43.12c-1.05 0-1.49-.49-1.5-1.48v-1.89V30.6c0-2.59 0-2.64-2.64-2.64h-35.91c-2.8 0-2.81 0-2.8-2.84q0-12.55.12-25.11h67.65c1.29 0 1.55.25 1.55 1.55q-.08 33.81-.04 67.6zM.04 124.38q13.21-.06 26.43-.12c1.05 0 1.49.49 1.5 1.48v37.2c0 2.59 0 2.64 2.64 2.64h35.91c2.8 0 2.81 0 2.8 2.84q0 12.55-.12 25.11H1.55c-1.29 0-1.55-.25-1.55-1.55q.08-33.82.04-67.6zM124.38 193.54q-.06-13.21-.12-26.43c0-1.05.49-1.49 1.48-1.5h37.2c2.59 0 2.64 0 2.64-2.64v-35.88c0-2.8 0-2.81 2.84-2.8l25.11.12v67.65c0 1.29-.25 1.55-1.55 1.55q-33.78-.11-67.6-.07z"></path></svg>';
				fullscreenButton.addEventListener('click', toggleFullscreen, false);
				buttonWrapper.appendChild(fullscreenButton);
			}
		}

		function create2D(img) {
			return new Promise(function (resolve) {

				var _img = new window.Image();

				_img.onload = function () {
					resolve(_img);
				};

				var ctx = window.document.createElement("canvas").getContext("2d");
				ctx.canvas.width = img.naturalWidth / 2;
				ctx.canvas.height = img.naturalHeight;
				ctx.drawImage(img, 0, 0);
				_img.src = ctx.canvas.toDataURL();

			});
		}


		function updateImage(_img) {
			image = canvas.getObjects()[0];

			window.fabric.Image.fromURL(_img.src, function (oImg) {
				canvas.add(oImg);
				canvas.remove(image);

				image = canvas.getObjects()[0];
				image.hasBorders = image.hasControls = false;
				image.selectable = false;

				var previousZoomMin = zoomMin;
				zoomMin = getMinZoom();

				if (!zoom) {
					zoom = zoomMin;
					canvas.setZoom(zoomMin);
				} else {
					zoom = zoom / (previousZoomMin / zoomMin);
					canvas.setZoom(zoom);
				}

				image.viewportCenter();

				image.setCoords();
				canvas.renderAll();



				canvasWrapper.classList.add("active");

				sendUpdate();

				createControlButtons();

				if('touchstart' in window.document.documentElement){
					return;
				}

				setEvents();
			}, { crossOrigin: "anonymous" });
		}


		function run() {

			canvas = window.document.createElement("canvas");
			canvasWrapper.appendChild(canvas);
			canvas = new window.fabric.Canvas(canvas, {
				allowTouchScrolling: false,
				enableRetinaScaling: true,
				stopContextMenu: true,
				lockUniScaling: true,
				centeredScaling: true,
				alignX: "mid",
				alignY: "mid",
			});

			canvas.setDimensions({ width: canvasWrapper.offsetWidth, height: canvasWrapper.offsetHeight });
			canvas.selection = false;

			var progressBar = document.createElement("div");
			progressBar.classList.add("renderer-progressbar");
			canvasWrapper.appendChild(progressBar);

			function loadMain() {
				window.imageRenderer.loadImage(imageItem, function (mainimg) {
					window.imageRenderer.stats.imageProgress = 100;
					progressBar.style.opacity = 0;

					setTimeout(function () {
						canvasWrapper.removeChild(progressBar);
					}, 600);

					if (is3D) {
						image3D = mainimg;

						create2D(image3D).then(function (mainimg2D) {
							image2D = mainimg2D;
							updateImage(window.imageRenderer.isFullscreen() ? image3D : image2D);
						});
					} else {
						image2D = mainimg;
						updateImage(window.imageRenderer.isFullscreen() ? image3D : image2D);
					}

				}, function (prog) {
					window.imageRenderer.stats.imageProgress = prog;
					progressBar.style.width = prog + "%";
					window.imageRenderer.trigger("statsUpdate", window.imageRenderer.stats);
				});
			}

			function loadPreview() {
				window.imageRenderer.loadImage(previewItem, function (previmg) {
					window.imageRenderer.stats.previewProgress = 100;

					if (is3D) {
						image3D = previmg;

						create2D(previmg).then(function (previmg) {

							image2D = previmg;
							updateImage(window.imageRenderer.isFullscreen() ? image3D : image2D);
						});
					} else {
						image2D = previmg;
						updateImage(window.imageRenderer.isFullscreen() ? image3D : image2D);
					}

					loadMain();

				}, function (prog) {
					window.imageRenderer.stats.previewProgress = prog;
					progressBar.style.width = prog + "%";
					window.imageRenderer.trigger("statsUpdate", window.imageRenderer.stats);
				});
			}

			if (previewItem) {
				loadPreview();
			} else {
				loadMain();
			}


			window.addEventListener("resize", elResize, false);
			window.onorientationchange = reCenter;

			resolve();
		}

		if (window.navigator.getVRDisplays) {
			try {
				window.navigator.getVRDisplays().then(function (displays) {
					if (displays.length > 0) {
						var vrDisplay = displays[0];
						canDoVR = vrDisplay.capabilities.canPresent;
					}

					run();
				});
			} catch (e) {
				run();
			}
		} else {
			run();
		}
	});
};
/*

TO INIT, PASS IN CANVAS ELEMENT. THERE ARE OPTIONS FOR MINIMUM WIDTH/HEIGHT

cropper.init(document.querySelector("#canvas_wrapper canvas"), {
	minWidth: 100,
	minHeight: 100
})

=====================================


IF YOU NEED DATA WHEN ITS BEEN UPDATED

cropper.onUpdate(function (data) {
	x1 = data.x1
	x2 = data.x2
	y1 = data.y1
	y2 = data.y2
})

=====================================


BY DEFAULT ITS HIDDEN, CALL THIS TO SHOW

cropper.show()

=====================================


CALL THIS TO GET COORDS IN PX

cropper.getCoordinates()

=====================================

CALL THIS TO GET COORDS IN %

cropper.getRelativeCoordinates()

======================================

THERE ARE A FEW OPTIONS TO GET A SCREENSHOT

screenshotData(type, quality) => base64 string
screenshotImage(callback, type, quality) => img element
screenshotCanvas(type, quality) => canvas element

*/

window.imageRenderer.cropper = {
	ver: "2.0.0",
	element: null,
	data: {
		mousemove: false,
		positions: {
			y1: 5,
			y2: 5,
			x1: 5,
			x2: 5
		},
		elements: {}
	},

	onUpdateCallbacks: [],
	onUpdate: function (cb) {
		var self = window.imageRenderer.cropper
		self.onUpdateCallbacks.push(cb)
	},

	getCoordinates: function () {
		var self = window.imageRenderer.cropper
		var w = self.element.offsetWidth
		var h = self.element.offsetHeight

		var data = {
			x: (self.data.positions.x1 / 100) * w,
			y: (self.data.positions.y1 / 100) * h,
			width: w - (((self.data.positions.x1 + self.data.positions.x2) / 100) * w),
			height: h - (((self.data.positions.y1 + self.data.positions.y2) / 100) * h)
		}

		for (var p in data) {
			if (data[p]) {
				data[p] = data[p] * window.devicePixelRatio
			}
		}

		return data
	},

	getRelativeCoordinates: function () {
		var self = window.imageRenderer.cropper
		var w = self.element.offsetWidth
		var h = self.element.offsetHeight

		return {
			x: self.data.positions.x1,
			y: self.data.positions.y1,
			width: ((w - (((self.data.positions.x1 + self.data.positions.x2) / 100) * w)) / w) * 100,
			height: ((h - (((self.data.positions.y1 + self.data.positions.y2) / 100) * h)) / h) * 100
		}
	},

	screenshotData: function (type, quality) {
		var self = window.imageRenderer.cropper
		if (!type) {
			type = "image/jpeg"
		}

		if (!quality) {
			quality = 0.92
		}

		return self.screenshotCanvas().toDataURL(type, quality)
	},

	screenshotImage: function (cb, type, quality) {
		var self = window.imageRenderer.cropper
		if (!type) {
			type = "image/jpeg"
		}

		if (!quality) {
			quality = 0.92
		}

		var img = new window.Image()
		img.onload = function () {
			cb(img)
		}
		img.src = self.screenshotData(type, quality)
	},

	screenshotDownload: function (type, quality) {
		var self = window.imageRenderer.cropper
		if (!type) {
			type = "image/jpeg"
		}

		if (!quality) {
			quality = 0.92
		}

		var a = window.document.createElement("a")
		a.download = true
		a.href = self.screenshotData(type, quality)
		a.click()
	},

	screenshotCanvas: function () {
		var self = window.imageRenderer.cropper
		var coords = self.getCoordinates();
		var ctx = window.document.createElement("canvas").getContext("2d")
		ctx.canvas.width = coords.width
		ctx.canvas.height = coords.height
		ctx.drawImage(self.canvas, coords.x, coords.y, coords.width, coords.height, 0, 0, coords.width, coords.height)
		return ctx.canvas
	},

	init: function (el, options) {
		var self = window.imageRenderer.cropper
		self.container = window.document.getElementById("crop-positioner")
		if (self.container) {
			self.container.parentNode.removeChild(self.container)
		}
		self.container = window.document.createElement("div")
		self.container.id = "crop-positioner"
		self.container.innerHTML = self.createHtml()
		self.onUpdateCallbacks = []
		self.element = el
		self.canvas = el.querySelector("canvas")
		self.element.appendChild(self.container)
		self.data.elements = {
			north: self.container.querySelector("#north-handle"),
			south: self.container.querySelector("#south-handle"),
			east: self.container.querySelector("#east-handle"),
			west: self.container.querySelector("#west-handle"),
			northeast: self.container.querySelector("#north-east-handle"),
			northwest: self.container.querySelector("#north-west-handle"),
			southeast: self.container.querySelector("#south-east-handle"),
			southwest: self.container.querySelector("#south-west-handle")
		}

		function mouseDown(e) {
			e.preventDefault()
			e.stopPropagation()

			var _self = this
			var handleHeight = (_self.offsetHeight / self.element.offsetHeight) * 100
			var handleWidth = (_self.offsetWidth / self.element.offsetWidth) * 100
			var mode = _self.id

			self.data.mousemove = true

			function move(e) {
				if (!self.data.mousemove) { return }
				e.stopPropagation()
				e.preventDefault()

				var height = ((e.y - (handleHeight / 2)) / self.element.offsetHeight) * 100 || 0
				var width = ((e.x - (handleWidth / 2)) / self.element.offsetWidth) * 100 || 0

				function checkHeight(y1, y2) {
					if (!options || !options.minHeight) {
						return true
					}
					return self.element.offsetHeight - (((y1 + y2) / 100) * self.element.offsetHeight) > options.minHeight
				}

				function checkWidth(x1, x2) {
					if (!options || !options.minWidth) {
						return true
					}
					return self.element.offsetWidth - (((x1 + x2) / 100) * self.element.offsetWidth) > options.minWidth
				}

				if (mode === 'north-handle') {

					if (checkHeight(height, self.data.positions.y2)) {
						self.data.positions.y1 = height
						self.container.querySelector("#north-space").style.height = self.data.positions.y1 + "%"
					}

				} else if (mode === 'south-handle') {

					height = 100 - height

					if (checkHeight(height, self.data.positions.y1)) {
						self.data.positions.y2 = height
						self.container.querySelector("#south-space").style.height = self.data.positions.y2 + "%"
					}

				} else if (mode === 'east-handle') {

					width = 100 - width

					if (checkWidth(width, self.data.positions.x1)) {
						self.data.positions.x2 = width
						self.container.querySelector("#east-space").style.width = self.data.positions.x2 + "%"
					}

				} else if (mode === 'west-handle') {

					if (checkWidth(width, self.data.positions.x2)) {
						self.data.positions.x1 = width
						self.container.querySelector("#west-space").style.width = self.data.positions.x1 + "%"
					}

				} else if (mode === 'north-east-handle') {

					if (checkHeight(height, self.data.positions.y2)) {
						self.data.positions.y1 = height
						self.container.querySelector("#north-space").style.height = self.data.positions.y1 + "%"
					}

					width = 100 - width

					if (checkWidth(width, self.data.positions.x1)) {
						self.data.positions.x2 = width
						self.container.querySelector("#east-space").style.width = self.data.positions.x2 + "%"
					}

				} else if (mode === 'north-west-handle') {
					if (checkHeight(height, self.data.positions.y2)) {
						self.data.positions.y1 = height
						self.container.querySelector("#north-space").style.height = self.data.positions.y1 + "%"
					}

					if (checkWidth(width, self.data.positions.x2)) {
						self.data.positions.x1 = width
						self.container.querySelector("#west-space").style.width = self.data.positions.x1 + "%"
					}
				} else if (mode === 'south-east-handle') {
					width = 100 - width
					height = 100 - height

					if (checkHeight(height, self.data.positions.y1)) {
						self.container.querySelector("#south-space").style.height = self.data.positions.y2 + "%"
						self.data.positions.y2 = height
					}

					if (checkWidth(width, self.data.positions.x1)) {
						self.data.positions.x2 = width
						self.container.querySelector("#east-space").style.width = self.data.positions.x2 + "%"
					}
				} else if (mode === 'south-west-handle') {
					height = 100 - height

					if (checkHeight(height, self.data.positions.y1)) {
						self.data.positions.y2 = height
						self.container.querySelector("#south-space").style.height = self.data.positions.y2 + "%"
					}

					if (checkWidth(width, self.data.positions.x2)) {
						self.data.positions.x1 = width
						self.container.querySelector("#west-space").style.width = self.data.positions.x1 + "%"
					}
				}

				self.onUpdateCallbacks.forEach(function (cb) {
					cb(self.getCoordinates())
				})
			}

			function clear() {
				self.data.mousemove = false
				window.document.removeEventListener('mousemove', move, false)
				window.document.removeEventListener('mouseup', clear, false)
				window.document.body.removeEventListener('mouseleave', clear, false)
			}

			window.document.addEventListener('mousemove', move, false)
			window.document.addEventListener('mouseup', clear, false)
			window.document.body.addEventListener('mouseleave', clear, false)
		}

		for (var handle in self.data.elements) {
			if (self.data.elements[handle]) {
				self.data.elements[handle].addEventListener("mousedown", mouseDown, false)
			}
		}

		self.sizeWatcher = window.requestAnimationFrame(self.position)

		self.getCoordinates()
	},

	position: function () {
		var self = window.imageRenderer.cropper
		if (!self.container) {
			return;
		}

		self.container.style.width = self.element.offsetWidth + "px"
		self.container.style.height = self.element.offsetHeight + "px"
		self.sizeWatcher = window.requestAnimationFrame(self.position)
	},

	destroy: function () {
		var self = window.imageRenderer.cropper
		if (self.container && self.container.parentNode) {
			self.container.parentNode.removeChild(self.container)
		}
	},

	createHtml: function () {
		return '<table><tr><td></td><td style="width:10px;"></td><td id="north-space" style="height: 5%;"></td><td style="width:10px"></td><td></td></tr><tr><td style="height:10px"></td><td id="north-west-handle" style="height:10px;cursor: nwse-resize;border-top: 1px dotted rgba(255, 255, 255, 0.25);background: transparent;border-left: 1px dotted rgba(255, 255, 255, 0.25);"><div class="handle" style="left: -5px; top: -5px;"></div></td><td id="north-handle" style="height:10px; background: transparent; cursor: ns-resize; border-top: 1px dotted rgba(255, 255, 255, 0.25);"><div class="handle" style="left: 50%; top: -5px; margin-left: -5px;"></div></td><td id="north-east-handle" style="height:10px;cursor: nesw-resize;border-top: 1px dotted rgba(255, 255, 255, 0.25);background: transparent;border-right: 1px dotted rgba(255, 255, 255, 0.25);"><div class="handle" style="left: 5px; top: -5px;"></div></td><td style="height:10px"></td></tr><tr><td id="west-space" style="width: 5%;"></td><td id="west-handle" style="cursor: ew-resize;border-left: 1px dotted rgba(255, 255, 255, 0.25);background: transparent;"><div class="handle" style="left: -5px; top: 50%; margin-top: -5px;"></div></td><td id="revealed-space" style="background: transparent;"></td><td id="east-handle" style="cursor: ew-resize;border-right: 1px dotted rgba(255, 255, 255, 0.25);background: transparent;"><div class="handle" style="right: -5px;top: 50%; margin-top: -5px;"></div></td><td id="east-space" style="width: 5%;"></td></tr><tr><td style="height:10px"></td><td id="south-west-handle" style="height:10px;cursor: nesw-resize; background: transparent; border-bottom: 1px dotted rgba(255, 255, 255, 0.25); border-left: 1px dotted rgba(255, 255, 255, 0.25);"><div class="handle" style="left: -5px; top: 5px;"></div></td><td id="south-handle" style="height:10px; cursor: ns-resize; border-bottom: 1px dotted rgba(255, 255, 255, 0.25);background: transparent;"><div class="handle" style="left: 50%; top: 5px; margin-left: -5px;"></div></td><td id="south-east-handle" style="height:10px;cursor: nwse-resize;background: transparent; border-bottom: 1px dotted rgba(255, 255, 255, 0.25); border-right: 1px dotted rgba(255, 255, 255, 0.25);"><div class="handle" style="left: 5px; top: 5px;"></div></td><td style="height:10px"></td></tr><tr><td></td><td></td><td id="south-space" style="height: 5%;"></td><td></td><td></td></tr></table>'
	}
}
//# sourceMappingURL=image-renderer.min.js.map
